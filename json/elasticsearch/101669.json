[{"authorTime":"2018-06-11 16:47:26","codes":[{"authorDate":"2018-06-11 16:47:26","commitOrder":3,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n    }\n","date":"2018-06-11 16:47:26","endLine":67,"groupId":"59751","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2a/b20522db65bc101b97914cb58b519fb92d244b.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"B"},{"authorDate":"2018-06-11 16:47:26","commitOrder":3,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getNetworkWriteBuffer()).thenReturn(writeBuffer);\n    }\n","date":"2018-06-11 16:47:26","endLine":71,"groupId":"70118","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/14/a22d300d12d682c6ec3fd564812f1cacbb7d9f.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getNetworkWriteBuffer()).thenReturn(writeBuffer);\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"MB"}],"commitId":"9ee492a3f0768a3790671bfe46223e700082730a","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-06-11 16:47:26","modifiedFileCount":"192","status":"M","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2018-12-07 09:09:07","codes":[{"authorDate":"2018-12-07 09:09:07","commitOrder":4,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2018-12-07 09:09:07","endLine":72,"groupId":"59751","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/a90a32d65c405defc28bf54c8b48757a0ee0f0.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"M"},{"authorDate":"2018-12-07 09:09:07","commitOrder":4,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getNetworkWriteBuffer()).thenReturn(writeBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2018-12-07 09:09:07","endLine":76,"groupId":"70118","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d7/fe1bbda254914ac3d163a71382b4e52ce45d7b.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getNetworkWriteBuffer()).thenReturn(writeBuffer);\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"M"}],"commitId":"373c67dd7ab31d5b57a2efa32b4188c9dc61449d","commitMessage":"@@@Add DirectByteBuffer strategy for transport-nio (#36289)\n\nThis is related to #27260. In Elasticsearch all of the messages that we\nserialize to write to the network are composed of heap bytes. When you\nread or write to a nio socket in java.  the heap memory you passed down\nmust be copied to/from direct memory. The JVM internally does some\nbuffering of the direct memory.  however it is essentially unbounded.\n\nThis commit introduces a simple mechanism of buffering and copying the\nmemory in transport-nio. Each network event loop is given a 64kb\nDirectByteBuffer. When we go to read we use this buffer and copy the\ndata after the read. Additionally.  when we go to write.  we copy the data\nto the direct memory before calling write. 64KB is chosen as this is the\ndefault receive buffer size we use for transport-netty4\n(NETTY_RECEIVE_PREDICTOR_SIZE).\n\nSince we only have one buffer per thread.  we could afford larger.\nHowever.  if we the buffer is large and not all of the data is flushed in\na write call.  we will do excess copies. This is something we can\nexplore in the future.","date":"2018-12-07 09:09:07","modifiedFileCount":"6","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-01-10 02:46:24","codes":[{"authorDate":"2018-12-07 09:09:07","commitOrder":5,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2018-12-07 09:09:07","endLine":72,"groupId":"59751","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/a90a32d65c405defc28bf54c8b48757a0ee0f0.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"N"},{"authorDate":"2019-01-10 02:46:24","commitOrder":5,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getNetworkWriteBuffer()).thenReturn(writeBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-01-10 02:46:24","endLine":82,"groupId":"43152","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/08/7012402285075465a25250c4afeaad63ec1823.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getNetworkWriteBuffer()).thenReturn(writeBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":57,"status":"M"}],"commitId":"cfa58a51afd1cd41d8aebb024d6f8987373b21d1","commitMessage":"@@@Add TLS/SSL channel close timeouts (#37246)\n\nClosing a channel using TLS/SSL requires reading and writing a\nCLOSE_NOTIFY message (for pre-1.3 TLS versions). Many implementations do\nnot actually send the CLOSE_NOTIFY message.  which means we are depending\non the TCP close from the other side to ensure channels are closed. In\ncase there is an issue with this.  we need a timeout. This commit adds a\ntimeout to the channel close process for TLS secured channels.\n\nAs part of this change.  we need a timer service. We could use the\ngeneric Elasticsearch timeout threadpool. However.  it would be nice to\nhave a local to the nio event loop timer service dedicated to network needs. In\nthe future this service could support read timeouts.  connect timeouts. \nrequest timeouts.  etc. This commit adds a basic priority queue backed\nservice. Since our timeout volume (channel closes) is very low.  this\nshould be fine. However.  this can be updated to something more efficient\nin the future if needed (timer wheel). Everything being local to the event loop\nthread makes the logic simple as no locking or synchronization is necessary.","date":"2019-01-10 02:46:24","modifiedFileCount":"7","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-04-26 04:30:16","codes":[{"authorDate":"2018-12-07 09:09:07","commitOrder":6,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2018-12-07 09:09:07","endLine":72,"groupId":"59751","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/a90a32d65c405defc28bf54c8b48757a0ee0f0.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"N"},{"authorDate":"2019-04-26 04:30:16","commitOrder":6,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-04-26 04:30:16","endLine":82,"groupId":"43152","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/89/3af2140b9b0dfef7cfc65d8b31fd074f436efa.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getNetworkWriteBuffer()).thenReturn(writeBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"}],"commitId":"0ca375ed42f420f4c7c4a8c489a2ecc328db3648","commitMessage":"@@@Remove dedicated SSL network write buffer (#41283)\n\nThis is related to #27260. Currently for the SSLDriver we allocate a\ndedicated network write buffer and encrypt the data into that buffer one\nbuffer at a time. This requires constantly switching between encrypting\nand flushing. This commit adds a dedicated outbound buffer for SSL\noperations that will internally allocate new packet sized buffers as\nthey are need (for writing encrypted data). This allows us to totally\nencrypt an operation before writing it to the network. Eventually it can\nbe hooked up to buffer recycling.","date":"2019-04-26 04:30:16","modifiedFileCount":"20","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-04-30 03:08:35","codes":[{"authorDate":"2018-12-07 09:09:07","commitOrder":7,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2018-12-07 09:09:07","endLine":72,"groupId":"59751","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/a90a32d65c405defc28bf54c8b48757a0ee0f0.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"N"},{"authorDate":"2019-04-30 03:08:35","commitOrder":7,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-04-30 03:08:35","endLine":86,"groupId":"9799","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dc/ccb23f1f6653b74dffc94a1489036d0e6298d0.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":60,"status":"M"}],"commitId":"7a407f5609ed996f56cad4b4886cfc587b6d6ee1","commitMessage":"@@@ Handle WRAP ops during SSL read (#41611)\n\nIt is possible that a WRAP operation can occur while decrypting\nhandshake data in TLS 1.3. The SSLDriver does not currently handle this\nwell as it does not have access to the outbound buffer during read call.\nThis commit moves the buffer into the Driver to fix this issue. Data\nwrapped during a read call will be queued for writing after the read\ncall is complete.","date":"2019-04-30 03:08:35","modifiedFileCount":"4","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-05-03 04:44:22","codes":[{"authorDate":"2018-12-07 09:09:07","commitOrder":8,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2018-12-07 09:09:07","endLine":72,"groupId":"59751","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/a90a32d65c405defc28bf54c8b48757a0ee0f0.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"N"},{"authorDate":"2019-05-03 04:44:22","commitOrder":8,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-05-03 04:44:22","endLine":84,"groupId":"9799","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6a/380a8fab20519b5c4961f8ca6b6321a1a19d13.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getNetworkReadBuffer()).thenReturn(readBuffer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"M"}],"commitId":"cb2bd0bb6b907c141a857d23d2630d7af80d5768","commitMessage":"@@@Read multiple TLS packets in one read call (#41725)\n\nThis is related to #27260. Currently we have a single read buffer that\nis no larger than a single TLS packet. This prevents us from reading\nmultiple TLS packets in a single socket read call. This commit modifies\nour TLS work to support reading similar to the plaintext case. The data\nwill be copied to a (potentially) recycled TLS packet-sized buffer for\ninteraction with the SSLEngine.","date":"2019-05-03 04:44:22","modifiedFileCount":"13","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-07-17 06:46:41","codes":[{"authorDate":"2018-12-07 09:09:07","commitOrder":9,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2018-12-07 09:09:07","endLine":72,"groupId":"59751","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/22/a90a32d65c405defc28bf54c8b48757a0ee0f0.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"N"},{"authorDate":"2019-07-17 06:46:41","commitOrder":9,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n        context.setSelectionKey(mock(SelectionKey.class));\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-07-17 06:46:41","endLine":87,"groupId":"9799","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8e/0a5ad23af313bf62554219304e3a3fc96ec066.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"M"}],"commitId":"b75003fd53615ff4ac03b23201748b9705a8fff1","commitMessage":"@@@Isolate nio channel registered from channel active (#44388)\n\nRegistering a channel with a selector is a required operation for the\nchannel to be handled properly. Currently.  we mix the registeration with\nother setup operations (ip filtering.  SSL initiation.  etc). However.  a\nfail to register is fatal. This PR modifies how registeration occurs to\nimmediately close the channel if it fails.\n\nThere are still two clear loopholes for how a user can interact with a\nchannel even if registration fails. 1. through the exception handler.\n2. through the channel accepted callback. These can perhaps be improved\nin the future. For now.  this PR prevents writes from proceeding if the\nchannel is not registered.","date":"2019-07-17 06:46:41","modifiedFileCount":"18","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-07-31 00:41:51","codes":[{"authorDate":"2019-07-31 00:41:51","commitOrder":10,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Config.Socket.class), mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-07-31 00:41:51","endLine":73,"groupId":"59751","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1b/ad1dd2b141afe703e92392757ee093bc749d15.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2019-07-31 00:41:51","commitOrder":10,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        socketConfig = new Config.Socket(randomBoolean(), randomBoolean(), randomBoolean(), -1, -1, mock(InetSocketAddress.class), false);\n        context = new SSLChannelContext(channel, selector, socketConfig, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n        context.setSelectionKey(mock(SelectionKey.class));\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-07-31 00:41:51","endLine":91,"groupId":"43152","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ca/0d07e8c19fccb822a5ac59ec1b81ada358a89b.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        context = new SSLChannelContext(channel, selector, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n        context.setSelectionKey(mock(SelectionKey.class));\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"}],"commitId":"f39e8e5dcf9bb3ffb1bf416fee9e66fb4b356141","commitMessage":"@@@Move nio channel initialization to event loop (#43780)\n\nCurrently in the transport-nio work we connect and bind channels on the\na thread before the channel is registered with a selector. Additionally. \nit is at this point that we set all the socket options. This commit\nmoves these operations onto the event-loop after the channel has been\nregistered with a selector. It attempts to set the socket options for a\nnon-server channel at registration time. If that fails.  it will attempt\nto set the options after the channel is connected. This should fix\n#41071.","date":"2019-07-31 00:41:51","modifiedFileCount":"20","status":"M","submitter":"Tim Brooks"},{"authorTime":"2019-08-05 22:09:11","codes":[{"authorDate":"2019-07-31 00:41:51","commitOrder":11,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Config.Socket.class), mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-07-31 00:41:51","endLine":73,"groupId":"101669","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1b/ad1dd2b141afe703e92392757ee093bc749d15.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        TestReadWriteHandler handler = new TestReadWriteHandler(readConsumer);\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        context = new BytesChannelContext(channel, selector, mock(Config.Socket.class), mock(Consumer.class), handler, channelBuffer);\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/BytesChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"N"},{"authorDate":"2019-08-05 22:09:11","commitOrder":11,"curCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        socketConfig = new Config.Socket(randomBoolean(), randomBoolean(), -1, -1, -1, randomBoolean(), -1, -1,\n            mock(InetSocketAddress.class), false);\n        context = new SSLChannelContext(channel, selector, socketConfig, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n        context.setSelectionKey(mock(SelectionKey.class));\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","date":"2019-08-05 22:09:11","endLine":92,"groupId":"101669","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"init","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/78/93c5aaf42579ddd6e5e92fb09f0df58071650e.src","preCode":"    public void init() {\n        readConsumer = mock(CheckedFunction.class);\n        TestReadWriteHandler readWriteHandler = new TestReadWriteHandler(readConsumer);\n\n        messageLength = randomInt(96) + 20;\n        selector = mock(NioSelector.class);\n        nioTimer = mock(TaskScheduler.class);\n        listener = mock(BiConsumer.class);\n        channel = mock(NioSocketChannel.class);\n        rawChannel = mock(SocketChannel.class);\n        sslDriver = mock(SSLDriver.class);\n        channelBuffer = InboundChannelBuffer.allocatingInstance();\n        outboundBuffer = new SSLOutboundBuffer((n) -> new Page(ByteBuffer.allocate(n), () -> {}));\n        when(channel.getRawChannel()).thenReturn(rawChannel);\n        exceptionHandler = mock(Consumer.class);\n        socketConfig = new Config.Socket(randomBoolean(), randomBoolean(), randomBoolean(), -1, -1, mock(InetSocketAddress.class), false);\n        context = new SSLChannelContext(channel, selector, socketConfig, exceptionHandler, sslDriver, readWriteHandler, channelBuffer);\n        context.setSelectionKey(mock(SelectionKey.class));\n\n        when(selector.isOnCurrentThread()).thenReturn(true);\n        when(selector.getTaskScheduler()).thenReturn(nioTimer);\n        when(sslDriver.getOutboundBuffer()).thenReturn(outboundBuffer);\n        ByteBuffer buffer = ByteBuffer.allocate(1 << 14);\n        when(selector.getIoBuffer()).thenAnswer(invocationOnMock -> {\n            buffer.clear();\n            return buffer;\n        });\n    }\n","realPath":"x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/nio/SSLChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"}],"commitId":"245cb348d351df7e95c5f029001f82c8b8cac8f8","commitMessage":"@@@Add per-socket keepalive options (#44055)\n\nUses JDK 11's per-socket configuration of TCP keepalive (supported on Linux and Mac).  see\nhttps://bugs.openjdk.java.net/browse/JDK-8194298.  and exposes these as transport settings.\nBy default.  these options are disabled for now (i.e. fall-back to OS behavior).  but we would like\nto explore whether we can enable them by default.  in particular to force keepalive configurations\nthat are better tuned for running ES.","date":"2019-08-05 22:09:11","modifiedFileCount":"22","status":"M","submitter":"Yannick Welsch"}]
