[{"authorTime":"2019-03-23 03:58:30","codes":[{"authorDate":"2019-03-23 03:58:30","commitOrder":1,"curCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n            assertThat(inboundRequest.getFeatures(), contains(feature1, feature2));\n\n            Request readMessage = new Request();\n            readMessage.readFrom(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","date":"2019-03-23 03:58:30","endLine":172,"groupId":"31419","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSendRequest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/ab504e61fa4c35b8713694fb93af8f7ee8d523.src","preCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n            assertThat(inboundRequest.getFeatures(), contains(feature1, feature2));\n\n            Request readMessage = new Request();\n            readMessage.readFrom(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"B"},{"authorDate":"2019-03-23 03:58:30","commitOrder":1,"curCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, Collections.emptySet(), channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response();\n            readMessage.readFrom(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","date":"2019-03-23 03:58:30","endLine":240,"groupId":"25475","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSendResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/ab504e61fa4c35b8713694fb93af8f7ee8d523.src","preCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, Collections.emptySet(), channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response();\n            readMessage.readFrom(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":174,"status":"B"}],"commitId":"9e11dfc7f01eff5eb23ca16ee283cfd029cdafc9","commitMessage":"@@@Move outbound message handling to OutboundHandler (#40336)\n\nCurrently there are some components of message serializer and sending\nthat still occur in TcpTransport. This commit makes it possible to\nsend a message without the TcpTransport by moving all of the remaining\napplication logic to the OutboundHandler. Additionally.  it adds unit\ntests to ensure that this logic works as expected.","date":"2019-03-23 03:58:30","modifiedFileCount":"12","status":"B","submitter":"Tim Brooks"},{"authorTime":"2019-07-20 10:20:39","codes":[{"authorDate":"2019-07-20 10:20:39","commitOrder":2,"curCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n            assertThat(inboundRequest.getFeatures(), contains(feature1, feature2));\n\n            Request readMessage = new Request(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","date":"2019-07-20 10:20:39","endLine":171,"groupId":"31419","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSendRequest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a5/73cb0618cbf171d597ca473507d321871896a1.src","preCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n            assertThat(inboundRequest.getFeatures(), contains(feature1, feature2));\n\n            Request readMessage = new Request();\n            readMessage.readFrom(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"},{"authorDate":"2019-07-20 10:20:39","commitOrder":2,"curCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, Collections.emptySet(), channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","date":"2019-07-20 10:20:39","endLine":238,"groupId":"25475","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSendResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a5/73cb0618cbf171d597ca473507d321871896a1.src","preCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, Collections.emptySet(), channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response();\n            readMessage.readFrom(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"M"}],"commitId":"7895dc9915422a33bb6814ec420c3b068aef4410","commitMessage":"@@@Convert Transport Request/Response to Writeable (#44636)\n\nThis commit converts all remaining TransportRequest and\nTransportResponse classes to implement Writeable.  and disallows\nStreamable implementations.\n\nrelates #34389","date":"2019-07-20 10:20:39","modifiedFileCount":"82","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2019-07-23 14:15:14","codes":[{"authorDate":"2019-07-20 10:20:39","commitOrder":3,"curCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n            assertThat(inboundRequest.getFeatures(), contains(feature1, feature2));\n\n            Request readMessage = new Request(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","date":"2019-07-20 10:20:39","endLine":171,"groupId":"31419","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSendRequest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a5/73cb0618cbf171d597ca473507d321871896a1.src","preCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n            assertThat(inboundRequest.getFeatures(), contains(feature1, feature2));\n\n            Request readMessage = new Request(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"N"},{"authorDate":"2019-07-23 14:15:14","commitOrder":3,"curCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","date":"2019-07-23 14:15:14","endLine":238,"groupId":"31421","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testSendResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/96/3ba63e1c3e85ba7b83f3c6ccb5ffd8be252bb6.src","preCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, Collections.emptySet(), channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"M"}],"commitId":"42a331c59ba58f18253e794fe16c673a34128c95","commitMessage":"@@@Remove Unused Features Field on StreamOutput (#44667)\n\n* Remove Unused Features Field on StreamOutput\n\n* Ever since b15d62c3ab5b3766a975f8d4b3878cbde8c2b6c0 this field and all the methods around it seem completely unused (that commit removed the only use of the getter) and\nare in fact wasting some allocations => removed it\n\n","date":"2019-07-23 14:15:14","modifiedFileCount":"9","status":"M","submitter":"Armin Braun"},{"authorTime":"2019-07-23 14:15:14","codes":[{"authorDate":"2019-07-28 18:00:38","commitOrder":4,"curCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n\n            Request readMessage = new Request(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","date":"2019-07-28 18:00:38","endLine":166,"groupId":"31419","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSendRequest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b1/5d444e24061bb08c9f63de38ee70c4a1b58f8c.src","preCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n            assertThat(inboundRequest.getFeatures(), contains(feature1, feature2));\n\n            Request readMessage = new Request(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"M"},{"authorDate":"2019-07-23 14:15:14","commitOrder":4,"curCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","date":"2019-07-23 14:15:14","endLine":238,"groupId":"31421","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testSendResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/96/3ba63e1c3e85ba7b83f3c6ccb5ffd8be252bb6.src","preCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"N"}],"commitId":"a9f351556f519e4f9b23e755a3e5da767512a66a","commitMessage":"@@@Remove client feature tracking (#44929)\n\nThis commit removes the infrastructure for client feature tracking. We\nintroduced this functionality to support clients that do not necessarily\nunderstand all the features that the server might support.  for example. \ncustoms in the cluster state provided by plugins that a client might not\nhave. This can arise in situations such as rolling upgrades from the OSS\ndistribution to the default distribution. With the removal of the\ntransport client.  this infrastructure is no longer needed. This commit\nremoves client feature tracking from the server in 8.0.0.","date":"2019-07-28 18:00:38","modifiedFileCount":"36","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-03-28 00:40:26","codes":[{"authorDate":"2020-03-28 00:40:26","commitOrder":5,"curCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestRequest request = new TestRequest(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {}));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestRequest message = new TestRequest(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertTrue(header.isRequest());\n        assertFalse(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","date":"2020-03-28 00:40:26","endLine":171,"groupId":"60535","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testSendRequest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4c/1cce0f40a63b7196af1ce0a1fc6dc6508d6d34.src","preCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Request request = new Request(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertTrue(inboundMessage.isRequest());\n            assertFalse(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n            InboundMessage.Request inboundRequest = (InboundMessage.Request) inboundMessage;\n\n            Request readMessage = new Request(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":111,"status":"M"},{"authorDate":"2020-03-28 00:40:26","commitOrder":5,"curCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestResponse response = new TestResponse(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {}));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestResponse message = new TestResponse(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertFalse(header.isRequest());\n        assertTrue(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertFalse(header.isError());\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","date":"2020-03-28 00:40:26","endLine":231,"groupId":"23166","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testSendResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4c/1cce0f40a63b7196af1ce0a1fc6dc6508d6d34.src","preCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        Response response = new Response(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener  = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        InboundMessage.Reader reader = new InboundMessage.Reader(Version.CURRENT, namedWriteableRegistry, threadPool.getThreadContext());\n        try (InboundMessage inboundMessage = reader.deserialize(reference.slice(6, reference.length() - 6))) {\n            assertEquals(version, inboundMessage.getVersion());\n            assertEquals(requestId, inboundMessage.getRequestId());\n            assertFalse(inboundMessage.isRequest());\n            assertTrue(inboundMessage.isResponse());\n            if (isHandshake) {\n                assertTrue(inboundMessage.isHandshake());\n            } else {\n                assertFalse(inboundMessage.isHandshake());\n            }\n            if (compress) {\n                assertTrue(inboundMessage.isCompress());\n            } else {\n                assertFalse(inboundMessage.isCompress());\n            }\n\n            InboundMessage.Response inboundResponse = (InboundMessage.Response) inboundMessage;\n            assertFalse(inboundResponse.isError());\n\n            Response readMessage = new Response(inboundMessage.getStreamInput());\n            assertEquals(value, readMessage.value);\n\n            try (ThreadContext.StoredContext existing = threadContext.stashContext()) {\n                ThreadContext.StoredContext storedContext = inboundMessage.getStoredContext();\n                assertNull(threadContext.getHeader(\"header\"));\n                storedContext.restore();\n                assertEquals(\"header_value\", threadContext.getHeader(\"header\"));\n            }\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"M"}],"commitId":"42150d3674089f415e0b8c54993aef2a03d016b5","commitMessage":"@@@Move transport decoding and aggregation to server (#48263)\n\nCurrently all of our transport protocol decoding and aggregation occurs\nin the individual transport modules. This means that each implementation\n(test.  netty.  nio) must implement this logic. Additionally.  it means\nthat the entire message has been read from the network before the server\npackage receives it.\n\nThis commit creates a pipeline in server which can be passed arbitrary\nbytes to handle. Internally.  the pipeline will decode.  decompress.  and\naggregate the messages. Additionally.  this allows us to run many\nmegabytes of bytes through the pipeline in tests to ensure that the\nlogic works.\n\nThis work will enable future work:\n\nCircuit breaking or backoff logic based on message type and byte\nin the content aggregator.\nSharing bytes with the application layer using the ref counted\nreleasable network bytes.\nImproved network monitoring based specifically on channels.\nFinally.  this fixes the bug where we do not circuit break on the correct\nmessage size when compression is enabled.","date":"2020-03-28 00:40:26","modifiedFileCount":"21","status":"M","submitter":"Tim Brooks"},{"authorTime":"2021-06-30 02:14:47","codes":[{"authorDate":"2021-06-30 02:14:47","commitOrder":6,"curCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        boolean compressUnsupportedDueToVersion = compressionScheme == Compression.Scheme.LZ4\n            && version.before(Compression.Scheme.LZ4_VERSION);\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestRequest request = new TestRequest(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {\n        }));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestRequest message = new TestRequest(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertTrue(header.isRequest());\n        assertFalse(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress && compressUnsupportedDueToVersion == false) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","date":"2021-06-30 02:14:47","endLine":182,"groupId":"60535","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testSendRequest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/62/2f750e3b10cab4fec8de090ca6b211ba0df9de.src","preCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestRequest request = new TestRequest(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {\n        }));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestRequest message = new TestRequest(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertTrue(header.isRequest());\n        assertFalse(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2021-06-30 02:14:47","commitOrder":6,"curCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        boolean compressUnsupportedDueToVersion = compressionScheme == Compression.Scheme.LZ4\n            && version.before(Compression.Scheme.LZ4_VERSION);\n\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestResponse response = new TestResponse(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {\n        }));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestResponse message = new TestResponse(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertFalse(header.isRequest());\n        assertTrue(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress && compressUnsupportedDueToVersion == false) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertFalse(header.isError());\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","date":"2021-06-30 02:14:47","endLine":246,"groupId":"23166","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testSendResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/62/2f750e3b10cab4fec8de090ca6b211ba0df9de.src","preCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestResponse response = new TestResponse(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {\n        }));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestResponse message = new TestResponse(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertFalse(header.isRequest());\n        assertTrue(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertFalse(header.isError());\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":184,"status":"M"}],"commitId":"293d490ded0b99c21752eac0345f95ba90e6e57a","commitMessage":"@@@Add additional transport compression options (#74587)\n\nThis commit is related to #73497. It adds two new settings. The first setting\nis transport.compression_scheme. This setting allows the user to\nconfigure LZ4 or DEFLATE as the transport compression. Additionally.  it\nmodifies transport.compress to support the value indexing_data. When\nthis setting is set to indexing_data only messages which are primarily\ncomposed of raw source data will be compressed. This is bulk.  operations\nrecovery.  and shard changes messages.","date":"2021-06-30 02:14:47","modifiedFileCount":"33","status":"M","submitter":"Tim Brooks"},{"authorTime":"2021-08-14 03:29:22","codes":[{"authorDate":"2021-08-14 03:29:22","commitOrder":7,"curCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        boolean compressUnsupportedDueToVersion = compressionScheme == Compression.Scheme.LZ4\n            && version.before(Compression.Scheme.LZ4_VERSION);\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestRequest request = new TestRequest(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        if (compress) {\n            handler.sendRequest(node, channel, requestId, action, request, options, version, compressionScheme, isHandshake);\n        } else {\n            handler.sendRequest(node, channel, requestId, action, request, options, version, null, isHandshake);\n        }\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {\n        }));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestRequest message = new TestRequest(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertTrue(header.isRequest());\n        assertFalse(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress && compressUnsupportedDueToVersion == false) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","date":"2021-08-14 03:29:22","endLine":185,"groupId":"104428","id":13,"instanceNumber":1,"isCurCommit":1,"methodName":"testSendRequest","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/5404a3e12c085890449c441c15080b082a6c30.src","preCode":"    public void testSendRequest() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        boolean compressUnsupportedDueToVersion = compressionScheme == Compression.Scheme.LZ4\n            && version.before(Compression.Scheme.LZ4_VERSION);\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestRequest request = new TestRequest(value);\n\n        AtomicReference<DiscoveryNode> nodeRef = new AtomicReference<>();\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportRequest> requestRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request,\n                                      TransportRequestOptions options) {\n                nodeRef.set(node);\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                requestRef.set(request);\n            }\n        });\n        handler.sendRequest(node, channel, requestId, action, request, options, version, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(node, nodeRef.get());\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(request, requestRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {\n        }));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestRequest message = new TestRequest(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertTrue(header.isRequest());\n        assertFalse(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress && compressUnsupportedDueToVersion == false) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"},{"authorDate":"2021-08-14 03:29:22","commitOrder":7,"curCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        boolean compressUnsupportedDueToVersion = compressionScheme == Compression.Scheme.LZ4\n            && version.before(Compression.Scheme.LZ4_VERSION);\n\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestResponse response = new TestResponse(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        if (compress) {\n            handler.sendResponse(version, channel, requestId, action, response, compressionScheme, isHandshake);\n        } else {\n            handler.sendResponse(version, channel, requestId, action, response, null, isHandshake);\n        }\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {\n        }));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestResponse message = new TestResponse(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertFalse(header.isRequest());\n        assertTrue(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress && compressUnsupportedDueToVersion == false) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertFalse(header.isError());\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","date":"2021-08-14 03:29:22","endLine":253,"groupId":"104428","id":14,"instanceNumber":2,"isCurCommit":1,"methodName":"testSendResponse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/28/5404a3e12c085890449c441c15080b082a6c30.src","preCode":"    public void testSendResponse() throws IOException {\n        ThreadContext threadContext = threadPool.getThreadContext();\n        Version version = randomFrom(Version.CURRENT, Version.CURRENT.minimumCompatibilityVersion());\n        String action = \"handshake\";\n        long requestId = randomLongBetween(0, 300);\n        boolean isHandshake = randomBoolean();\n        boolean compress = randomBoolean();\n        boolean compressUnsupportedDueToVersion = compressionScheme == Compression.Scheme.LZ4\n            && version.before(Compression.Scheme.LZ4_VERSION);\n\n        String value = \"message\";\n        threadContext.putHeader(\"header\", \"header_value\");\n        TestResponse response = new TestResponse(value);\n\n        AtomicLong requestIdRef = new AtomicLong();\n        AtomicReference<String> actionRef = new AtomicReference<>();\n        AtomicReference<TransportResponse> responseRef = new AtomicReference<>();\n        handler.setMessageListener(new TransportMessageListener() {\n            @Override\n            public void onResponseSent(long requestId, String action, TransportResponse response) {\n                requestIdRef.set(requestId);\n                actionRef.set(action);\n                responseRef.set(response);\n            }\n        });\n        handler.sendResponse(version, channel, requestId, action, response, compress, isHandshake);\n\n        BytesReference reference = channel.getMessageCaptor().get();\n        ActionListener<Void> sendListener = channel.getListenerCaptor().get();\n        if (randomBoolean()) {\n            sendListener.onResponse(null);\n        } else {\n            sendListener.onFailure(new IOException(\"failed\"));\n        }\n        assertEquals(requestId, requestIdRef.get());\n        assertEquals(action, actionRef.get());\n        assertEquals(response, responseRef.get());\n\n        pipeline.handleBytes(channel, new ReleasableBytesReference(reference, () -> {\n        }));\n        final Tuple<Header, BytesReference> tuple = message.get();\n        final Header header = tuple.v1();\n        final TestResponse message = new TestResponse(tuple.v2().streamInput());\n        assertEquals(version, header.getVersion());\n        assertEquals(requestId, header.getRequestId());\n        assertFalse(header.isRequest());\n        assertTrue(header.isResponse());\n        if (isHandshake) {\n            assertTrue(header.isHandshake());\n        } else {\n            assertFalse(header.isHandshake());\n        }\n        if (compress && compressUnsupportedDueToVersion == false) {\n            assertTrue(header.isCompressed());\n        } else {\n            assertFalse(header.isCompressed());\n        }\n\n        assertFalse(header.isError());\n\n        assertEquals(value, message.value);\n        assertEquals(\"header_value\", header.getHeaders().v1().get(\"header\"));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/transport/OutboundHandlerTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"e6fd459a6e275efa663af0b711c87da3b18d8007","commitMessage":"@@@Respond with same compression scheme received (#76372)\n\nThis is related to #73497. Currently.  we only use the configured\ntransport.compression_scheme setting when compressing a request or a\nresponse. Additionally.  the cluster.remote.*.compression_scheme\nsetting is ignored. This commit fixes this behavior by respecting the\nper-cluster setting. Additionally.  it resolves confusion around inbound\nand outbound connections by always responding with the same scheme that\nwas received. This allows remote connections to have different schemes\nthan local connections.","date":"2021-08-14 03:29:22","modifiedFileCount":"18","status":"M","submitter":"Tim Brooks"}]
