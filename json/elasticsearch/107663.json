[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-09-18 00:41:10","commitOrder":2,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        DiskUsage usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowTresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowTresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowTresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, allocation, 0);\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2018-09-18 00:41:10","endLine":251,"groupId":"15399","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a7/426d3e551b51da198d15523ed4b19439564214.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        DiskUsage usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowTresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowTresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowTresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, allocation, 0);\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"MB"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsage usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2018-04-26 03:22:53","endLine":304,"groupId":"15400","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ad/30dc49a55242e31ce4a81214318fd56f775e7c.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsage usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"NB"}],"commitId":"7ff11b4ae1c84b8190b919d5ddb7d6e63efe5062","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-09-18 00:41:10","modifiedFileCount":"73","status":"M","submitter":"Lee Hinman"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2019-06-28 21:47:24","commitOrder":3,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        DiskUsage usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, allocation, 0);\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2019-06-28 21:47:24","endLine":254,"groupId":"15399","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/08/38999c4f36759153e1c5d0228a93e180765e3c.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        DiskUsage usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowTresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowTresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowTresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, allocation, 0);\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":3,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsage usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2018-04-26 03:22:53","endLine":304,"groupId":"15400","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ad/30dc49a55242e31ce4a81214318fd56f775e7c.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsage usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"N"}],"commitId":"88c9ecb0b06c0c1951900e162687fdd8c66bd972","commitMessage":"@@@Fix threshold spelling errors (#43326)\n\nSubstitutes treshold by threshold","date":"2019-06-28 21:47:24","modifiedFileCount":"2","status":"M","submitter":"weizijun"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2019-10-18 21:43:55","commitOrder":4,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        DiskUsage usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2019-10-18 21:43:55","endLine":276,"groupId":"15399","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a0/4823b4f11882261517aba71d2b1361c7baf0a9.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        DiskUsage usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, allocation, 0);\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":4,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsage usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2018-04-26 03:22:53","endLine":304,"groupId":"15400","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ad/30dc49a55242e31ce4a81214318fd56f775e7c.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsage usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"N"}],"commitId":"e16bb9aedef4b71f51cab4fee29a5420e10b491e","commitMessage":"@@@Quieter logging from the DiskThresholdMonitor (#48115)\n\nToday if an Elasticsearch node reaches a disk watermark then it will repeatedly\nemit logging about it.  which implies that some action needs to be taken by the\nadministrator. This is misleading. Elasticsearch strives to keep nodes under\nthe high watermark.  but it is normal to have a few nodes occasionally exceed\nthis level. Nodes may be over the low watermark for an extended period without\nany ill effects.\n\nThis commit enhances the logging emitted by the `DiskThresholdMonitor` to be\nless misleading. The expected case of hitting the high watermark and\nimmediately relocating one or more shards that to bring the node back under the\nwatermark again is reduced in severity to `INFO`. Additionally.  `INFO` messages\nare not emitted repeatedly.\n\nFixes #48038","date":"2019-10-18 21:43:55","modifiedFileCount":"10","status":"M","submitter":"David Turner"},{"authorTime":"2019-10-23 23:58:38","codes":[{"authorDate":"2019-10-23 23:58:38","commitOrder":5,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2019-10-23 23:58:38","endLine":291,"groupId":"15399","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/8d7e1f00a31abf355a4e2f54d2ed2f40171263.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        DiskUsage usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2019-10-23 23:58:38","commitOrder":5,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2019-10-23 23:58:38","endLine":357,"groupId":"0","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/8d7e1f00a31abf355a4e2f54d2ed2f40171263.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsage usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"36b03a22dc4def007786ed0ee15b6fbc601f07cc","commitMessage":"@@@Handle negative free disk space in deciders (#48392)\n\nToday it is possible that the total size of all relocating shards exceeds the\ntotal amount of free disk space. For instance.  this may be caused by another\nuser of the same disk increasing their disk usage.  or may be due to how\nElasticsearch double-counts relocations that are nearly complete particularly\nif there are many concurrent relocations in progress.\n\nThe `DiskThresholdDecider` treats negative free space similarly to zero free\nspace.  but it then fails when rendering the messages that explain its decision.\nThis commit fixes its handling of negative free space.\n\nFixes #48380","date":"2019-10-23 23:58:38","modifiedFileCount":"3","status":"M","submitter":"David Turner"},{"authorTime":"2019-10-24 15:43:46","codes":[{"authorDate":"2019-10-23 23:58:38","commitOrder":6,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2019-10-23 23:58:38","endLine":291,"groupId":"15399","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/8d7e1f00a31abf355a4e2f54d2ed2f40171263.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"N"},{"authorDate":"2019-10-24 15:43:46","commitOrder":6,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2019-10-24 15:43:46","endLine":357,"groupId":"15400","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/60/634684ed0c8079e999fc314427af155c8a9038.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"668919f7896fa262fa40a97d2deef1eb9455b035","commitMessage":"@@@Fix relocating shards size calculation (#48421)\n\nIn #48392 we added a second computation of the sizes of the relocating shards\nin `canRemain()` but passed the wrong value for `subtractLeavingShards`. This\nfixes that. It also removes some unnecessary logging in a test case added in\nthe same commit.","date":"2019-10-24 15:43:46","modifiedFileCount":"2","status":"M","submitter":"David Turner"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":7,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2020-04-01 03:52:01","endLine":291,"groupId":"15399","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/fe0b340a9d3e4d0bfd0f3f8c9d7b737f509646.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":7,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2020-04-01 03:52:01","endLine":357,"groupId":"15400","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/fe0b340a9d3e4d0bfd0f3f8c9d7b737f509646.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metaData(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-09-07 20:03:03","commitOrder":8,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating [{}] node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\", shardRouting,\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating [{}] node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\", shardRouting,\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2020-09-07 20:03:03","endLine":307,"groupId":"15399","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/dd/84712559e29000bb129363e87f6470f351affa.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating, node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\",\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating, node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\",\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":8,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2020-04-01 03:52:01","endLine":357,"groupId":"15400","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/fe0b340a9d3e4d0bfd0f3f8c9d7b737f509646.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"N"}],"commitId":"5f8c1f04845d495744de5ddb0b49a9e0e5c73b4b","commitMessage":"@@@Introduce integ tests for high disk watermark (#60460)\n\nAn important goal of the disk threshold decider is to ensure that nodes\nuse less disk space than the high watermark.  and to take action if a\nnode ever exceeds this watermark. Today we do not have any\nintegration-style tests of this high-level behaviour. This commit\nintroduces a small test harness that can adjust the apparent size of the\ndisk and verify that the disk threshold decider moves shards around in\nresponse.\n\nCo-authored-by: Yannick Welsch <yannick@welsch.lu>","date":"2020-09-07 20:03:03","modifiedFileCount":"5","status":"M","submitter":"David Turner"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-10-06 23:29:42","commitOrder":9,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.snapshotShardSizeInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating [{}] node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\", shardRouting,\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating [{}] node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\", shardRouting,\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2020-10-06 23:29:42","endLine":308,"groupId":"15399","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9c/783c1a414155560814a0c8b225b8a7fa3df231.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating [{}] node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\", shardRouting,\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating [{}] node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\", shardRouting,\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":9,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2020-04-01 03:52:01","endLine":357,"groupId":"15400","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e3/fe0b340a9d3e4d0bfd0f3f8c9d7b737f509646.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":294,"status":"N"}],"commitId":"2afec0d916c7de33c9a6c3cbe30a8a2ee61be765","commitMessage":"@@@Determine shard size before allocating shards recovering from snapshots (#61906)\n\nDetermines the shard size of shards before allocating shards that are \nrecovering from snapshots. It ensures during shard allocation that the \ntarget node that is selected as recovery target will have enough free \ndisk space for the recovery event. This applies to regular restores.  \nCCR bootstrap from remote.  as well as mounting searchable snapshots.\n\nThe InternalSnapshotInfoService is responsible for fetching snapshot \nshard sizes from repositories. It provides a getShardSize() method \nto other components of the system that can be used to retrieve the \nlatest known shard size. If the latest snapshot shard size retrieval \nfailed.  the getShardSize() returns \nShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE. While \nwe'd like a better way to handle such failures.  returning this value \nallows to keep the existing behavior for now.\n\nNote that this PR does not address an issues (we already have today) \nwhere a replica is being allocated without knowing how much disk \nspace is being used by the primary. ","date":"2020-10-06 23:29:42","modifiedFileCount":"49","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2020-11-06 22:24:22","codes":[{"authorDate":"2020-11-06 22:24:22","commitOrder":10,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ImmutableOpenMap<String, DiskUsage> usages = allocation.clusterInfo().getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return YES_UNALLOCATED_PRIMARY_BETWEEN_WATERMARKS;\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return YES_UNALLOCATED_PRIMARY_BETWEEN_WATERMARKS;\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.snapshotShardSizeInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating [{}] node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\", shardRouting,\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating [{}] node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\", shardRouting,\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2020-11-06 22:24:22","endLine":305,"groupId":"61717","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f0/82605d2951194601d79544e940185d216dca5e.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ClusterInfo clusterInfo = allocation.clusterInfo();\n        ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                        \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                        \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.YES, NAME,\n                    \"the node is above the low watermark, but less than the high watermark, and this primary shard has \" +\n                    \"never been allocated before\");\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.snapshotShardSizeInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating [{}] node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\", shardRouting,\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating [{}] node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\", shardRouting,\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"},{"authorDate":"2020-11-06 22:24:22","commitOrder":10,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return YES_NOT_MOST_UTILIZED_DISK;\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2020-11-06 22:24:22","endLine":373,"groupId":"31606","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f0/82605d2951194601d79544e940185d216dca5e.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return allocation.decision(Decision.YES, NAME,\n                    \"this shard is not allocated on the most utilized disk and can remain\");\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":311,"status":"M"}],"commitId":"efecaed611c006527e6959bf6c731091f5d12783","commitMessage":"@@@Small Simplifications DiskThresholdDecider (#64703)\n\nSome smaller improvements in the direction of #62275 and removal of some\ndead code and duplication.","date":"2020-11-06 22:24:22","modifiedFileCount":"1","status":"M","submitter":"Armin Braun"},{"authorTime":"2021-02-09 01:11:26","codes":[{"authorDate":"2021-02-09 01:11:26","commitOrder":11,"curCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ImmutableOpenMap<String, DiskUsage> usages = allocation.clusterInfo().getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        if (SETTING_IGNORE_DISK_WATERMARKS.get(allocation.metadata().index(shardRouting.index()).getSettings())) {\n            return YES_DISK_WATERMARKS_IGNORED;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return YES_UNALLOCATED_PRIMARY_BETWEEN_WATERMARKS;\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return YES_UNALLOCATED_PRIMARY_BETWEEN_WATERMARKS;\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.snapshotShardSizeInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating [{}] node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\", shardRouting,\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating [{}] node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\", shardRouting,\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","date":"2021-02-09 01:11:26","endLine":305,"groupId":"107663","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"canAllocate","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bf/5df649e83b7f944b689d134790811587ffea5b.src","preCode":"    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        ImmutableOpenMap<String, DiskUsage> usages = allocation.clusterInfo().getNodeMostAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        final double usedDiskThresholdLow = 100.0 - diskThresholdSettings.getFreeDiskThresholdLow();\n        final double usedDiskThresholdHigh = 100.0 - diskThresholdSettings.getFreeDiskThresholdHigh();\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, false);\n        \r\n        double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        \r\n        double usedDiskPercentage = usage.getUsedDiskAsPercentage();\n        long freeBytes = usage.getFreeBytes();\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, false, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, preventing allocation\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n\n            return allocation.decision(Decision.NO, NAME,\n                \"the node has fewer free bytes remaining than the total size of all incoming shards: \" +\n                    \"free space [%sB], relocating shards [%sB]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n\n        ByteSizeValue freeBytesValue = new ByteSizeValue(freeBytes);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% used disk\", node.nodeId(), usedDiskPercentage);\n        }\n\n        \r\n        \r\n        boolean skipLowThresholdChecks = shardRouting.primary() &&\n            shardRouting.active() == false && shardRouting.recoverySource().getType() == RecoverySource.Type.EMPTY_STORE;\n\n        \r\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, preventing allocation\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue);\n            } else if (freeBytes > diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdLow(), freeBytesValue, node.nodeId());\n                }\n                return YES_UNALLOCATED_PRIMARY_BETWEEN_WATERMARKS;\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], having less than the minimum required [%s] free \" +\n                    \"space, actual free: [%s]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(),\n                    diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue);\n            }\n        }\n\n        \r\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdLow()) {\n            \r\n            if (skipLowThresholdChecks == false) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the low watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getLowWatermarkRaw(), usedDiskThresholdLow, freeDiskPercentage);\n            } else if (freeDiskPercentage > diskThresholdSettings.getFreeDiskThresholdHigh()) {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"more than the allowed {} used disk threshold ({} used) on node [{}], \" +\n                                    \"but allowing allocation because primary has never been allocated\",\n                            Strings.format1Decimals(usedDiskThresholdLow, \"%\"),\n                            Strings.format1Decimals(usedDiskPercentage, \"%\"), node.nodeId());\n                }\n                return YES_UNALLOCATED_PRIMARY_BETWEEN_WATERMARKS;\n            } else {\n                \r\n                \r\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, \" +\n                                    \"preventing allocation even though primary has never been allocated\",\n                            Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                            Strings.format1Decimals(freeDiskPercentage, \"%\"), node.nodeId());\n                }\n                return allocation.decision(Decision.NO, NAME,\n                    \"the node is above the high watermark cluster setting [%s=%s], using more disk space than the maximum allowed \" +\n                    \"[%s%%], actual free: [%s%%]\",\n                    CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                    diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeDiskPercentage);\n            }\n        }\n\n        \r\n        final long shardSize = getExpectedShardSize(shardRouting, 0L,\n            allocation.clusterInfo(), allocation.snapshotShardSizeInfo(), allocation.metadata(), allocation.routingTable());\n        assert shardSize >= 0 : shardSize;\n        double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned(usage, shardSize);\n        long freeBytesAfterShard = freeBytes - shardSize;\n        if (freeBytesAfterShard < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            logger.warn(\"after allocating [{}] node [{}] would have less than the required threshold of \" +\n                    \"{} free (currently {} free, estimated shard size is {}), preventing allocation\", shardRouting,\n                    node.nodeId(), diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytesValue, new ByteSizeValue(shardSize));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to have less than the minimum required [%s] of free space (free: [%s], estimated shard size: [%s])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(),\n                freeBytesValue, new ByteSizeValue(shardSize));\n        }\n        if (freeSpaceAfterShard < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            logger.warn(\"after allocating [{}] node [{}] would have more than the allowed \" +\n                            \"{} free disk threshold ({} free), preventing allocation\", shardRouting,\n                    node.nodeId(), Strings.format1Decimals(diskThresholdSettings.getFreeDiskThresholdHigh(), \"%\"),\n                                                           Strings.format1Decimals(freeSpaceAfterShard, \"%\"));\n            return allocation.decision(Decision.NO, NAME,\n                \"allocating the shard to this node will bring the node above the high watermark cluster setting [%s=%s] \" +\n                    \"and cause it to use more disk space than the maximum allowed [%s%%] (free space after shard added: [%s%%])\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(), usedDiskThresholdHigh, freeSpaceAfterShard);\n        }\n\n        assert freeBytesAfterShard >= 0 : freeBytesAfterShard;\n        return allocation.decision(Decision.YES, NAME,\n                \"enough disk for shard on node, free: [%s], shard size: [%s], free after allocating shard: [%s]\",\n                freeBytesValue,\n                new ByteSizeValue(shardSize),\n                new ByteSizeValue(freeBytesAfterShard));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"M"},{"authorDate":"2021-02-09 01:11:26","commitOrder":11,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        if (SETTING_IGNORE_DISK_WATERMARKS.get(allocation.metadata().index(shardRouting.index()).getSettings())) {\n            return YES_DISK_WATERMARKS_IGNORED;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return YES_NOT_MOST_UTILIZED_DISK;\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","date":"2021-02-09 01:11:26","endLine":377,"groupId":"107663","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bf/5df649e83b7f944b689d134790811587ffea5b.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.currentNodeId().equals(node.nodeId()) == false) {\n            throw new IllegalArgumentException(\"Shard [\" + shardRouting + \"] is not allocated on node: [\" + node.nodeId() + \"]\");\n        }\n        final ClusterInfo clusterInfo = allocation.clusterInfo();\n        final ImmutableOpenMap<String, DiskUsage> usages = clusterInfo.getNodeLeastAvailableDiskUsages();\n        final Decision decision = earlyTerminate(allocation, usages);\n        if (decision != null) {\n            return decision;\n        }\n\n        \r\n        \r\n        final DiskUsageWithRelocations usage = getDiskUsage(node, allocation, usages, true);\n        final String dataPath = clusterInfo.getDataPath(shardRouting);\n        \r\n        final double freeDiskPercentage = usage.getFreeDiskAsPercentage();\n        final long freeBytes = usage.getFreeBytes();\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"node [{}] has {}% free disk ({} bytes)\", node.nodeId(), freeDiskPercentage, freeBytes);\n        }\n        if (dataPath == null || usage.getPath().equals(dataPath) == false) {\n            return YES_NOT_MOST_UTILIZED_DISK;\n        }\n        if (freeBytes < 0L) {\n            final long sizeOfRelocatingShards = sizeOfRelocatingShards(node, true, usage.getPath(),\n                allocation.clusterInfo(), allocation.metadata(), allocation.routingTable());\n            logger.debug(\"fewer free bytes remaining than the size of all incoming shards: \" +\n                    \"usage {} on node {} including {} bytes of relocations, shard cannot remain\",\n                usage, node.nodeId(), sizeOfRelocatingShards);\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because the node has fewer free bytes remaining than the total size of all \" +\n                    \"incoming shards: free space [%s], relocating shards [%s]\",\n                freeBytes + sizeOfRelocatingShards, sizeOfRelocatingShards);\n        }\n        if (freeBytes < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeBytesThresholdHigh(), freeBytes, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s] free space on node, actual free: [%s]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeBytesThresholdHigh(), new ByteSizeValue(freeBytes));\n        }\n        if (freeDiskPercentage < diskThresholdSettings.getFreeDiskThresholdHigh()) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain\",\n                        diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage, node.nodeId());\n            }\n            return allocation.decision(Decision.NO, NAME,\n                \"the shard cannot remain on this node because it is above the high watermark cluster setting [%s=%s] \" +\n                    \"and there is less than the required [%s%%] free disk on node, actual free: [%s%%]\",\n                CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(),\n                diskThresholdSettings.getHighWatermarkRaw(),\n                diskThresholdSettings.getFreeDiskThresholdHigh(), freeDiskPercentage);\n        }\n\n        return allocation.decision(Decision.YES, NAME,\n                \"there is enough disk on this node for the shard to remain, free: [%s]\", new ByteSizeValue(freeBytes));\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":311,"status":"M"}],"commitId":"716bd74ebd4314fa2c5ca45c513ecc1b4e94c562","commitMessage":"@@@Ignore disk watermarks on partial shards (#68673)\n\nToday the disk threshold decider applies even to partially-restored\nshards.  which makes no sense since these shards effectively consume no\ndisk space of their own. With this commit the disk threshold decider now\nfreely permits the allocation of these shards.","date":"2021-02-09 01:11:26","modifiedFileCount":"6","status":"M","submitter":"David Turner"}]
