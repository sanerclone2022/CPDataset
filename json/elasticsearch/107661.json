[{"authorTime":"2019-11-15 21:25:32","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\", shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else if (decision != Decision.ALWAYS\n                        && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {\n                ret.add(decision);\n            }\n        }\n        return ret;\n    }\n","date":"2018-04-26 03:22:53","endLine":122,"groupId":"34212","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/53/e67ba25a429a4640cb73bda269bd52d1de0fd8.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\", shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else if (decision != Decision.ALWAYS\n                        && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {\n                ret.add(decision);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"NB"},{"authorDate":"2019-11-15 21:25:32","commitOrder":2,"curCode":"    public Decision shouldAutoExpandToNode(IndexMetaData indexMetaData, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetaData, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else if (decision != Decision.ALWAYS\n                && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {\n                ret.add(decision);\n            }\n        }\n        return ret;\n    }\n","date":"2019-11-15 21:25:32","endLine":167,"groupId":"34214","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldAutoExpandToNode","params":"(IndexMetaDataindexMetaData@DiscoveryNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f7/ec43b5197ea099dc10d6d943dfe2b04bc4c48f.src","preCode":"    public Decision shouldAutoExpandToNode(IndexMetaData indexMetaData, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetaData, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else if (decision != Decision.ALWAYS\n                && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {\n                ret.add(decision);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"B"}],"commitId":"18c2aab5766892d3ac5b3ffa84e525033ed5dec8","commitMessage":"@@@Auto-expand indices according to allocation filtering rules (#48974)\n\nHonours allocation filtering rules when auto-expanding indices.","date":"2019-11-15 21:25:32","modifiedFileCount":"6","status":"M","submitter":"Yannick Welsch"},{"authorTime":"2020-02-19 18:12:50","codes":[{"authorDate":"2020-02-19 18:12:50","commitOrder":3,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\",\n                        shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","date":"2020-02-19 18:12:50","endLine":120,"groupId":"34212","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3f/0607df3caa01d789007a4e455752b9225847d9.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\",\n                        shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else if (decision != Decision.ALWAYS\n                        && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {\n                ret.add(decision);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2020-02-19 18:12:50","commitOrder":3,"curCode":"    public Decision shouldAutoExpandToNode(IndexMetaData indexMetaData, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetaData, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","date":"2020-02-19 18:12:50","endLine":158,"groupId":"34214","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldAutoExpandToNode","params":"(IndexMetaDataindexMetaData@DiscoveryNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3f/0607df3caa01d789007a4e455752b9225847d9.src","preCode":"    public Decision shouldAutoExpandToNode(IndexMetaData indexMetaData, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetaData, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else if (decision != Decision.ALWAYS\n                && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {\n                ret.add(decision);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"}],"commitId":"2f6ac68fd821b5971b04b17742d7cd356988ce61","commitMessage":"@@@Deciders should not by default collect yes'es (#52438)\n\nAllocationDeciders would collect Yes decisions when not asking for debug\ninfo. Changed to only include Yes decisions when debug is requested\n(explain).","date":"2020-02-19 18:12:50","modifiedFileCount":"1","status":"M","submitter":"Henning Andersen"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-02-19 18:12:50","commitOrder":4,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\",\n                        shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","date":"2020-02-19 18:12:50","endLine":120,"groupId":"34212","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3f/0607df3caa01d789007a4e455752b9225847d9.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\",\n                        shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"N"},{"authorDate":"2020-04-01 03:52:01","commitOrder":4,"curCode":"    public Decision shouldAutoExpandToNode(IndexMetadata indexMetadata, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetadata, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","date":"2020-04-01 03:52:01","endLine":158,"groupId":"34214","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldAutoExpandToNode","params":"(IndexMetadataindexMetadata@DiscoveryNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/59/33c0bda3ac4da8b9591df7d33afdb04009c82c.src","preCode":"    public Decision shouldAutoExpandToNode(IndexMetaData indexMetaData, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetaData, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-10-31 01:30:42","codes":[{"authorDate":"2020-10-31 01:30:42","commitOrder":5,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision.type() == Decision.Type.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\",\n                        shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return Decision.NO;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","date":"2020-10-31 01:30:42","endLine":120,"groupId":"9777","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a7/b3f9ba18efbdd061c8a665fd02fed440ffd784.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\",\n                        shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2020-10-31 01:30:42","commitOrder":5,"curCode":"    public Decision shouldAutoExpandToNode(IndexMetadata indexMetadata, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetadata, node, allocation);\n            \r\n            if (decision.type() == Decision.Type.NO) {\n                if (!allocation.debugDecision()) {\n                    return Decision.NO;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","date":"2020-10-31 01:30:42","endLine":158,"groupId":"9783","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldAutoExpandToNode","params":"(IndexMetadataindexMetadata@DiscoveryNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a7/b3f9ba18efbdd061c8a665fd02fed440ffd784.src","preCode":"    public Decision shouldAutoExpandToNode(IndexMetadata indexMetadata, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetadata, node, allocation);\n            \r\n            if (decision == Decision.NO) {\n                if (!allocation.debugDecision()) {\n                    return decision;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"}],"commitId":"0ed5174cb870c4d6be23c7820513cbdb3cf0ecb8","commitMessage":"@@@Make some Allocation Decider Code a Little More JIT Aware (#62275)\n\nWhen investigating our code cache usage for another issue I ran into this. This PR just fixes a few spots and there's many more. The current way we compute the decisions often creates much larger than necessary methods because the compiler has no efficient way of optimizing away things like using CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING.getKey() as an explain parameter that do allocations (but whose results are thrown away immediately if debug is off).\n\nAs a result e.g. the max retry allocation decider's canAllocate compiles into an 18kb method before and into a 2kb method after this change (at C1 L3). I think if we're a little more mindful of the JIT here we can get some measurable speedups out of the allocation deciders logic. Plus.  this kind of change saves quite a few in allocations in isolation as well which is always nice on a hot CS thread I suppose.","date":"2020-10-31 01:30:42","modifiedFileCount":"8","status":"M","submitter":"Armin Braun"},{"authorTime":"2021-02-02 18:20:51","codes":[{"authorDate":"2021-02-02 18:20:51","commitOrder":6,"curCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision.type() == Decision.Type.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\",\n                        shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (allocation.debugDecision() == false) {\n                    return Decision.NO;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","date":"2021-02-02 18:20:51","endLine":120,"groupId":"107661","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"canRemain","params":"(ShardRoutingshardRouting@RoutingNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7d/bdafa728d20fff24666963362b054c0eea74f3.src","preCode":"    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Shard [{}] should be ignored for node [{}]\", shardRouting, node.nodeId());\n            }\n            return Decision.NO;\n        }\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.canRemain(shardRouting, node, allocation);\n            \r\n            if (decision.type() == Decision.Type.NO) {\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Shard [{}] can not remain on node [{}] due to [{}]\",\n                        shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName());\n                }\n                if (!allocation.debugDecision()) {\n                    return Decision.NO;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"},{"authorDate":"2021-02-02 18:20:51","commitOrder":6,"curCode":"    public Decision shouldAutoExpandToNode(IndexMetadata indexMetadata, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetadata, node, allocation);\n            \r\n            if (decision.type() == Decision.Type.NO) {\n                if (allocation.debugDecision() == false) {\n                    return Decision.NO;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","date":"2021-02-02 18:20:51","endLine":158,"groupId":"107661","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldAutoExpandToNode","params":"(IndexMetadataindexMetadata@DiscoveryNodenode@RoutingAllocationallocation)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/7d/bdafa728d20fff24666963362b054c0eea74f3.src","preCode":"    public Decision shouldAutoExpandToNode(IndexMetadata indexMetadata, DiscoveryNode node, RoutingAllocation allocation) {\n        Decision.Multi ret = new Decision.Multi();\n        for (AllocationDecider allocationDecider : allocations) {\n            Decision decision = allocationDecider.shouldAutoExpandToNode(indexMetadata, node, allocation);\n            \r\n            if (decision.type() == Decision.Type.NO) {\n                if (!allocation.debugDecision()) {\n                    return Decision.NO;\n                } else {\n                    ret.add(decision);\n                }\n            } else {\n                addDecision(ret, decision, allocation);\n            }\n        }\n        return ret;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/AllocationDeciders.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"}],"commitId":"dfac67aff0ca126901d72ed7fe862a1e7adb19b0","commitMessage":"@@@Replace NOT operator with explicit `false` check - part 4 (#68275)\n\nPart 4.\n\nWe have an in-house rule to compare explicitly against `false` instead\nof using the logical not operator (`!`). However.  this hasn't\nhistorically been enforced.  meaning that there are many violations in\nthe source at present.\n\nWe now have a Checkstyle rule that can detect these cases.  but before we\ncan turn it on.  we need to fix the existing violations. This is being\ndone over a series of PRs.  since there are a lot to fix.","date":"2021-02-02 18:20:51","modifiedFileCount":"93","status":"M","submitter":"Rory Hunter"}]
