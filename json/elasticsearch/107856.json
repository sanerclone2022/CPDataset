[{"authorTime":"2021-01-25 23:36:30","codes":[{"authorDate":"2021-01-25 23:36:30","commitOrder":2,"curCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.root().findTemplate(context.path(), name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n            RuntimeFieldType.Parser parser = parserContext.runtimeFieldTypeParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeFieldType runtimeFieldType = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeFieldType, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","date":"2021-01-25 23:36:30","endLine":219,"groupId":"30147","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"applyMatchingTemplate","params":"(ParseContextcontext@Stringname@DynamicTemplate.XContentFieldTypematchType@DateFormatterdateFormatter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d9/f346ba46623e611a1df20efcd3ba09703b6727.src","preCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.root().findTemplate(context.path(), name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n            RuntimeFieldType.Parser parser = parserContext.runtimeFieldTypeParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeFieldType runtimeFieldType = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeFieldType, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"MB"},{"authorDate":"2021-01-25 23:36:30","commitOrder":2,"curCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n        parserContext = parserContext.createDynamicTemplateFieldContext(parserContext);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","date":"2021-01-25 23:36:30","endLine":245,"groupId":"33761","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"parseDynamicTemplateMapping","params":"(Stringname@StringmappingType@Map<String@Object>mapping@DateFormatterdateFormatter@ParseContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d9/f346ba46623e611a1df20efcd3ba09703b6727.src","preCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n        parserContext = parserContext.createDynamicTemplateFieldContext(parserContext);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"B"}],"commitId":"54c8d45fa561335b8a5bd0790e6c5ec19a2bf361","commitMessage":"@@@Add bwc for parsing mappings from dynamic templates (#67763)\n\nDuring refactoring of the mapper parsing code.  the part that checks for unknown\nmapper parameters and throws an error when one is found was moved to\nFieldMapper.Builder#parse which gets also executed when applying matching\ndynamic templates. However.  dynamic templates introduced during the 7.x versions\nmay still contain arbitrary parameters.  although we have deprecation warnings\nfor that in place on latest 7.x now. When using these templates.  indexing a new\ndocument with a new field that triggers one of these mappings to be parsed can\ncreate an error as demonstrated in #66765. Instead we need to be lenient in\nthese cases and simply ignore the unknown parameter while issuing a deprecation\nwarning here as well.\n\nCloses #66765","date":"2021-01-25 23:36:30","modifiedFileCount":"4","status":"M","submitter":"Christoph B?scher"},{"authorTime":"2021-01-25 23:36:30","codes":[{"authorDate":"2021-03-23 19:24:33","commitOrder":3,"curCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.root().findTemplate(context.path(), name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","date":"2021-03-23 19:24:33","endLine":213,"groupId":"59972","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"applyMatchingTemplate","params":"(ParseContextcontext@Stringname@DynamicTemplate.XContentFieldTypematchType@DateFormatterdateFormatter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/9e/fbc1f8fdc1cf492b166d7628073db2d5b0ee78.src","preCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.root().findTemplate(context.path(), name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n            RuntimeFieldType.Parser parser = parserContext.runtimeFieldTypeParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeFieldType runtimeFieldType = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeFieldType, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"},{"authorDate":"2021-01-25 23:36:30","commitOrder":3,"curCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n        parserContext = parserContext.createDynamicTemplateFieldContext(parserContext);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","date":"2021-01-25 23:36:30","endLine":245,"groupId":"33761","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"parseDynamicTemplateMapping","params":"(Stringname@StringmappingType@Map<String@Object>mapping@DateFormatterdateFormatter@ParseContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d9/f346ba46623e611a1df20efcd3ba09703b6727.src","preCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n        parserContext = parserContext.createDynamicTemplateFieldContext(parserContext);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"N"}],"commitId":"3e81651a8cdbc2813466c0b2ec57f716e7356405","commitMessage":"@@@Rename RuntimeFieldType to RuntimeField (#70719)\n\nRuntimeFieldType was recently made an interface.  hence it no longer extends MappedFieldType. It makes sense then to rename it to RuntimeField.\n","date":"2021-03-23 19:24:33","modifiedFileCount":"34","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-01-25 23:36:30","codes":[{"authorDate":"2021-04-21 21:28:12","commitOrder":4,"curCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","date":"2021-04-21 21:28:12","endLine":209,"groupId":"59972","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"applyMatchingTemplate","params":"(ParseContextcontext@Stringname@DynamicTemplate.XContentFieldTypematchType@DateFormatterdateFormatter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f5/6843672f29d66b813e5df0ebd076134be96ef7.src","preCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.root().findTemplate(context.path(), name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":183,"status":"M"},{"authorDate":"2021-01-25 23:36:30","commitOrder":4,"curCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n        parserContext = parserContext.createDynamicTemplateFieldContext(parserContext);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","date":"2021-01-25 23:36:30","endLine":245,"groupId":"33761","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"parseDynamicTemplateMapping","params":"(Stringname@StringmappingType@Map<String@Object>mapping@DateFormatterdateFormatter@ParseContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d9/f346ba46623e611a1df20efcd3ba09703b6727.src","preCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n        parserContext = parserContext.createDynamicTemplateFieldContext(parserContext);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":233,"status":"N"}],"commitId":"9a86dde3572a6f3999eea75bc3ce30b965837ba3","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-21 21:28:12","modifiedFileCount":"1285","status":"M","submitter":"iverase"},{"authorTime":"2021-06-18 07:33:58","codes":[{"authorDate":"2021-06-18 07:33:58","commitOrder":5,"curCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","date":"2021-06-18 07:33:58","endLine":209,"groupId":"59972","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"applyMatchingTemplate","params":"(ParseContextcontext@Stringname@DynamicTemplate.XContentFieldTypematchType@DateFormatterdateFormatter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3d/3ef06141c77535c479191c3ba27ce5777dc800.src","preCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":183,"status":"M"},{"authorDate":"2021-06-18 07:33:58","commitOrder":5,"curCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","date":"2021-06-18 07:33:58","endLine":234,"groupId":"33761","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"parseDynamicTemplateMapping","params":"(Stringname@StringmappingType@Map<String@Object>mapping@DateFormatterdateFormatter@ParseContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3d/3ef06141c77535c479191c3ba27ce5777dc800.src","preCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.parserContext(dateFormatter);\n        parserContext = parserContext.createDynamicTemplateFieldContext(parserContext);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"M"}],"commitId":"82ae6742eba59c58a93bf9e32ea37220d01ab75c","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles","date":"2021-06-18 07:33:58","modifiedFileCount":"125","status":"M","submitter":"Elastic Machine"},{"authorTime":"2021-06-23 15:28:56","codes":[{"authorDate":"2021-06-23 15:28:56","commitOrder":6,"curCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","date":"2021-06-23 15:28:56","endLine":207,"groupId":"59972","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"applyMatchingTemplate","params":"(ParseContextcontext@Stringname@DynamicTemplate.XContentFieldTypematchType@DateFormatterdateFormatter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d4/79a74a7c32215175a01aaa48dd6bab42fca67c.src","preCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            Mapper.TypeParser.ParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"M"},{"authorDate":"2021-06-23 15:28:56","commitOrder":6,"curCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","date":"2021-06-23 15:28:56","endLine":232,"groupId":"33761","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"parseDynamicTemplateMapping","params":"(Stringname@StringmappingType@Map<String@Object>mapping@DateFormatterdateFormatter@ParseContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d4/79a74a7c32215175a01aaa48dd6bab42fca67c.src","preCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        Mapper.TypeParser.ParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"M"}],"commitId":"0d0e403258fe5817da4cda5ed60e769dccdc2ee1","commitMessage":"@@@Move and rename ParserContext (#74402)\n\nParserContext is an inner class of Mapper.TypeParser but is used outside of the context of parsing mappers.  for instance also to parse runtime fields. Its purpose is to be used to parse mappings in general.  and its name is confusing as it differs ever so slightly from ParseContext which is used for parsing incoming documents.\n\nThis commit moves ParserContext to be a top-level class.  and renames it to MappingParserContext.\n","date":"2021-06-23 15:28:56","modifiedFileCount":"25","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-07-06 21:15:59","codes":[{"authorDate":"2021-07-06 21:15:59","commitOrder":7,"curCode":"    private static boolean applyMatchingTemplate(DocumentParserContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","date":"2021-07-06 21:15:59","endLine":207,"groupId":"59972","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"applyMatchingTemplate","params":"(DocumentParserContextcontext@Stringname@DynamicTemplate.XContentFieldTypematchType@DateFormatterdateFormatter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/38/6e72fa18ac47c1ff7186088a435a4911ab4f59.src","preCode":"    private static boolean applyMatchingTemplate(ParseContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"M"},{"authorDate":"2021-07-06 21:15:59","commitOrder":7,"curCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               DocumentParserContext context) {\n        MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","date":"2021-07-06 21:15:59","endLine":232,"groupId":"33761","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"parseDynamicTemplateMapping","params":"(Stringname@StringmappingType@Map<String@Object>mapping@DateFormatterdateFormatter@DocumentParserContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/38/6e72fa18ac47c1ff7186088a435a4911ab4f59.src","preCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               ParseContext context) {\n        MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"M"}],"commitId":"c6641bf00c2ae7b9024e0f6d4ecad4596a67facc","commitMessage":"@@@Rename ParseContext to DocumentParserContext (#74963)\n\nParseContext is used to parse documents. It was easily confused with ParserContext (now renamed to MappingParserContext) which is instead used to parse mappings.\n\nTo remove any confusion.  this commit renames ParseContext to DocumentParserContext and adapts its subclasses accordingly.","date":"2021-07-06 21:15:59","modifiedFileCount":"66","status":"M","submitter":"Luca Cavanna"},{"authorTime":"2021-07-06 21:15:59","codes":[{"authorDate":"2021-08-10 20:07:53","commitOrder":8,"curCode":"    private static boolean applyMatchingTemplate(DocumentParserContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField.Builder builder = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(builder.createRuntimeField(parserContext), context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","date":"2021-08-10 20:07:53","endLine":206,"groupId":"107856","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"applyMatchingTemplate","params":"(DocumentParserContextcontext@Stringname@DynamicTemplate.XContentFieldTypematchType@DateFormatterdateFormatter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d9/8cdb403f848443d88f410b330a8f7bdf599f93.src","preCode":"    private static boolean applyMatchingTemplate(DocumentParserContext context,\n                                                 String name,\n                                                 DynamicTemplate.XContentFieldType matchType,\n                                                 DateFormatter dateFormatter) throws IOException {\n        DynamicTemplate dynamicTemplate = context.findDynamicTemplate(name, matchType);\n        if (dynamicTemplate == null) {\n            return false;\n        }\n        String dynamicType = dynamicTemplate.isRuntimeMapping() ? matchType.defaultRuntimeMappingType() : matchType.defaultMappingType();\n\n        String mappingType = dynamicTemplate.mappingType(dynamicType);\n        Map<String, Object> mapping = dynamicTemplate.mappingForName(name, dynamicType);\n        if (dynamicTemplate.isRuntimeMapping()) {\n            MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n            RuntimeField.Parser parser = parserContext.runtimeFieldParser(mappingType);\n            String fullName = context.path().pathAsText(name);\n            if (parser == null) {\n                throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + fullName + \"]\");\n            }\n            RuntimeField runtimeField = parser.parse(fullName, mapping, parserContext);\n            Runtime.createDynamicField(runtimeField, context);\n        } else {\n            Mapper.Builder builder = parseDynamicTemplateMapping(name, mappingType, mapping, dateFormatter, context);\n            CONCRETE.createDynamicField(builder, context);\n        }\n        return true;\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"M"},{"authorDate":"2021-07-06 21:15:59","commitOrder":8,"curCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               DocumentParserContext context) {\n        MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","date":"2021-07-06 21:15:59","endLine":232,"groupId":"107856","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"parseDynamicTemplateMapping","params":"(Stringname@StringmappingType@Map<String@Object>mapping@DateFormatterdateFormatter@DocumentParserContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/38/6e72fa18ac47c1ff7186088a435a4911ab4f59.src","preCode":"    private static Mapper.Builder parseDynamicTemplateMapping(String name,\n                                               String mappingType,\n                                               Map<String, Object> mapping,\n                                               DateFormatter dateFormatter,\n                                               DocumentParserContext context) {\n        MappingParserContext parserContext = context.dynamicTemplateParserContext(dateFormatter);\n        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType);\n        if (typeParser == null) {\n            throw new MapperParsingException(\"failed to find type parsed [\" + mappingType + \"] for [\" + name + \"]\");\n        }\n        return typeParser.parse(name, mapping, parserContext);\n    }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/DynamicFieldsBuilder.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":221,"status":"N"}],"commitId":"32d2f60f8aec4d2a2291c67a508c9796cb74bf82","commitMessage":"@@@Emit multiple fields from a runtime field script (#75108)\n\nWe have recently introduced support for grok and dissect to the runtime fields \nPainless context that allows to split a field into multiple fields. However.  each runtime \nfield can only emit values for a single field. This commit introduces support for emitting \nmultiple fields from the same script.\n\nThe API call to define a runtime field that emits multiple fields is the following:\n\n```\nPUT localhost:9200/logs/_mappings\n{\n    \"runtime\" : {\n      \"log\" : {\n        \"type\" : \"composite\". \n        \"script\" : \"emit(grok(\\\"%{COMMONAPACHELOG}\\\").extract(doc[\\\"message.keyword\\\"].value))\". \n        \"fields\" : {\n            \"clientip\" : {\n                \"type\" : \"ip\"\n            }. \n            \"response\" : {\n                \"type\" : \"long\"\n            }\n        }\n      }\n    }\n}\n```\n\nThe script context for this new field type accepts two emit signatures:\n\n* `emit(String.  Object)`\n* `emit(Map)`\n\nSub-fields need to be declared under fields in order to be discoverable through \nthe field_caps API and accessible through the search API. \n\nThe way that it emits multiple fields is by returning multiple MappedFieldTypes \nfrom RuntimeField#asMappedFieldTypes. The sub-fields are instances of the \nruntime fields that are already supported.  with a little tweak to adapt the script \ndefined by their parent to an artificial script factory for each of the sub-fields \nthat makes its corresponding sub-field accessible. This approach allows to reuse \nall of the existing runtime fields code for the sub-fields.\n\nThe runtime section has been flat so far as it has not supported objects until now. \nThat stays the same.  meaning that runtime fields can have dots in their names. \nBecause there are though two ways to create the same field with the introduction \nof the ability to emit multiple fields.  we have to make sure that a runtime field with \na certain name cannot be defined twice.  which is why the following mappings are \nrejected with the error `Found two runtime fields with same name [log.response]`:\n\n```\nPUT localhost:9200/logs/_mappings\n{\n    \"runtime\" : {\n        \"log.response\" : {\n            \"type\" : \"keyword\"\n        }. \n        \"log\" : {\n            \"type\" : \"composite\". \n            \"script\" : \"emit(\\\"response\\\".  grok(\\\"%{COMMONAPACHELOG}\\\").extract(doc[\\\"message.keyword\\\"].value)?.response)\". \n            \"fields\" : {\n                \"response\" : {\n                    \"type\" : \"long\"\n                }\n            }\n        }\n    }\n}\n```\n\nCloses #68203","date":"2021-08-10 20:07:53","modifiedFileCount":"30","status":"M","submitter":"Luca Cavanna"}]
