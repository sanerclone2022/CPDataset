[{"authorTime":"2018-06-04 17:14:17","codes":[{"authorDate":"2018-06-04 17:14:17","commitOrder":1,"curCode":"        public Query phraseQuery(String field, TokenStream stream, int slop, boolean enablePosIncrements) throws IOException {\n\n            if (indexPhrases && slop == 0 && hasGaps(cache(stream)) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            PhraseQuery.Builder builder = new PhraseQuery.Builder();\n            builder.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            stream.reset();\n            while (stream.incrementToken()) {\n                if (enablePosIncrements) {\n                    position += posIncrAtt.getPositionIncrement();\n                }\n                else {\n                    position += 1;\n                }\n                builder.add(new Term(field, termAtt.getBytesRef()), position);\n            }\n\n            return builder.build();\n        }\n","date":"2018-06-04 17:14:17","endLine":601,"groupId":"43527","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"phraseQuery","params":"(Stringfield@TokenStreamstream@intslop@booleanenablePosIncrements)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d2/ba5fbc0c2d1aadff4b2eeb3c826d991b9b00a5.src","preCode":"        public Query phraseQuery(String field, TokenStream stream, int slop, boolean enablePosIncrements) throws IOException {\n\n            if (indexPhrases && slop == 0 && hasGaps(cache(stream)) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            PhraseQuery.Builder builder = new PhraseQuery.Builder();\n            builder.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            stream.reset();\n            while (stream.incrementToken()) {\n                if (enablePosIncrements) {\n                    position += posIncrAtt.getPositionIncrement();\n                }\n                else {\n                    position += 1;\n                }\n                builder.add(new Term(field, termAtt.getBytesRef()), position);\n            }\n\n            return builder.build();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":576,"status":"B"},{"authorDate":"2018-06-04 17:14:17","commitOrder":1,"curCode":"        public Query multiPhraseQuery(String field, TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {\n\n            if (indexPhrases && slop == 0 && hasGaps(cache(stream)) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n\n            MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n            mpqb.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            List<Term> multiTerms = new ArrayList<>();\n            stream.reset();\n            while (stream.incrementToken()) {\n                int positionIncrement = posIncrAtt.getPositionIncrement();\n\n                if (positionIncrement > 0 && multiTerms.size() > 0) {\n                    if (enablePositionIncrements) {\n                        mpqb.add(multiTerms.toArray(new Term[0]), position);\n                    } else {\n                        mpqb.add(multiTerms.toArray(new Term[0]));\n                    }\n                    multiTerms.clear();\n                }\n                position += positionIncrement;\n                multiTerms.add(new Term(field, termAtt.getBytesRef()));\n            }\n\n            if (enablePositionIncrements) {\n                mpqb.add(multiTerms.toArray(new Term[0]), position);\n            } else {\n                mpqb.add(multiTerms.toArray(new Term[0]));\n            }\n            return mpqb.build();\n        }\n","date":"2018-06-04 17:14:17","endLine":642,"groupId":"66686","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"multiPhraseQuery","params":"(Stringfield@TokenStreamstream@intslop@booleanenablePositionIncrements)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d2/ba5fbc0c2d1aadff4b2eeb3c826d991b9b00a5.src","preCode":"        public Query multiPhraseQuery(String field, TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {\n\n            if (indexPhrases && slop == 0 && hasGaps(cache(stream)) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n\n            MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n            mpqb.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            List<Term> multiTerms = new ArrayList<>();\n            stream.reset();\n            while (stream.incrementToken()) {\n                int positionIncrement = posIncrAtt.getPositionIncrement();\n\n                if (positionIncrement > 0 && multiTerms.size() > 0) {\n                    if (enablePositionIncrements) {\n                        mpqb.add(multiTerms.toArray(new Term[0]), position);\n                    } else {\n                        mpqb.add(multiTerms.toArray(new Term[0]));\n                    }\n                    multiTerms.clear();\n                }\n                position += positionIncrement;\n                multiTerms.add(new Term(field, termAtt.getBytesRef()));\n            }\n\n            if (enablePositionIncrements) {\n                mpqb.add(multiTerms.toArray(new Term[0]), position);\n            } else {\n                mpqb.add(multiTerms.toArray(new Term[0]));\n            }\n            return mpqb.build();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":604,"status":"B"}],"commitId":"1c40da8fbfdd900332b1ae7d202503f5f3e704a8","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-06-04 17:14:17","modifiedFileCount":"49","status":"B","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2019-01-17 22:10:28","codes":[{"authorDate":"2019-01-17 22:10:28","commitOrder":2,"curCode":"        public Query phraseQuery(TokenStream stream, int slop, boolean enablePosIncrements) throws IOException {\n            String field = name();\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            PhraseQuery.Builder builder = new PhraseQuery.Builder();\n            builder.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            stream.reset();\n            while (stream.incrementToken()) {\n                if (enablePosIncrements) {\n                    position += posIncrAtt.getPositionIncrement();\n                }\n                else {\n                    position += 1;\n                }\n                builder.add(new Term(field, termAtt.getBytesRef()), position);\n            }\n\n            return builder.build();\n        }\n","date":"2019-01-17 22:10:28","endLine":672,"groupId":"43527","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"phraseQuery","params":"(TokenStreamstream@intslop@booleanenablePosIncrements)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/fc470e130bce0ef74551763ac0c2dbf1db6dfd.src","preCode":"        public Query phraseQuery(String field, TokenStream stream, int slop, boolean enablePosIncrements) throws IOException {\n\n            if (indexPhrases && slop == 0 && hasGaps(cache(stream)) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            PhraseQuery.Builder builder = new PhraseQuery.Builder();\n            builder.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            stream.reset();\n            while (stream.incrementToken()) {\n                if (enablePosIncrements) {\n                    position += posIncrAtt.getPositionIncrement();\n                }\n                else {\n                    position += 1;\n                }\n                builder.add(new Term(field, termAtt.getBytesRef()), position);\n            }\n\n            return builder.build();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":647,"status":"M"},{"authorDate":"2019-01-17 22:10:28","commitOrder":2,"curCode":"        public Query multiPhraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {\n            String field = name();\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            return createPhraseQuery(stream, field, slop, enablePositionIncrements);\n        }\n","date":"2019-01-17 22:10:28","endLine":682,"groupId":"43527","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"multiPhraseQuery","params":"(TokenStreamstream@intslop@booleanenablePositionIncrements)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/fc470e130bce0ef74551763ac0c2dbf1db6dfd.src","preCode":"        public Query multiPhraseQuery(String field, TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {\n\n            if (indexPhrases && slop == 0 && hasGaps(cache(stream)) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n\n            MultiPhraseQuery.Builder mpqb = new MultiPhraseQuery.Builder();\n            mpqb.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            List<Term> multiTerms = new ArrayList<>();\n            stream.reset();\n            while (stream.incrementToken()) {\n                int positionIncrement = posIncrAtt.getPositionIncrement();\n\n                if (positionIncrement > 0 && multiTerms.size() > 0) {\n                    if (enablePositionIncrements) {\n                        mpqb.add(multiTerms.toArray(new Term[0]), position);\n                    } else {\n                        mpqb.add(multiTerms.toArray(new Term[0]));\n                    }\n                    multiTerms.clear();\n                }\n                position += positionIncrement;\n                multiTerms.add(new Term(field, termAtt.getBytesRef()));\n            }\n\n            if (enablePositionIncrements) {\n                mpqb.add(multiTerms.toArray(new Term[0]), position);\n            } else {\n                mpqb.add(multiTerms.toArray(new Term[0]));\n            }\n            return mpqb.build();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":675,"status":"M"}],"commitId":"4351a5e5375237b8259fbcbd3ff4d7c59cc2d215","commitMessage":"@@@Allow field types to optimize phrase prefix queries (#37436)\n\nThis change adds a way to customize how phrase prefix queries should be created\non field types. The match phrase prefix query is exposed in field types in order\nto allow optimizations based on the options set on the field.\nFor instance the text field uses the configured prefix field (if available) to\nbuild a span near that mixes the original field and the prefix field on the last\nposition.\nThis change also contains a small refactoring of the match/multi_match query that\nsimplifies the interactions between the builders.\n\nCloses #31921","date":"2019-01-17 22:10:28","modifiedFileCount":"16","status":"M","submitter":"Jim Ferenczi"},{"authorTime":"2019-01-17 22:10:28","codes":[{"authorDate":"2019-07-17 23:08:28","commitOrder":3,"curCode":"        public Query phraseQuery(TokenStream stream, int slop, boolean enablePosIncrements) throws IOException {\n            String field = name();\n            \r\n            \r\n            \r\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false && stream.hasAttribute(BytesTermAttribute.class) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            PhraseQuery.Builder builder = new PhraseQuery.Builder();\n            builder.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            stream.reset();\n            while (stream.incrementToken()) {\n                if (termAtt.getBytesRef() == null) {\n                    throw new IllegalStateException(\"Null term while building phrase query\");\n                }\n                if (enablePosIncrements) {\n                    position += posIncrAtt.getPositionIncrement();\n                }\n                else {\n                    position += 1;\n                }\n                builder.add(new Term(field, termAtt.getBytesRef()), position);\n            }\n\n            return builder.build();\n        }\n","date":"2019-07-17 23:08:28","endLine":713,"groupId":"43777","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"phraseQuery","params":"(TokenStreamstream@intslop@booleanenablePosIncrements)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/df/0177a41a57c8866dabcbe9cc7b80620b5d38c8.src","preCode":"        public Query phraseQuery(TokenStream stream, int slop, boolean enablePosIncrements) throws IOException {\n            String field = name();\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            PhraseQuery.Builder builder = new PhraseQuery.Builder();\n            builder.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            stream.reset();\n            while (stream.incrementToken()) {\n                if (enablePosIncrements) {\n                    position += posIncrAtt.getPositionIncrement();\n                }\n                else {\n                    position += 1;\n                }\n                builder.add(new Term(field, termAtt.getBytesRef()), position);\n            }\n\n            return builder.build();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":682,"status":"M"},{"authorDate":"2019-01-17 22:10:28","commitOrder":3,"curCode":"        public Query multiPhraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {\n            String field = name();\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            return createPhraseQuery(stream, field, slop, enablePositionIncrements);\n        }\n","date":"2019-01-17 22:10:28","endLine":682,"groupId":"43527","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"multiPhraseQuery","params":"(TokenStreamstream@intslop@booleanenablePositionIncrements)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e5/fc470e130bce0ef74551763ac0c2dbf1db6dfd.src","preCode":"        public Query multiPhraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {\n            String field = name();\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            return createPhraseQuery(stream, field, slop, enablePositionIncrements);\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":675,"status":"N"}],"commitId":"c8ae530e7a609f9cd849961dd3921871d2f65c0c","commitMessage":"@@@Don't use index_phrases on graph queries (#44340)\n\nDue to https://issues.apache.org/jira/browse/LUCENE-8916.  when you\ntry to use a synonym filter with the index_phrases option on a text field. \nyou can end up with null values in a Phrase query.  leading to weird\nexceptions further down the querying chain. As a workaround.  this commit\ndisables the index_phrases optimization for queries that produce token\ngraphs.\n\nFixes #43976","date":"2019-07-17 23:08:28","modifiedFileCount":"2","status":"M","submitter":"Alan Woodward"},{"authorTime":"2021-04-27 19:31:29","codes":[{"authorDate":"2021-04-27 19:31:29","commitOrder":4,"curCode":"        public Query phraseQuery(TokenStream stream, int slop, boolean enablePosIncrements,\n                SearchExecutionContext context) throws IOException {\n            String field = name();\n            checkForPositions();\n            \r\n            \r\n            \r\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false && stream.hasAttribute(BytesTermAttribute.class) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            PhraseQuery.Builder builder = new PhraseQuery.Builder();\n            builder.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            stream.reset();\n            while (stream.incrementToken()) {\n                if (termAtt.getBytesRef() == null) {\n                    throw new IllegalStateException(\"Null term while building phrase query\");\n                }\n                if (enablePosIncrements) {\n                    position += posIncrAtt.getPositionIncrement();\n                }\n                else {\n                    position += 1;\n                }\n                builder.add(new Term(field, termAtt.getBytesRef()), position);\n            }\n\n            return builder.build();\n        }\n","date":"2021-04-27 19:31:29","endLine":756,"groupId":"107792","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"phraseQuery","params":"(TokenStreamstream@intslop@booleanenablePosIncrements@SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1d/a11ec947438cbabba784f86fe9d4e9f87bd9e5.src","preCode":"        public Query phraseQuery(TokenStream stream, int slop, boolean enablePosIncrements) throws IOException {\n            String field = name();\n            \r\n            \r\n            \r\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false && stream.hasAttribute(BytesTermAttribute.class) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            PhraseQuery.Builder builder = new PhraseQuery.Builder();\n            builder.setSlop(slop);\n\n            TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);\n            PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);\n            int position = -1;\n\n            stream.reset();\n            while (stream.incrementToken()) {\n                if (termAtt.getBytesRef() == null) {\n                    throw new IllegalStateException(\"Null term while building phrase query\");\n                }\n                if (enablePosIncrements) {\n                    position += posIncrAtt.getPositionIncrement();\n                }\n                else {\n                    position += 1;\n                }\n                builder.add(new Term(field, termAtt.getBytesRef()), position);\n            }\n\n            return builder.build();\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":723,"status":"M"},{"authorDate":"2021-04-27 19:31:29","commitOrder":4,"curCode":"        public Query multiPhraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements,\n                SearchExecutionContext context) throws IOException {\n            String field = name();\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            return createPhraseQuery(stream, field, slop, enablePositionIncrements);\n        }\n","date":"2021-04-27 19:31:29","endLine":767,"groupId":"107792","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"multiPhraseQuery","params":"(TokenStreamstream@intslop@booleanenablePositionIncrements@SearchExecutionContextcontext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1d/a11ec947438cbabba784f86fe9d4e9f87bd9e5.src","preCode":"        public Query multiPhraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {\n            String field = name();\n            if (indexPhrases && slop == 0 && hasGaps(stream) == false) {\n                stream = new FixedShingleFilter(stream, 2);\n                field = field + FAST_PHRASE_SUFFIX;\n            }\n            return createPhraseQuery(stream, field, slop, enablePositionIncrements);\n        }\n","realPath":"server/src/main/java/org/elasticsearch/index/mapper/TextFieldMapper.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"M"}],"commitId":"cf360cefb68002fb5871d879f3a07643209904dc","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-04-27 19:31:29","modifiedFileCount":"260","status":"M","submitter":"iverase"}]
