[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance from node1 to node 2 since index [test] is all on node1\");\n\n        routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test1\", INITIALIZING));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","date":"2018-04-26 03:22:53","endLine":675,"groupId":"42157","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRebalanceWithIgnoredUnassignedShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8c/ccdb08fb5e90ddfa107506f0e0f04380f1412c.src","preCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance from node1 to node 2 since index [test] is all on node1\");\n\n        routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test1\", INITIALIZING));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":577,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder().put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT).put(IndexMetaData.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\")).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","date":"2018-04-26 03:22:53","endLine":758,"groupId":"42156","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRebalanceWhileShardFetching","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8c/ccdb08fb5e90ddfa107506f0e0f04380f1412c.src","preCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder().put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT).put(IndexMetaData.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\")).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":677,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-10-30 23:09:57","commitOrder":2,"curCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance\" +\n            \" from node1 to node 2 since index [test] is all on node1\");\n\n        routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test1\", INITIALIZING));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","date":"2018-10-30 23:09:57","endLine":696,"groupId":"42157","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRebalanceWithIgnoredUnassignedShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bc/a086b8fc92b486fa9ede830b1a23545662d700.src","preCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance from node1 to node 2 since index [test] is all on node1\");\n\n        routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test1\", INITIALIZING));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":596,"status":"M"},{"authorDate":"2018-04-26 03:22:53","commitOrder":2,"curCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder().put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT).put(IndexMetaData.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\")).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","date":"2018-04-26 03:22:53","endLine":758,"groupId":"42156","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRebalanceWhileShardFetching","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8c/ccdb08fb5e90ddfa107506f0e0f04380f1412c.src","preCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder().put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT).put(IndexMetaData.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\")).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":677,"status":"N"}],"commitId":"18c72e86c57c7f719a4e99e98cc75c9ae3e92a69","commitMessage":"@@@Merge remote-tracking branch 'upstream/master' into index-lifecycle\n","date":"2018-10-30 23:09:57","modifiedFileCount":"101","status":"M","submitter":"Tal Levy"},{"authorTime":"2019-07-18 13:39:24","codes":[{"authorDate":"2019-07-18 13:39:24","commitOrder":3,"curCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance\" +\n            \" from node1 to node 2 since index [test] is all on node1\");\n\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test1\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","date":"2019-07-18 13:39:24","endLine":662,"groupId":"5181","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRebalanceWithIgnoredUnassignedShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8e/b056c77825c95e15662a03bacaf7f5087c0c28.src","preCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance\" +\n            \" from node1 to node 2 since index [test] is all on node1\");\n\n        routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test1\", INITIALIZING));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":564,"status":"M"},{"authorDate":"2019-07-18 13:39:24","commitOrder":3,"curCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder()\n            .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)\n                    .put(IndexMetaData.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\"))\n                    .numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","date":"2019-07-18 13:39:24","endLine":749,"groupId":"5183","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRebalanceWhileShardFetching","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/8e/b056c77825c95e15662a03bacaf7f5087c0c28.src","preCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder()\n            .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)\n                    .put(IndexMetaData.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\"))\n                    .numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        RoutingNodes routingNodes = clusterState.getRoutingNodes();\n        clusterState = strategy.applyStartedShards(clusterState, routingNodes.shardsWithState(\"test\", INITIALIZING));\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":664,"status":"M"}],"commitId":"51fb95ef83f7a1aa6cbc5207e504b03ccee724ee","commitMessage":"@@@Defer reroute when starting shards (#44433)\n\n* Defer reroute when starting shards\n\nToday we reroute the cluster as part of the process of starting a shard.  which\nruns at `URGENT` priority. In large clusters.  rerouting may take some time to\ncomplete.  and this means that a mere trickle of shard-started events can cause\nstarvation for other.  lower-priority.  tasks that are pending on the master.\n\nHowever.  it isn't really necessary to perform a reroute when starting a shard. \nas long as one occurs eventually. This commit removes the inline reroute from\nthe process of starting a shard and replaces it with a deferred one that runs\nat `NORMAL` priority.  avoiding starvation of higher-priority tasks.\n\nThis may improve some of the situations related to #42738 and #42105.\n\n* Specific test case for followup priority setting\n\nWe cannot set the priority in all InternalTestClusters because the deprecation\nwarning makes some tests unhappy. This commit adds a specific test instead.\n\n* Checkstyle\n\n* Cluster state always changed here\n\n* Assert consistency of routing nodes\n\n* Restrict setting only to reasonable priorities\n","date":"2019-07-18 13:39:24","modifiedFileCount":"60","status":"M","submitter":"David Turner"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":4,"curCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetadata.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .addAsNew(metadata.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metadata(metadata).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance\" +\n            \" from node1 to node 2 since index [test] is all on node1\");\n\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test1\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","date":"2020-04-01 03:52:01","endLine":662,"groupId":"5181","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testRebalanceWithIgnoredUnassignedShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/84/7bb30e6e481d64279298e0eb193bf0fab1a1e6.src","preCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance\" +\n            \" from node1 to node 2 since index [test] is all on node1\");\n\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test1\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":564,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":4,"curCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder()\n            .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetadata.builder(\"test1\").settings(settings(Version.CURRENT)\n                    .put(IndexMetadata.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\"))\n                    .numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .addAsNew(metadata.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metadata(metadata).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","date":"2020-04-01 03:52:01","endLine":749,"groupId":"5183","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testRebalanceWhileShardFetching","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/84/7bb30e6e481d64279298e0eb193bf0fab1a1e6.src","preCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder()\n            .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetaData.builder(\"test1\").settings(settings(Version.CURRENT)\n                    .put(IndexMetaData.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\"))\n                    .numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metaData.index(\"test\"))\n                .addAsNew(metaData.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metaData(metaData).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":664,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-04-06 21:51:05","codes":[{"authorDate":"2020-04-06 21:51:05","commitOrder":5,"curCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(ShardRouting shardRouting, RoutingAllocation allocation,\n                                           UnassignedAllocationHandler unassignedAllocationHandler) {\n                if (allocateTest1.get() == false && \"test1\".equals(shardRouting.index().getName())) {\n                    unassignedAllocationHandler.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                } else {\n                    super.allocateUnassigned(shardRouting, allocation, unassignedAllocationHandler);\n                }\n            }\n        });\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetadata.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .addAsNew(metadata.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metadata(metadata).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance\" +\n            \" from node1 to node 2 since index [test] is all on node1\");\n\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test1\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","date":"2020-04-06 21:51:05","endLine":656,"groupId":"102205","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testRebalanceWithIgnoredUnassignedShards","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/2b1cac50068fe2aeb6ee1025168ad3f4a48bd9.src","preCode":"    public void testRebalanceWithIgnoredUnassignedShards() {\n        final AtomicBoolean allocateTest1 = new AtomicBoolean(false);\n\n        AllocationService strategy = createAllocationService(Settings.EMPTY, new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (allocateTest1.get() == false) {\n                    RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned();\n                    RoutingNodes.UnassignedShards.UnassignedIterator iterator = unassigned.iterator();\n                    while (iterator.hasNext()) {\n                        ShardRouting next = iterator.next();\n                        if (\"test1\".equals(next.index().getName())) {\n                            iterator.removeAndIgnore(UnassignedInfo.AllocationStatus.NO_ATTEMPT, allocation.changes());\n                        }\n\n                    }\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetadata.builder(\"test1\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .addAsNew(metadata.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metadata(metadata).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we unassigned shards\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set allocateTest1 to true and reroute we should see the [test1] index initializing\");\n        allocateTest1.set(true);\n        resultingState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultingState, not(equalTo(clusterState)));\n        clusterState = resultingState;\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"now start initializing shards and expect exactly one rebalance\" +\n            \" from node1 to node 2 since index [test] is all on node1\");\n\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test1\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":564,"status":"M"},{"authorDate":"2020-04-06 21:51:05","commitOrder":5,"curCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder()\n            .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void beforeAllocation(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n            }\n        });\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetadata.builder(\"test1\").settings(settings(Version.CURRENT)\n                    .put(IndexMetadata.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\"))\n                    .numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .addAsNew(metadata.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metadata(metadata).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","date":"2020-04-06 21:51:05","endLine":742,"groupId":"102205","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testRebalanceWhileShardFetching","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/95/2b1cac50068fe2aeb6ee1025168ad3f4a48bd9.src","preCode":"    public void testRebalanceWhileShardFetching() {\n        final AtomicBoolean hasFetches = new AtomicBoolean(true);\n        AllocationService strategy = createAllocationService(Settings.builder()\n            .put(ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING.getKey(),\n                ClusterRebalanceAllocationDecider.ClusterRebalanceType.ALWAYS.toString()).build(), new TestGatewayAllocator() {\n            @Override\n            public void allocateUnassigned(RoutingAllocation allocation) {\n                if (hasFetches.get()) {\n                    allocation.setHasPendingAsyncFetch();\n                }\n                super.allocateUnassigned(allocation);\n            }\n        });\n\n        Metadata metadata = Metadata.builder()\n                .put(IndexMetadata.builder(\"test\").settings(settings(Version.CURRENT)).numberOfShards(2).numberOfReplicas(0))\n                .put(IndexMetadata.builder(\"test1\").settings(settings(Version.CURRENT)\n                    .put(IndexMetadata.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey() + \"_id\", \"node1,node2\"))\n                    .numberOfShards(2).numberOfReplicas(0))\n                .build();\n\n        \r\n        \r\n        RoutingTable initialRoutingTable = RoutingTable.builder()\n                .addAsNew(metadata.index(\"test\"))\n                .addAsNew(metadata.index(\"test1\"))\n                .build();\n\n        ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING\n            .getDefault(Settings.EMPTY)).metadata(metadata).routingTable(initialRoutingTable).build();\n\n        logger.info(\"start two nodes\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        clusterState = strategy.reroute(clusterState, \"reroute\");\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(INITIALIZING));\n        }\n\n        logger.debug(\"start all the primary shards for test\");\n        clusterState = startInitializingShardsAndReroute(strategy, clusterState, \"test\");\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n\n        logger.debug(\"now, start 1 more node, check that rebalancing will not happen since we have shard sync going on\");\n        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())\n                .add(newNode(\"node2\")))\n                .build();\n        logger.debug(\"reroute and check that nothing has changed\");\n        ClusterState resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, equalTo(clusterState));\n\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).primaryShard().state(), equalTo(STARTED));\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        logger.debug(\"now set hasFetches to true and reroute we should now see exactly one relocating shard\");\n        hasFetches.set(false);\n        resultState = strategy.reroute(clusterState, \"reroute\");\n        assertThat(resultState, not(equalTo(clusterState)));\n        clusterState = resultState;\n        int numStarted = 0;\n        int numRelocating = 0;\n        for (int i = 0; i < clusterState.routingTable().index(\"test\").shards().size(); i++) {\n\n            assertThat(clusterState.routingTable().index(\"test\").shard(i).shards().size(), equalTo(1));\n            if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == STARTED) {\n                numStarted++;\n            } else if (clusterState.routingTable().index(\"test\").shard(i).primaryShard().state() == RELOCATING) {\n                numRelocating++;\n            }\n        }\n        for (int i = 0; i < clusterState.routingTable().index(\"test1\").shards().size(); i++) {\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).shards().size(), equalTo(1));\n            assertThat(clusterState.routingTable().index(\"test1\").shard(i).primaryShard().state(), equalTo(UNASSIGNED));\n        }\n        assertEquals(numStarted, 1);\n        assertEquals(numRelocating, 1);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/ClusterRebalanceRoutingTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":658,"status":"M"}],"commitId":"f6feb6c2c845aaab31cec4b4047c77c2caf85b89","commitMessage":"@@@Merge feature/searchable-snapshots branch into master (#54803)\n\nThis commit merges the searchable-snapshots feature branch into master.\nSee #54803 for the complete list of squashed commits.\n\nCo-authored-by: David Turner <david.turner@elastic.co>\nCo-authored-by: Yannick Welsch <yannick@welsch.lu>\nCo-authored-by: Lee Hinman <dakrone@users.noreply.github.com>\nCo-authored-by: Andrei Dan <andrei.dan@elastic.co>","date":"2020-04-06 21:51:05","modifiedFileCount":"73","status":"M","submitter":"Tanguy Leroux"}]
