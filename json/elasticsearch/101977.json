[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no such index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2018-04-26 03:22:53","endLine":161,"groupId":"55299","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testValidateShrinkIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/60/74102cde31363431fd5eb9a4bd707b9e0fab06.src","preCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no such index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no such index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2018-04-26 03:22:53","endLine":228,"groupId":"45900","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testValidateSplitIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/60/74102cde31363431fd5eb9a4bd707b9e0fab06.src","preCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no such index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-10-26 01:00:36","codes":[{"authorDate":"2018-10-26 01:00:36","commitOrder":2,"curCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2018-10-26 01:00:36","endLine":190,"groupId":"55299","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testValidateShrinkIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/cacee395a315f255b5c6fecaba1a0fd0e33b83.src","preCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no such index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2018-10-26 01:00:36","commitOrder":2,"curCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2018-10-26 01:00:36","endLine":257,"groupId":"45900","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testValidateSplitIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5c/cacee395a315f255b5c6fecaba1a0fd0e33b83.src","preCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no such index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"3e7042832acfffad4de4214ad6491b147f5157b0","commitMessage":"@@@Merge remote-tracking branch 'origin/master' into index-lifecycle\n","date":"2018-10-26 01:00:36","modifiedFileCount":"350","status":"M","submitter":"Lee Hinman"},{"authorTime":"2018-11-02 00:05:41","codes":[{"authorDate":"2018-11-02 00:05:41","commitOrder":3,"curCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2018-11-02 01:13:02","endLine":190,"groupId":"55299","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testValidateShrinkIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/aa/0f6834b98ec18bf0c1b03bfd51c1d67aedaba0.src","preCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2018-11-02 00:05:41","commitOrder":3,"curCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2018-11-02 01:13:02","endLine":257,"groupId":"45900","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testValidateSplitIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/aa/0f6834b98ec18bf0c1b03bfd51c1d67aedaba0.src","preCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(Settings.builder().build(), new AllocationDeciders(Settings.EMPTY,\n            Collections.singleton(new MaxRetryAllocationDecider(Settings.EMPTY))),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":192,"status":"M"}],"commitId":"c3cf7dd305b3d4636405c292659dbff05307f146","commitMessage":"@@@Merge remote-tracking branch 'upstream/master' into index-lifecycle\n","date":"2018-11-02 01:13:02","modifiedFileCount":"456","status":"M","submitter":"Tal Levy"},{"authorTime":"2018-12-18 06:42:58","codes":[{"authorDate":"2018-12-18 06:42:58","commitOrder":4,"curCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2018-12-18 06:42:58","endLine":191,"groupId":"55299","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testValidateShrinkIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ec/89e085f07844a4ad4c6b4b82f9265082c99e7c.src","preCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"},{"authorDate":"2018-12-18 06:42:58","commitOrder":4,"curCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2018-12-18 06:42:58","endLine":258,"groupId":"45900","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testValidateSplitIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ec/89e085f07844a4ad4c6b4b82f9265082c99e7c.src","preCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"f0f2b261595e2f5ea48736eac7a4e4121dd20b2c","commitMessage":"@@@Fix duplicate phrase in shrink/split error message (#36734)\n\nThis commit removes a duplicate \"must be a\" from the shrink/split error\nmessages.","date":"2018-12-18 06:42:58","modifiedFileCount":"3","status":"M","submitter":"Jason Tedor"},{"authorTime":"2019-07-18 13:39:24","codes":[{"authorDate":"2019-07-18 13:39:24","commitOrder":5,"curCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2019-07-18 13:39:24","endLine":175,"groupId":"55299","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testValidateShrinkIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/66/7909d644beb0da1c97674c6eeafb0d838a0890.src","preCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"},{"authorDate":"2019-07-18 13:39:24","commitOrder":5,"curCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2019-07-18 13:39:24","endLine":241,"groupId":"45900","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testValidateSplitIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/66/7909d644beb0da1c97674c6eeafb0d838a0890.src","preCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = service.applyStartedShards(clusterState,\n            routingTable.index(\"source\").shardsWithState(ShardRoutingState.INITIALIZING)).routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetaDataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"}],"commitId":"51fb95ef83f7a1aa6cbc5207e504b03ccee724ee","commitMessage":"@@@Defer reroute when starting shards (#44433)\n\n* Defer reroute when starting shards\n\nToday we reroute the cluster as part of the process of starting a shard.  which\nruns at `URGENT` priority. In large clusters.  rerouting may take some time to\ncomplete.  and this means that a mere trickle of shard-started events can cause\nstarvation for other.  lower-priority.  tasks that are pending on the master.\n\nHowever.  it isn't really necessary to perform a reroute when starting a shard. \nas long as one occurs eventually. This commit removes the inline reroute from\nthe process of starting a shard and replaces it with a deferred one that runs\nat `NORMAL` priority.  avoiding starvation of higher-priority tasks.\n\nThis may improve some of the situations related to #42738 and #42105.\n\n* Specific test case for followup priority setting\n\nWe cannot set the priority in all InternalTestClusters because the deprecation\nwarning makes some tests unhappy. This commit adds a specific test instead.\n\n* Checkstyle\n\n* Cluster state always changed here\n\n* Assert consistency of routing nodes\n\n* Restrict setting only to reasonable priorities\n","date":"2019-07-18 13:39:24","modifiedFileCount":"60","status":"M","submitter":"David Turner"},{"authorTime":"2020-04-01 03:52:01","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":6,"curCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetadataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetadataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2020-04-01 03:52:01","endLine":237,"groupId":"55299","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testValidateShrinkIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/03/04cfaabd2f7f64d25809d047b88bd0e1cd664b.src","preCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetaDataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetaDataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetaDataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"},{"authorDate":"2020-04-01 03:52:01","commitOrder":6,"curCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetadataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetadataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2020-04-01 03:52:01","endLine":303,"groupId":"45900","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testValidateSplitIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/03/04cfaabd2f7f64d25809d047b88bd0e1cd664b.src","preCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetaDataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetaDataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetaDataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":239,"status":"M"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2020-06-26 22:33:37","codes":[{"authorDate":"2020-06-26 22:33:37","commitOrder":7,"curCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"target\", \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY),\n                        \"source\", \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"source\", \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetadataCreateIndexService.validateShrinkIndex(clusterState, \"source\", \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2020-06-26 22:33:37","endLine":227,"groupId":"26318","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testValidateShrinkIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/1120fce627d1e8c0472deee317133555c99632.src","preCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"target\", Collections.emptySet(), \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                Collections.emptySet(), \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                        , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.emptySet(), \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                MetadataCreateIndexService.validateShrinkIndex(state, \"source\", Collections.singleton(\"foo\"),\n                    \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetadataCreateIndexService.validateShrinkIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-06-26 22:33:37","commitOrder":7,"curCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"target\", \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"no_such_index\", \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetadataCreateIndexService.validateSplitIndex(clusterState, \"source\", \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2020-06-26 22:33:37","endLine":286,"groupId":"51597","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testValidateSplitIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/ba/1120fce627d1e8c0472deee317133555c99632.src","preCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"target\", Collections.emptySet(), \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"no_such_index\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(),\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", Collections.emptySet(), \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", Collections.emptySet(), \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        assertEquals(\"mappings are not allowed when resizing indices, all mappings are copied from the source index\",\n            expectThrows(IllegalArgumentException.class, () -> {\n                    MetadataCreateIndexService.validateSplitIndex(state, \"source\", Collections.singleton(\"foo\"),\n                        \"target\", targetSettings);\n                }\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetadataCreateIndexService.validateSplitIndex(clusterState, \"source\", Collections.emptySet(), \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":229,"status":"M"}],"commitId":"cac5f29cee7572a3695e2b8d17d0a0cb7ac473dd","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-06-26 22:33:37","modifiedFileCount":"731","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-10-06 23:29:42","codes":[{"authorDate":"2020-10-06 23:29:42","commitOrder":8,"curCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"target\", \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY),\n                        \"source\", \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"source\", \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE,\n            EmptySnapshotsInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetadataCreateIndexService.validateShrinkIndex(clusterState, \"source\", \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2020-10-06 23:29:42","endLine":228,"groupId":"101977","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testValidateShrinkIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/489ed6008b7a2f380705a5ed1d1b7c070761c7.src","preCode":"    public void testValidateShrinkIndex() {\n        int numShards = randomIntBetween(2, 42);\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"target\", \"source\", Settings.EMPTY)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"no_such_index\", \"target\", Settings.EMPTY)\n            ).getMessage());\n\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", 1).build();\n        assertEquals(\"can't shrink an index with only one shard\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                1, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\", targetSettings)).getMessage());\n\n        assertEquals(\"the number of target shards [10] must be less that the number of source shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\",\n                5, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 10).build())).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(\n                        createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY),\n                        \"source\", \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"index source must have all shards allocated on the same node to shrink index\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateShrinkIndex(state, \"source\", \"target\", targetSettings)\n\n            ).getMessage());\n        assertEquals(\"the number of source shards [8] must be a multiple of [3]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                    MetadataCreateIndexService.validateShrinkIndex(createClusterState(\"source\", 8, randomIntBetween(0, 10),\n                        Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\",\n                        Settings.builder().put(\"index.number_of_shards\", 3).build())\n            ).getMessage());\n\n        \r\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).build())).nodes(DiscoveryNodes.builder().add(newNode(\"node1\")))\n            .build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(1, numShards/2);\n        } while (isShrinkable(numShards, targetShards) == false);\n        MetadataCreateIndexService.validateShrinkIndex(clusterState, \"source\", \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"},{"authorDate":"2020-10-06 23:29:42","commitOrder":8,"curCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"target\", \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"no_such_index\", \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE,\n            EmptySnapshotsInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetadataCreateIndexService.validateSplitIndex(clusterState, \"source\", \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","date":"2020-10-06 23:29:42","endLine":288,"groupId":"101977","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testValidateSplitIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a8/489ed6008b7a2f380705a5ed1d1b7c070761c7.src","preCode":"    public void testValidateSplitIndex() {\n        int numShards = randomIntBetween(1, 42);\n        Settings targetSettings = Settings.builder().put(\"index.number_of_shards\", numShards * 2).build();\n        ClusterState state = createClusterState(\"source\", numShards, randomIntBetween(0, 10),\n            Settings.builder().put(\"index.blocks.write\", true).build());\n\n        assertEquals(\"index [source] already exists\",\n            expectThrows(ResourceAlreadyExistsException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"target\", \"source\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"no such index [no_such_index]\",\n            expectThrows(IndexNotFoundException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(state, \"no_such_index\", \"target\", targetSettings)\n            ).getMessage());\n\n        assertEquals(\"the number of source shards [10] must be less that the number of target shards [5]\",\n            expectThrows(IllegalArgumentException.class, () -> MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\",\n                10, 0, Settings.builder().put(\"index.blocks.write\", true).build()), \"source\",\n                \"target\", Settings.builder().put(\"index.number_of_shards\", 5).build())\n            ).getMessage());\n\n\n        assertEquals(\"index source must be read-only to resize index. use \\\"index.blocks.write=true\\\"\",\n            expectThrows(IllegalStateException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(\n                    createClusterState(\"source\", randomIntBetween(2, 100), randomIntBetween(0, 10), Settings.EMPTY)\n                    , \"source\", \"target\", targetSettings)\n            ).getMessage());\n\n\n        assertEquals(\"the number of source shards [3] must be a factor of [4]\",\n            expectThrows(IllegalArgumentException.class, () ->\n                MetadataCreateIndexService.validateSplitIndex(createClusterState(\"source\", 3, randomIntBetween(0, 10),\n                    Settings.builder().put(\"index.blocks.write\", true).build()), \"source\", \"target\",\n                    Settings.builder().put(\"index.number_of_shards\", 4).build())\n            ).getMessage());\n\n        int targetShards;\n        do {\n            targetShards = randomIntBetween(numShards+1, 100);\n        } while (isSplitable(numShards, targetShards) == false);\n        ClusterState clusterState = ClusterState.builder(createClusterState(\"source\", numShards, 0,\n            Settings.builder().put(\"index.blocks.write\", true).put(\"index.number_of_routing_shards\", targetShards).build()))\n            .nodes(DiscoveryNodes.builder().add(newNode(\"node1\"))).build();\n        AllocationService service = new AllocationService(new AllocationDeciders(\n            Collections.singleton(new MaxRetryAllocationDecider())),\n            new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n\n        RoutingTable routingTable = service.reroute(clusterState, \"reroute\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n        \r\n        routingTable = ESAllocationTestCase.startInitializingShardsAndReroute(service, clusterState, \"source\").routingTable();\n        clusterState = ClusterState.builder(clusterState).routingTable(routingTable).build();\n\n        MetadataCreateIndexService.validateSplitIndex(clusterState, \"source\", \"target\",\n            Settings.builder().put(\"index.number_of_shards\", targetShards).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexServiceTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"}],"commitId":"2afec0d916c7de33c9a6c3cbe30a8a2ee61be765","commitMessage":"@@@Determine shard size before allocating shards recovering from snapshots (#61906)\n\nDetermines the shard size of shards before allocating shards that are \nrecovering from snapshots. It ensures during shard allocation that the \ntarget node that is selected as recovery target will have enough free \ndisk space for the recovery event. This applies to regular restores.  \nCCR bootstrap from remote.  as well as mounting searchable snapshots.\n\nThe InternalSnapshotInfoService is responsible for fetching snapshot \nshard sizes from repositories. It provides a getShardSize() method \nto other components of the system that can be used to retrieve the \nlatest known shard size. If the latest snapshot shard size retrieval \nfailed.  the getShardSize() returns \nShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE. While \nwe'd like a better way to handle such failures.  returning this value \nallows to keep the existing behavior for now.\n\nNote that this PR does not address an issues (we already have today) \nwhere a replica is being allocated without knowing how much disk \nspace is being used by the primary. ","date":"2020-10-06 23:29:42","modifiedFileCount":"49","status":"M","submitter":"Yannick Welsch"}]
