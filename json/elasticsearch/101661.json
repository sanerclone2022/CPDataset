[{"authorTime":"2018-06-11 16:47:26","codes":[{"authorDate":"2018-06-11 16:47:26","commitOrder":1,"curCode":"    public void testWriteIsQueuedInChannel() {\n        assertFalse(context.readyForFlush());\n\n        ByteBuffer[] buffer = {ByteBuffer.allocate(10)};\n        FlushReadyWrite writeOperation = new FlushReadyWrite(context, buffer, listener);\n        when(readWriteHandler.writeToBytes(writeOperation)).thenReturn(Collections.singletonList(writeOperation));\n        context.queueWriteOperation(writeOperation);\n\n        verify(readWriteHandler).writeToBytes(writeOperation);\n        assertTrue(context.readyForFlush());\n    }\n","date":"2018-06-11 16:47:26","endLine":189,"groupId":"42206","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testWriteIsQueuedInChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fd/b4a77b922e281718aee9b9ce80181df3686cc3.src","preCode":"    public void testWriteIsQueuedInChannel() {\n        assertFalse(context.readyForFlush());\n\n        ByteBuffer[] buffer = {ByteBuffer.allocate(10)};\n        FlushReadyWrite writeOperation = new FlushReadyWrite(context, buffer, listener);\n        when(readWriteHandler.writeToBytes(writeOperation)).thenReturn(Collections.singletonList(writeOperation));\n        context.queueWriteOperation(writeOperation);\n\n        verify(readWriteHandler).writeToBytes(writeOperation);\n        assertTrue(context.readyForFlush());\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/SocketChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":179,"status":"B"},{"authorDate":"2018-06-11 16:47:26","commitOrder":1,"curCode":"    public void testFlushOpsClearedOnClose() throws Exception {\n        try (SocketChannel realChannel = SocketChannel.open()) {\n            when(channel.getRawChannel()).thenReturn(realChannel);\n            InboundChannelBuffer channelBuffer = InboundChannelBuffer.allocatingInstance();\n            context = new TestSocketChannelContext(channel, selector, exceptionHandler, readWriteHandler, channelBuffer);\n\n            assertFalse(context.readyForFlush());\n\n            ByteBuffer[] buffer = {ByteBuffer.allocate(10)};\n            WriteOperation writeOperation = mock(WriteOperation.class);\n            BiConsumer<Void, Exception> listener2 = mock(BiConsumer.class);\n            when(readWriteHandler.writeToBytes(writeOperation)).thenReturn(Arrays.asList(new FlushOperation(buffer, listener),\n                new FlushOperation(buffer, listener2)));\n            context.queueWriteOperation(writeOperation);\n\n            assertTrue(context.readyForFlush());\n\n            when(channel.isOpen()).thenReturn(true);\n            context.closeFromSelector();\n\n            verify(selector, times(1)).executeFailedListener(same(listener), any(ClosedChannelException.class));\n            verify(selector, times(1)).executeFailedListener(same(listener2), any(ClosedChannelException.class));\n\n            assertFalse(context.readyForFlush());\n        }\n    }\n","date":"2018-06-11 16:47:26","endLine":224,"groupId":"21761","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFlushOpsClearedOnClose","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/fd/b4a77b922e281718aee9b9ce80181df3686cc3.src","preCode":"    public void testFlushOpsClearedOnClose() throws Exception {\n        try (SocketChannel realChannel = SocketChannel.open()) {\n            when(channel.getRawChannel()).thenReturn(realChannel);\n            InboundChannelBuffer channelBuffer = InboundChannelBuffer.allocatingInstance();\n            context = new TestSocketChannelContext(channel, selector, exceptionHandler, readWriteHandler, channelBuffer);\n\n            assertFalse(context.readyForFlush());\n\n            ByteBuffer[] buffer = {ByteBuffer.allocate(10)};\n            WriteOperation writeOperation = mock(WriteOperation.class);\n            BiConsumer<Void, Exception> listener2 = mock(BiConsumer.class);\n            when(readWriteHandler.writeToBytes(writeOperation)).thenReturn(Arrays.asList(new FlushOperation(buffer, listener),\n                new FlushOperation(buffer, listener2)));\n            context.queueWriteOperation(writeOperation);\n\n            assertTrue(context.readyForFlush());\n\n            when(channel.isOpen()).thenReturn(true);\n            context.closeFromSelector();\n\n            verify(selector, times(1)).executeFailedListener(same(listener), any(ClosedChannelException.class));\n            verify(selector, times(1)).executeFailedListener(same(listener2), any(ClosedChannelException.class));\n\n            assertFalse(context.readyForFlush());\n        }\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/SocketChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":199,"status":"B"}],"commitId":"9ee492a3f0768a3790671bfe46223e700082730a","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-06-11 16:47:26","modifiedFileCount":"192","status":"B","submitter":"Colin Goodheart-Smithe"},{"authorTime":"2019-07-17 06:46:41","codes":[{"authorDate":"2019-07-17 06:46:41","commitOrder":2,"curCode":"    public void testWriteIsQueuedInChannel() {\n        assertFalse(context.readyForFlush());\n\n        ByteBuffer[] buffer = {ByteBuffer.allocate(10)};\n        FlushReadyWrite writeOperation = new FlushReadyWrite(context, buffer, listener);\n        when(handler.writeToBytes(writeOperation)).thenReturn(Collections.singletonList(writeOperation));\n        context.queueWriteOperation(writeOperation);\n\n        verify(handler).writeToBytes(writeOperation);\n        assertTrue(context.readyForFlush());\n    }\n","date":"2019-07-17 06:46:41","endLine":199,"groupId":"101661","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testWriteIsQueuedInChannel","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/21/0a27aa109fa0e74cb0ce0ff2f083990298feb8.src","preCode":"    public void testWriteIsQueuedInChannel() {\n        assertFalse(context.readyForFlush());\n\n        ByteBuffer[] buffer = {ByteBuffer.allocate(10)};\n        FlushReadyWrite writeOperation = new FlushReadyWrite(context, buffer, listener);\n        when(readWriteHandler.writeToBytes(writeOperation)).thenReturn(Collections.singletonList(writeOperation));\n        context.queueWriteOperation(writeOperation);\n\n        verify(readWriteHandler).writeToBytes(writeOperation);\n        assertTrue(context.readyForFlush());\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/SocketChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":189,"status":"M"},{"authorDate":"2019-07-17 06:46:41","commitOrder":2,"curCode":"    public void testFlushOpsClearedOnClose() throws Exception {\n        try (SocketChannel realChannel = SocketChannel.open()) {\n            when(channel.getRawChannel()).thenReturn(realChannel);\n            InboundChannelBuffer channelBuffer = InboundChannelBuffer.allocatingInstance();\n            context = new TestSocketChannelContext(channel, selector, exceptionHandler, handler, channelBuffer);\n\n            assertFalse(context.readyForFlush());\n\n            ByteBuffer[] buffer = {ByteBuffer.allocate(10)};\n            WriteOperation writeOperation = mock(WriteOperation.class);\n            BiConsumer<Void, Exception> listener2 = mock(BiConsumer.class);\n            when(handler.writeToBytes(writeOperation)).thenReturn(Arrays.asList(new FlushOperation(buffer, listener),\n                new FlushOperation(buffer, listener2)));\n            context.queueWriteOperation(writeOperation);\n\n            assertTrue(context.readyForFlush());\n\n            when(channel.isOpen()).thenReturn(true);\n            context.closeFromSelector();\n\n            verify(selector, times(1)).executeFailedListener(same(listener), any(ClosedChannelException.class));\n            verify(selector, times(1)).executeFailedListener(same(listener2), any(ClosedChannelException.class));\n\n            assertFalse(context.readyForFlush());\n        }\n    }\n","date":"2019-07-17 06:46:41","endLine":234,"groupId":"101661","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testFlushOpsClearedOnClose","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/21/0a27aa109fa0e74cb0ce0ff2f083990298feb8.src","preCode":"    public void testFlushOpsClearedOnClose() throws Exception {\n        try (SocketChannel realChannel = SocketChannel.open()) {\n            when(channel.getRawChannel()).thenReturn(realChannel);\n            InboundChannelBuffer channelBuffer = InboundChannelBuffer.allocatingInstance();\n            context = new TestSocketChannelContext(channel, selector, exceptionHandler, readWriteHandler, channelBuffer);\n\n            assertFalse(context.readyForFlush());\n\n            ByteBuffer[] buffer = {ByteBuffer.allocate(10)};\n            WriteOperation writeOperation = mock(WriteOperation.class);\n            BiConsumer<Void, Exception> listener2 = mock(BiConsumer.class);\n            when(readWriteHandler.writeToBytes(writeOperation)).thenReturn(Arrays.asList(new FlushOperation(buffer, listener),\n                new FlushOperation(buffer, listener2)));\n            context.queueWriteOperation(writeOperation);\n\n            assertTrue(context.readyForFlush());\n\n            when(channel.isOpen()).thenReturn(true);\n            context.closeFromSelector();\n\n            verify(selector, times(1)).executeFailedListener(same(listener), any(ClosedChannelException.class));\n            verify(selector, times(1)).executeFailedListener(same(listener2), any(ClosedChannelException.class));\n\n            assertFalse(context.readyForFlush());\n        }\n    }\n","realPath":"libs/nio/src/test/java/org/elasticsearch/nio/SocketChannelContextTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":209,"status":"M"}],"commitId":"b75003fd53615ff4ac03b23201748b9705a8fff1","commitMessage":"@@@Isolate nio channel registered from channel active (#44388)\n\nRegistering a channel with a selector is a required operation for the\nchannel to be handled properly. Currently.  we mix the registeration with\nother setup operations (ip filtering.  SSL initiation.  etc). However.  a\nfail to register is fatal. This PR modifies how registeration occurs to\nimmediately close the channel if it fails.\n\nThere are still two clear loopholes for how a user can interact with a\nchannel even if registration fails. 1. through the exception handler.\n2. through the channel accepted callback. These can perhaps be improved\nin the future. For now.  this PR prevents writes from proceeding if the\nchannel is not registered.","date":"2019-07-17 06:46:41","modifiedFileCount":"18","status":"M","submitter":"Tim Brooks"}]
