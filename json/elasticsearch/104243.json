[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_6_3_0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        XContentParser parser = createParser(polygonGeoJson);\n        parser.nextToken();\n        ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).build());\n    }\n","date":"2018-04-26 03:22:53","endLine":272,"groupId":"28318","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6f/9128454f3743f94eb41b1397535f2a06aae105.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_6_3_0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        XContentParser parser = createParser(polygonGeoJson);\n        parser.nextToken();\n        ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":238,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        XContentParser parser = createParser(polygonGeoJson);\n        parser.nextToken();\n        ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n    }\n","date":"2018-04-26 03:22:53","endLine":291,"groupId":"25740","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/6f/9128454f3743f94eb41b1397535f2a06aae105.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        XContentParser parser = createParser(polygonGeoJson);\n        parser.nextToken();\n        ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":274,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-06-25 03:39:56","codes":[{"authorDate":"2018-06-25 03:39:56","commitOrder":2,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_6_3_0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).build());\n        }\n    }\n","date":"2018-06-25 16:41:24","endLine":275,"groupId":"28318","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bb/462ac60342f5462e37ed248fd6151eee744af3.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_6_3_0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        XContentParser parser = createParser(polygonGeoJson);\n        parser.nextToken();\n        ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).build());\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"M"},{"authorDate":"2018-06-25 03:39:56","commitOrder":2,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n        }\n    }\n","date":"2018-06-25 16:41:24","endLine":295,"groupId":"25740","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bb/462ac60342f5462e37ed248fd6151eee744af3.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        XContentParser parser = createParser(polygonGeoJson);\n        parser.nextToken();\n        ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":277,"status":"M"}],"commitId":"e6dc01d2b7d36b6d2a6aa11289afb70c9568c986","commitMessage":"@@@Close xcontent parsers (partial) (#31513)\n\nPartial pass at closing XContentParsers in server.  This mostly involved adding try-with-resources statements around the usage of XContentParsers.","date":"2018-06-25 16:41:24","modifiedFileCount":"53","status":"M","submitter":"Tom Callahan"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2018-06-25 03:39:56","commitOrder":3,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_6_3_0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).build());\n        }\n    }\n","date":"2018-06-25 16:41:24","endLine":275,"groupId":"28318","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bb/462ac60342f5462e37ed248fd6151eee744af3.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_6_3_0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).build());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":240,"status":"N"},{"authorDate":"2018-07-10 07:44:12","commitOrder":3,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"M"}],"commitId":"e9cd0556c167b257bb588af5547923e5f13a99ca","commitMessage":"@@@Merge branch 'master' into index-lifecycle\n","date":"2018-07-10 07:44:12","modifiedFileCount":"627","status":"M","submitter":"Tal Levy"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2018-11-22 01:15:01","commitOrder":4,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.apache.lucene.geo.Polygon p = new org.apache.lucene.geo.Polygon(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray());\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2018-11-22 01:15:01","endLine":309,"groupId":"48610","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/81/3b0f3c6267d2f54e30f2852b63e3a5b0918f29.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_6_3_0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).build());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":266,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":4,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"3bee25cb700208311ef751b1f460342bdba4ec70","commitMessage":"@@@[GEO] Add support to ShapeBuilders for building Lucene geometry (#35707)\n\n* [GEO] Add support to ShapeBuilders for building Lucene geometry\n\nThis commit adds support for building lucene geometry from the ShapeBuilders.\nThis is needed for integrating LatLonShape as the primary indexing approach\nfor geo_shape field types. All unit and integration tests are updated to\nadd randomization for testing both jts/s4j shapes and lucene shapes.\n","date":"2018-11-22 01:15:01","modifiedFileCount":"25","status":"M","submitter":"Nick Knize"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2018-12-18 04:38:14","commitOrder":5,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.apache.lucene.geo.Polygon p = new org.apache.lucene.geo.Polygon(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray());\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2018-12-18 04:38:14","endLine":310,"groupId":"48610","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2a/cabee8797f4a6409311693e9d41ec748886e76.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.apache.lucene.geo.Polygon p = new org.apache.lucene.geo.Polygon(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray());\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":266,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":5,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"5bc7822562a6eefa4a64743233160cdc9f431adf","commitMessage":"@@@[Geo] Integrate Lucene's LatLonShape (BKD Backed GeoShapes) as default `geo_shape` indexing approach (#35320)\n\nThis commit  exposes lucene's LatLonShape field as the\ndefault type in GeoShapeFieldMapper. To use the new \nindexing approach.  simply set \"type\" : \"geo_shape\" in \nthe mappings without setting any of the strategy.  precision.  \ntree_levels.  or distance_error_pct parameters. Note the \nfollowing when using the new indexing approach:\n\n* geo_shape query does not support querying by \nMULTIPOINT.\n* LINESTRING and MULTILINESTRING queries do not \nyet support WITHIN relation.\n* CONTAINS relation is not yet supported.\nThe tree.  precision.  tree_levels.  distance_error_pct.  \nand points_only parameters are deprecated.\n","date":"2018-12-18 04:38:14","modifiedFileCount":"22","status":"M","submitter":"Nick Knize"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2018-12-18 10:09:46","commitOrder":6,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.apache.lucene.geo.Polygon p = new org.apache.lucene.geo.Polygon(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray());\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2018-12-18 10:09:46","endLine":309,"groupId":"48610","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/a9/a210549064f6aaef26cfe48ce405a849a7ff21.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.apache.lucene.geo.Polygon p = new org.apache.lucene.geo.Polygon(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray());\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":266,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":6,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"96d279ed83e25f427db86b831333ca6772202a91","commitMessage":"@@@Revert \"[Geo] Integrate Lucene's LatLonShape (BKD Backed GeoShapes) as default `geo_shape` indexing approach (#35320)\"\n\nThis reverts commit 5bc7822562a6eefa4a64743233160cdc9f431adf.\n","date":"2018-12-18 10:09:46","modifiedFileCount":"22","status":"M","submitter":"Nicholas Knize"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2018-12-18 23:54:56","commitOrder":7,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.apache.lucene.geo.Polygon p = new org.apache.lucene.geo.Polygon(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray());\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2018-12-18 23:54:56","endLine":310,"groupId":"48610","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/2a/cabee8797f4a6409311693e9d41ec748886e76.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final GeoShapeFieldMapper mapperBuilder = new GeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.apache.lucene.geo.Polygon p = new org.apache.lucene.geo.Polygon(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray());\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":266,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":7,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"ec0dc2c0e900e1703dea29ddb56e4916618fc49e","commitMessage":"@@@[Geo] Integrate Lucene's LatLonShape (BKD Backed GeoShapes) as default `geo_shape` indexing approach (#36751)\n\n* [Geo] Expose BKDBackedGeoShapes as new VECTOR strategy\n\nThis commit exposes lucene's LatLonShape field as a new\nstrategy in GeoShapeFieldMapper. To use the new indexing\napproach.  strategy should be set to \"vector\" in the\ngeo_shape field mapper. If the tree parameter is set\nthe mapper will throw an IAE. Note the following:\n\nWhen using vector strategy:\n\n* geo_shape query does not support querying by POINT. \nMULTIPOINT.  or GEOMETRYCOLLECTION.\n* LINESTRING and MULTILINESTRING queries do not support\nWITHIN relation.\n* CONTAINS relation is not supported.\n* The tree.  precision.  tree_levels.  distance_error_pct. \nand points_only parameters will not throw an exception\nbut they have no effect and will be marked as\ndeprecated..\n\nAll other features are supported.\n\n* revert change to PercolatorFieldMapper\n\n* fix ExistsQuery for geo_shape vector strategy\n\n* add deprecation logging for tree.  precision.  tree_levels.  distance_error_pct.  and points_only\n\n* initial update to geoshape docs.  including mapping migration updates\n\n* initial support for GeoCollection queries\n\n* fix docs and javadoc errors\n\n* clean up geocollection queries\n\n* set deprecated mapping tests to NOTCONSOLE\n\n* fix geo-shape mapper asciidoc mapping and test warnings\n\n* add support for point queries using LatLonShapeBoundingBoxQuery\n\n* update GeoShapeQueryBuilderTests to include POINT queries for VECTOR strategy. Other comment cleanups\n\n* add lucene geometry build testing to ShapeBuilder tests\n\n* remove deprecated prefix tree mapping from geo-shape.asciidoc\n\n* refactor GeoShapeFieldMapper into LegacyGeoShapeFieldMapper and GeoShapeFieldMapper\n\nBoth classes derive from BaseGeoShapeFieldMapper that provides shared parameters:\ncoerce.  ignoreMalformed.  ignore_z_value.  orientation.\n\n* update docs to remove vector strategy\n\n* fix GeometryCollectionBuilder#buildLucene to return the object created by the shape builder\n\n* fix LineLength failure in GeoJsonShapeParserTests\n\n* ShapeMapper refactor changes from PR feedback\n\n* fix typo in geo-shape.asciidoc\n\n* ignore circle test in docs\n\n* update indexing-approach ref to geoshape-indexing-approach\n\n* add warnings check for LegacyGeoShapeFieldMapper to AbstractBuilderTestCase\n\n* fix deprecatedParameters setup\n\n* update indexing approach\n\n* fixing unexpected warnings failures\n\n* move orientation back to field type\n\n* remove if in LegacyGeoShapeFieldMapper#doXContent. Fix GeoShapeFieldMapper to work with double array as a point\n\n* fix indexing-approach link in circle section of geoshape docs\n\n* add strategy to deprecation warnings check\n\n* fix test failures\n\n* fix typo in QueryStringQueryBuilderTests\n\n* fix total hits to totalHits().value\n\n* fix version number\n\n* add version check to BaseGeoShapeFieldMapper\n\n* fix line length!\n\n* revert version check in BaseGeoShapeFieldMapper\n\n* Fix serialization of mappings of legacy shapes.\n","date":"2018-12-18 23:54:56","modifiedFileCount":"20","status":"M","submitter":"Nick Knize"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2019-01-26 00:37:27","commitOrder":8,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geo.geometry.Polygon p = new org.elasticsearch.geo.geometry.Polygon(new org.elasticsearch.geo.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2019-01-26 00:37:27","endLine":316,"groupId":"48610","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/74/024ddcada5ee8393f8b609bbd68b648e067d97.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.apache.lucene.geo.Polygon p = new org.apache.lucene.geo.Polygon(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray());\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":271,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":8,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"68149b6058a720ec891974e8a6982c5e480fb9f1","commitMessage":"@@@Geo: replace intermediate geo objects with libs/geo (#37721)\n\nReplaces intermediate geo objects built by ShapeBuilders with\nobjects from the libs/geo hierarchy. This should allow us to build\nall geo functionality around a single hierarchy.\n\nFollow up for #35320","date":"2019-01-26 00:37:27","modifiedFileCount":"27","status":"M","submitter":"Igor Motov"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2019-04-19 09:19:43","commitOrder":9,"curCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geo.geometry.Polygon p = new org.elasticsearch.geo.geometry.Polygon(new org.elasticsearch.geo.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2019-04-19 09:19:43","endLine":316,"groupId":"64278","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/58/06875ce109b6c2e7534db3254d73e62873eb60.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomVersionBetween(random(), Version.V_6_0_0, Version.CURRENT);\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geo.geometry.Polygon p = new org.elasticsearch.geo.geometry.Polygon(new org.elasticsearch.geo.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":271,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":9,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"2d29807b9cdd2bb3e78dbd2f8b1d33fa9d35081e","commitMessage":"@@@Remove several uses of 6.x version constants (#41162)\n\nThis commit removes many conditionals in serialization.  as well as tests\nwhich no longer need to be compatible with 6.x now that master is 8.0.\nAdditionally.  many tests are changed to not depend on a fixed version. \nbut instead use new helper methods for getting the range of index\ncompatible versions with the current version.  which will make the tests\nnot need changes in the future when version constants are removed.\n","date":"2019-04-19 09:19:43","modifiedFileCount":"37","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2019-07-16 21:37:04","commitOrder":10,"curCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geo.geometry.Polygon p = new org.elasticsearch.geo.geometry.Polygon(new org.elasticsearch.geo.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2019-07-16 21:37:04","endLine":317,"groupId":"64278","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/cc/fc599f4cadc12195886cf7714ac82c70c628ad.src","preCode":"    public void testParse3DPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geo.geometry.Polygon p = new org.elasticsearch.geo.geometry.Polygon(new org.elasticsearch.geo.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":272,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":10,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"33ad7928fbba6f2a371c5133685bf46afabc2aef","commitMessage":"@@@Geo: extract dateline handling logic from ShapeBuilders (#44187)\n\nExtracts dateline decomposition logic from ShapeBuilder into a separate\nutility class that is used on the indexing side. The search side\nwill be handled as part of another PR at this time we will remove\nthe decomposition logic from ShapeBuilders as well. This PR also doesn't\nchange any existing logic including bugs.\n\nRelates to #40908","date":"2019-07-16 21:37:04","modifiedFileCount":"8","status":"M","submitter":"Igor Motov"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2019-08-10 01:22:00","commitOrder":11,"curCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2019-08-10 01:22:00","endLine":318,"groupId":"64278","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/56/0d2987086d6505a493da36902b1d99e5305664.src","preCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geo.geometry.Polygon p = new org.elasticsearch.geo.geometry.Polygon(new org.elasticsearch.geo.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.y).toArray(),\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":274,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":11,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"13a8835e5a8615aeb8304b48fd9e543a83361e13","commitMessage":"@@@Geo: Change order of parameter in Geometries to lon.  lat (#45332)\n\nChanges the order of parameters in Geometries from lat.  lon to lon.  lat\nand moves all Geometry classes are moved to the\norg.elasticsearch.geomtery package.\n\nCloses #45048","date":"2019-08-10 01:22:00","modifiedFileCount":"65","status":"M","submitter":"Igor Motov"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2020-04-01 03:52:01","commitOrder":12,"curCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2020-04-01 03:52:01","endLine":318,"groupId":"64278","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c3/748ed140b6fceb89f507ec0622cc398958d4de.src","preCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":274,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":12,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"95a7eed9aa35f47b228e402508709b5bd6703cf4","commitMessage":"@@@Rename MetaData to Metadata in all of the places (#54519)\n\nThis is a simple naming change PR.  to fix the fact that \"metadata\" is a\nsingle English word.  and for too long we have not followed general\nnaming conventions for it. We are also not consistent about it.  for\nexample.  METADATA instead of META_DATA if we were trying to be\nconsistent with MetaData (although METADATA is correct when considered\nin the context of \"metadata\"). This was a simple find and replace across\nthe code base.  only taking a few minutes to fix this naming issue\nforever.","date":"2020-04-01 03:52:01","modifiedFileCount":"1712","status":"M","submitter":"Jason Tedor"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2020-10-22 16:11:41","commitOrder":13,"curCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            new LegacyGeoShapeFieldMapper.Builder(\"test\", Version.CURRENT, false, true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2020-10-22 16:11:41","endLine":318,"groupId":"64278","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/bd893bfb1fea229a7ddb290c676bace641b6be.src","preCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            (LegacyGeoShapeFieldMapper) (new LegacyGeoShapeFieldMapper.Builder(\"test\").ignoreZValue(true).build(mockBuilderContext));\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":274,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":13,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"bfaf3040c6e5245b6d3367483ba86c676dd09bd2","commitMessage":"@@@Convert geo field mappers to Parametrized form (#63836)\n\nRelates to #62988","date":"2020-10-22 16:11:41","modifiedFileCount":"42","status":"M","submitter":"Alan Woodward"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2020-11-05 18:48:39","commitOrder":14,"curCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            new LegacyGeoShapeFieldMapper.Builder(\"test\", Version.CURRENT, false, true).build(new ContentPath());\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2020-11-05 18:48:39","endLine":316,"groupId":"64278","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1f/93017cf4fdf6a23624f209ee40593e289d1f20.src","preCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        Mapper.BuilderContext mockBuilderContext = new Mapper.BuilderContext(indexSettings, new ContentPath());\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            new LegacyGeoShapeFieldMapper.Builder(\"test\", Version.CURRENT, false, true).build(mockBuilderContext);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":273,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":14,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"0fd70ae383620d587a36ea71baca9295da93a76a","commitMessage":"@@@Remove Mapper.BuilderContext (#64625)\n\nMapper.BuilderContext is a simple wrapper around two objects.  some\nIndexSettings and a ContentPath. The IndexSettings are the same as\nthose provided in the ParserContext.  so we can simplify things here\nby removing them and just passing ContentPath directly to\nMapper.Builder#build()","date":"2020-11-05 18:48:39","modifiedFileCount":"103","status":"M","submitter":"Alan Woodward"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2021-05-12 20:50:26","commitOrder":15,"curCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        final Version version = VersionUtils.randomPreviousCompatibleVersion(random(), Version.V_8_0_0);\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            new LegacyGeoShapeFieldMapper.Builder(\"test\", version, false, true)\n                .build(new ContentPath());\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2021-05-12 20:50:26","endLine":307,"groupId":"64278","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/99/9fd006f4382821e3a04d2ca7a55e1c2d30cbee.src","preCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            new LegacyGeoShapeFieldMapper.Builder(\"test\", Version.CURRENT, false, true).build(new ContentPath());\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":262,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":15,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"25740","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"4528e780c48ada91fd452b9c51dc1a37772c5f07","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n\n# Conflicts:\n#\tx-pack/plugin/spatial/build.gradle\n#\tx-pack/plugin/spatial/src/main/java/org/elasticsearch/xpack/spatial/SpatialPlugin.java\n","date":"2021-05-12 20:50:26","modifiedFileCount":"564","status":"M","submitter":"iverase"},{"authorTime":"2018-07-10 07:44:12","codes":[{"authorDate":"2021-09-08 23:34:14","commitOrder":16,"curCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        final Version version = VersionUtils.randomPreviousCompatibleVersion(random(), Version.V_8_0_0);\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            new LegacyGeoShapeFieldMapper.Builder(\"test\", version, false, true)\n                .build(MapperBuilderContext.ROOT);\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","date":"2021-09-08 23:34:14","endLine":307,"groupId":"104243","id":31,"instanceNumber":1,"isCurCommit":1,"methodName":"testParse3DPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/47/50c18d34578b59791b6cb9356ea5e7d0e83e79.src","preCode":"    public void testParse3DPolygon() throws IOException, ParseException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n\n        List<Coordinate> shellCoordinates = new ArrayList<>();\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 0, 10));\n        shellCoordinates.add(new Coordinate(101, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 1, 10));\n        shellCoordinates.add(new Coordinate(100, 0, 10));\n        Coordinate[] coordinates = shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]);\n\n        Version randomVersion = VersionUtils.randomIndexCompatibleVersion(random());\n        Settings indexSettings = Settings.builder()\n            .put(IndexMetadata.SETTING_VERSION_CREATED, randomVersion)\n            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build();\n\n        LinearRing shell = GEOMETRY_FACTORY.createLinearRing(shellCoordinates.toArray(new Coordinate[shellCoordinates.size()]));\n        Polygon expected = GEOMETRY_FACTORY.createPolygon(shell, null);\n        final Version version = VersionUtils.randomPreviousCompatibleVersion(random(), Version.V_8_0_0);\n        final LegacyGeoShapeFieldMapper mapperBuilder =\n            new LegacyGeoShapeFieldMapper.Builder(\"test\", version, false, true)\n                .build(new ContentPath());\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertEquals(jtsGeom(expected), ShapeParser.parse(parser, mapperBuilder).buildS4J());\n        }\n\n        org.elasticsearch.geometry.Polygon p = new org.elasticsearch.geometry.Polygon(new org.elasticsearch.geometry.LinearRing(\n            Arrays.stream(coordinates).mapToDouble(i->i.x).toArray(), Arrays.stream(coordinates).mapToDouble(i->i.y).toArray()\n        ));\n        assertGeometryEquals(p, polygonGeoJson, false);\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":262,"status":"M"},{"authorDate":"2018-07-10 07:44:12","commitOrder":16,"curCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","date":"2018-07-10 07:44:12","endLine":299,"groupId":"104243","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"testInvalidDimensionalPolygon","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/17/f25d1556d4832429876e5ed2819ae0ad7c1113.src","preCode":"    public void testInvalidDimensionalPolygon() throws IOException {\n        XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()\n            .startObject()\n            .field(\"type\", \"Polygon\")\n            .startArray(\"coordinates\")\n            .startArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .startArray().value(101.0).value(1.0).endArray()\n            .startArray().value(101.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(0.0).value(10.0).endArray()\n            .startArray().value(100.0).value(1.0).value(10.0).endArray()\n            .endArray()\n            .endArray()\n            .endObject();\n        try (XContentParser parser = createParser(polygonGeoJson)) {\n            parser.nextToken();\n            ElasticsearchGeoAssertions.assertValidException(parser, ElasticsearchParseException.class);\n            assertNull(parser.nextToken());\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/common/geo/GeoJsonShapeParserTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":280,"status":"N"}],"commitId":"9312eba5ed2a4174e0ac1ce823e98f47a19b4fc1","commitMessage":"@@@Change Mapper.build() to take a context object (#77108)\n\nMapper.build() currently takes a ContentPath object that it can use to generate\nfield type names that will include its parent names. We would like to expand field types\nto include more information about their parents.  and ContentPath does not hold this\ninformation. This commit replaces the ContentPath parameter with a new\nMapperBuilderContext.  which currently holds only the content path information but\ncan be expanded in future to hold parent relationship information.\n\nRelates to #75474","date":"2021-09-08 23:34:14","modifiedFileCount":"97","status":"M","submitter":"Alan Woodward"}]
