[{"authorTime":"2019-02-12 20:37:12","codes":[{"authorDate":"2019-02-12 20:37:12","commitOrder":1,"curCode":"    public void testAddUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Add.INSTANCE,\n                                new RetentionLeaseActions.AddRequest(shardId, id, retainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse stats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n        assertNotNull(stats.getShards());\n        assertThat(stats.getShards(), arrayWithSize(1));\n        assertNotNull(stats.getShards()[0].getRetentionLeaseStats());\n        assertThat(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease retentionLease = stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n        assertThat(retentionLease.id(), equalTo(id));\n        assertThat(retentionLease.retainingSequenceNumber(), equalTo(retainingSequenceNumber == RETAIN_ALL ? 0L : retainingSequenceNumber));\n        assertThat(retentionLease.source(), equalTo(source));\n    }\n","date":"2019-02-12 20:37:12","endLine":336,"groupId":"71662","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testAddUnderBlock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bf/f4493321289fd3b3a6e0e5c42365fab8a642cb.src","preCode":"    public void testAddUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Add.INSTANCE,\n                                new RetentionLeaseActions.AddRequest(shardId, id, retainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse stats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n        assertNotNull(stats.getShards());\n        assertThat(stats.getShards(), arrayWithSize(1));\n        assertNotNull(stats.getShards()[0].getRetentionLeaseStats());\n        assertThat(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease retentionLease = stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n        assertThat(retentionLease.id(), equalTo(id));\n        assertThat(retentionLease.retainingSequenceNumber(), equalTo(retainingSequenceNumber == RETAIN_ALL ? 0L : retainingSequenceNumber));\n        assertThat(retentionLease.source(), equalTo(source));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseActionsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"B"},{"authorDate":"2019-02-12 20:37:12","commitOrder":1,"curCode":"    public void testRenewUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n\n        \r\n\r\n\r\n\r\n\r\n\n        final TimeValue estimatedTimeInterval = ThreadPool.ESTIMATED_TIME_INTERVAL_SETTING.get(getInstanceFromNode(Node.class).settings());\n\n        client()\n                .execute(\n                        RetentionLeaseActions.Add.INSTANCE,\n                        new RetentionLeaseActions.AddRequest(indexService.getShard(0).shardId(), id, retainingSequenceNumber, source))\n                .actionGet();\n\n        \r\n\r\n\r\n\n        final ThreadPool threadPool = getInstanceFromNode(ThreadPool.class);\n        final long timestampUpperBound = threadPool.absoluteTimeInMillis();\n        final long start = System.nanoTime();\n\n        final IndicesStatsResponse initialStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(initialStats.getShards());\n        assertThat(initialStats.getShards(), arrayWithSize(1));\n        assertNotNull(initialStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease initialRetentionLease =\n                initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n\n        final long nextRetainingSequenceNumber =\n                retainingSequenceNumber == RETAIN_ALL && randomBoolean() ? RETAIN_ALL\n                        : randomLongBetween(Math.max(retainingSequenceNumber, 0L), Long.MAX_VALUE);\n\n        \r\n\r\n\r\n\r\n\n        do {\n            final long end = System.nanoTime();\n            if (end - start < estimatedTimeInterval.nanos()) {\n                Thread.sleep(TimeUnit.NANOSECONDS.toMillis(estimatedTimeInterval.nanos() - (end - start)));\n            }\n        } while (threadPool.absoluteTimeInMillis() <= timestampUpperBound);\n\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Renew.INSTANCE,\n                                new RetentionLeaseActions.RenewRequest(shardId, id, nextRetainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse renewedStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(renewedStats.getShards());\n        assertThat(renewedStats.getShards(), arrayWithSize(1));\n        assertNotNull(renewedStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease renewedRetentionLease =\n                renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n        assertThat(renewedRetentionLease.id(), equalTo(id));\n        assertThat(\n                renewedRetentionLease.retainingSequenceNumber(),\n                equalTo(nextRetainingSequenceNumber == RETAIN_ALL ? 0L : nextRetainingSequenceNumber));\n        assertThat(renewedRetentionLease.timestamp(), greaterThan(initialRetentionLease.timestamp()));\n        assertThat(renewedRetentionLease.source(), equalTo(source));\n    }\n","date":"2019-02-12 20:37:12","endLine":439,"groupId":"31410","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testRenewUnderBlock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/bf/f4493321289fd3b3a6e0e5c42365fab8a642cb.src","preCode":"    public void testRenewUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n\n        \r\n\r\n\r\n\r\n\r\n\n        final TimeValue estimatedTimeInterval = ThreadPool.ESTIMATED_TIME_INTERVAL_SETTING.get(getInstanceFromNode(Node.class).settings());\n\n        client()\n                .execute(\n                        RetentionLeaseActions.Add.INSTANCE,\n                        new RetentionLeaseActions.AddRequest(indexService.getShard(0).shardId(), id, retainingSequenceNumber, source))\n                .actionGet();\n\n        \r\n\r\n\r\n\n        final ThreadPool threadPool = getInstanceFromNode(ThreadPool.class);\n        final long timestampUpperBound = threadPool.absoluteTimeInMillis();\n        final long start = System.nanoTime();\n\n        final IndicesStatsResponse initialStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(initialStats.getShards());\n        assertThat(initialStats.getShards(), arrayWithSize(1));\n        assertNotNull(initialStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease initialRetentionLease =\n                initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n\n        final long nextRetainingSequenceNumber =\n                retainingSequenceNumber == RETAIN_ALL && randomBoolean() ? RETAIN_ALL\n                        : randomLongBetween(Math.max(retainingSequenceNumber, 0L), Long.MAX_VALUE);\n\n        \r\n\r\n\r\n\r\n\n        do {\n            final long end = System.nanoTime();\n            if (end - start < estimatedTimeInterval.nanos()) {\n                Thread.sleep(TimeUnit.NANOSECONDS.toMillis(estimatedTimeInterval.nanos() - (end - start)));\n            }\n        } while (threadPool.absoluteTimeInMillis() <= timestampUpperBound);\n\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Renew.INSTANCE,\n                                new RetentionLeaseActions.RenewRequest(shardId, id, nextRetainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse renewedStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(renewedStats.getShards());\n        assertThat(renewedStats.getShards(), arrayWithSize(1));\n        assertNotNull(renewedStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease renewedRetentionLease =\n                renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n        assertThat(renewedRetentionLease.id(), equalTo(id));\n        assertThat(\n                renewedRetentionLease.retainingSequenceNumber(),\n                equalTo(nextRetainingSequenceNumber == RETAIN_ALL ? 0L : nextRetainingSequenceNumber));\n        assertThat(renewedRetentionLease.timestamp(), greaterThan(initialRetentionLease.timestamp()));\n        assertThat(renewedRetentionLease.source(), equalTo(source));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseActionsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":338,"status":"B"}],"commitId":"bbe990f86275ed6d696681afc636d940ddf49d26","commitMessage":"@@@Introduce retention lease actions (#38756)\n\nThis commit introduces actions for some common retention lease\noperations that clients need to be able to perform remotely. These\nactions include add/renew/remove.","date":"2019-02-12 20:37:12","modifiedFileCount":"8","status":"B","submitter":"Jason Tedor"},{"authorTime":"2019-08-02 22:00:32","codes":[{"authorDate":"2019-08-02 22:00:32","commitOrder":2,"curCode":"    public void testAddUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Add.INSTANCE,\n                                new RetentionLeaseActions.AddRequest(shardId, id, retainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse stats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n        assertNotNull(stats.getShards());\n        assertThat(stats.getShards(), arrayWithSize(1));\n        assertNotNull(stats.getShards()[0].getRetentionLeaseStats());\n        assertThat(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(stats.getShards()[0].getShardRouting())));\n        final RetentionLease retentionLease = stats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n        assertThat(retentionLease.id(), equalTo(id));\n        assertThat(retentionLease.retainingSequenceNumber(), equalTo(retainingSequenceNumber == RETAIN_ALL ? 0L : retainingSequenceNumber));\n        assertThat(retentionLease.source(), equalTo(source));\n    }\n","date":"2019-08-02 22:00:32","endLine":347,"groupId":"71662","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testAddUnderBlock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/51/1a93e8268d157c227ee01bbd76fad33c387e23.src","preCode":"    public void testAddUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Add.INSTANCE,\n                                new RetentionLeaseActions.AddRequest(shardId, id, retainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse stats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n        assertNotNull(stats.getShards());\n        assertThat(stats.getShards(), arrayWithSize(1));\n        assertNotNull(stats.getShards()[0].getRetentionLeaseStats());\n        assertThat(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease retentionLease = stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n        assertThat(retentionLease.id(), equalTo(id));\n        assertThat(retentionLease.retainingSequenceNumber(), equalTo(retainingSequenceNumber == RETAIN_ALL ? 0L : retainingSequenceNumber));\n        assertThat(retentionLease.source(), equalTo(source));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseActionsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":301,"status":"M"},{"authorDate":"2019-08-02 22:00:32","commitOrder":2,"curCode":"    public void testRenewUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n\n        \r\n\r\n\r\n\r\n\r\n\n        final TimeValue estimatedTimeInterval = ThreadPool.ESTIMATED_TIME_INTERVAL_SETTING.get(getInstanceFromNode(Node.class).settings());\n\n        client()\n                .execute(\n                        RetentionLeaseActions.Add.INSTANCE,\n                        new RetentionLeaseActions.AddRequest(indexService.getShard(0).shardId(), id, retainingSequenceNumber, source))\n                .actionGet();\n\n        \r\n\r\n\r\n\n        final ThreadPool threadPool = getInstanceFromNode(ThreadPool.class);\n        final long timestampUpperBound = threadPool.absoluteTimeInMillis();\n        final long start = System.nanoTime();\n\n        final IndicesStatsResponse initialStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(initialStats.getShards());\n        assertThat(initialStats.getShards(), arrayWithSize(1));\n        assertNotNull(initialStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(initialStats.getShards()[0].getShardRouting())));\n        final RetentionLease initialRetentionLease = initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n\n        final long nextRetainingSequenceNumber =\n                retainingSequenceNumber == RETAIN_ALL && randomBoolean() ? RETAIN_ALL\n                        : randomLongBetween(Math.max(retainingSequenceNumber, 0L), Long.MAX_VALUE);\n\n        \r\n\r\n\r\n\r\n\n        do {\n            final long end = System.nanoTime();\n            if (end - start < estimatedTimeInterval.nanos()) {\n                Thread.sleep(TimeUnit.NANOSECONDS.toMillis(estimatedTimeInterval.nanos() - (end - start)));\n            }\n        } while (threadPool.absoluteTimeInMillis() <= timestampUpperBound);\n\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Renew.INSTANCE,\n                                new RetentionLeaseActions.RenewRequest(shardId, id, nextRetainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse renewedStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(renewedStats.getShards());\n        assertThat(renewedStats.getShards(), arrayWithSize(1));\n        assertNotNull(renewedStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(renewedStats.getShards()[0].getShardRouting())));\n        final RetentionLease renewedRetentionLease = renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n        assertThat(renewedRetentionLease.id(), equalTo(id));\n        assertThat(\n                renewedRetentionLease.retainingSequenceNumber(),\n                equalTo(nextRetainingSequenceNumber == RETAIN_ALL ? 0L : nextRetainingSequenceNumber));\n        assertThat(renewedRetentionLease.timestamp(), greaterThan(initialRetentionLease.timestamp()));\n        assertThat(renewedRetentionLease.source(), equalTo(source));\n    }\n","date":"2019-08-02 22:00:32","endLine":452,"groupId":"71662","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testRenewUnderBlock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/51/1a93e8268d157c227ee01bbd76fad33c387e23.src","preCode":"    public void testRenewUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n\n        \r\n\r\n\r\n\r\n\r\n\n        final TimeValue estimatedTimeInterval = ThreadPool.ESTIMATED_TIME_INTERVAL_SETTING.get(getInstanceFromNode(Node.class).settings());\n\n        client()\n                .execute(\n                        RetentionLeaseActions.Add.INSTANCE,\n                        new RetentionLeaseActions.AddRequest(indexService.getShard(0).shardId(), id, retainingSequenceNumber, source))\n                .actionGet();\n\n        \r\n\r\n\r\n\n        final ThreadPool threadPool = getInstanceFromNode(ThreadPool.class);\n        final long timestampUpperBound = threadPool.absoluteTimeInMillis();\n        final long start = System.nanoTime();\n\n        final IndicesStatsResponse initialStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(initialStats.getShards());\n        assertThat(initialStats.getShards(), arrayWithSize(1));\n        assertNotNull(initialStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease initialRetentionLease =\n                initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n\n        final long nextRetainingSequenceNumber =\n                retainingSequenceNumber == RETAIN_ALL && randomBoolean() ? RETAIN_ALL\n                        : randomLongBetween(Math.max(retainingSequenceNumber, 0L), Long.MAX_VALUE);\n\n        \r\n\r\n\r\n\r\n\n        do {\n            final long end = System.nanoTime();\n            if (end - start < estimatedTimeInterval.nanos()) {\n                Thread.sleep(TimeUnit.NANOSECONDS.toMillis(estimatedTimeInterval.nanos() - (end - start)));\n            }\n        } while (threadPool.absoluteTimeInMillis() <= timestampUpperBound);\n\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Renew.INSTANCE,\n                                new RetentionLeaseActions.RenewRequest(shardId, id, nextRetainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse renewedStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(renewedStats.getShards());\n        assertThat(renewedStats.getShards(), arrayWithSize(1));\n        assertNotNull(renewedStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(1));\n        final RetentionLease renewedRetentionLease =\n                renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases().iterator().next();\n        assertThat(renewedRetentionLease.id(), equalTo(id));\n        assertThat(\n                renewedRetentionLease.retainingSequenceNumber(),\n                equalTo(nextRetainingSequenceNumber == RETAIN_ALL ? 0L : nextRetainingSequenceNumber));\n        assertThat(renewedRetentionLease.timestamp(), greaterThan(initialRetentionLease.timestamp()));\n        assertThat(renewedRetentionLease.source(), equalTo(source));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseActionsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":349,"status":"M"}],"commitId":"01287eacb2f2d2673bc25078fb0b76d81beaad9b","commitMessage":"@@@Use index for peer recovery instead of translog (#45136)\n\nToday we recover a replica by copying operations from the primary's translog.\nHowever we also retain some historical operations in the index itself.  as long\nas soft-deletes are enabled. This commit adjusts peer recovery to use the\noperations in the index for recovery rather than those in the translog.  and\nensures that the replication group retains enough history for use in peer\nrecovery by means of retention leases.\n\nReverts #38904 and #42211\nRelates #41536","date":"2019-08-02 22:00:32","modifiedFileCount":"42","status":"M","submitter":"David Turner"},{"authorTime":"2020-11-18 16:50:23","codes":[{"authorDate":"2020-11-18 16:50:23","commitOrder":3,"curCode":"    public void testAddUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Add.INSTANCE,\n                                new RetentionLeaseActions.AddRequest(shardId, id, retainingSequenceNumber, source),\n                                new ActionListener<>() {\n\n                                    @Override\n                                    public void onResponse(final ActionResponse.Empty response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse stats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n        assertNotNull(stats.getShards());\n        assertThat(stats.getShards(), arrayWithSize(1));\n        assertNotNull(stats.getShards()[0].getRetentionLeaseStats());\n        assertThat(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(stats.getShards()[0].getShardRouting())));\n        final RetentionLease retentionLease = stats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n        assertThat(retentionLease.id(), equalTo(id));\n        assertThat(retentionLease.retainingSequenceNumber(), equalTo(retainingSequenceNumber == RETAIN_ALL ? 0L : retainingSequenceNumber));\n        assertThat(retentionLease.source(), equalTo(source));\n    }\n","date":"2020-11-18 16:50:23","endLine":348,"groupId":"103546","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testAddUnderBlock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1c/5ac508fbc10351398deceb3ee927c5cbdf153f.src","preCode":"    public void testAddUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Add.INSTANCE,\n                                new RetentionLeaseActions.AddRequest(shardId, id, retainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse stats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n        assertNotNull(stats.getShards());\n        assertThat(stats.getShards(), arrayWithSize(1));\n        assertNotNull(stats.getShards()[0].getRetentionLeaseStats());\n        assertThat(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(stats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(stats.getShards()[0].getShardRouting())));\n        final RetentionLease retentionLease = stats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n        assertThat(retentionLease.id(), equalTo(id));\n        assertThat(retentionLease.retainingSequenceNumber(), equalTo(retainingSequenceNumber == RETAIN_ALL ? 0L : retainingSequenceNumber));\n        assertThat(retentionLease.source(), equalTo(source));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseActionsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":302,"status":"M"},{"authorDate":"2020-11-18 16:50:23","commitOrder":3,"curCode":"    public void testRenewUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n\n        \r\n\r\n\r\n\r\n\r\n\n        final TimeValue estimatedTimeInterval = ThreadPool.ESTIMATED_TIME_INTERVAL_SETTING.get(getInstanceFromNode(Node.class).settings());\n\n        client()\n                .execute(\n                        RetentionLeaseActions.Add.INSTANCE,\n                        new RetentionLeaseActions.AddRequest(indexService.getShard(0).shardId(), id, retainingSequenceNumber, source))\n                .actionGet();\n\n        \r\n\r\n\r\n\n        final ThreadPool threadPool = getInstanceFromNode(ThreadPool.class);\n        final long timestampUpperBound = threadPool.absoluteTimeInMillis();\n        final long start = System.nanoTime();\n\n        final IndicesStatsResponse initialStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(initialStats.getShards());\n        assertThat(initialStats.getShards(), arrayWithSize(1));\n        assertNotNull(initialStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(initialStats.getShards()[0].getShardRouting())));\n        final RetentionLease initialRetentionLease = initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n\n        final long nextRetainingSequenceNumber =\n                retainingSequenceNumber == RETAIN_ALL && randomBoolean() ? RETAIN_ALL\n                        : randomLongBetween(Math.max(retainingSequenceNumber, 0L), Long.MAX_VALUE);\n\n        \r\n\r\n\r\n\r\n\n        do {\n            final long end = System.nanoTime();\n            if (end - start < estimatedTimeInterval.nanos()) {\n                Thread.sleep(TimeUnit.NANOSECONDS.toMillis(estimatedTimeInterval.nanos() - (end - start)));\n            }\n        } while (threadPool.absoluteTimeInMillis() <= timestampUpperBound);\n\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Renew.INSTANCE,\n                                new RetentionLeaseActions.RenewRequest(shardId, id, nextRetainingSequenceNumber, source),\n                                new ActionListener<>() {\n\n                                    @Override\n                                    public void onResponse(final ActionResponse.Empty response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse renewedStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(renewedStats.getShards());\n        assertThat(renewedStats.getShards(), arrayWithSize(1));\n        assertNotNull(renewedStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(renewedStats.getShards()[0].getShardRouting())));\n        final RetentionLease renewedRetentionLease = renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n        assertThat(renewedRetentionLease.id(), equalTo(id));\n        assertThat(\n                renewedRetentionLease.retainingSequenceNumber(),\n                equalTo(nextRetainingSequenceNumber == RETAIN_ALL ? 0L : nextRetainingSequenceNumber));\n        assertThat(renewedRetentionLease.timestamp(), greaterThan(initialRetentionLease.timestamp()));\n        assertThat(renewedRetentionLease.source(), equalTo(source));\n    }\n","date":"2020-11-18 16:50:23","endLine":453,"groupId":"103546","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testRenewUnderBlock","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/1c/5ac508fbc10351398deceb3ee927c5cbdf153f.src","preCode":"    public void testRenewUnderBlock() throws InterruptedException {\n        final Settings settings = Settings.builder()\n                .put(\"index.number_of_shards\", 1)\n                .put(\"index.number_of_replicas\", 0)\n                .put(IndexSettings.INDEX_SOFT_DELETES_SETTING.getKey(), true)\n                .build();\n        final IndexService indexService = createIndex(\"index\", settings);\n        ensureGreen(\"index\");\n        final String id = randomAlphaOfLength(8);\n        final long retainingSequenceNumber = randomBoolean() ? RETAIN_ALL : randomNonNegativeLong();\n        final String source = randomAlphaOfLength(8);\n\n        \r\n\r\n\r\n\r\n\r\n\n        final TimeValue estimatedTimeInterval = ThreadPool.ESTIMATED_TIME_INTERVAL_SETTING.get(getInstanceFromNode(Node.class).settings());\n\n        client()\n                .execute(\n                        RetentionLeaseActions.Add.INSTANCE,\n                        new RetentionLeaseActions.AddRequest(indexService.getShard(0).shardId(), id, retainingSequenceNumber, source))\n                .actionGet();\n\n        \r\n\r\n\r\n\n        final ThreadPool threadPool = getInstanceFromNode(ThreadPool.class);\n        final long timestampUpperBound = threadPool.absoluteTimeInMillis();\n        final long start = System.nanoTime();\n\n        final IndicesStatsResponse initialStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(initialStats.getShards());\n        assertThat(initialStats.getShards(), arrayWithSize(1));\n        assertNotNull(initialStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(initialStats.getShards()[0].getShardRouting())));\n        final RetentionLease initialRetentionLease = initialStats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n\n        final long nextRetainingSequenceNumber =\n                retainingSequenceNumber == RETAIN_ALL && randomBoolean() ? RETAIN_ALL\n                        : randomLongBetween(Math.max(retainingSequenceNumber, 0L), Long.MAX_VALUE);\n\n        \r\n\r\n\r\n\r\n\n        do {\n            final long end = System.nanoTime();\n            if (end - start < estimatedTimeInterval.nanos()) {\n                Thread.sleep(TimeUnit.NANOSECONDS.toMillis(estimatedTimeInterval.nanos() - (end - start)));\n            }\n        } while (threadPool.absoluteTimeInMillis() <= timestampUpperBound);\n\n        runActionUnderBlockTest(\n                indexService,\n                (shardId, actionLatch) ->\n                        client().execute(\n                                RetentionLeaseActions.Renew.INSTANCE,\n                                new RetentionLeaseActions.RenewRequest(shardId, id, nextRetainingSequenceNumber, source),\n                                new ActionListener<RetentionLeaseActions.Response>() {\n\n                                    @Override\n                                    public void onResponse(final RetentionLeaseActions.Response response) {\n                                        actionLatch.countDown();\n                                    }\n\n                                    @Override\n                                    public void onFailure(final Exception e) {\n                                        fail(e.toString());\n                                    }\n\n                                }));\n\n        final IndicesStatsResponse renewedStats = client()\n                .execute(\n                        IndicesStatsAction.INSTANCE,\n                        new IndicesStatsRequest().indices(\"index\"))\n                .actionGet();\n\n        assertNotNull(renewedStats.getShards());\n        assertThat(renewedStats.getShards(), arrayWithSize(1));\n        assertNotNull(renewedStats.getShards()[0].getRetentionLeaseStats());\n        assertThat(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().leases(), hasSize(2));\n        assertTrue(renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().contains(\n            ReplicationTracker.getPeerRecoveryRetentionLeaseId(renewedStats.getShards()[0].getShardRouting())));\n        final RetentionLease renewedRetentionLease = renewedStats.getShards()[0].getRetentionLeaseStats().retentionLeases().get(id);\n        assertThat(renewedRetentionLease.id(), equalTo(id));\n        assertThat(\n                renewedRetentionLease.retainingSequenceNumber(),\n                equalTo(nextRetainingSequenceNumber == RETAIN_ALL ? 0L : nextRetainingSequenceNumber));\n        assertThat(renewedRetentionLease.timestamp(), greaterThan(initialRetentionLease.timestamp()));\n        assertThat(renewedRetentionLease.source(), equalTo(source));\n    }\n","realPath":"server/src/test/java/org/elasticsearch/index/seqno/RetentionLeaseActionsTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":350,"status":"M"}],"commitId":"acb811ea6d04a8366966a5effd094fede44b5d4f","commitMessage":"@@@Dry up Empty ActionResponse Implementations (#65035)\n\nNo need to have multiple empty action response implementations.\n=> Use a single class and singleton for all of them like we do for\nempty flat transport responses.","date":"2020-11-18 16:50:23","modifiedFileCount":"34","status":"M","submitter":"Armin Braun"}]
