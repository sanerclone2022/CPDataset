[{"authorTime":"2021-02-26 03:15:57","codes":[{"authorDate":"2021-02-26 03:15:57","commitOrder":1,"curCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(0L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertThat(debug, hasEntry(\"specialized_for\", \"match_all\"));\n            assertThat((int) debug.get(\"results_from_metadata\"), greaterThan(0));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n            }\n        );\n    }\n","date":"2021-02-26 03:15:57","endLine":384,"groupId":"2714","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchAll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/32/490c97060d04c26dcdb9226941f1e0199ba6c0.src","preCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(0L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertThat(debug, hasEntry(\"specialized_for\", \"match_all\"));\n            assertThat((int) debug.get(\"results_from_metadata\"), greaterThan(0));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"B"},{"authorDate":"2021-02-26 03:15:57","commitOrder":1,"curCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(10L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertThat(debug, hasEntry(\"specialized_for\", \"match_all\"));\n            assertThat(debug, hasEntry(\"results_from_metadata\", 0));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n            }\n        );\n    }\n","date":"2021-02-26 03:15:57","endLine":410,"groupId":"4639","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMatchAllWithDocCount","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/32/490c97060d04c26dcdb9226941f1e0199ba6c0.src","preCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(10L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertThat(debug, hasEntry(\"specialized_for\", \"match_all\"));\n            assertThat(debug, hasEntry(\"results_from_metadata\", 0));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":386,"status":"B"}],"commitId":"4ffdad36d422258f0042f08cab88cb2c4c922738","commitMessage":"@@@Speed up terms agg when alone (#69377)\n\nThis speeds up the `terms` agg in a very specific case:\n1. It has no child aggregations\n2. It has no parent aggregations\n3. There are no deleted documents\n4. You are not using document level security\n5. There is no top level query\n6. The field has global ordinals\n7. There are less than one thousand distinct terms\n\nThat is a lot of restirctions! But the speed up pretty substantial because\nin those cases we can serve the entire aggregation using metadata that\nlucene precomputes while it builds the index. In a real rally track we\nhave we get a 92% speed improvement.  but the index isn't *that* big:\n\n```\n| 90th percentile service time | keyword-terms-low-cardinality |     446.031 |     36.7677 | -409.263 |     ms |\n```\n\nIn a rally track with a larger index I ran some tests by hand and the\naggregation went from 2200ms to 8ms.\n\nEven though there are 7 restrictions on this.  I expect it to come into\nplay enough to matter. Restriction 6 just means you are aggregating on\na `keyword` field. Or an `ip`. And its fairly common for `keyword`s to\nhave less than a thousand distinct values. Certainly not everywhere.  but\nsome places.\n\nI expect \"cold tier\" indices are very very likely not to have deleted\ndocuments at all. And the optimization works segment by segment - so\nit'll save some time on each segment without deleted documents. But more\ntime if the entire index doesn't have any.\n\nThe optimization builds on #68871 which translates `terms` aggregations\nagainst low cardinality fields with global ordinals into a `filters`\naggregation. This teaches the `filters` aggregation to recognize when\nit can get its results from the index metadata. Rather.  it creates the\ninfrastructure to make that fairly simple and applies it in the case of\nthe queries generated by the terms aggregation.\n","date":"2021-02-26 03:15:57","modifiedFileCount":"8","status":"B","submitter":"Nik Everett"},{"authorTime":"2021-06-07 17:00:50","codes":[{"authorDate":"2021-06-07 17:00:50","commitOrder":2,"curCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(0L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertMap(debug, matchesMap().extraOk().entry(\"specialized_for\", \"match_all\").entry(\"results_from_metadata\", greaterThan(0)));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n            }\n        );\n    }\n","date":"2021-06-07 17:00:50","endLine":466,"groupId":"2714","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchAll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5e/0a8a7a2051a92a0e9b10259e5edbe1ac8c690e.src","preCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(0L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertThat(debug, hasEntry(\"specialized_for\", \"match_all\"));\n            assertThat((int) debug.get(\"results_from_metadata\"), greaterThan(0));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":443,"status":"M"},{"authorDate":"2021-06-07 17:00:50","commitOrder":2,"curCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(10L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertMap(debug, matchesMap().extraOk().entry(\"specialized_for\", \"match_all\").entry(\"results_from_metadata\", 0));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n            }\n        );\n    }\n","date":"2021-06-07 17:00:50","endLine":491,"groupId":"4639","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMatchAllWithDocCount","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5e/0a8a7a2051a92a0e9b10259e5edbe1ac8c690e.src","preCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(10L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertThat(debug, hasEntry(\"specialized_for\", \"match_all\"));\n            assertThat(debug, hasEntry(\"results_from_metadata\", 0));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":468,"status":"M"}],"commitId":"9cbc5f7e8fd4a73255d4ed35d4935410b52b9bcd","commitMessage":"@@@Merge branch 'master' into feature/vector-tiles\n","date":"2021-06-07 17:00:50","modifiedFileCount":"192","status":"M","submitter":"iverase"},{"authorTime":"2021-06-24 20:56:01","codes":[{"authorDate":"2021-06-24 20:56:01","commitOrder":3,"curCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", 1)\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 1)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","date":"2021-06-24 20:56:01","endLine":469,"groupId":"47207","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchAll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/a0a7373cf97b0d11246afaa81af7603b52d192.src","preCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(0L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertMap(debug, matchesMap().extraOk().entry(\"specialized_for\", \"match_all\").entry(\"results_from_metadata\", greaterThan(0)));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"M"},{"authorDate":"2021-06-24 20:56:01","commitOrder":3,"curCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", 1)\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", 1)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 0)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","date":"2021-06-24 20:56:01","endLine":507,"groupId":"47207","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testMatchAllWithDocCount","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/5d/a0a7373cf97b0d11246afaa81af7603b52d192.src","preCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        withAggregator(builder, new MatchAllDocsQuery(), buildIndex, (searcher, aggregator) -> {\n            assertThat(aggregator, instanceOf(FiltersAggregator.FilterByFilter.class));\n            \r\n            assertThat(((FiltersAggregator.FilterByFilter) aggregator).estimateCost(Long.MAX_VALUE), equalTo(10L));\n            Map<String, Object> debug = collectAndGetFilterDebugInfo(searcher, aggregator);\n            assertMap(debug, matchesMap().extraOk().entry(\"specialized_for\", \"match_all\").entry(\"results_from_metadata\", 0));\n        });\n        testCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters result) -> {\n                assertThat(result.getBuckets(), hasSize(1));\n                assertThat(result.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":471,"status":"M"}],"commitId":"a5af44d413b7a17395ee3dc5c47fdbad88fb270d","commitMessage":"@@@Disable optimization if we aren't sure its faster (#74260)\n\nThis disables the filter-by-filter aggregation optimization used by\n`terms`.  `range`.  `date_histogram`.  and `date_range` aggregations unless\nwe're *sure* that its faster than the \"native\" implementation. Mostly this\nis when the top level query is empty or we can merge it into the filter\ngenerated by the agg rewrite process.\n\nNow that we have hard and fast rules we can drop the cost estimation\nframework without too much fear. So we remove it in this change. It\nstomps a bunch of complexity. Sadly.  without the cost estimation stuff\nwe have to add a separate mechanism for blocking the optimization\nagainst runtime fields for which it'd be kind of garbage. For that I\nadded another rule preventing the filter-by-filter aggregation from\nrunning against the queries made by runtime fields. Its not fool-proof. \nbut we have control over what queries we pass as a filter so its not\nwide open.\n\nI spent a lot of time working on an alternative to this that preserved\nthat fancy filter-by-filter collection mechanism and was much more kind\nto the query cache. It detected cases where going full filter-by-filter\nwas bad and grouped those filters together to collect in one pass with a\nfunny ORing collector. It *worked*. And.  if we were super concerned with\nthe performance of the `filters` aggregation it'd be the way to go. But\nit was very complex and it was actually slower than using the native\naggregation for things like `terms` and `date_histogram`. It was\nglorious. But it was wrong for us. Too complex and optimized the wrong\nthings.\n\nSo here we are. Hopefully this is a fairly simple solution to a sneaky\nproblem.\n","date":"2021-06-24 20:56:01","modifiedFileCount":"19","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-07-01 00:19:26","codes":[{"authorDate":"2021-07-01 00:19:26","commitOrder":4,"curCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 1)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","date":"2021-07-01 00:19:26","endLine":470,"groupId":"47207","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchAll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b5/60445cf7d5422b02dc6db5a77c9ed256da3b21.src","preCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", 1)\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 1)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":434,"status":"M"},{"authorDate":"2021-07-01 00:19:26","commitOrder":4,"curCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 0)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","date":"2021-07-01 00:19:26","endLine":508,"groupId":"47207","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testMatchAllWithDocCount","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b5/60445cf7d5422b02dc6db5a77c9ed256da3b21.src","preCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", 1)\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", 1)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 0)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":472,"status":"M"}],"commitId":"bdd62d76c3a7d017d80adf47bb2221659bee2735","commitMessage":"@@@Fix aggs test failures (#74750)\n\nThe tests for the debugging information in the filters aggregation where\ntoo specific for the kind of randomization we run with. They asserted\nthat the indices contained only a single segment which is *usually*\ntrue.  but our test randomization framework sometimes emit many segmented\nindices.  just to exercise the code. That's a good thing. But the tests\nhad a wrong assertion. This swaps the assertion from `equalTo(1)` to\n`greaterThanOrEqualTo(1)`.\n\nCloses #74677\n","date":"2021-07-01 00:19:26","modifiedFileCount":"1","status":"M","submitter":"Nik Everett"},{"authorTime":"2021-07-01 00:19:26","codes":[{"authorDate":"2021-07-07 02:22:44","commitOrder":5,"curCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", greaterThanOrEqualTo(1))\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","date":"2021-07-07 02:22:44","endLine":470,"groupId":"105208","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchAll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/07/5e177fab3fe6c3d68e5588c8ec81276bee9402.src","preCode":"    public void testMatchAll() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of());\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(10L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", 0)\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 1)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":434,"status":"M"},{"authorDate":"2021-07-01 00:19:26","commitOrder":5,"curCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 0)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","date":"2021-07-01 00:19:26","endLine":508,"groupId":"105208","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testMatchAllWithDocCount","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/b5/60445cf7d5422b02dc6db5a77c9ed256da3b21.src","preCode":"    public void testMatchAllWithDocCount() throws IOException {\n        AggregationBuilder builder = new FiltersAggregationBuilder(\"test\", new KeyedFilter(\"q1\", new MatchAllQueryBuilder()));\n        CheckedConsumer<RandomIndexWriter, IOException> buildIndex = iw -> {\n            for (int i = 0; i < 10; i++) {\n                iw.addDocument(List.of(new CustomTermFreqField(DocCountFieldMapper.NAME, DocCountFieldMapper.NAME, i + 1)));\n            }\n        };\n        debugTestCase(\n            builder,\n            new MatchAllDocsQuery(),\n            buildIndex,\n            (InternalFilters filters, Class<? extends Aggregator> impl, Map<String, Map<String, Object>> debug) -> {\n                assertThat(filters.getBuckets(), hasSize(1));\n                assertThat(filters.getBucketByKey(\"q1\").getDocCount(), equalTo(55L));\n\n                assertThat(impl, equalTo(FilterByFilterAggregator.class));\n                assertMap(\n                    debug,\n                    matchesMap().entry(\n                        \"test\",\n                        matchesMap().entry(\"segments_counted\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_collected\", 0)\n                            .entry(\"segments_with_doc_count_field\", greaterThanOrEqualTo(1))\n                            .entry(\"segments_with_deleted_docs\", 0)\n                            .entry(\n                                \"filters\",\n                                matchesList().item(\n                                    matchesMap().entry(\"query\", \"*:*\")\n                                        .entry(\"specialized_for\", \"match_all\")\n                                        .entry(\"results_from_metadata\", 0)\n                                )\n                            )\n                    )\n                );\n            }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/filter/FiltersAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":472,"status":"N"}],"commitId":"cbcc219b869897ee2413931a7dcac496cf1f8381","commitMessage":"@@@Fix aggs test failures (again) (#74965)\n\nThe tests for the debugging information in the filters aggregation where\ntoo specific for the kind of randomization we run with. We mostly fixed\nthem in #74750 by replacing `equalTo(1)` with `greaterThanOrEqualTo(1)`.\nBut we missed a spot. In all fairness.  we ran the test a couple thousand\ntimes and it didn't fail. But letting the ES build chew on it gets many\nmany many thousands of executions over a month. So it found the spot.\nThis performs one additional `equalTo(1)` to `greaterThanOrEqualTo(1)`\nreplacement.\n\nCloses #74936","date":"2021-07-07 02:22:44","modifiedFileCount":"1","status":"M","submitter":"Nik Everett"}]
