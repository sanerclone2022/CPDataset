[{"authorTime":"2018-04-26 03:22:53","codes":[{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testRebalancingNotAllowedDueToCanAllocate() {\n        AllocationDecider canAllocateDecider = new AllocationDecider(Settings.EMPTY) {\n            @Override\n            public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                return Decision.NO;\n            }\n        };\n        Tuple<ClusterState, MoveDecision> rebalance = setupStateAndRebalance(canAllocateDecider, Settings.EMPTY, false);\n        ClusterState clusterState = rebalance.v1();\n        MoveDecision rebalanceDecision = rebalance.v2();\n        assertEquals(Type.YES, rebalanceDecision.getClusterRebalanceDecision().type());\n        assertEquals(AllocationDecision.NO, rebalanceDecision.getAllocationDecision());\n        assertThat(rebalanceDecision.getExplanation(), startsWith(\n            \"cannot rebalance as no target node exists that can both allocate this shard and improve the cluster balance\"));\n        assertEquals(clusterState.nodes().getSize() - 1, rebalanceDecision.getNodeDecisions().size());\n        assertNull(rebalanceDecision.getTargetNode());\n        int prevRanking = 0;\n        for (NodeAllocationResult result : rebalanceDecision.getNodeDecisions()) {\n            assertThat(result.getWeightRanking(), greaterThanOrEqualTo(prevRanking));\n            prevRanking = result.getWeightRanking();\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":150,"groupId":"58631","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRebalancingNotAllowedDueToCanAllocate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/40/5f459e99a399acca5fa791ef63b66a2ec2b51f.src","preCode":"    public void testRebalancingNotAllowedDueToCanAllocate() {\n        AllocationDecider canAllocateDecider = new AllocationDecider(Settings.EMPTY) {\n            @Override\n            public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                return Decision.NO;\n            }\n        };\n        Tuple<ClusterState, MoveDecision> rebalance = setupStateAndRebalance(canAllocateDecider, Settings.EMPTY, false);\n        ClusterState clusterState = rebalance.v1();\n        MoveDecision rebalanceDecision = rebalance.v2();\n        assertEquals(Type.YES, rebalanceDecision.getClusterRebalanceDecision().type());\n        assertEquals(AllocationDecision.NO, rebalanceDecision.getAllocationDecision());\n        assertThat(rebalanceDecision.getExplanation(), startsWith(\n            \"cannot rebalance as no target node exists that can both allocate this shard and improve the cluster balance\"));\n        assertEquals(clusterState.nodes().getSize() - 1, rebalanceDecision.getNodeDecisions().size());\n        assertNull(rebalanceDecision.getTargetNode());\n        int prevRanking = 0;\n        for (NodeAllocationResult result : rebalanceDecision.getNodeDecisions()) {\n            assertThat(result.getWeightRanking(), greaterThanOrEqualTo(prevRanking));\n            prevRanking = result.getWeightRanking();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/BalancedSingleShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"B"},{"authorDate":"2018-04-26 03:22:53","commitOrder":1,"curCode":"    public void testDontBalanceShardWhenThresholdNotMet() {\n        AllocationDecider canAllocateDecider = new AllocationDecider(Settings.EMPTY) {\n            @Override\n            public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                return Decision.YES;\n            }\n        };\n        \r\n        Settings balancerSettings = Settings.builder().put(BalancedShardsAllocator.THRESHOLD_SETTING.getKey(), 1000f).build();\n        Tuple<ClusterState, MoveDecision> rebalance = setupStateAndRebalance(canAllocateDecider, balancerSettings, false);\n        ClusterState clusterState = rebalance.v1();\n        MoveDecision rebalanceDecision = rebalance.v2();\n        assertEquals(Type.YES, rebalanceDecision.getClusterRebalanceDecision().type());\n        assertEquals(AllocationDecision.NO, rebalanceDecision.getAllocationDecision());\n        assertNotNull(rebalanceDecision.getExplanation());\n        assertEquals(clusterState.nodes().getSize() - 1, rebalanceDecision.getNodeDecisions().size());\n        assertNull(rebalanceDecision.getTargetNode());\n        int prevRanking = 0;\n        for (NodeAllocationResult result : rebalanceDecision.getNodeDecisions()) {\n            assertThat(result.getWeightRanking(), greaterThanOrEqualTo(prevRanking));\n            prevRanking = result.getWeightRanking();\n        }\n    }\n","date":"2018-04-26 03:22:53","endLine":174,"groupId":"58631","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testDontBalanceShardWhenThresholdNotMet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/40/5f459e99a399acca5fa791ef63b66a2ec2b51f.src","preCode":"    public void testDontBalanceShardWhenThresholdNotMet() {\n        AllocationDecider canAllocateDecider = new AllocationDecider(Settings.EMPTY) {\n            @Override\n            public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                return Decision.YES;\n            }\n        };\n        \r\n        Settings balancerSettings = Settings.builder().put(BalancedShardsAllocator.THRESHOLD_SETTING.getKey(), 1000f).build();\n        Tuple<ClusterState, MoveDecision> rebalance = setupStateAndRebalance(canAllocateDecider, balancerSettings, false);\n        ClusterState clusterState = rebalance.v1();\n        MoveDecision rebalanceDecision = rebalance.v2();\n        assertEquals(Type.YES, rebalanceDecision.getClusterRebalanceDecision().type());\n        assertEquals(AllocationDecision.NO, rebalanceDecision.getAllocationDecision());\n        assertNotNull(rebalanceDecision.getExplanation());\n        assertEquals(clusterState.nodes().getSize() - 1, rebalanceDecision.getNodeDecisions().size());\n        assertNull(rebalanceDecision.getTargetNode());\n        int prevRanking = 0;\n        for (NodeAllocationResult result : rebalanceDecision.getNodeDecisions()) {\n            assertThat(result.getWeightRanking(), greaterThanOrEqualTo(prevRanking));\n            prevRanking = result.getWeightRanking();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/BalancedSingleShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"B"}],"commitId":"d74fb9eb4559077e2d20b19a9ed62d9ff825027a","commitMessage":"@@@Opened x-pack ILM code\n","date":"2018-04-26 03:22:53","modifiedFileCount":"0","status":"B","submitter":"Tal Levy"},{"authorTime":"2018-11-02 00:05:41","codes":[{"authorDate":"2018-11-02 00:05:41","commitOrder":2,"curCode":"    public void testRebalancingNotAllowedDueToCanAllocate() {\n        AllocationDecider canAllocateDecider = new AllocationDecider() {\n            @Override\n            public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                return Decision.NO;\n            }\n        };\n        Tuple<ClusterState, MoveDecision> rebalance = setupStateAndRebalance(canAllocateDecider, Settings.EMPTY, false);\n        ClusterState clusterState = rebalance.v1();\n        MoveDecision rebalanceDecision = rebalance.v2();\n        assertEquals(Type.YES, rebalanceDecision.getClusterRebalanceDecision().type());\n        assertEquals(AllocationDecision.NO, rebalanceDecision.getAllocationDecision());\n        assertThat(rebalanceDecision.getExplanation(), startsWith(\n            \"cannot rebalance as no target node exists that can both allocate this shard and improve the cluster balance\"));\n        assertEquals(clusterState.nodes().getSize() - 1, rebalanceDecision.getNodeDecisions().size());\n        assertNull(rebalanceDecision.getTargetNode());\n        int prevRanking = 0;\n        for (NodeAllocationResult result : rebalanceDecision.getNodeDecisions()) {\n            assertThat(result.getWeightRanking(), greaterThanOrEqualTo(prevRanking));\n            prevRanking = result.getWeightRanking();\n        }\n    }\n","date":"2018-11-02 01:13:02","endLine":150,"groupId":"102148","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRebalancingNotAllowedDueToCanAllocate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/a7fa47025d63b6d6d65a606b6cdb4ab38c1aee.src","preCode":"    public void testRebalancingNotAllowedDueToCanAllocate() {\n        AllocationDecider canAllocateDecider = new AllocationDecider(Settings.EMPTY) {\n            @Override\n            public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                return Decision.NO;\n            }\n        };\n        Tuple<ClusterState, MoveDecision> rebalance = setupStateAndRebalance(canAllocateDecider, Settings.EMPTY, false);\n        ClusterState clusterState = rebalance.v1();\n        MoveDecision rebalanceDecision = rebalance.v2();\n        assertEquals(Type.YES, rebalanceDecision.getClusterRebalanceDecision().type());\n        assertEquals(AllocationDecision.NO, rebalanceDecision.getAllocationDecision());\n        assertThat(rebalanceDecision.getExplanation(), startsWith(\n            \"cannot rebalance as no target node exists that can both allocate this shard and improve the cluster balance\"));\n        assertEquals(clusterState.nodes().getSize() - 1, rebalanceDecision.getNodeDecisions().size());\n        assertNull(rebalanceDecision.getTargetNode());\n        int prevRanking = 0;\n        for (NodeAllocationResult result : rebalanceDecision.getNodeDecisions()) {\n            assertThat(result.getWeightRanking(), greaterThanOrEqualTo(prevRanking));\n            prevRanking = result.getWeightRanking();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/BalancedSingleShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2018-11-02 00:05:41","commitOrder":2,"curCode":"    public void testDontBalanceShardWhenThresholdNotMet() {\n        AllocationDecider canAllocateDecider = new AllocationDecider() {\n            @Override\n            public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                return Decision.YES;\n            }\n        };\n        \r\n        Settings balancerSettings = Settings.builder().put(BalancedShardsAllocator.THRESHOLD_SETTING.getKey(), 1000f).build();\n        Tuple<ClusterState, MoveDecision> rebalance = setupStateAndRebalance(canAllocateDecider, balancerSettings, false);\n        ClusterState clusterState = rebalance.v1();\n        MoveDecision rebalanceDecision = rebalance.v2();\n        assertEquals(Type.YES, rebalanceDecision.getClusterRebalanceDecision().type());\n        assertEquals(AllocationDecision.NO, rebalanceDecision.getAllocationDecision());\n        assertNotNull(rebalanceDecision.getExplanation());\n        assertEquals(clusterState.nodes().getSize() - 1, rebalanceDecision.getNodeDecisions().size());\n        assertNull(rebalanceDecision.getTargetNode());\n        int prevRanking = 0;\n        for (NodeAllocationResult result : rebalanceDecision.getNodeDecisions()) {\n            assertThat(result.getWeightRanking(), greaterThanOrEqualTo(prevRanking));\n            prevRanking = result.getWeightRanking();\n        }\n    }\n","date":"2018-11-02 01:13:02","endLine":174,"groupId":"102148","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testDontBalanceShardWhenThresholdNotMet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/e4/a7fa47025d63b6d6d65a606b6cdb4ab38c1aee.src","preCode":"    public void testDontBalanceShardWhenThresholdNotMet() {\n        AllocationDecider canAllocateDecider = new AllocationDecider(Settings.EMPTY) {\n            @Override\n            public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n                return Decision.YES;\n            }\n        };\n        \r\n        Settings balancerSettings = Settings.builder().put(BalancedShardsAllocator.THRESHOLD_SETTING.getKey(), 1000f).build();\n        Tuple<ClusterState, MoveDecision> rebalance = setupStateAndRebalance(canAllocateDecider, balancerSettings, false);\n        ClusterState clusterState = rebalance.v1();\n        MoveDecision rebalanceDecision = rebalance.v2();\n        assertEquals(Type.YES, rebalanceDecision.getClusterRebalanceDecision().type());\n        assertEquals(AllocationDecision.NO, rebalanceDecision.getAllocationDecision());\n        assertNotNull(rebalanceDecision.getExplanation());\n        assertEquals(clusterState.nodes().getSize() - 1, rebalanceDecision.getNodeDecisions().size());\n        assertNull(rebalanceDecision.getTargetNode());\n        int prevRanking = 0;\n        for (NodeAllocationResult result : rebalanceDecision.getNodeDecisions()) {\n            assertThat(result.getWeightRanking(), greaterThanOrEqualTo(prevRanking));\n            prevRanking = result.getWeightRanking();\n        }\n    }\n","realPath":"server/src/test/java/org/elasticsearch/cluster/routing/allocation/BalancedSingleShardTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"}],"commitId":"c3cf7dd305b3d4636405c292659dbff05307f146","commitMessage":"@@@Merge remote-tracking branch 'upstream/master' into index-lifecycle\n","date":"2018-11-02 01:13:02","modifiedFileCount":"456","status":"M","submitter":"Tal Levy"}]
