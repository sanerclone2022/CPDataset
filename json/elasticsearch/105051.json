[{"authorTime":"2019-01-23 01:38:55","codes":[{"authorDate":"2019-01-23 01:38:55","commitOrder":1,"curCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),\n                histogram -> {\n                    assertEquals(0, histogram.getBuckets().size());\n                    assertFalse(AggregationInspectionHelper.hasValue(histogram));\n                }\n        );\n    }\n","date":"2019-01-23 01:38:55","endLine":70,"groupId":"4728","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchNoDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c1/b9396664a228e520a3222e7ebdd3653afa2ad4.src","preCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),\n                histogram -> {\n                    assertEquals(0, histogram.getBuckets().size());\n                    assertFalse(AggregationInspectionHelper.hasValue(histogram));\n                }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"B"},{"authorDate":"2019-01-23 01:38:55","commitOrder":1,"curCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n                histogram -> {\n                    assertEquals(0, histogram.getBuckets().size());\n                    assertFalse(AggregationInspectionHelper.hasValue(histogram));\n                }\n        );\n    }\n","date":"2019-01-23 01:38:55","endLine":123,"groupId":"8728","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testAggregateWrongField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/c1/b9396664a228e520a3222e7ebdd3653afa2ad4.src","preCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n                histogram -> {\n                    assertEquals(0, histogram.getBuckets().size());\n                    assertFalse(AggregationInspectionHelper.hasValue(histogram));\n                }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"B"}],"commitId":"2ba9e361aba7df6e9c0b5fa8fae3d219d50ddf09","commitMessage":"@@@Add helper classes to determine if aggs have a value (#36020)\n\nThis adds a set of helper classes to determine if an agg \"has a value\". \nThis is needed because InternalAggs represent \"empty\" in different \nmanners according to convention. Some use `NaN`.  `+/- Inf`.  `0.0`.  etc.\n\nA user can pass the Internal agg type to one of these helper methods\nand it will report if the agg contains a value or not.  which allows the\nuser to differentiate \"empty\" from a real `NaN`.\n\nThese helpers are best-effort in some cases.  For example.  several\npipeline aggs share a single return class but use different conventions\nto mark \"empty\".  so the helper uses the loosest definition that applies\nto all the aggs that use the class.\n\nSums in particular are unreliable.  The InternalSum simply returns 0.0\nif the agg is empty (which is correct.  no values == sum of zero).  But this\nalso means the helper cannot differentiate from \"empty\" and `+1 + -1`.","date":"2019-01-23 01:38:55","modifiedFileCount":"45","status":"B","submitter":"Zachary Tong"},{"authorTime":"2019-05-07 05:17:11","codes":[{"authorDate":"2019-05-07 05:17:11","commitOrder":2,"curCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),\n            histogram -> assertEquals(0, histogram.getBuckets().size())\n        );\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(DATE_FIELD),\n            histogram -> assertEquals(0, histogram.getBuckets().size())\n        );\n    }\n","date":"2019-05-07 05:17:11","endLine":87,"groupId":"4728","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchNoDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f6/71b21eb5e9b0c49e60b194b419f18b022ac45b.src","preCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),\n                histogram -> {\n                    assertEquals(0, histogram.getBuckets().size());\n                    assertFalse(AggregationInspectionHelper.hasValue(histogram));\n                }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"},{"authorDate":"2019-05-07 05:17:11","commitOrder":2,"curCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size())\n        );\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size())\n        );\n    }\n","date":"2019-05-07 05:17:11","endLine":215,"groupId":"8728","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testAggregateWrongField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/f6/71b21eb5e9b0c49e60b194b419f18b022ac45b.src","preCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n                aggregation -> aggregation.dateHistogramInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n                histogram -> {\n                    assertEquals(0, histogram.getBuckets().size());\n                    assertFalse(AggregationInspectionHelper.hasValue(histogram));\n                }\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"290c8b8256fc4da512e7bbe1c727005c21d55a67","commitMessage":"@@@Force selection of calendar or fixed intervals in date histo agg (#33727)\n\nThe date_histogram accepts an interval which can be either a calendar \ninterval (DST-aware.  leap seconds.  arbitrary length of months.  etc) or \nfixed interval (strict multiples of SI units). Unfortunately this is inferred\nby first trying to parse as a calendar interval.  then falling back to fixed\nif that fails.\n\nThis leads to confusing arrangement where `1d` == calendar.  but \n`2d` == fixed.  And if you want a day of fixed time.  you have to \nspecify `24h` (e.g. the next smallest unit).  This arrangement is very\nerror-prone for users.\n\nThis PR adds `calendar_interval` and `fixed_interval` parameters to any\ncode that uses intervals (date_histogram.  rollup.  composite.  datafeed.  etc).\nCalendar only accepts calendar intervals.  fixed accepts any combination of\nunits (meaning `1d` can be used to specify `24h` in fixed time).  and both\nare mutually exclusive.  \n\nThe old interval behavior is deprecated and will throw a deprecation warning.\nIt is also mutually exclusive with the two new parameters. In the future the \nold dual-purpose interval will be removed.\n\nThe change applies to both REST and java clients.\n\n","date":"2019-05-07 05:17:11","modifiedFileCount":"51","status":"M","submitter":"Zachary Tong"},{"authorTime":"2019-08-27 02:21:42","codes":[{"authorDate":"2019-08-27 02:21:42","commitOrder":3,"curCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(DATE_FIELD),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","date":"2019-08-27 02:21:42","endLine":87,"groupId":"4728","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchNoDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4e/ba98dd49b9d8dea544775cf1e520575222b1ff.src","preCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),\n            histogram -> assertEquals(0, histogram.getBuckets().size())\n        );\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(DATE_FIELD),\n            histogram -> assertEquals(0, histogram.getBuckets().size())\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":78,"status":"M"},{"authorDate":"2019-08-27 02:21:42","commitOrder":3,"curCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","date":"2019-08-27 02:21:42","endLine":215,"groupId":"8728","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testAggregateWrongField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4e/ba98dd49b9d8dea544775cf1e520575222b1ff.src","preCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size())\n        );\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size())\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"1a0dddf4ad24b3f2c751a1fe0e024fdbf8754f94","commitMessage":"@@@Range Field support for Histogram and Date Histogram aggregations(#45395)\n\n * Add support for a Range field ValuesSource.  including decode logic for range doc values and exposing RangeType as a first class enum\n * Provide hooks in ValuesSourceConfig for aggregations to control ValuesSource class selection on missing & script values\n * Branch aggregator creation in Histogram and DateHistogram based on ValuesSource class.  to enable specialization based on type.  This is similar to how Terms aggregator works.\n * Prioritize field type when available for selecting the ValuesSource class type to use for an aggregation\n\n","date":"2019-08-27 02:21:42","modifiedFileCount":"44","status":"M","submitter":"Mark Tozzi"},{"authorTime":"2019-08-27 02:21:42","codes":[{"authorDate":"2020-05-07 19:22:32","commitOrder":4,"curCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","date":"2020-05-07 19:22:32","endLine":97,"groupId":"4728","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchNoDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/98/a58adfed6f2db5530932118b338a533b80315d.src","preCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(DATE_FIELD),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(DATE_FIELD),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"M"},{"authorDate":"2019-08-27 02:21:42","commitOrder":4,"curCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","date":"2019-08-27 02:21:42","endLine":215,"groupId":"8728","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testAggregateWrongField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/4e/ba98dd49b9d8dea544775cf1e520575222b1ff.src","preCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"N"}],"commitId":"0097a86d5389d990387005d64a908777dcf61ff6","commitMessage":"@@@Optimize date_histograms across daylight savings time (#55559)\n\nRounding dates on a shard that contains a daylight savings time transition\nis currently something like 1400% slower than when a shard contains dates\nonly on one side of the DST transition. And it makes a ton of short lived\ngarbage. This replaces that implementation with one that benchmarks to\nhaving around 30% overhead instead of the 1400%. And it doesn't generate\nany garbage per search hit.\n\nSome background:\nThere are two ways to round in ES:\n* Round to the nearest time unit (Day/Hour/Week/Month/etc)\n* Round to the nearest time *interval* (3 days/2 weeks/etc)\n\nI'm only optimizing the first one in this change and plan to do the second\nin a follow up. It turns out that rounding to the nearest unit really *is*\ntwo problems: when the unit rounds to midnight (day/week/month/year) and\nwhen it doesn't (hour/minute/second). Rounding to midnight is consistently\nabout 25% faster and rounding to individual hour or minutes.\n\nThis optimization relies on being able to *usually* figure out what the\nminimum and maximum dates are on the shard. This is similar to an existing\noptimization where we rewrite time zones that aren't fixed\n(think America/New_York and its daylight savings time transitions) into\nfixed time zones so long as there isn't a daylight savings time transition\non the shard (UTC-5 or UTC-4 for America/New_York). Once I implement\ntime interval rounding the time zone rewriting optimization *should* no\nlonger be needed.\n\nThis optimization doesn't come into play for `composite` or\n`auto_date_histogram` aggs because neither have been migrated to the new\n`DATE` `ValuesSourceType` which is where that range lookup happens. When\nthey are they will be able to pick up the optimization without much work.\nI expect this to be substantial for `auto_date_histogram` but less so for\n`composite` because it deals with fewer values.\n\nNote: My 30% overhead figure comes from small numbers of daylight savings\ntime transitions. That overhead gets higher when there are more\ntransitions in logarithmic fashion. When there are two thousand years\nworth of transitions my algorithm ends up being 250% slower than rounding\nwithout a time zone.  but java time is 47000% slower at that point. \nallocating memory as fast as it possibly can.\n","date":"2020-05-07 19:22:32","modifiedFileCount":"19","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-05-20 01:48:25","codes":[{"authorDate":"2020-05-20 01:48:25","commitOrder":5,"curCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), DATASET,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchNoDocsQuery(), DATASET,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","date":"2020-05-20 01:48:25","endLine":105,"groupId":"4728","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchNoDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3d/ba9219ab182e44d9bfe6c1f1f0e90a511b07c5.src","preCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchNoDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"},{"authorDate":"2020-05-20 01:48:25","commitOrder":5,"curCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), DATASET,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchAllDocsQuery(), DATASET,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","date":"2020-05-20 01:48:25","endLine":308,"groupId":"8728","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testAggregateWrongField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/3d/ba9219ab182e44d9bfe6c1f1f0e90a511b07c5.src","preCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchAllDocsQuery(), dataset,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":299,"status":"M"}],"commitId":"bea2341c9e12a2d28e7efa1b0cd35f6ebfedc0db","commitMessage":"@@@Save memory when date_histogram is not on top (#56921)\n\nWhen `date_histogram` is a sub-aggregator it used to allocate a bunch of\nobjects for every one of it's parent's buckets. This uses the data\nstructures that we built in #55873 rework the `date_histogram`\naggregator instead of all of the allocation.\n\nPart of #56487","date":"2020-05-20 01:48:25","modifiedFileCount":"7","status":"M","submitter":"Nik Everett"},{"authorTime":"2020-08-07 05:14:20","codes":[{"authorDate":"2020-08-07 05:14:20","commitOrder":6,"curCode":"    public void testMatchNoDocs() throws IOException {\n        testSearchCase(new MatchNoDocsQuery(), DATASET,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testSearchCase(new MatchNoDocsQuery(), DATASET,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","date":"2020-08-07 05:14:20","endLine":89,"groupId":"105051","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testMatchNoDocs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d2/97d9fabc6139339ee1186ab355b5d85c4dbf7f.src","preCode":"    public void testMatchNoDocs() throws IOException {\n        testBothCases(new MatchNoDocsQuery(), DATASET,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchNoDocsQuery(), DATASET,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(AGGREGABLE_DATE),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2020-08-07 05:14:20","commitOrder":6,"curCode":"    public void testAggregateWrongField() throws IOException {\n        testSearchCase(new MatchAllDocsQuery(), DATASET,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testSearchCase(new MatchAllDocsQuery(), DATASET,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","date":"2020-08-07 05:14:20","endLine":243,"groupId":"105051","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testAggregateWrongField","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-elasticsearch-10-0.7/blobInfo/CC_OUT/blobs/d2/97d9fabc6139339ee1186ab355b5d85c4dbf7f.src","preCode":"    public void testAggregateWrongField() throws IOException {\n        testBothCases(new MatchAllDocsQuery(), DATASET,\n            aggregation -> aggregation.calendarInterval(DateHistogramInterval.YEAR).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n        testBothCases(new MatchAllDocsQuery(), DATASET,\n            aggregation -> aggregation.fixedInterval(new DateHistogramInterval(\"365d\")).field(\"wrong_field\"),\n            histogram -> assertEquals(0, histogram.getBuckets().size()), false\n        );\n    }\n","realPath":"server/src/test/java/org/elasticsearch/search/aggregations/bucket/histogram/DateHistogramAggregatorTests.java","repoName":"elasticsearch","snippetEndLine":0,"snippetStartLine":0,"startLine":234,"status":"M"}],"commitId":"5e3ea6eb11c68bdcc9adda51715a6e1fea9186d6","commitMessage":"@@@Merge branch 'master' into feature/runtime_fields\n","date":"2020-08-07 05:14:20","modifiedFileCount":"73","status":"M","submitter":"Nik Everett"}]
