[{"authorTime":"2019-04-10 22:28:13","codes":[{"authorDate":"2019-04-02 18:05:29","commitOrder":5,"curCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        boolean processOverflow = false;\n                        do {\n                            boolean useOverflow = false;\n                            if (processOverflow) {\n                                useOverflow = true;\n                            }\n                            processOverflow = false;\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (useOverflow) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    processOverflow = true;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0) || processOverflow); \r\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","date":"2019-04-02 18:05:29","endLine":1128,"groupId":"9243","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(finalByteBuffer[]dsts@finalintoffset@finalintlength@finallongtimeout@finalTimeUnitunit@finalAattachment@finalCompletionHandler<Long@?superA>handler)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/61/ed2532531bd8463e8ac6db38b9cd6d9be06b0a.src","preCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        boolean processOverflow = false;\n                        do {\n                            boolean useOverflow = false;\n                            if (processOverflow) {\n                                useOverflow = true;\n                            }\n                            processOverflow = false;\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (useOverflow) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    processOverflow = true;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0) || processOverflow); \r\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":987,"status":"NB"},{"authorDate":"2019-04-10 22:28:13","commitOrder":5,"curCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if ( closing || closed) return -1;\n        \r\n        if (!handshakeComplete) throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) return -1;\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        boolean processOverflow = false;\n        do {\n            boolean useOverflow = false;\n            if (processOverflow) {\n                useOverflow = true;\n            }\n            processOverflow = false;\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (useOverflow) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        processOverflow = true;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while (netInBuffer.position() != 0 || processOverflow); \r\n        return read;\n    }\n","date":"2019-04-10 22:28:13","endLine":735,"groupId":"5849","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(ByteBuffer[]dsts@intoffset@intlength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/37/bcc1fcaded34ae68a8b0884c8aeaf1ff8932c6.src","preCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if ( closing || closed) return -1;\n        \r\n        if (!handshakeComplete) throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) return -1;\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        boolean processOverflow = false;\n        do {\n            boolean useOverflow = false;\n            if (processOverflow) {\n                useOverflow = true;\n            }\n            processOverflow = false;\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (useOverflow) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        processOverflow = true;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while (netInBuffer.position() != 0 || processOverflow); \r\n        return read;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":633,"status":"B"}],"commitId":"d58aa0849f6eda19720af61082f8b12254e841bb","commitMessage":"@@@Add vectoring for NIO\n\nThis is done by adding the ScatteringByteChannel and\nGatheringByteChannel in the main NioChannel. The read SSL code is the\nmost complex portion and is based on the latest version of the NIO2\nchannel.","date":"2019-04-10 22:28:13","modifiedFileCount":"2","status":"M","submitter":"remm"},{"authorTime":"2019-05-23 04:50:22","codes":[{"authorDate":"2019-04-02 18:05:29","commitOrder":6,"curCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        boolean processOverflow = false;\n                        do {\n                            boolean useOverflow = false;\n                            if (processOverflow) {\n                                useOverflow = true;\n                            }\n                            processOverflow = false;\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (useOverflow) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    processOverflow = true;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0) || processOverflow); \r\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","date":"2019-04-02 18:05:29","endLine":1128,"groupId":"9243","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(finalByteBuffer[]dsts@finalintoffset@finalintlength@finallongtimeout@finalTimeUnitunit@finalAattachment@finalCompletionHandler<Long@?superA>handler)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/61/ed2532531bd8463e8ac6db38b9cd6d9be06b0a.src","preCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        boolean processOverflow = false;\n                        do {\n                            boolean useOverflow = false;\n                            if (processOverflow) {\n                                useOverflow = true;\n                            }\n                            processOverflow = false;\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (useOverflow) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    processOverflow = true;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0) || processOverflow); \r\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":987,"status":"N"},{"authorDate":"2019-05-23 04:50:22","commitOrder":6,"curCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if (closing || closed) {\n            return -1;\n        }\n        \r\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) {\n            return -1;\n        }\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        boolean processOverflow = false;\n        do {\n            boolean useOverflow = false;\n            if (processOverflow) {\n                useOverflow = true;\n            }\n            processOverflow = false;\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (useOverflow) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        processOverflow = true;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while (netInBuffer.position() != 0 || processOverflow); \r\n        return read;\n    }\n","date":"2019-05-23 04:50:22","endLine":772,"groupId":"5849","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(ByteBuffer[]dsts@intoffset@intlength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/6f/32cf373764b845e3182723d064766e4abd4c76.src","preCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if ( closing || closed) return -1;\n        \r\n        if (!handshakeComplete) throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) return -1;\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        boolean processOverflow = false;\n        do {\n            boolean useOverflow = false;\n            if (processOverflow) {\n                useOverflow = true;\n            }\n            processOverflow = false;\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (useOverflow) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        processOverflow = true;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while (netInBuffer.position() != 0 || processOverflow); \r\n        return read;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":664,"status":"M"}],"commitId":"cbe9c72d78ddf450d19e7ffe846cdc328c337b0b","commitMessage":"@@@Code style\n\nThere's a lot of code in common in SecureNioXChannel.  so cleanup before\nlooking at it.","date":"2019-05-23 04:50:22","modifiedFileCount":"2","status":"M","submitter":"remm"},{"authorTime":"2020-03-04 23:05:00","codes":[{"authorDate":"2020-03-04 23:05:00","commitOrder":7,"curCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        OverflowState overflowState = OverflowState.NONE;\n                        do {\n                            if (overflowState == OverflowState.PROCESSING) {\n                                overflowState = OverflowState.DONE;\n                            }\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (overflowState == OverflowState.DONE) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    overflowState = OverflowState.PROCESSING;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                                overflowState != OverflowState.DONE);\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","date":"2020-03-04 23:06:46","endLine":1128,"groupId":"3132","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(finalByteBuffer[]dsts@finalintoffset@finalintlength@finallongtimeout@finalTimeUnitunit@finalAattachment@finalCompletionHandler<Long@?superA>handler)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/d3/a0b732eac588a0675a318b1029aae2eb57b03e.src","preCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        boolean processOverflow = false;\n                        do {\n                            boolean useOverflow = false;\n                            if (processOverflow) {\n                                useOverflow = true;\n                            }\n                            processOverflow = false;\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (useOverflow) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    processOverflow = true;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0) || processOverflow); \r\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":988,"status":"M"},{"authorDate":"2020-03-04 23:05:00","commitOrder":7,"curCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if (closing || closed) {\n            return -1;\n        }\n        \r\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) {\n            return -1;\n        }\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        OverflowState overflowState = OverflowState.NONE;\n        do {\n            if (overflowState == OverflowState.PROCESSING) {\n                overflowState = OverflowState.DONE;\n            }\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (overflowState == OverflowState.DONE) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        overflowState = OverflowState.PROCESSING;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                overflowState != OverflowState.DONE);\n        return read;\n    }\n","date":"2020-03-04 23:06:46","endLine":745,"groupId":"5849","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(ByteBuffer[]dsts@intoffset@intlength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/6c/f10fb5f974517466a0398ec50ce8d77bfb61fd.src","preCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if (closing || closed) {\n            return -1;\n        }\n        \r\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) {\n            return -1;\n        }\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        boolean processOverflow = false;\n        do {\n            boolean useOverflow = false;\n            if (processOverflow) {\n                useOverflow = true;\n            }\n            processOverflow = false;\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (useOverflow) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        processOverflow = true;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while (netInBuffer.position() != 0 || processOverflow); \r\n        return read;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":638,"status":"M"}],"commitId":"997f99a0a96a0c3c09a86bd8a5595d6c1f62cbfc","commitMessage":"@@@Additional fix for BZ 64192.\n\nhttps://bz.apache.org/bugzilla/show_bug.cgi?id=64192\nIt was noted during investigation of BZ 64192 that inconsistent values\nwere being returned for the number of bytes read.","date":"2020-03-04 23:06:46","modifiedFileCount":"2","status":"M","submitter":"Mark Thomas"},{"authorTime":"2020-03-04 23:05:00","codes":[{"authorDate":"2021-05-27 02:27:37","commitOrder":8,"curCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        OverflowState overflowState = OverflowState.NONE;\n                        do {\n                            if (overflowState == OverflowState.PROCESSING) {\n                                overflowState = OverflowState.DONE;\n                            }\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (overflowState == OverflowState.DONE) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                                    tasks();\n                                }\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    overflowState = OverflowState.PROCESSING;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                                overflowState != OverflowState.DONE);\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","date":"2021-05-27 02:27:58","endLine":1170,"groupId":"3132","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(finalByteBuffer[]dsts@finalintoffset@finalintlength@finallongtimeout@finalTimeUnitunit@finalAattachment@finalCompletionHandler<Long@?superA>handler)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/f0/e4bb7636cbf6ae39ef924f1e18bca99656884d.src","preCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        OverflowState overflowState = OverflowState.NONE;\n                        do {\n                            if (overflowState == OverflowState.PROCESSING) {\n                                overflowState = OverflowState.DONE;\n                            }\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (overflowState == OverflowState.DONE) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    overflowState = OverflowState.PROCESSING;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                                overflowState != OverflowState.DONE);\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1029,"status":"M"},{"authorDate":"2020-03-04 23:05:00","commitOrder":8,"curCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if (closing || closed) {\n            return -1;\n        }\n        \r\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) {\n            return -1;\n        }\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        OverflowState overflowState = OverflowState.NONE;\n        do {\n            if (overflowState == OverflowState.PROCESSING) {\n                overflowState = OverflowState.DONE;\n            }\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (overflowState == OverflowState.DONE) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        overflowState = OverflowState.PROCESSING;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                overflowState != OverflowState.DONE);\n        return read;\n    }\n","date":"2020-03-04 23:06:46","endLine":745,"groupId":"5849","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(ByteBuffer[]dsts@intoffset@intlength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/6c/f10fb5f974517466a0398ec50ce8d77bfb61fd.src","preCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if (closing || closed) {\n            return -1;\n        }\n        \r\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) {\n            return -1;\n        }\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        OverflowState overflowState = OverflowState.NONE;\n        do {\n            if (overflowState == OverflowState.PROCESSING) {\n                overflowState = OverflowState.DONE;\n            }\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (overflowState == OverflowState.DONE) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        overflowState = OverflowState.PROCESSING;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                overflowState != OverflowState.DONE);\n        return read;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":638,"status":"N"}],"commitId":"1bb4e9fcb1242819205724873142b0524dcd40f4","commitMessage":"@@@Code clean-up. Add braces to improve clarity\n\nAgain.  mainly to trigger CI to test configuration changes.","date":"2021-05-27 02:27:58","modifiedFileCount":"39","status":"M","submitter":"Mark Thomas"},{"authorTime":"2020-03-04 23:05:00","codes":[{"authorDate":"2021-07-27 23:26:05","commitOrder":9,"curCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        OverflowState overflowState = OverflowState.NONE;\n                        do {\n                            if (overflowState == OverflowState.PROCESSING) {\n                                overflowState = OverflowState.DONE;\n                            }\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (overflowState == OverflowState.DONE) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                                    tasks();\n                                }\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    overflowState = OverflowState.PROCESSING;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                                overflowState != OverflowState.DONE);\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","date":"2021-07-27 23:45:49","endLine":1170,"groupId":"12418","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(finalByteBuffer[]dsts@finalintoffset@finalintlength@finallongtimeout@finalTimeUnitunit@finalAattachment@finalCompletionHandler<Long@?superA>handler)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/f4/60304040b3609d9740cfab0e61b377cf77722b.src","preCode":"    public <A> void read(final ByteBuffer[] dsts, final int offset, final int length,\n            final long timeout, final TimeUnit unit, final A attachment,\n            final CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        \r\n                        long read = 0;\n                        \r\n                        SSLEngineResult unwrap;\n                        ByteBuffer[] dsts2 = dsts;\n                        int length2 = length;\n                        OverflowState overflowState = OverflowState.NONE;\n                        do {\n                            if (overflowState == OverflowState.PROCESSING) {\n                                overflowState = OverflowState.DONE;\n                            }\n                            \r\n                            netInBuffer.flip();\n                            \r\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts2, offset, length2);\n                            \r\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                \r\n                                read += unwrap.bytesProduced();\n                                if (overflowState == OverflowState.DONE) {\n                                    \r\n                                    read -= getBufHandler().getReadBuffer().position();\n                                }\n                                \r\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                                    tasks();\n                                }\n                                \r\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                \r\n                                \r\n                                break;\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                                \r\n                                \r\n                                \r\n                                ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                                boolean found = false;\n                                boolean resized = true;\n                                for (int i = 0; i < length2; i++) {\n                                    \r\n                                    \r\n                                    if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                        getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getBufHandler().getReadBuffer();\n                                        found = true;\n                                    } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                        getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                                        if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                            resized = false;\n                                        }\n                                        dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                                        found = true;\n                                    }\n                                }\n                                if (found) {\n                                    if (!resized) {\n                                        throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                                    }\n                                } else {\n                                    \r\n                                    dsts2 = new ByteBuffer[dsts.length + 1];\n                                    int dstOffset = 0;\n                                    for (int i = 0; i < dsts.length + 1; i++) {\n                                        if (i == offset + length) {\n                                            dsts2[i] = readBuffer;\n                                            dstOffset = -1;\n                                        } else {\n                                            dsts2[i] = dsts[i + dstOffset];\n                                        }\n                                    }\n                                    length2 = length + 1;\n                                    getBufHandler().configureReadBufferForWrite();\n                                    overflowState = OverflowState.PROCESSING;\n                                }\n                            } else if (unwrap.getStatus() == Status.CLOSED) {\n                                break;\n                            } else {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                                overflowState != OverflowState.DONE);\n                        int capacity = 0;\n                        final int endOffset = offset + length;\n                        for (int i = offset; i < endOffset; i++) {\n                            capacity += dsts[i].remaining();\n                        }\n                        if (capacity == 0) {\n                            unwrapBeforeRead = true;\n                        } else {\n                            unwrapBeforeRead = false;\n                        }\n                        \r\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (unwrapBeforeRead || netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1029,"status":"M"},{"authorDate":"2020-03-04 23:05:00","commitOrder":9,"curCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if (closing || closed) {\n            return -1;\n        }\n        \r\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) {\n            return -1;\n        }\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        OverflowState overflowState = OverflowState.NONE;\n        do {\n            if (overflowState == OverflowState.PROCESSING) {\n                overflowState = OverflowState.DONE;\n            }\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (overflowState == OverflowState.DONE) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        overflowState = OverflowState.PROCESSING;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                overflowState != OverflowState.DONE);\n        return read;\n    }\n","date":"2020-03-04 23:06:46","endLine":745,"groupId":"12418","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(ByteBuffer[]dsts@intoffset@intlength)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/6c/f10fb5f974517466a0398ec50ce8d77bfb61fd.src","preCode":"    public long read(ByteBuffer[] dsts, int offset, int length)\n            throws IOException {\n        \r\n        if (closing || closed) {\n            return -1;\n        }\n        \r\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n\n        \r\n        int netread = sc.read(netInBuffer);\n        \r\n        if (netread == -1) {\n            return -1;\n        }\n\n        \r\n        int read = 0;\n        \r\n        SSLEngineResult unwrap;\n        OverflowState overflowState = OverflowState.NONE;\n        do {\n            if (overflowState == OverflowState.PROCESSING) {\n                overflowState = OverflowState.DONE;\n            }\n            \r\n            netInBuffer.flip();\n            \r\n            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n            \r\n            netInBuffer.compact();\n\n            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                \r\n                read += unwrap.bytesProduced();\n                if (overflowState == OverflowState.DONE) {\n                    \r\n                    read -= getBufHandler().getReadBuffer().position();\n                }\n                \r\n                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n                    tasks();\n                }\n                \r\n                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                    break;\n                }\n            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW) {\n                if (read > 0) {\n                    \r\n                    \r\n                    \r\n                    break;\n                } else {\n                    ByteBuffer readBuffer = getBufHandler().getReadBuffer();\n                    boolean found = false;\n                    boolean resized = true;\n                    for (int i = 0; i < length; i++) {\n                        \r\n                        \r\n                        if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                            getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getBufHandler().getReadBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getBufHandler().getReadBuffer();\n                            found = true;\n                        } else if (getAppReadBufHandler() != null && dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                            getAppReadBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());\n                            if (dsts[offset + i] == getAppReadBufHandler().getByteBuffer()) {\n                                resized = false;\n                            }\n                            dsts[offset + i] = getAppReadBufHandler().getByteBuffer();\n                            found = true;\n                        }\n                    }\n                    if (found) {\n                        if (!resized) {\n                            throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                        }\n                    } else {\n                        \r\n                        ByteBuffer[] dsts2 = new ByteBuffer[dsts.length + 1];\n                        int dstOffset = 0;\n                        for (int i = 0; i < dsts.length + 1; i++) {\n                            if (i == offset + length) {\n                                dsts2[i] = readBuffer;\n                                dstOffset = -1;\n                            } else {\n                                dsts2[i] = dsts[i + dstOffset];\n                            }\n                        }\n                        dsts = dsts2;\n                        length++;\n                        getBufHandler().configureReadBufferForWrite();\n                        overflowState = OverflowState.PROCESSING;\n                    }\n                }\n            } else {\n                \r\n                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n            }\n        } while ((netInBuffer.position() != 0 || overflowState == OverflowState.PROCESSING) &&\n                overflowState != OverflowState.DONE);\n        return read;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":638,"status":"N"}],"commitId":"abd84d2096124a597e342897e0be25bbe8a03214","commitMessage":"@@@Fix redundant specification of type arguments warnings","date":"2021-07-27 23:45:49","modifiedFileCount":"13","status":"M","submitter":"Mark Thomas"}]
