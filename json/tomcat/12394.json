[{"authorTime":"2014-11-11 00:46:40","codes":[{"authorDate":"2014-11-11 00:46:40","commitOrder":1,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2014-11-11 00:46:40","endLine":1475,"groupId":"13886","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ac/598dd56f755e36a7c5c1d89d448f7ed6aae65a.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"B"},{"authorDate":"2014-11-11 00:46:40","commitOrder":1,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            synchronized (completionHandler) {\n                if (readPending) {\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","date":"2014-11-11 00:46:40","endLine":905,"groupId":"7171","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/9a/d3200cbda48d27d3b427787dc54751a1707c61.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            synchronized (completionHandler) {\n                if (readPending) {\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":844,"status":"B"}],"commitId":"b91a979f518dcb88a06b3ca5d9056f198a356562","commitMessage":"@@@Add common methods to SocketWrapperBase as abstract methods and rename\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1637929 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-11 00:46:40","modifiedFileCount":"7","status":"B","submitter":"Mark Emlyn David Thomas"},{"authorTime":"2014-11-11 00:47:25","codes":[{"authorDate":"2014-11-11 00:46:40","commitOrder":2,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2014-11-11 00:46:40","endLine":1475,"groupId":"13886","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ac/598dd56f755e36a7c5c1d89d448f7ed6aae65a.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"N"},{"authorDate":"2014-11-11 00:47:25","commitOrder":2,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            synchronized (completionHandlerRead) {\n                if (readPending) {\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","date":"2014-11-11 00:47:25","endLine":941,"groupId":"7171","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/74/aa40c856ea0211ffa5566f6eafc6e42a7ca36d.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            synchronized (completionHandler) {\n                if (readPending) {\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":880,"status":"M"}],"commitId":"8522410c493e279c814e6d11654924e9ac3c114a","commitMessage":"@@@Push write methods down to SocketWrapper for NIO2\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1637935 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-11 00:47:25","modifiedFileCount":"2","status":"M","submitter":"Mark Emlyn David Thomas"},{"authorTime":"2014-11-12 18:49:20","codes":[{"authorDate":"2014-11-11 00:46:40","commitOrder":3,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2014-11-11 00:46:40","endLine":1475,"groupId":"13886","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ac/598dd56f755e36a7c5c1d89d448f7ed6aae65a.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"N"},{"authorDate":"2014-11-12 18:49:20","commitOrder":3,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","date":"2014-11-12 18:49:20","endLine":941,"groupId":"7171","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/34/d488ac47d8531f5c5bbda1b3390eed51ee6451.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            synchronized (completionHandlerRead) {\n                if (readPending) {\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":880,"status":"M"}],"commitId":"d106268faf8fc2ffecee614e0a0a6bc0a1d9a854","commitMessage":"@@@Rename for readability and aignment with NIO AJP impl\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1638752 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-12 18:49:20","modifiedFileCount":"1","status":"M","submitter":"Mark Emlyn David Thomas"},{"authorTime":"2014-11-24 06:50:00","codes":[{"authorDate":"2014-11-11 00:46:40","commitOrder":4,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2014-11-11 00:46:40","endLine":1475,"groupId":"13886","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ac/598dd56f755e36a7c5c1d89d448f7ed6aae65a.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"N"},{"authorDate":"2014-11-24 06:50:00","commitOrder":4,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","date":"2014-11-24 06:50:00","endLine":958,"groupId":"5476","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/de/5e60ef85522b32b1fd6537cd5c7f9c80e1dc45.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":883,"status":"M"}],"commitId":"e73c241d36ab4a1ccabf74d0ff28b36bdeaee3da","commitMessage":"@@@Additional debug messages.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1641273 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-24 06:50:00","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2014-11-24 06:50:09","codes":[{"authorDate":"2014-11-11 00:46:40","commitOrder":5,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2014-11-11 00:46:40","endLine":1475,"groupId":"13886","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ac/598dd56f755e36a7c5c1d89d448f7ed6aae65a.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"N"},{"authorDate":"2014-11-24 06:50:09","commitOrder":5,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    } else {\n                        interest = true;\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","date":"2014-11-24 06:50:09","endLine":960,"groupId":"5476","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/d0/18653b6a2e1dff7598bef49daf02469415f9ca.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":883,"status":"M"}],"commitId":"5dcc6407bc6c492e6aba728a234da2dc84aa29fa","commitMessage":"@@@Fix NIO2 with AJP.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1641275 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-24 06:50:09","modifiedFileCount":"2","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-08 21:11:04","codes":[{"authorDate":"2014-11-11 00:46:40","commitOrder":6,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2014-11-11 00:46:40","endLine":1475,"groupId":"13886","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ac/598dd56f755e36a7c5c1d89d448f7ed6aae65a.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"N"},{"authorDate":"2015-01-08 21:11:04","commitOrder":6,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    } else {\n                        readInterest = true;\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","date":"2015-01-08 21:11:04","endLine":1039,"groupId":"5476","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/53/4365ec43ecd06d840775f199bfea04586222b6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    } else {\n                        interest = true;\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":962,"status":"M"}],"commitId":"c708760fb98a5b727d64c017983eb39c1fe72e46","commitMessage":"@@@Separate readInterest and writeInterest\nFix failing unit test\ntestMessagesNonBlocking(org.apache.coyote.http11.upgrade.TestUpgrade)\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1650281 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-08 21:11:04","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-15 17:21:08","codes":[{"authorDate":"2014-11-11 00:46:40","commitOrder":7,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2014-11-11 00:46:40","endLine":1475,"groupId":"13886","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ac/598dd56f755e36a7c5c1d89d448f7ed6aae65a.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1431,"status":"N"},{"authorDate":"2015-01-15 17:21:08","commitOrder":7,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    } else {\n                        readInterest = true;\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","date":"2015-01-15 17:21:08","endLine":1059,"groupId":"5476","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/84/290e56ab6cd3f9fa24d15d0e05ee7853f6bed0.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    } else {\n                        readInterest = true;\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":979,"status":"M"}],"commitId":"01cb27645886be47d007aa06c056194e6cb7e451","commitMessage":"@@@NIO reafctoring\n - Use read from socketWrapper rather than HttpNio2InputBuffer\n - Various API tweaks to support the above\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1652002 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-15 17:21:08","modifiedFileCount":"8","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-15 17:21:08","codes":[{"authorDate":"2015-01-15 17:21:17","commitOrder":8,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-01-15 17:21:17","endLine":1461,"groupId":"0","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/58/afe096675518f03d4372eb6d4d8a83f83c6d9e.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            readBuffer.clear();\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                readBuffer.flip();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == 0) {\n                readBuffer.flip();\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1419,"status":"M"},{"authorDate":"2015-01-15 17:21:08","commitOrder":8,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    } else {\n                        readInterest = true;\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","date":"2015-01-15 17:21:08","endLine":1059,"groupId":"5476","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/84/290e56ab6cd3f9fa24d15d0e05ee7853f6bed0.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    } else {\n                        readInterest = true;\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":979,"status":"N"}],"commitId":"9718447a0342866373fec40498e960040d58b738","commitMessage":"@@@InputBuffer refactoring. All compiles but not yet tested.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1652003 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-15 17:21:17","modifiedFileCount":"9","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-15 17:21:24","codes":[{"authorDate":"2015-01-15 17:21:24","commitOrder":9,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-01-15 17:21:24","endLine":1463,"groupId":"7725","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/57/ddb67769c0f83689e795dd7bd5f8be96873ca6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1419,"status":"M"},{"authorDate":"2015-01-15 17:21:24","commitOrder":9,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            synchronized (readCompletionHandler) {\n                socketBufferHandler.configureReadBufferForRead();\n\n                int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n                \r\n                if (remaining >= len) {\n                    socketBufferHandler.getReadBuffer().get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    readPending.release();\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                \r\n                \r\n                int nRead = fillReadBuffer(block && remaining == 0);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > leftToWrite) {\n                        socketBufferHandler.getReadBuffer().get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n                return len - leftToWrite;\n            }\n        }\n","date":"2015-01-15 17:21:24","endLine":1047,"groupId":"12139","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/f1/e329e20d9ada24f56311efe3d28aec08529ca7.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            synchronized (readCompletionHandler) {\n                if (readPending) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n\n                ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer();\n\n                if (!flipped) {\n                    readBuffer.flip();\n                    flipped = true;\n                }\n                int remaining = readBuffer.remaining();\n                \r\n                if (remaining >= len) {\n                    readBuffer.get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    readBuffer.get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                readBuffer.clear();\n                flipped = false;\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    if (!flipped) {\n                        readBuffer.flip();\n                        flipped = true;\n                    }\n                    if (nRead > leftToWrite) {\n                        readBuffer.get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        readBuffer.get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0) {\n                    if (block) {\n                        if (!flipped) {\n                            readBuffer.flip();\n                            flipped = true;\n                        }\n                    } else {\n                        readInterest = true;\n                    }\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":972,"status":"M"}],"commitId":"a9c95a37f94d2074800c326fcb85510e0062ce7c","commitMessage":"@@@Fix first set of issues found with NIO2 and new SocketBufferHandler\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1652004 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-15 17:21:24","modifiedFileCount":"7","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-15 17:21:40","codes":[{"authorDate":"2015-01-15 17:21:24","commitOrder":10,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-01-15 17:21:24","endLine":1463,"groupId":"7725","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/57/ddb67769c0f83689e795dd7bd5f8be96873ca6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1419,"status":"N"},{"authorDate":"2015-01-15 17:21:40","commitOrder":10,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            synchronized (readCompletionHandler) {\n                socketBufferHandler.configureReadBufferForRead();\n\n                int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n                \r\n                if (remaining >= len) {\n                    socketBufferHandler.getReadBuffer().get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    readPending.release();\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                    \r\n                    \r\n                    \r\n                    \r\n                    readPending.release();\n                    return remaining;\n                }\n\n                \r\n                \r\n                \r\n                int nRead = fillReadBuffer(block && remaining == 0);\n                if (block && remaining == 0) {\n                    \r\n                    readPending.release();\n                }\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > leftToWrite) {\n                        socketBufferHandler.getReadBuffer().get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n                return len - leftToWrite;\n            }\n        }\n","date":"2015-01-15 17:21:40","endLine":1075,"groupId":"12910","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/97/366c6081abf8f23ac28f161a37f1c1dc5c0a8b.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            synchronized (readCompletionHandler) {\n                socketBufferHandler.configureReadBufferForRead();\n\n                int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n                \r\n                if (remaining >= len) {\n                    socketBufferHandler.getReadBuffer().get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    readPending.release();\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                    leftToWrite -= remaining;\n                    newOffset += remaining;\n                }\n\n                \r\n                \r\n                \r\n                int nRead = fillReadBuffer(block && remaining == 0);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > leftToWrite) {\n                        socketBufferHandler.getReadBuffer().get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":992,"status":"M"}],"commitId":"a10b70d31a5ef03129ce246c4ccf3728154d9d77","commitMessage":"@@@Fix remaining NIO2 unit test failures after refactoring.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1652007 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-15 17:21:40","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-15 22:56:53","codes":[{"authorDate":"2015-01-15 17:21:24","commitOrder":11,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-01-15 17:21:24","endLine":1463,"groupId":"7725","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/57/ddb67769c0f83689e795dd7bd5f8be96873ca6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1419,"status":"N"},{"authorDate":"2015-01-15 22:56:53","commitOrder":11,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            synchronized (readCompletionHandler) {\n                socketBufferHandler.configureReadBufferForRead();\n\n                int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n                \r\n                if (remaining >= len) {\n                    socketBufferHandler.getReadBuffer().get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    readPending.release();\n                    return len;\n                }\n\n                \r\n                if (remaining > 0) {\n                    socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                    \r\n                    \r\n                    \r\n                    \r\n                    readPending.release();\n                    return remaining;\n                }\n\n                \r\n                \r\n                \r\n                int nRead = fillReadBuffer(block);\n                if (block) {\n                    \r\n                    readPending.release();\n                }\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2015-01-15 22:56:53","endLine":1073,"groupId":"7644","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/67/7b3f146004a4421d226c9b73cf4516c2f89ffa.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            synchronized (readCompletionHandler) {\n                socketBufferHandler.configureReadBufferForRead();\n\n                int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n                \r\n                if (remaining >= len) {\n                    socketBufferHandler.getReadBuffer().get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    readPending.release();\n                    return len;\n                }\n\n                \r\n                int leftToWrite = len;\n                int newOffset = off;\n                if (remaining > 0) {\n                    socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                    \r\n                    \r\n                    \r\n                    \r\n                    readPending.release();\n                    return remaining;\n                }\n\n                \r\n                \r\n                \r\n                int nRead = fillReadBuffer(block && remaining == 0);\n                if (block && remaining == 0) {\n                    \r\n                    readPending.release();\n                }\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > leftToWrite) {\n                        socketBufferHandler.getReadBuffer().get(b, newOffset, leftToWrite);\n                        leftToWrite = 0;\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, newOffset, nRead);\n                        leftToWrite -= nRead;\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + (len - leftToWrite) + \"]\");\n                }\n                return len - leftToWrite;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":994,"status":"M"}],"commitId":"cf879ef55102f7d35071b909b84c360cb47838ff","commitMessage":"@@@Simplify\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1652122 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-15 22:56:53","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-16 18:53:21","codes":[{"authorDate":"2015-01-15 17:21:24","commitOrder":12,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-01-15 17:21:24","endLine":1463,"groupId":"7725","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/57/ddb67769c0f83689e795dd7bd5f8be96873ca6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1419,"status":"N"},{"authorDate":"2015-01-16 18:53:21","commitOrder":12,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2015-01-16 18:53:21","endLine":1066,"groupId":"16445","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/c6/6d72e7510980c0d940b5b890076404442537d1.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            synchronized (readCompletionHandler) {\n                socketBufferHandler.configureReadBufferForRead();\n\n                int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n                \r\n                if (remaining >= len) {\n                    socketBufferHandler.getReadBuffer().get(b, off, len);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                    }\n                    readPending.release();\n                    return len;\n                }\n\n                \r\n                if (remaining > 0) {\n                    socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                    \r\n                    \r\n                    \r\n                    \r\n                    readPending.release();\n                    return remaining;\n                }\n\n                \r\n                int nRead = fillReadBuffer(block);\n                if (block) {\n                    \r\n                    readPending.release();\n                }\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":993,"status":"M"}],"commitId":"259d37f91ae7ad7fe36a4ef127cd8fbd4eae91a5","commitMessage":"@@@Streamlining\n - reduce scope of sync (in really only needs to surrond non-blocking\nread and readInterest)\n - make fillReadBuffer responsible for releasing readPending semaphore\nin blocking case (it already did it for non-blcoking)\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1652384 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-16 18:53:21","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-30 03:12:06","codes":[{"authorDate":"2015-01-15 17:21:24","commitOrder":13,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-01-15 17:21:24","endLine":1463,"groupId":"7725","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/57/ddb67769c0f83689e795dd7bd5f8be96873ca6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1419,"status":"N"},{"authorDate":"2015-01-30 03:12:06","commitOrder":13,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2015-01-30 03:12:06","endLine":1057,"groupId":"16445","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/9d/2ca7f697d9645d883c403528f4c22d6438e793.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":981,"status":"M"}],"commitId":"c9db3fe106fa8a97a6ba5e0c9a3b51103e6f8529","commitMessage":"@@@Fix an NPE appearing in the unit test logs.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1655811 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-30 03:12:06","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-02-17 23:17:27","codes":[{"authorDate":"2015-01-15 17:21:24","commitOrder":14,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-01-15 17:21:24","endLine":1463,"groupId":"7725","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/57/ddb67769c0f83689e795dd7bd5f8be96873ca6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1419,"status":"N"},{"authorDate":"2015-02-17 23:17:27","commitOrder":14,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2015-02-17 23:17:27","endLine":1071,"groupId":"16445","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/37/e082da8c213174e5e4cfa24c399e2df880b213.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read: [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":995,"status":"M"}],"commitId":"1a1d320cdb62f39dc65c2d0f075d6dfe130439bc","commitMessage":"@@@Tweak debug message\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1660407 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-02-17 23:17:27","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-02-23 02:49:37","codes":[{"authorDate":"2015-02-23 02:49:37","commitOrder":15,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                return -1;\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-02-23 02:49:37","endLine":1445,"groupId":"7725","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/fc/647ad1c569c842411f0413e919bf2313a51111.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                \r\n                throw new EOFException();\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1402,"status":"M"},{"authorDate":"2015-02-23 02:49:37","commitOrder":15,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2015-02-23 02:49:37","endLine":1075,"groupId":"16445","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ea/6dac3b6da6db6bea4a89131e7a53ce4a5aa577.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    throw new EOFException();\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":999,"status":"M"}],"commitId":"f5a023eb260c020a7c947d9502aa5c67e092b1f7","commitMessage":"@@@Update I/O implementations to support returning -1 for end of stream.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1661517 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-02-23 02:49:37","modifiedFileCount":"3","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-02-23 02:49:37","codes":[{"authorDate":"2015-02-24 17:53:57","commitOrder":16,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                return -1;\n            }\n\n            return len - leftToWrite;\n        }\n","date":"2015-02-24 17:53:57","endLine":1451,"groupId":"0","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/50/d8090d5243f26975480186966a18ef95b5a68f.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                leftToWrite -= remaining;\n                newOffset += remaining;\n            }\n\n            \r\n            \r\n            \r\n            int nRead = fillReadBuffer(block && remaining == 0);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                return -1;\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1404,"status":"M"},{"authorDate":"2015-02-23 02:49:37","commitOrder":16,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2015-02-23 02:49:37","endLine":1075,"groupId":"16445","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ea/6dac3b6da6db6bea4a89131e7a53ce4a5aa577.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":999,"status":"N"}],"commitId":"3e1769a00e7da07da3584175e5b99977c1da8190","commitMessage":"@@@Remove an (unproven) optimisation that didn't handle end-of-stream correctly and triggered at least one failure in the unit tests.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1661877 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-02-24 17:53:57","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-02-23 02:49:37","codes":[{"authorDate":"2015-02-24 18:52:54","commitOrder":17,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","date":"2015-02-24 18:52:54","endLine":1447,"groupId":"233","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/69/a74990e4c6d497d9c6dc3286da138e21b0d19b.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            int leftToWrite = len;\n            int newOffset = off;\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > leftToWrite) {\n                    readBuffer.get(b, newOffset, leftToWrite);\n                    leftToWrite = 0;\n                } else {\n                    readBuffer.get(b, newOffset, nRead);\n                    leftToWrite -= nRead;\n                }\n            } else if (nRead == -1) {\n                return -1;\n            }\n\n            return len - leftToWrite;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1404,"status":"M"},{"authorDate":"2015-02-23 02:49:37","commitOrder":17,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2015-02-23 02:49:37","endLine":1075,"groupId":"16445","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ea/6dac3b6da6db6bea4a89131e7a53ce4a5aa577.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":999,"status":"N"}],"commitId":"ab8db5cee10a38d04e35723b1c0cc24176b1e80d","commitMessage":"@@@Further simplifications\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1661882 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-02-24 18:52:54","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-02-23 02:49:37","codes":[{"authorDate":"2015-05-26 19:29:15","commitOrder":18,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            lastRead = System.currentTimeMillis();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","date":"2015-05-26 19:29:15","endLine":1232,"groupId":"6706","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/83/b4fd11c5a71686b15982243335891a885af1ee.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1188,"status":"M"},{"authorDate":"2015-02-23 02:49:37","commitOrder":18,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2015-02-23 02:49:37","endLine":1075,"groupId":"16445","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ea/6dac3b6da6db6bea4a89131e7a53ce4a5aa577.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":999,"status":"N"}],"commitId":"af496aebb02196a1d1d3373b271b3f6330a6c4a5","commitMessage":"@@@Various fixes to timeout handling post the 9.0.x connector refactoring\nHighlights:\n - use longs for timeouts in AprEndpoint\n - APR read/write registration now uses current timeout\n - move last[Read|Write] to NIO since only NIO uses it\n - Simplify switching between keepAlive and So timeouts for HTTP\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1681742 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-05-26 19:29:15","modifiedFileCount":"6","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-09-04 18:11:08","codes":[{"authorDate":"2015-05-26 19:29:15","commitOrder":19,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            lastRead = System.currentTimeMillis();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","date":"2015-05-26 19:29:15","endLine":1232,"groupId":"6706","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/83/b4fd11c5a71686b15982243335891a885af1ee.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            lastRead = System.currentTimeMillis();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1188,"status":"N"},{"authorDate":"2015-09-04 18:11:08","commitOrder":19,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                \r\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return (nRead > len) ? len : nRead;\n            }\n        }\n","date":"2015-09-04 18:11:08","endLine":954,"groupId":"16445","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/b4/6ea3ae7e1c8052befb837f9de01f92fbb41d4d.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                \r\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":877,"status":"M"}],"commitId":"d1df3d7c17f197851aeccf346b6664edebc93d8b","commitMessage":"@@@Fix incorrect return value (although it doesn't seem to have any real consequences).\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1701202 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-09-04 18:11:08","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2016-06-01 02:50:12","codes":[{"authorDate":"2015-05-26 19:29:15","commitOrder":20,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            lastRead = System.currentTimeMillis();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","date":"2015-05-26 19:29:15","endLine":1232,"groupId":"6706","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/83/b4fd11c5a71686b15982243335891a885af1ee.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            lastRead = System.currentTimeMillis();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1188,"status":"N"},{"authorDate":"2016-06-01 02:50:12","commitOrder":20,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                \r\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return (nRead > len) ? len : nRead;\n            }\n        }\n","date":"2016-06-01 02:50:12","endLine":951,"groupId":"16445","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/2b/dbc01038aa2ecd032f95494ccae9b3819a66e6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            if (getError() != null) {\n                throw getError();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                \r\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return (nRead > len) ? len : nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":876,"status":"M"}],"commitId":"85d8f447b58098f8e1677ca0729287dda19a45f7","commitMessage":"@@@Refactor\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1746319 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-06-01 02:50:12","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2016-06-01 02:50:12","codes":[{"authorDate":"2016-08-10 15:49:31","commitOrder":21,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","date":"2016-08-10 15:49:31","endLine":1180,"groupId":"6706","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/c3/9ec629ae0a6a8499e8ae2eb47de67fad24589d.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            lastRead = System.currentTimeMillis();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1136,"status":"M"},{"authorDate":"2016-06-01 02:50:12","commitOrder":21,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                \r\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return (nRead > len) ? len : nRead;\n            }\n        }\n","date":"2016-06-01 02:50:12","endLine":951,"groupId":"16445","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/2b/dbc01038aa2ecd032f95494ccae9b3819a66e6.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                \r\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return (nRead > len) ? len : nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":876,"status":"N"}],"commitId":"878dda058cd45b3d4c48d165daa351fb4bed698a","commitMessage":"@@@Use methods updateLastRead/updateLastWrite instead of direct update of lastRead/lastWrite.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1755683 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-08-10 15:49:31","modifiedFileCount":"1","status":"M","submitter":"Violeta Georgieva Georgieva"},{"authorTime":"2016-08-10 20:38:31","codes":[{"authorDate":"2016-08-10 20:38:31","commitOrder":22,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            \r\n            if (remaining > 0) {\n                remaining = Math.min(remaining, len);\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                readBuffer.get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-10 20:38:31","endLine":1170,"groupId":"3643","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a5/a86fe97ed34e8b38ef2f2f1d06cd02a3850a44.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            if (remaining >= len) {\n                readBuffer.get(b, off, len);\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                if (nRead > len) {\n                    readBuffer.get(b, off, len);\n                    return len;\n                } else {\n                    readBuffer.get(b, off, nRead);\n                    return nRead;\n                }\n            } else {\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1136,"status":"M"},{"authorDate":"2016-08-10 20:38:31","commitOrder":22,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            \r\n            if (remaining > 0) {\n                remaining = Math.min(remaining, len);\n            \treadBuffer.get(b, off, remaining);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + remaining + \"]\");\n                }\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    readBuffer.get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2016-08-10 20:38:31","endLine":879,"groupId":"3643","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/0d/3af1bdd2bcdbf2ae8024d167bf994c52953815.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n\n            int remaining = socketBufferHandler.getReadBuffer().remaining();\n\n            \r\n            if (remaining >= len) {\n                socketBufferHandler.getReadBuffer().get(b, off, len);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + len + \"]\");\n                }\n                \r\n                readPending.release();\n                return len;\n            }\n\n            \r\n            if (remaining > 0) {\n                socketBufferHandler.getReadBuffer().get(b, off, remaining);\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    if (nRead > len) {\n                        socketBufferHandler.getReadBuffer().get(b, off, len);\n                    } else {\n                        socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                    }\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                } else if (nRead == -1) {\n                    return -1;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return (nRead > len) ? len : nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":815,"status":"M"}],"commitId":"5a0770b367e69119fe3ebd91eff7e948176218c9","commitMessage":"@@@Remove duplications.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1755731 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-08-10 20:38:31","modifiedFileCount":"3","status":"M","submitter":"Violeta Georgieva Georgieva"},{"authorTime":"2016-08-18 21:19:30","codes":[{"authorDate":"2016-08-10 20:38:31","commitOrder":23,"curCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            \r\n            if (remaining > 0) {\n                remaining = Math.min(remaining, len);\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                readBuffer.get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-10 20:38:31","endLine":1170,"groupId":"3643","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a5/a86fe97ed34e8b38ef2f2f1d06cd02a3850a44.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            \r\n            if (remaining > 0) {\n                remaining = Math.min(remaining, len);\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                readBuffer.get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1136,"status":"N"},{"authorDate":"2016-08-18 21:19:30","commitOrder":23,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            \r\n            if (remaining > 0) {\n                remaining = Math.min(remaining, len);\n                readBuffer.get(b, off, remaining);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + remaining + \"]\");\n                }\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    readBuffer.get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2016-08-18 21:19:30","endLine":880,"groupId":"12709","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/dd/7495f1f6726b643942077140ef49279ec6410a.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            \r\n            if (remaining > 0) {\n                remaining = Math.min(remaining, len);\n                readBuffer.get(b, off, remaining);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + remaining + \"]\");\n                }\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    readBuffer.get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":815,"status":"M"}],"commitId":"850bddb7d9f4ad5cd4b47ae8ef509724353636fa","commitMessage":"@@@Ensure that Semaphore.release is called in all cases. Even when there is an exception.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1756778 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-08-18 21:19:30","modifiedFileCount":"1","status":"M","submitter":"Violeta Georgieva Georgieva"},{"authorTime":"2016-08-18 22:43:05","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":24,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len)\n                throws IOException {\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            \r\n            if (remaining > 0) {\n                remaining = Math.min(remaining, len);\n                readBuffer.get(b, off, remaining);\n                return remaining;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            int nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                readBuffer.get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"M"},{"authorDate":"2016-08-18 22:43:05","commitOrder":24,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2016-08-18 22:43:05","endLine":870,"groupId":"9313","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ef/88b342771d258c0dc8c17aed68f11f526dc369.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            socketBufferHandler.configureReadBufferForRead();\n            ByteBuffer readBuffer = socketBufferHandler.getReadBuffer();\n            int remaining = readBuffer.remaining();\n\n            \r\n            \r\n            if (remaining > 0) {\n                remaining = Math.min(remaining, len);\n                readBuffer.get(b, off, remaining);\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read from buffer: [\" + remaining + \"]\");\n                }\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return remaining;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                int nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    readBuffer.get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":815,"status":"M"}],"commitId":"943e546ba4b359c379468362b26abcaf0acbb8a7","commitMessage":"@@@Reduce duplications.\nExtract a new method SocketWrapperBase.populateReadBuffer(byte[].  int.  int).\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1756798 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-08-18 22:43:05","modifiedFileCount":"4","status":"M","submitter":"Violeta Georgieva Georgieva"},{"authorTime":"2019-02-19 22:58:00","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":25,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-02-19 22:58:00","commitOrder":25,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-02-19 22:58:00","endLine":823,"groupId":"9313","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/e7/e1ad83d4c6b14ef2aa347bd95bbea4c9756af5.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"}],"commitId":"b64f8a45637b35efed6856da02218178c7ddb157","commitMessage":"@@@63182: Avoid extra notifications when using non container threads on read causing thread safety problems. Tentative fix.  but the pattern is clearly causing a thread safety problem there. Also move ContainerMarkerThread.  but leave the old location around for compatibility.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1853886 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2019-02-19 22:58:00","modifiedFileCount":"3","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2019-02-21 00:50:12","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":26,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-02-21 00:50:12","commitOrder":26,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-02-21 00:50:12","endLine":819,"groupId":"9313","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/6a/99df8205f6ef3e439e9871e81f6628ef4a674b.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"}],"commitId":"6d3ee3a7eef77a62daf9e4bccaa17a6e1b35fd19","commitMessage":"@@@Code cleanup and remove the extra readInterest = true.  they don't seem to be useful.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1853973 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2019-02-21 00:50:12","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2019-02-21 02:45:17","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":27,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":53,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-02-21 02:45:17","commitOrder":27,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-02-21 02:45:17","endLine":821,"groupId":"9313","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/b1/dd850232b3cec32f78f7a8a9b25c216281d455.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"}],"commitId":"b4c35f65ef79d5f5fe04166e356661c48223b54c","commitMessage":"@@@Testing with CI (it did work locally)\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1853979 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2019-02-21 02:45:17","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2019-02-22 00:37:20","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":28,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":55,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-02-22 00:37:20","commitOrder":28,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-02-22 00:37:20","endLine":821,"groupId":"9313","id":56,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/83/23bfed0de735c0de7131feab0fde5fbf52c30e.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"}],"commitId":"33161af9713e5a49880476049c63c218e9878852","commitMessage":"@@@Refactor to redo fix for 63182. The root cause is that the pending flag is released once processing start.  and concurrent unsynced access from non container threads can cause awaitBytes to happen concurrently.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1854066 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2019-02-22 00:37:20","modifiedFileCount":"11","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2019-02-22 04:18:12","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":29,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":57,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-02-22 04:18:12","commitOrder":29,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-02-22 04:18:12","endLine":821,"groupId":"9313","id":58,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a8/35a7225378cc44793962fd4fa30689255b9e14.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"}],"commitId":"5d8365c30c3f7228282fcf8eb33e346235601361","commitMessage":"@@@Revert again after CI fail.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1854089 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2019-02-22 04:18:12","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2019-02-22 22:58:45","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":30,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":59,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-02-22 22:58:45","commitOrder":30,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-02-22 22:58:45","endLine":821,"groupId":"9313","id":60,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/47/1e6dde02f517d41a6d0fc35707361e4c7f1140.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"}],"commitId":"f5af978590f2e9c649b9b4b858edb6b524973f29","commitMessage":"@@@Try something different with CI\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1854140 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2019-02-22 22:58:45","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2019-02-22 23:37:03","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":31,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":61,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-02-22 23:37:03","commitOrder":31,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-02-22 23:37:03","endLine":821,"groupId":"9313","id":62,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a8/35a7225378cc44793962fd4fa30689255b9e14.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"}],"commitId":"3b2e5285187b6512e53ede1d8172fc363128002d","commitMessage":"@@@Revert\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1854141 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2019-02-22 23:37:03","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2019-03-01 01:30:21","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":32,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":63,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-03-01 01:30:21","commitOrder":32,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (readNotify) {\n                readNotify = false;\n            } else {\n                if (block) {\n                    try {\n                        readPending.acquire();\n                    } catch (InterruptedException e) {\n                        throw new IOException(e);\n                    }\n                } else {\n                    if (!readPending.tryAcquire()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                        }\n                        return 0;\n                    }\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-03-01 01:30:21","endLine":831,"groupId":"9313","id":64,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/db/abe5692b77bff5261095c47c990bc902a005d7.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":774,"status":"M"}],"commitId":"d13a54413cc6a7084da8c4225e4918038fc8f6d9","commitMessage":"@@@Refactor read notification\n\nAnother attempt for 63182. The rationale is that it is better to\nconsider a non blocking read is pending until the \"client\" code actually\nreads.","date":"2019-03-01 01:30:21","modifiedFileCount":"1","status":"M","submitter":"remm"},{"authorTime":"2019-03-01 06:12:52","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":33,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":65,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-03-01 06:12:52","commitOrder":33,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (!readNotify) {\n                if (block) {\n                    try {\n                        readPending.acquire();\n                    } catch (InterruptedException e) {\n                        throw new IOException(e);\n                    }\n                } else {\n                    if (!readPending.tryAcquire()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                        }\n                        return 0;\n                    }\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                if (readNotify) {\n                    \r\n                    readNotify = false;\n                }\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-03-01 06:12:52","endLine":833,"groupId":"11133","id":66,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/98/2dd4438e62d6ce878747ecf2fb9fc3847c02e2.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (readNotify) {\n                readNotify = false;\n            } else {\n                if (block) {\n                    try {\n                        readPending.acquire();\n                    } catch (InterruptedException e) {\n                        throw new IOException(e);\n                    }\n                } else {\n                    if (!readPending.tryAcquire()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                        }\n                        return 0;\n                    }\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":774,"status":"M"}],"commitId":"d3bd3f71ea04c26f638a9a43586fb7d63bbf5ae8","commitMessage":"@@@Add missing check in registerReadInterest\n\nFollow up for 63182.  and test with CI. Simplify test case a bit.","date":"2019-03-01 06:12:52","modifiedFileCount":"2","status":"M","submitter":"remm"},{"authorTime":"2019-03-01 18:28:52","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":34,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":67,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-03-01 18:28:52","commitOrder":34,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-03-01 18:28:52","endLine":821,"groupId":"9313","id":68,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/b1/dbb7ca246f8abbfce0c0c5efa31743d9a342d2.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (!readNotify) {\n                if (block) {\n                    try {\n                        readPending.acquire();\n                    } catch (InterruptedException e) {\n                        throw new IOException(e);\n                    }\n                } else {\n                    if (!readPending.tryAcquire()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                        }\n                        return 0;\n                    }\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                if (readNotify) {\n                    \r\n                    readNotify = false;\n                }\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":768,"status":"M"}],"commitId":"23d554fa045ee5d980b2919b34bf77c0da4d4f15","commitMessage":"@@@Revert again for now","date":"2019-03-01 18:28:52","modifiedFileCount":"1","status":"M","submitter":"remm"},{"authorTime":"2019-03-02 03:57:36","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":35,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"6781","id":69,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-03-02 03:57:36","commitOrder":35,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (!readNotify) {\n                if (block) {\n                    try {\n                        readPending.acquire();\n                    } catch (InterruptedException e) {\n                        throw new IOException(e);\n                    }\n                } else {\n                    if (!readPending.tryAcquire()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                        }\n                        return 0;\n                    }\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                if (readNotify) {\n                    \r\n                    readNotify = false;\n                }\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-03-02 03:57:36","endLine":833,"groupId":"11133","id":70,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/80/2023e8a2b820c5c0579de0f7f3a6d44049848f.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (block) {\n                try {\n                    readPending.acquire();\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            } else {\n                if (!readPending.tryAcquire()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                    }\n                    return 0;\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block && ContainerThreadMarker.isContainerThread()) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":774,"status":"M"}],"commitId":"c084c08f6ab727e5df59ea167155d3321977689e","commitMessage":"@@@Iterate refactoring and test with CI\n\nChange HTTP/1.1 available so that it avoids reading.  as it is correct\nfor isReady to return false if no data is available in buffers. Change\nregisterReadInterest to use a regular read rather than a keepalive read.","date":"2019-03-02 03:57:36","modifiedFileCount":"3","status":"M","submitter":"remm"},{"authorTime":"2019-03-02 06:15:23","codes":[{"authorDate":"2016-08-18 22:43:05","commitOrder":36,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","date":"2016-08-18 22:43:05","endLine":1160,"groupId":"12394","id":71,"instanceNumber":1,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/96/46630b01bcd0e1d5da1fbe60aa3740d085e214.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                return nRead;\n                \r\n\r\n\r\n\r\n\r\n\r\n\n            }\n\n            \r\n            nRead = fillReadBuffer(block);\n            updateLastRead();\n\n            \r\n            \r\n            if (nRead > 0) {\n                socketBufferHandler.configureReadBufferForRead();\n                nRead = Math.min(nRead, len);\n                socketBufferHandler.getReadBuffer().get(b, off, nRead);\n            }\n            return nRead;\n        }\n","realPath":"java/org/apache/tomcat/util/net/NioEndpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":1135,"status":"N"},{"authorDate":"2019-03-02 06:15:23","commitOrder":36,"curCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (!readNotify) {\n                if (block) {\n                    try {\n                        readPending.acquire();\n                    } catch (InterruptedException e) {\n                        throw new IOException(e);\n                    }\n                } else {\n                    if (!readPending.tryAcquire()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                        }\n                        return 0;\n                    }\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                \r\n                readNotify = false;\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","date":"2019-03-02 06:15:23","endLine":831,"groupId":"12394","id":72,"instanceNumber":2,"isCurCommit":0,"methodName":"read","params":"(booleanblock@byte[]b@intoff@intlen)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/de/44f370d654d99648b0812ed4e01eba147bd494.src","preCode":"        public int read(boolean block, byte[] b, int off, int len) throws IOException {\n            checkError();\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Socket: [\" + this + \"], block: [\" + block + \"], length: [\" + len + \"]\");\n            }\n\n            if (socketBufferHandler == null) {\n                throw new IOException(sm.getString(\"socket.closed\"));\n            }\n\n            if (!readNotify) {\n                if (block) {\n                    try {\n                        readPending.acquire();\n                    } catch (InterruptedException e) {\n                        throw new IOException(e);\n                    }\n                } else {\n                    if (!readPending.tryAcquire()) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Socket: [\" + this + \"], Read in progress. Returning [0]\");\n                        }\n                        return 0;\n                    }\n                }\n            }\n\n            int nRead = populateReadBuffer(b, off, len);\n            if (nRead > 0) {\n                if (readNotify) {\n                    \r\n                    readNotify = false;\n                }\n                \r\n                \r\n                \r\n                \r\n                readPending.release();\n                return nRead;\n            }\n\n            synchronized (readCompletionHandler) {\n                \r\n                nRead = fillReadBuffer(block);\n                \r\n                \r\n                if (nRead > 0) {\n                    socketBufferHandler.configureReadBufferForRead();\n                    nRead = Math.min(nRead, len);\n                    socketBufferHandler.getReadBuffer().get(b, off, nRead);\n                } else if (nRead == 0 && !block) {\n                    readInterest = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Socket: [\" + this + \"], Read: [\" + nRead + \"]\");\n                }\n                return nRead;\n            }\n        }\n","realPath":"java/org/apache/tomcat/util/net/Nio2Endpoint.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":774,"status":"M"}],"commitId":"071c2b6759a28c5fc7f7719d5345fa645a37fd6f","commitMessage":"@@@Simplify code","date":"2019-03-02 06:15:23","modifiedFileCount":"1","status":"M","submitter":"remm"}]
