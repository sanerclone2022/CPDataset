[{"authorTime":"2011-03-01 19:12:22","codes":[{"authorDate":"2014-03-10 19:27:11","commitOrder":5,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_WRITE;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2014-03-10 19:27:11","endLine":291,"groupId":"1837","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/98/046a2b87654268cf6feeb377f7d785abfa42c3.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_WRITE;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":201,"status":"B"},{"authorDate":"2011-03-01 19:12:22","commitOrder":5,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n        \n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n        \n        SSLEngineResult handshake = null;\n        \n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE; \n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2011-03-01 19:12:22","endLine":209,"groupId":"7792","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/f2/ee23113a964824cc7dd62e9684fa3053d92863.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n        \n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n        \n        SSLEngineResult handshake = null;\n        \n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE; \n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"NB"}],"commitId":"27ac1263bf25a6af9175afe772416e39b1f51f6a","commitMessage":"@@@Add experimental NIO2 connector. Based on code developed by Nabil Benothman.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1575905 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-03-10 19:27:11","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2011-03-01 19:12:22","codes":[{"authorDate":"2014-03-26 18:11:06","commitOrder":6,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2014-03-26 18:11:06","endLine":294,"groupId":"1837","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/99/a23825a508cbbe6ccc3ac22289811dc1281fcf.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_WRITE;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return Nio2Endpoint.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"},{"authorDate":"2011-03-01 19:12:22","commitOrder":6,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n        \n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n        \n        SSLEngineResult handshake = null;\n        \n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE; \n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2011-03-01 19:12:22","endLine":209,"groupId":"7792","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/f2/ee23113a964824cc7dd62e9684fa3053d92863.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n        \n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n        \n        SSLEngineResult handshake = null;\n        \n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE; \n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"N"}],"commitId":"96b5a35f88bdf7ebc9fede46884302b6e1e5764b","commitMessage":"@@@- Remove useless IOE on flush.\n- Remove nearly all extra fields from the socket wrapper.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1581778 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-03-26 18:11:06","modifiedFileCount":"5","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2011-03-01 19:12:22","codes":[{"authorDate":"2014-04-04 18:10:28","commitOrder":7,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2014-04-04 18:10:28","endLine":297,"groupId":"1913","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/7b/55bc73ae9a2d64799ef005594f3026891dbef6.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(\"Handshake error\");\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"M"},{"authorDate":"2011-03-01 19:12:22","commitOrder":7,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n        \n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n        \n        SSLEngineResult handshake = null;\n        \n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE; \n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2011-03-01 19:12:22","endLine":209,"groupId":"7792","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/f2/ee23113a964824cc7dd62e9684fa3053d92863.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n        \n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n        \n        SSLEngineResult handshake = null;\n        \n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE; \n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) \n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"N"}],"commitId":"501dfa46576d1ae0a29f1ebe1b080e49aa0beaa6","commitMessage":"@@@Code cleanups and i18n in NIO2.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1584593 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-04-04 18:10:28","modifiedFileCount":"6","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2014-04-04 21:26:11","codes":[{"authorDate":"2014-04-04 18:10:28","commitOrder":8,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2014-04-04 18:10:28","endLine":297,"groupId":"1913","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/7b/55bc73ae9a2d64799ef005594f3026891dbef6.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"N"},{"authorDate":"2014-04-04 21:26:11","commitOrder":8,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2014-04-04 21:26:11","endLine":218,"groupId":"722","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/42/f18032cebdb557f5fd1ed05b6126f8b34d7132.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(\"NOT_HANDSHAKING during handshake\");\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(\"Unexpected status:\" + handshake.getStatus() + \" during handshake WRAP.\");\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(\"Invalid handshake status:\"+handshakeStatus+\" during handshake UNWRAP.\");\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(\"Invalid handshake status:\"+handshakeStatus);\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":157,"status":"M"}],"commitId":"70c82a92c0d479d75a0404fbb5e6c313d1a4f0e8","commitMessage":"@@@Port i18n to the NIO1 connector.  for consistency.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1584662 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-04-04 21:26:11","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2014-11-24 17:37:03","codes":[{"authorDate":"2014-04-04 18:10:28","commitOrder":9,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2014-04-04 18:10:28","endLine":297,"groupId":"1913","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/7b/55bc73ae9a2d64799ef005594f3026891dbef6.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"N"},{"authorDate":"2014-11-24 17:37:03","commitOrder":9,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        \r\n                        \r\n                        bufHandler.getReadBuffer().compact();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2014-11-24 17:37:03","endLine":218,"groupId":"722","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/cc/1c055112d93b86c532fa3a65ab7b7e5c981109.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"8bf93eee6d8d7579ed8bd3d2c809cde74cdd19f2","commitMessage":"@@@Fix SSL for NIO that was broken by AJP refactoring.\nAdd some TODO markers as this is only a temporary fix.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1641343 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-24 17:37:03","modifiedFileCount":"3","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-01-15 17:21:17","codes":[{"authorDate":"2014-04-04 18:10:28","commitOrder":10,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2014-04-04 18:10:28","endLine":297,"groupId":"1913","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/7b/55bc73ae9a2d64799ef005594f3026891dbef6.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"N"},{"authorDate":"2015-01-15 17:21:17","commitOrder":10,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2015-01-15 17:21:17","endLine":211,"groupId":"722","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/4c/1afaf32a3b7d7998099b027344df9e63a381e0.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        \r\n                        \r\n                        bufHandler.getReadBuffer().compact();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"}],"commitId":"9718447a0342866373fec40498e960040d58b738","commitMessage":"@@@InputBuffer refactoring. All compiles but not yet tested.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1652003 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-15 17:21:17","modifiedFileCount":"9","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-04-09 23:16:42","codes":[{"authorDate":"2015-04-09 23:16:42","commitOrder":11,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-04-09 23:16:42","endLine":304,"groupId":"1913","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a4/b5fefa4445cfd40fd89ff05045fc8a9df79659.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete)\n            return 0; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"},{"authorDate":"2015-04-09 23:16:42","commitOrder":11,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2015-04-09 23:16:42","endLine":219,"groupId":"722","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/84/002497d1c1bb7d9252a8acc1139c7a62e6eaba.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if ( handshakeComplete ) return 0; \r\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"M"}],"commitId":"27269dfe1a5a6c34aa2ffbf1d3dd3909c800c0d5","commitMessage":"@@@Some initial plumbing for SNI.\nWhile Java 8 supports SNI.  if you want different certs for different hosts then you have to manually parse the incoming TLS bytes to look for the SNI extension. This makes it 'interesting'. The idea at this point is to do it as part of the handshake. This will require moving the SSLEngine init code to processSNI() - that is the next step.\nFix some Java 8 Javadoc issues while I was in the area.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1672393 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-04-09 23:16:42","modifiedFileCount":"4","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-05-19 19:02:24","codes":[{"authorDate":"2015-05-19 19:02:24","commitOrder":12,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"channel.nio.ssl.wrapException\", e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-05-19 19:02:24","endLine":292,"groupId":"12369","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/93/32b38edd32445b9553cbda93a4b569036d40d5.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap();\n                    if (handshake.getStatus() == Status.OK){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":183,"status":"M"},{"authorDate":"2015-05-19 19:02:24","commitOrder":12,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"channel.nio.ssl.wrapException\", e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2015-05-19 19:02:24","endLine":236,"groupId":"0","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/25/ee977f37311eab4a8df69e4ee7f6e066329ac5.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    handshake = handshakeWrap(write);\n                    if ( handshake.getStatus() == Status.OK ){\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"}],"commitId":"f62ad6e2e5a593b89fae39ad17d314e5c2f82a1c","commitMessage":"@@@Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=57931\nEnsure that the TLS connection is closed cleanly so that the client receives the appropriate error code when the connection is terminated due to invalid / missing client cert (or any other reason during the handshake)\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1680246 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-05-19 19:02:24","modifiedFileCount":"2","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-05-19 19:25:21","codes":[{"authorDate":"2015-05-19 19:25:21","commitOrder":13,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-05-19 19:25:21","endLine":292,"groupId":"12369","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/e5/c441e53309e07cb9224c1ca53e090f1950a534.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"channel.nio.ssl.wrapException\", e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":183,"status":"M"},{"authorDate":"2015-05-19 19:25:21","commitOrder":13,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2015-05-19 19:25:21","endLine":236,"groupId":"4666","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/c2/d5637be0906f7e7a307896134590169ba64f8b.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"channel.nio.ssl.wrapException\", e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"}],"commitId":"a693896f097f9ec1b0ca23ba03d3bc5e9a26667c","commitMessage":"@@@Follow-up to r1680246 - add missing i18n lookups\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1680252 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-05-19 19:25:21","modifiedFileCount":"2","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-05-19 19:25:21","codes":[{"authorDate":"2015-07-15 23:50:12","commitOrder":14,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-07-15 23:50:12","endLine":308,"groupId":"12369","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/3e/cda0cea1175116ef66d479d75bbc0c2ddea552.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"M"},{"authorDate":"2015-05-19 19:25:21","commitOrder":14,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2015-05-19 19:25:21","endLine":236,"groupId":"4666","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/c2/d5637be0906f7e7a307896134590169ba64f8b.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"N"}],"commitId":"e7847ab4b67fdbfafa27169f04c4b1db53dc8c9a","commitMessage":"@@@Add ALPN to NIO2 with JSSE and OpenSSL. No NIO yet since it would need a refactoring to pass the socket wrapper to NioChannel to be able to set the negotiated protocol (?).\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1691237 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-07-15 23:50:12","modifiedFileCount":"5","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2015-07-16 00:20:38","codes":[{"authorDate":"2015-07-15 23:50:12","commitOrder":15,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-07-15 23:50:12","endLine":308,"groupId":"12369","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/3e/cda0cea1175116ef66d479d75bbc0c2ddea552.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"N"},{"authorDate":"2015-07-16 00:20:38","commitOrder":15,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2015-07-16 00:20:38","endLine":250,"groupId":"4666","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/d6/2cc37dcfcc1a515c3acecb2122a28454d0ca6d.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"}],"commitId":"3a343479bdd446c46dcd8aeecc2241d9857ed738","commitMessage":"@@@Add ALPN support to NIO by passing the socket wrapper to the channel.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1691244 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-07-16 00:20:38","modifiedFileCount":"3","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2015-07-16 00:20:38","codes":[{"authorDate":"2015-10-23 06:15:04","commitOrder":16,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            log.debug(\"Handshake status [\" + handshakeStatus + \"]\" );\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n            log.debug(\"Handshake complete [\" + handshakeComplete + \"]\" );\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-10-23 06:15:04","endLine":309,"groupId":"12369","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/67/6335784fb0e29982e9131222e7e5ec1484f91e.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"M"},{"authorDate":"2015-07-16 00:20:38","commitOrder":16,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2015-07-16 00:20:38","endLine":250,"groupId":"4666","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/d6/2cc37dcfcc1a515c3acecb2122a28454d0ca6d.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"N"}],"commitId":"dadc84c6539c0615e5cac57372f03121f4995e7d","commitMessage":"@@@Remove unused code\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1710107 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-10-23 06:15:04","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-07-16 00:20:38","codes":[{"authorDate":"2015-10-23 06:27:11","commitOrder":17,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-10-23 06:27:11","endLine":307,"groupId":"12369","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/03/74747656933ee9d14712d6000605b3d92b5a26.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            log.debug(\"Handshake status [\" + handshakeStatus + \"]\" );\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n            log.debug(\"Handshake complete [\" + handshakeComplete + \"]\" );\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"M"},{"authorDate":"2015-07-16 00:20:38","commitOrder":17,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","date":"2015-07-16 00:20:38","endLine":250,"groupId":"4666","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/d6/2cc37dcfcc1a515c3acecb2122a28454d0ca6d.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"N"}],"commitId":"4e5ab0b319a85f3087fa40aa570ecce4064f716f","commitMessage":"@@@Remove temporary debug statements from r1710107\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1710108 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-10-23 06:27:11","modifiedFileCount":"1","status":"M","submitter":"Mark Thomas"},{"authorTime":"2015-11-09 17:39:49","codes":[{"authorDate":"2015-10-23 06:27:11","commitOrder":18,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-10-23 06:27:11","endLine":307,"groupId":"12369","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/03/74747656933ee9d14712d6000605b3d92b5a26.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"N"},{"authorDate":"2015-11-09 17:39:49","commitOrder":18,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2015-11-09 17:39:49","endLine":249,"groupId":"4666","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/4a/bea25087a63783a99105fd6b704749b077bf48.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\r\n        }\r\n        \r\n        \r\n        return handshakeComplete?0:(SelectionKey.OP_WRITE|SelectionKey.OP_READ);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"}],"commitId":"96ecbb20259b395dc9f93d2a087ab6f9bb983811","commitMessage":"@@@Fix Findbugs warnings. Remove code that will never execute because the condition it depends on can never be met.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1713362 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-11-09 17:39:49","modifiedFileCount":"5","status":"M","submitter":"Mark Thomas"},{"authorTime":"2016-04-13 22:18:00","codes":[{"authorDate":"2015-10-23 06:27:11","commitOrder":19,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-10-23 06:27:11","endLine":307,"groupId":"12369","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/03/74747656933ee9d14712d6000605b3d92b5a26.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"N"},{"authorDate":"2016-04-13 22:18:00","commitOrder":19,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socketWrapper.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2016-04-13 22:18:00","endLine":249,"groupId":"4666","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/34/2f3dc7ee22ee993db281d5eeefdeec985ed921.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"}],"commitId":"86b54bcd1b21613ec61cddb9f1066281a8554dc0","commitMessage":"@@@Use socketWrapper rather than socket to make the code clearer\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1738946 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-04-13 22:18:00","modifiedFileCount":"2","status":"M","submitter":"Mark Thomas"},{"authorTime":"2016-09-09 20:59:02","codes":[{"authorDate":"2015-10-23 06:27:11","commitOrder":20,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2015-10-23 06:27:11","endLine":307,"groupId":"12369","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/03/74747656933ee9d14712d6000605b3d92b5a26.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"N"},{"authorDate":"2016-09-09 20:59:02","commitOrder":20,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socketWrapper.setNegotiatedProtocol(\n                                ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2016-09-09 20:59:02","endLine":250,"groupId":"4666","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/22/bd1ffed9210d129953fcd09c58a5677261c87e.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socketWrapper.setNegotiatedProtocol(\n                                ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        bufHandler.configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"M"}],"commitId":"233433aadd82d9a7afd42347e54212a4d1d10c64","commitMessage":"@@@Access the socket buffer handler via getBufHandler method for consistency with the rest of the code.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1760005 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-09-09 20:59:02","modifiedFileCount":"2","status":"M","submitter":"Violeta Georgieva Georgieva"},{"authorTime":"2016-09-09 20:59:02","codes":[{"authorDate":"2016-10-31 23:29:27","commitOrder":21,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2016-10-31 23:29:27","endLine":322,"groupId":"12369","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/69/8c5d143649909ce775c50fbd43e2f27f73b470.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getSoTimeout(), TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"M"},{"authorDate":"2016-09-09 20:59:02","commitOrder":21,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socketWrapper.setNegotiatedProtocol(\n                                ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2016-09-09 20:59:02","endLine":250,"groupId":"4666","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/22/bd1ffed9210d129953fcd09c58a5677261c87e.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socketWrapper.setNegotiatedProtocol(\n                                ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"N"}],"commitId":"712bcbcf6ace924fae6aa5694ff6d7eb852561e1","commitMessage":"@@@Follow up to r1767250: rename soTimeout to connectionTimeout in ProcotolHandler and Endpoint\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1767307 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-10-31 23:29:27","modifiedFileCount":"9","status":"M","submitter":"Mark Thomas"},{"authorTime":"2016-09-09 20:59:02","codes":[{"authorDate":"2017-01-10 23:22:47","commitOrder":22,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2017-01-10 23:22:47","endLine":322,"groupId":"12369","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/bc/69ba7296b691bafb0834e458d07cf5fff7e0dc.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handhakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":207,"status":"M"},{"authorDate":"2016-09-09 20:59:02","commitOrder":22,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socketWrapper.setNegotiatedProtocol(\n                                ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2016-09-09 20:59:02","endLine":250,"groupId":"4666","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/22/bd1ffed9210d129953fcd09c58a5677261c87e.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socketWrapper.setNegotiatedProtocol(\n                                ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"N"}],"commitId":"379eda0a04c3b7e9f94c6b6cae5d13d042c59eac","commitMessage":"@@@Spelling fixes. Patch provided by Josh Soref.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1778141 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2017-01-10 23:22:47","modifiedFileCount":"35","status":"M","submitter":"Violeta Georgieva Georgieva"},{"authorTime":"2017-01-20 08:12:16","codes":[{"authorDate":"2017-01-20 08:12:16","commitOrder":23,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2017-01-20 08:12:16","endLine":329,"groupId":"12369","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/3b/42bd66938b07785cdfadfba2b822ad87773857.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socket.setNegotiatedProtocol(((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"M"},{"authorDate":"2017-01-20 08:12:16","commitOrder":23,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2017-01-20 08:12:16","endLine":261,"groupId":"4666","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a5/22e7b92313bceffc753cbd2a60c52e39465e9f.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols() && sslEngine instanceof SSLUtil.ProtocolInfo) {\n                        socketWrapper.setNegotiatedProtocol(\n                                ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"5ac9eaf7144ce1f8d21955f0fb4e4f5e6d84c91d","commitMessage":"@@@Adding ALPN support for JSSE with Java 9\nEnable ALPN and also.  therefore.  HTTP/2 for the NIO and NIO2 HTTP connectors when using the JSSE implementation for TLS when running on Java 9.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1779545 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2017-01-20 08:12:16","modifiedFileCount":"4","status":"M","submitter":"Mark Thomas"},{"authorTime":"2017-01-20 08:12:16","codes":[{"authorDate":"2017-08-09 03:29:55","commitOrder":24,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read = sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS).intValue();\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2017-08-09 03:29:55","endLine":332,"groupId":"12369","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ed/c9d5d9cb8420e2fdfe0e6a40c96186250afe14.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"M"},{"authorDate":"2017-01-20 08:12:16","commitOrder":24,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2017-01-20 08:12:16","endLine":261,"groupId":"4666","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a5/22e7b92313bceffc753cbd2a60c52e39465e9f.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"N"}],"commitId":"aba1417937a553f3ca12244af72b52f9f230efe8","commitMessage":"@@@Improve the handling of client disconnections during the TLS renegotiation handshake.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1804463 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2017-08-09 03:29:55","modifiedFileCount":"8","status":"M","submitter":"Mark Thomas"},{"authorTime":"2017-01-20 08:12:16","codes":[{"authorDate":"2018-01-05 17:36:40","commitOrder":25,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read = sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS).intValue();\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2018-01-05 17:36:40","endLine":336,"groupId":"12369","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/3e/ff0fe9b8ba8564b76383819b2e61146c5d6719.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read = sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS).intValue();\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"M"},{"authorDate":"2017-01-20 08:12:16","commitOrder":25,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2017-01-20 08:12:16","endLine":261,"groupId":"4666","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a5/22e7b92313bceffc753cbd2a60c52e39465e9f.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"N"}],"commitId":"c4b4ded24966ae0d164f5220e0e6e6c34a16a2da","commitMessage":"@@@Following a report on the user list.  the \"buffer full\" check and clear seems misplaced for NIO2.  and should happen before a read.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1820272 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2018-01-05 17:36:40","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2018-02-15 20:05:55","codes":[{"authorDate":"2018-02-15 20:05:55","commitOrder":26,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read = sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS).intValue();\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2018-02-15 20:05:55","endLine":336,"groupId":"12369","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ac/f0aca4a7466da24314b1a36df52fc14dd883cf.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read = sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS).intValue();\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshakeStatus));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"M"},{"authorDate":"2018-02-15 20:05:55","commitOrder":26,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2018-02-15 20:05:55","endLine":259,"groupId":"4666","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ae/9abbbc2d76be3e0c9b87ecd5c39f78c2030070.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else if (handshake.getStatus() == Status.BUFFER_OVERFLOW) {\n                        getBufHandler().configureReadBufferForWrite();\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshakeStatus));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"eaccc5b36507efc50ab5a28e31284bc2ce601851","commitMessage":"@@@Overflow during handshake is an invalid situation.  so fix the NIO handshake. Also improve the error message with the actual status.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1824301 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2018-02-15 20:05:55","modifiedFileCount":"2","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2018-02-15 20:05:55","codes":[{"authorDate":"2018-05-30 16:07:46","commitOrder":27,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                    TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read = sc.read(netInBuffer).get(Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                        TimeUnit.MILLISECONDS).intValue();\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2018-05-30 16:07:46","endLine":350,"groupId":"12369","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/00/5a1315aed0c4d6a6ac7c2218e02d7629460536.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read = sc.read(netInBuffer).get(endpoint.getConnectionTimeout(),\n                                        TimeUnit.MILLISECONDS).intValue();\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"},{"authorDate":"2018-02-15 20:05:55","commitOrder":27,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2018-02-15 20:05:55","endLine":259,"groupId":"4666","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ae/9abbbc2d76be3e0c9b87ecd5c39f78c2030070.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"N"}],"commitId":"f939d43746e5b5fb8d34b666cd619e5ee83eb220","commitMessage":"@@@Add missing timeout on handshake IO operations for NIO2.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1832519 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2018-05-30 16:07:46","modifiedFileCount":"1","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2018-02-15 20:05:55","codes":[{"authorDate":"2018-05-31 04:46:02","commitOrder":28,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, Nio2Endpoint.toNio2Timeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, Nio2Endpoint.toNio2Timeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2018-05-31 04:46:02","endLine":361,"groupId":"9298","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/b0/202b706a05d7acfd923609abcde9cee8f25d3c.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                sc.write(netOutBuffer).get(Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                        TimeUnit.MILLISECONDS);\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                    TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read = sc.read(netInBuffer).get(Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),\n                                        TimeUnit.MILLISECONDS).intValue();\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"},{"authorDate":"2018-02-15 20:05:55","commitOrder":28,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2018-02-15 20:05:55","endLine":259,"groupId":"4666","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ae/9abbbc2d76be3e0c9b87ecd5c39f78c2030070.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"N"}],"commitId":"9848fa581d9a2619581782874f6b53cdfd5e1c42","commitMessage":"@@@Rework timeout a bit.  to align with the API (read and write from async channel without timeout use 0 in NIO2; Future.get(infinite) is not as efficient as get()).\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1832572 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2018-05-31 04:46:02","modifiedFileCount":"3","status":"M","submitter":"Remy Maucherat"},{"authorTime":"2018-02-15 20:05:55","codes":[{"authorDate":"2019-03-29 17:33:01","commitOrder":29,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2019-03-29 17:33:01","endLine":361,"groupId":"9298","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/cb/670aece79ad542291ccc517d7b94d99fae76c4.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, Nio2Endpoint.toNio2Timeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, Nio2Endpoint.toNio2Timeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"},{"authorDate":"2018-02-15 20:05:55","commitOrder":29,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2018-02-15 20:05:55","endLine":259,"groupId":"4666","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ae/9abbbc2d76be3e0c9b87ecd5c39f78c2030070.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"N"}],"commitId":"27f06bca46a20cb3faab1221fca7bfd8e88bceda","commitMessage":"@@@Move timeout utility method to use it in two additional locations","date":"2019-03-29 17:33:01","modifiedFileCount":"4","status":"M","submitter":"remm"},{"authorTime":"2019-05-23 04:50:22","codes":[{"authorDate":"2019-03-29 17:33:01","commitOrder":30,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2019-03-29 17:33:01","endLine":361,"groupId":"9298","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/cb/670aece79ad542291ccc517d7b94d99fae76c4.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"N"},{"authorDate":"2019-05-23 04:50:22","commitOrder":30,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2019-05-23 04:50:22","endLine":259,"groupId":"4666","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/6f/32cf373764b845e3182723d064766e4abd4c76.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) return SelectionKey.OP_WRITE; \r\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch ( handshakeStatus ) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete?0:SelectionKey.OP_WRITE;\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if ( handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer)) ) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if ( handshake.getStatus() == Status.OK ) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\r\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"cbe9c72d78ddf450d19e7ffe846cdc328c337b0b","commitMessage":"@@@Code style\n\nThere's a lot of code in common in SecureNioXChannel.  so cleanup before\nlooking at it.","date":"2019-05-23 04:50:22","modifiedFileCount":"2","status":"M","submitter":"remm"},{"authorTime":"2019-05-23 04:50:22","codes":[{"authorDate":"2019-10-03 00:10:19","commitOrder":31,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2019-10-03 00:10:19","endLine":362,"groupId":"9298","id":53,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/54/d9e0302d0858a85edf4290b5b43ec837d3ae82.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socket.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socket.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"M"},{"authorDate":"2019-05-23 04:50:22","commitOrder":31,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2019-05-23 04:50:22","endLine":259,"groupId":"4666","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/6f/32cf373764b845e3182723d064766e4abd4c76.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"N"}],"commitId":"e68e41700fd7235bc29f47c40624ee2da5c90698","commitMessage":"@@@Harmonize names with NIO","date":"2019-10-03 00:10:19","modifiedFileCount":"3","status":"M","submitter":"remm"},{"authorTime":"2020-05-09 00:36:10","codes":[{"authorDate":"2020-05-09 00:36:10","commitOrder":32,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2020-05-09 00:36:10","endLine":362,"groupId":"9298","id":55,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/39/4837ce20127d4389cad83287f874c704047518.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"M"},{"authorDate":"2020-05-09 00:36:10","commitOrder":32,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2020-05-09 00:36:10","endLine":233,"groupId":"4666","id":56,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a1/7667539c251f5796f0b5034e91640968edadf3.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isJre9Available()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"M"}],"commitId":"19ce5009930289f59e63250592f894aaa53cf302","commitMessage":"@@@Add support for ALPN on Java 8\n\nHTTP/2 with a browser does work for me now. Feel free to test.  it needs\na very recent Java 8.\nIt is also possible to get rid of the reflection and JreCompat for ALPN. \nbut it would create a hard dependency on the newest Java 8s. OTOH. \nprevious releases will soon be insecure so update is more or less\nrequired. I will start with that change in Tomcat 10.  and it could be\nbackported later to Tomcat 9 and 8.5.  when we consider not using a\ncompatible Java 8 is a problem.","date":"2020-05-09 00:36:10","modifiedFileCount":"6","status":"M","submitter":"remm"},{"authorTime":"2020-07-03 16:37:58","codes":[{"authorDate":"2020-07-03 16:37:58","commitOrder":33,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        socketWrapper.setNegotiatedProtocol(sslEngine.getApplicationProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2020-07-03 16:37:58","endLine":355,"groupId":"9298","id":57,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/3d/b103870d9911164a2ede7d6cda87b9c495a9b4.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":219,"status":"M"},{"authorDate":"2020-07-03 16:37:58","commitOrder":33,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        socketWrapper.setNegotiatedProtocol(sslEngine.getApplicationProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2020-07-03 16:37:58","endLine":226,"groupId":"4666","id":58,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/ef/0a33eb6107743bdc88dc1d7cf9462c76983771.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"}],"commitId":"7763877a98e5c74bb579b64f31e938fea17290a5","commitMessage":"@@@Direct use of the ALPN API\n\nTomcat 10 will now require at least Java 8_251.  which was released in\nApril 2020.  for TLS support. Any Java 9+ JVM will work too.\nThis will not be backported to Tomcat 9.0 as it slightly changes the\nAPIs.  although the changes are trivial.","date":"2020-07-03 16:37:58","modifiedFileCount":"9","status":"M","submitter":"remm"},{"authorTime":"2020-07-03 17:16:24","codes":[{"authorDate":"2020-07-03 17:16:24","commitOrder":34,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2020-07-03 17:16:24","endLine":362,"groupId":"9298","id":59,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/39/4837ce20127d4389cad83287f874c704047518.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        socketWrapper.setNegotiatedProtocol(sslEngine.getApplicationProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"M"},{"authorDate":"2020-07-03 17:16:24","commitOrder":34,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2020-07-03 17:16:24","endLine":233,"groupId":"4666","id":60,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a1/7667539c251f5796f0b5034e91640968edadf3.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        socketWrapper.setNegotiatedProtocol(sslEngine.getApplicationProtocol());\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"M"}],"commitId":"35d84487fd10bfd6f2a00494078a5e3eef1b1830","commitMessage":"@@@Revert \"Direct use of the ALPN API\"\n\nThis reverts commit 7763877a98e5c74bb579b64f31e938fea17290a5.\n","date":"2020-07-03 17:16:24","modifiedFileCount":"9","status":"M","submitter":"remm"},{"authorTime":"2020-07-03 17:16:24","codes":[{"authorDate":"2021-05-27 02:27:37","commitOrder":35,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2021-05-27 02:27:58","endLine":369,"groupId":"9298","id":61,"instanceNumber":1,"isCurCommit":0,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/f0/e4bb7636cbf6ae39ef924f1e18bca99656884d.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK)\n                            handshakeStatus = tasks();\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":225,"status":"M"},{"authorDate":"2020-07-03 17:16:24","commitOrder":35,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2020-07-03 17:16:24","endLine":233,"groupId":"4666","id":62,"instanceNumber":2,"isCurCommit":0,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/a1/7667539c251f5796f0b5034e91640968edadf3.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"N"}],"commitId":"1bb4e9fcb1242819205724873142b0524dcd40f4","commitMessage":"@@@Code clean-up. Add braces to improve clarity\n\nAgain.  mainly to trigger CI to test configuration changes.","date":"2021-05-27 02:27:58","modifiedFileCount":"39","status":"M","submitter":"Mark Thomas"},{"authorTime":"2021-07-28 20:16:59","codes":[{"authorDate":"2021-07-28 20:16:59","commitOrder":36,"curCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else {\n                            socketWrapper.setNegotiatedProtocol(sslEngine.getApplicationProtocol());\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","date":"2021-07-28 20:16:59","endLine":367,"groupId":"10411","id":63,"instanceNumber":1,"isCurCommit":1,"methodName":"handshakeInternal","params":"(booleanasync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/56/a9ebf51e6561a693950c4c34fe72f4203f9140.src","preCode":"    protected int handshakeInternal(boolean async) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        SSLEngineResult handshake = null;\n        long timeout = endpoint.getConnectionTimeout();\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING: {\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                }\n                case FINISHED: {\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    if (handshakeComplete) {\n                        return 0;\n                    } else {\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                }\n                case NEED_WRAP: {\n                    \r\n                    try {\n                        handshake = handshakeWrap();\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap();\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || netOutBuffer.remaining() > 0) {\n                        \r\n                        if (async) {\n                            sc.write(netOutBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeWriteCompletionHandler);\n                        } else {\n                            try {\n                                if (timeout > 0) {\n                                    sc.write(netOutBuffer).get(timeout, TimeUnit.MILLISECONDS);\n                                } else {\n                                    sc.write(netOutBuffer).get();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    }\n                    \r\n                    \r\n                }\n                \r\n                case NEED_UNWRAP: {\n                    \r\n                    handshake = handshakeUnwrap();\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.BUFFER_UNDERFLOW) {\n                        if (netInBuffer.position() == netInBuffer.limit()) {\n                            \r\n                            netInBuffer.clear();\n                        }\n                        \r\n                        if (async) {\n                            sc.read(netInBuffer, AbstractEndpoint.toTimeout(timeout),\n                                    TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);\n                        } else {\n                            try {\n                                int read;\n                                if (timeout > 0) {\n                                    read = sc.read(netInBuffer).get(timeout, TimeUnit.MILLISECONDS).intValue();\n                                } else {\n                                    read = sc.read(netInBuffer).get().intValue();\n                                }\n                                if (read == -1) {\n                                    throw new EOFException();\n                                }\n                            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n                                throw new IOException(sm.getString(\"channel.nio.ssl.handshakeError\"));\n                            }\n                        }\n                        return 1;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringUnwrap\", handshake.getStatus()));\n                    }\n                    break;\n                }\n                case NEED_TASK: {\n                    handshakeStatus = tasks();\n                    break;\n                }\n                default: throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return handshakeComplete ? 0 : handshakeInternal(async);\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNio2Channel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"},{"authorDate":"2021-07-28 20:16:59","commitOrder":36,"curCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else {\n                            socketWrapper.setNegotiatedProtocol(sslEngine.getApplicationProtocol());\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","date":"2021-07-28 20:16:59","endLine":236,"groupId":"10411","id":64,"instanceNumber":2,"isCurCommit":1,"methodName":"handshake","params":"(booleanread@booleanwrite)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-tomcat-10-0.7/blobInfo/CC_OUT/blobs/e3/fc746ab65c40d9970edbc761f554e59a87eba9.src","preCode":"    public int handshake(boolean read, boolean write) throws IOException {\n        if (handshakeComplete) {\n            return 0; \r\n        }\n\n        if (!sniComplete) {\n            int sniResult = processSNI();\n            if (sniResult == 0) {\n                sniComplete = true;\n            } else {\n                return sniResult;\n            }\n        }\n\n        if (!flush(netOutBuffer)) {\n            return SelectionKey.OP_WRITE; \r\n        }\n\n        SSLEngineResult handshake = null;\n\n        while (!handshakeComplete) {\n            switch (handshakeStatus) {\n                case NOT_HANDSHAKING:\n                    \r\n                    throw new IOException(sm.getString(\"channel.nio.ssl.notHandshaking\"));\n                case FINISHED:\n                    if (endpoint.hasNegotiableProtocols()) {\n                        if (sslEngine instanceof SSLUtil.ProtocolInfo) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    ((SSLUtil.ProtocolInfo) sslEngine).getNegotiatedProtocol());\n                        } else if (JreCompat.isAlpnSupported()) {\n                            socketWrapper.setNegotiatedProtocol(\n                                    JreCompat.getInstance().getApplicationProtocol(sslEngine));\n                        }\n                    }\n                    \r\n                    handshakeComplete = !netOutBuffer.hasRemaining();\n                    \r\n                    return handshakeComplete ? 0 : SelectionKey.OP_WRITE;\n                case NEED_WRAP:\n                    \r\n                    try {\n                        handshake = handshakeWrap(write);\n                    } catch (SSLException e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\"channel.nio.ssl.wrapException\"), e);\n                        }\n                        handshake = handshakeWrap(write);\n                    }\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if (handshake.getStatus() == Status.CLOSED) {\n                        flush(netOutBuffer);\n                        return -1;\n                    } else {\n                        \r\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    if (handshakeStatus != HandshakeStatus.NEED_UNWRAP || (!flush(netOutBuffer))) {\n                        \r\n                        return SelectionKey.OP_WRITE;\n                    }\n                    \r\n                    \r\n                \r\n                case NEED_UNWRAP:\n                    \r\n                    handshake = handshakeUnwrap(read);\n                    if (handshake.getStatus() == Status.OK) {\n                        if (handshakeStatus == HandshakeStatus.NEED_TASK) {\n                            handshakeStatus = tasks();\n                        }\n                    } else if ( handshake.getStatus() == Status.BUFFER_UNDERFLOW ){\n                        \r\n                        return SelectionKey.OP_READ;\n                    } else {\n                        throw new IOException(sm.getString(\"channel.nio.ssl.unexpectedStatusDuringWrap\", handshake.getStatus()));\n                    }\n                    break;\n                case NEED_TASK:\n                    handshakeStatus = tasks();\n                    break;\n                default:\n                    throw new IllegalStateException(sm.getString(\"channel.nio.ssl.invalidStatus\", handshakeStatus));\n            }\n        }\n        \r\n        return 0;\n    }\n","realPath":"java/org/apache/tomcat/util/net/SecureNioChannel.java","repoName":"tomcat","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"}],"commitId":"3a062482563222cb86742bf844f5c2fa7ed9fe2d","commitMessage":"@@@Remove use of JreCompat as it is not required with Java 11+","date":"2021-07-28 20:16:59","modifiedFileCount":"2","status":"M","submitter":"Mark Thomas"}]
