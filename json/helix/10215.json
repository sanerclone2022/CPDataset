[{"authorTime":"2013-10-19 06:26:36","codes":[{"authorDate":"2013-10-19 06:26:36","commitOrder":1,"curCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    final String instanceName = \"localhost_12918\";\n    MockParticipant participant = new MockParticipant(clusterName, instanceName, ZK_ADDR, null);\n    participant.syncStart();\n\n    final ZkClient client = participant.getManager().getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n    client.unsubscribeStateChanges(listener);\n    \r\n    LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n    Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n        return liveInstance == null;\n      }\n    }, 3 * 1000);\n    Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2013-10-19 06:26:36","endLine":193,"groupId":"1449","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testParticipantFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/b1/0fb960f8ca22e8a62a64e0386cf06a6dab78b9.src","preCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    final String instanceName = \"localhost_12918\";\n    MockParticipant participant = new MockParticipant(clusterName, instanceName, ZK_ADDR, null);\n    participant.syncStart();\n\n    final ZkClient client = participant.getManager().getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n    client.unsubscribeStateChanges(listener);\n    \r\n    LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n    Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n        return liveInstance == null;\n      }\n    }, 3 * 1000);\n    Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"B"},{"authorDate":"2013-10-19 06:26:36","commitOrder":1,"curCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    ClusterController controller = new ClusterController(clusterName, \"controller\", ZK_ADDR);\n    controller.syncStart();\n\n    final ZkClient client = controller.getManager().getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n\n    \r\n    LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n    Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n        return leader == null;\n      }\n    }, 5 * 1000);\n    Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2013-10-19 06:26:36","endLine":271,"groupId":"1450","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testControllerFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/b1/0fb960f8ca22e8a62a64e0386cf06a6dab78b9.src","preCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    ClusterController controller = new ClusterController(clusterName, \"controller\", ZK_ADDR);\n    controller.syncStart();\n\n    final ZkClient client = controller.getManager().getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n\n    \r\n    LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n    Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n        return leader == null;\n      }\n    }, 5 * 1000);\n    Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"B"}],"commitId":"7db3d060e99aa06e4241401485e37c65bb6e2298","commitMessage":"@@@Merge branch 'helix-0.6.2-release' of https://git-wip-us.apache.org/repos/asf/incubator-helix into helix-0.6.2-release\n","date":"2013-10-19 06:26:36","modifiedFileCount":"2","status":"B","submitter":"Kanak Biscuitwala"},{"authorTime":"2013-10-25 09:35:16","codes":[{"authorDate":"2013-10-25 09:35:16","commitOrder":2,"curCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    final String instanceName = \"localhost_12918\";\n    MockParticipantManager participant =\n        new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n    participant.syncStart();\n\n    final ZkClient client = participant.getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n    client.unsubscribeStateChanges(listener);\n    \r\n    LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n    Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n        return liveInstance == null;\n      }\n    }, 3 * 1000);\n    Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2013-10-25 09:35:16","endLine":194,"groupId":"1449","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testParticipantFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/37/709fcd40d455b5c8eb38bbedf6aaff16d154f8.src","preCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    final String instanceName = \"localhost_12918\";\n    MockParticipant participant = new MockParticipant(clusterName, instanceName, ZK_ADDR, null);\n    participant.syncStart();\n\n    final ZkClient client = participant.getManager().getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n    client.unsubscribeStateChanges(listener);\n    \r\n    LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n    Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n        return liveInstance == null;\n      }\n    }, 3 * 1000);\n    Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2013-10-25 09:35:16","commitOrder":2,"curCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    ClusterControllerManager controller =\n        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller\");\n    controller.syncStart();\n\n    final ZkClient client = controller.getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n\n    \r\n    LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n    Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n        return leader == null;\n      }\n    }, 5 * 1000);\n    Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2013-10-25 09:35:16","endLine":273,"groupId":"1450","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testControllerFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/37/709fcd40d455b5c8eb38bbedf6aaff16d154f8.src","preCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    ClusterController controller = new ClusterController(clusterName, \"controller\", ZK_ADDR);\n    controller.syncStart();\n\n    final ZkClient client = controller.getManager().getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n\n    \r\n    LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n    Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n        return leader == null;\n      }\n    }, 5 * 1000);\n    Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"M"}],"commitId":"5c7721970eef78e2d13d35b4934b07cb11a03cd9","commitMessage":"@@@Merge branch 'helix-0.6.2-release' of https://git-wip-us.apache.org/repos/asf/incubator-helix into helix-0.6.2-release\n","date":"2013-10-25 09:35:16","modifiedFileCount":"105","status":"M","submitter":"Kanak Biscuitwala"},{"authorTime":"2018-05-22 09:19:48","codes":[{"authorDate":"2018-05-22 09:19:48","commitOrder":3,"curCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD, Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      final String instanceName = \"localhost_12918\";\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n      participant.syncStart();\n\n      final ZkClient client = participant.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < _disconnectThreshold; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(new Verifier() {\n\n          @Override\n          public boolean verify() throws Exception {\n            return listener.count == expectDisconnectCnt.get();\n          }\n        }, 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n      client.unsubscribeStateChanges(listener);\n      \r\n      LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n      Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return client.getShutdownTrigger();\n        }\n      }, 30 * 1000);\n\n      Assert.assertTrue(success, \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(new TestHelper.Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n          return liveInstance == null;\n        }\n      }, 3 * 1000);\n      Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2018-07-14 04:56:56","endLine":224,"groupId":"2711","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testParticipantFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/5a/cae6cb3f17729244f23dc42a5a322b49d53a0c.src","preCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    final String instanceName = \"localhost_12918\";\n    MockParticipantManager participant =\n        new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n    participant.syncStart();\n\n    final ZkClient client = participant.getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n    client.unsubscribeStateChanges(listener);\n    \r\n    LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n    Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n        return liveInstance == null;\n      }\n    }, 3 * 1000);\n    Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"},{"authorDate":"2018-05-22 09:19:48","commitOrder":3,"curCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD, Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      ClusterControllerManager controller =\n          new ClusterControllerManager(ZK_ADDR, clusterName, \"controller\");\n      controller.syncStart();\n\n      final ZkClient client = controller.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < n; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(new Verifier() {\n\n          @Override\n          public boolean verify() throws Exception {\n            return listener.count == expectDisconnectCnt.get();\n          }\n        }, 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n\n      \r\n      LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n      Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return client.getShutdownTrigger();\n        }\n      }, 30 * 1000);\n\n      Assert.assertTrue(success, \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(new TestHelper.Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n          return leader == null;\n        }\n      }, 5 * 1000);\n      Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2018-07-14 04:56:56","endLine":308,"groupId":"2712","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testControllerFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/5a/cae6cb3f17729244f23dc42a5a322b49d53a0c.src","preCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n        \"localhost\", \r\n        \"TestDB\", \r\n        1, \r\n        32, \r\n        1, \r\n        1, \r\n        \"MasterSlave\", false);\n\n    ClusterControllerManager controller =\n        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller\");\n    controller.syncStart();\n\n    final ZkClient client = controller.getZkClient();\n    final ZkStateCountListener listener = new ZkStateCountListener();\n    client.subscribeStateChanges(listener);\n\n    final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n    final int n = ZKHelixManager.MAX_DISCONNECT_THRESHOLD;\n    for (int i = 0; i < n; i++) {\n      String oldSessionId = ZkTestHelper.getSessionId(client);\n      ZkTestHelper.simulateZkStateDisconnected(client);\n      expectDisconnectCnt.incrementAndGet();\n      \r\n      TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return listener.count == expectDisconnectCnt.get();\n        }\n      }, 30 * 1000);\n\n      String newSessionId = ZkTestHelper.getSessionId(client);\n      Assert.assertEquals(newSessionId, oldSessionId);\n    }\n\n    \r\n    LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n    Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n    \r\n    ZkTestHelper.simulateZkStateDisconnected(client);\n    \r\n    boolean success = TestHelper.verify(new Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        return client.getShutdownTrigger();\n      }\n    }, 30 * 1000);\n\n    Assert.assertTrue(success, \"The \" + (n + 1)\n        + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n    \r\n    success = TestHelper.verify(new TestHelper.Verifier() {\n\n      @Override\n      public boolean verify() throws Exception {\n        LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n        return leader == null;\n      }\n    }, 5 * 1000);\n    Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"M"}],"commitId":"f1a900e465725028ffd77a0699334c1290661fd7","commitMessage":"@@@Fix zkclient state related check and some potential bugs.\n\nChange the connection flapping check to tolerate high threshold. This feature is going to be deprecated in the future.\n\nAdditional changes\n1. Remove duplicate test TestZkManagerFlappingDetection that already covered by TestZkFlapping.\n","date":"2018-07-14 04:56:56","modifiedFileCount":"10","status":"M","submitter":"Jiajun Wang"},{"authorTime":"2018-09-27 02:39:42","codes":[{"authorDate":"2018-09-27 02:39:42","commitOrder":4,"curCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD, Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      final String instanceName = \"localhost_12918\";\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n      participant.syncStart();\n\n      final ZkClient client = (ZkClient) participant.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < _disconnectThreshold; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(new Verifier() {\n\n          @Override\n          public boolean verify() throws Exception {\n            return listener.count == expectDisconnectCnt.get();\n          }\n        }, 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n      client.unsubscribeStateChanges(listener);\n      \r\n      LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n      Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return client.getShutdownTrigger();\n        }\n      }, 30 * 1000);\n\n      Assert.assertTrue(success, \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(new TestHelper.Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n          return liveInstance == null;\n        }\n      }, 3 * 1000);\n      Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2018-10-30 09:15:22","endLine":145,"groupId":"2711","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testParticipantFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f7/3450281d7fd0ebb07b81a93e553a44896e0244.src","preCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD, Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      final String instanceName = \"localhost_12918\";\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n      participant.syncStart();\n\n      final ZkClient client = participant.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < _disconnectThreshold; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(new Verifier() {\n\n          @Override\n          public boolean verify() throws Exception {\n            return listener.count == expectDisconnectCnt.get();\n          }\n        }, 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n      client.unsubscribeStateChanges(listener);\n      \r\n      LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n      Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return client.getShutdownTrigger();\n        }\n      }, 30 * 1000);\n\n      Assert.assertTrue(success, \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(new TestHelper.Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n          return liveInstance == null;\n        }\n      }, 3 * 1000);\n      Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2018-09-27 02:39:42","commitOrder":4,"curCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD, Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      ClusterControllerManager controller =\n          new ClusterControllerManager(ZK_ADDR, clusterName, \"controller\");\n      controller.syncStart();\n\n      final ZkClient client = (ZkClient) controller.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < n; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(new Verifier() {\n\n          @Override\n          public boolean verify() throws Exception {\n            return listener.count == expectDisconnectCnt.get();\n          }\n        }, 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n\n      \r\n      LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n      Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return client.getShutdownTrigger();\n        }\n      }, 30 * 1000);\n\n      Assert.assertTrue(success, \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(new TestHelper.Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n          return leader == null;\n        }\n      }, 5 * 1000);\n      Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2018-10-30 09:15:22","endLine":229,"groupId":"0","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testControllerFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f7/3450281d7fd0ebb07b81a93e553a44896e0244.src","preCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD, Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      ClusterControllerManager controller =\n          new ClusterControllerManager(ZK_ADDR, clusterName, \"controller\");\n      controller.syncStart();\n\n      final ZkClient client = controller.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < n; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(new Verifier() {\n\n          @Override\n          public boolean verify() throws Exception {\n            return listener.count == expectDisconnectCnt.get();\n          }\n        }, 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n\n      \r\n      LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n      Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return client.getShutdownTrigger();\n        }\n      }, 30 * 1000);\n\n      Assert.assertTrue(success, \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(new TestHelper.Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n          return leader == null;\n        }\n      }, 5 * 1000);\n      Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":148,"status":"M"}],"commitId":"9d7364d7abba3932a1b25e96e4eb9dd3e203cec9","commitMessage":"@@@Using HelixZkClient to replace ZkClient in helix-core and helix-rest.\n\n1. Replace as much usage as possible. For the raw ZkClient tests.  the usages are kept.\n2. For backward compatibility.  some public interfaces still returns ZkClient. Marks them as Deprecated.\n","date":"2018-10-30 09:15:22","modifiedFileCount":"60","status":"M","submitter":"Jiajun Wang"},{"authorTime":"2019-05-04 08:52:17","codes":[{"authorDate":"2019-05-04 08:52:17","commitOrder":5,"curCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD,\n        Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      final String instanceName = \"localhost_12918\";\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n      participant.syncStart();\n\n      final ZkClient client = (ZkClient) participant.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < _disconnectThreshold; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(() -> listener.count == expectDisconnectCnt.get(), 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n      client.unsubscribeStateChanges(listener);\n      \r\n      LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n      Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(client::getShutdownTrigger, 30 * 1000);\n\n      Assert.assertTrue(success,\n          \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(() -> {\n        LiveInstance liveInstance1 = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n        return liveInstance1 == null;\n      }, 3 * 1000);\n      Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n      participant.syncStop();\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2019-05-25 09:19:21","endLine":131,"groupId":"10215","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testParticipantFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/5a/d5212067c97d73f4e49f71680e28047a11933d.src","preCode":"  public void testParticipantFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD, Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      final String instanceName = \"localhost_12918\";\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n      participant.syncStart();\n\n      final ZkClient client = (ZkClient) participant.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < _disconnectThreshold; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(new Verifier() {\n\n          @Override\n          public boolean verify() throws Exception {\n            return listener.count == expectDisconnectCnt.get();\n          }\n        }, 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n      client.unsubscribeStateChanges(listener);\n      \r\n      LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n      Assert.assertNotNull(liveInstance, \"Live-instance should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return client.getShutdownTrigger();\n        }\n      }, 30 * 1000);\n\n      Assert.assertTrue(success, \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(new TestHelper.Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n          return liveInstance == null;\n        }\n      }, 3 * 1000);\n      Assert.assertTrue(success, \"Live-instance should be gone after \" + (n + 1) + \" disconnects\");\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"M"},{"authorDate":"2019-05-04 08:52:17","commitOrder":5,"curCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD,\n        Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      ClusterControllerManager controller =\n          new ClusterControllerManager(ZK_ADDR, clusterName, \"controller\");\n      controller.syncStart();\n\n      final ZkClient client = (ZkClient) controller.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < n; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(() -> listener.count == expectDisconnectCnt.get(), 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n\n      \r\n      LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n      Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(client::getShutdownTrigger, 30 * 1000);\n\n      Assert.assertTrue(success,\n          \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(() -> {\n        LiveInstance leader1 = accessor.getProperty(keyBuilder.controllerLeader());\n        return leader1 == null;\n      }, 5 * 1000);\n      Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n\n      controller.syncStop();\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2019-05-25 09:19:21","endLine":204,"groupId":"10215","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testControllerFlapping","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/5a/d5212067c97d73f4e49f71680e28047a11933d.src","preCode":"  public void testControllerFlapping() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    final HelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    System.setProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD, Integer.toString(_disconnectThreshold));\n\n    try {\n      TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, \r\n          \"localhost\", \r\n          \"TestDB\", \r\n          1, \r\n          32, \r\n          1, \r\n          1, \r\n          \"MasterSlave\", false);\n\n      ClusterControllerManager controller =\n          new ClusterControllerManager(ZK_ADDR, clusterName, \"controller\");\n      controller.syncStart();\n\n      final ZkClient client = (ZkClient) controller.getZkClient();\n      final ZkStateCountListener listener = new ZkStateCountListener();\n      client.subscribeStateChanges(listener);\n\n      final AtomicInteger expectDisconnectCnt = new AtomicInteger(0);\n      final int n = _disconnectThreshold;\n      for (int i = 0; i < n; i++) {\n        String oldSessionId = ZkTestHelper.getSessionId(client);\n        ZkTestHelper.simulateZkStateReconnected(client);\n        expectDisconnectCnt.incrementAndGet();\n        \r\n        TestHelper.verify(new Verifier() {\n\n          @Override\n          public boolean verify() throws Exception {\n            return listener.count == expectDisconnectCnt.get();\n          }\n        }, 30 * 1000);\n\n        String newSessionId = ZkTestHelper.getSessionId(client);\n        Assert.assertEquals(newSessionId, oldSessionId);\n      }\n\n      \r\n      LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n      Assert.assertNotNull(leader, \"Leader should exist after \" + n + \" disconnects\");\n\n      \r\n      ZkTestHelper.simulateZkStateReconnected(client);\n      \r\n      boolean success = TestHelper.verify(new Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          return client.getShutdownTrigger();\n        }\n      }, 30 * 1000);\n\n      Assert.assertTrue(success, \"The \" + (n + 1) + \"th disconnect event should trigger ZkHelixManager#disonnect\");\n\n      \r\n      success = TestHelper.verify(new TestHelper.Verifier() {\n\n        @Override\n        public boolean verify() throws Exception {\n          LiveInstance leader = accessor.getProperty(keyBuilder.controllerLeader());\n          return leader == null;\n        }\n      }, 5 * 1000);\n      Assert.assertTrue(success, \"Leader should be gone after \" + (n + 1) + \" disconnects\");\n    } finally {\n      System.clearProperty(SystemPropertyKeys.MAX_DISCONNECT_THRESHOLD);\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkFlapping.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"M"}],"commitId":"5ce3934c5b4655e90021061720adbb3a42b1bb6b","commitMessage":"@@@TEST: Groom and refactor Helix integration tests\n\nIt was observed that there was a lot of technical debt (improper and buggy cleanup) in Helix's unit and integration tests. There were also mock controller and participant threads that were never shut down properly. This was preventing mvn test suite from completing over a remote machine (TMC).  and even on local environments.  mvn test was not passing. This diff refactors tests and makes sure that ZK is cleaned up after tests.\n\nChangelist:\n1. Inspect and correct mock threads (controller.  participant.  spectator.  etc)\n2. Ensure there are no leftover garbage clusters from tests\n3. Java 8 syntax\n4. Style fixes in old tests using Helix open source style file (helix-style.xml)\n\nRB=1654905\nG=helix-reviewers\nA=jxue. eblumena\n\nSigned-off-by: Hunter Lee <hulee@linkedin.com>\n","date":"2019-05-25 09:19:21","modifiedFileCount":"122","status":"M","submitter":"Hunter Lee"}]
