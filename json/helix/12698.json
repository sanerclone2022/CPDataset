[{"authorTime":"2013-08-22 04:42:57","codes":[{"authorDate":"2013-08-22 04:42:57","commitOrder":1,"curCode":"  public void set(ConfigScope scope, Map<String, String> keyValueMap) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster: \" + clusterName + \" is NOT setup.\");\n    }\n\n    if (scope.getScope() == ConfigScopeProperty.PARTICIPANT) {\n      String scopeStr = scope.getScopeStr();\n      String instanceName = scopeStr.substring(scopeStr.lastIndexOf('/') + 1);\n      if (!ZKUtil.isInstanceSetup(zkClient, scope.getClusterName(), instanceName,\n          InstanceType.PARTICIPANT)) {\n        throw new HelixException(\"instance: \" + instanceName + \" is NOT setup in cluster: \"\n            + clusterName);\n      }\n    }\n\n    \r\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.setSimpleField(key, value);\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.getMapField(splits[1]).put(key, value);\n      }\n    }\n    ZKUtil.createOrUpdate(zkClient, splits[0], update, true, true);\n    return;\n  }\n","date":"2013-08-22 04:42:57","endLine":263,"groupId":"3790","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"set","params":"(ConfigScopescope@Map<String@String>keyValueMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/34/aef49b8db5d7f53480f5aa7be772a369c9c4f7.src","preCode":"  public void set(ConfigScope scope, Map<String, String> keyValueMap) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster: \" + clusterName + \" is NOT setup.\");\n    }\n\n    if (scope.getScope() == ConfigScopeProperty.PARTICIPANT) {\n      String scopeStr = scope.getScopeStr();\n      String instanceName = scopeStr.substring(scopeStr.lastIndexOf('/') + 1);\n      if (!ZKUtil.isInstanceSetup(zkClient, scope.getClusterName(), instanceName,\n          InstanceType.PARTICIPANT)) {\n        throw new HelixException(\"instance: \" + instanceName + \" is NOT setup in cluster: \"\n            + clusterName);\n      }\n    }\n\n    \r\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.setSimpleField(key, value);\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.getMapField(splits[1]).put(key, value);\n      }\n    }\n    ZKUtil.createOrUpdate(zkClient, splits[0], update, true, true);\n    return;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/ConfigAccessor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"B"},{"authorDate":"2013-08-22 04:42:57","commitOrder":1,"curCode":"  public void remove(ConfigScope scope, List<String> keys) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster \" + clusterName + \" is not setup yet\");\n    }\n\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      \r\n      for (String key : keys) {\n        update.setSimpleField(key, \"\");\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      \r\n      for (String key : keys) {\n        update.getMapField(splits[1]).put(key, \"\");\n      }\n    }\n\n    ZKUtil.subtract(zkClient, splits[0], update);\n    return;\n  }\n","date":"2013-08-22 04:42:57","endLine":367,"groupId":"4382","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"remove","params":"(ConfigScopescope@List<String>keys)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/34/aef49b8db5d7f53480f5aa7be772a369c9c4f7.src","preCode":"  public void remove(ConfigScope scope, List<String> keys) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster \" + clusterName + \" is not setup yet\");\n    }\n\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      \r\n      for (String key : keys) {\n        update.setSimpleField(key, \"\");\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      \r\n      for (String key : keys) {\n        update.getMapField(splits[1]).put(key, \"\");\n      }\n    }\n\n    ZKUtil.subtract(zkClient, splits[0], update);\n    return;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/ConfigAccessor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":334,"status":"B"}],"commitId":"f414aad4c9b26fc767eaf373f7691f8e0487a598","commitMessage":"@@@[HELIX-198] Unify helix code style.  rb=13710\n","date":"2013-08-22 04:42:57","modifiedFileCount":"597","status":"B","submitter":"zzhang"},{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2017-11-08 08:48:26","commitOrder":2,"curCode":"  public void set(ConfigScope scope, Map<String, String> keyValueMap) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster: \" + clusterName + \" is NOT setup.\");\n    }\n\n    if (scope.getScope() == ConfigScopeProperty.PARTICIPANT) {\n      String scopeStr = scope.getScopeStr();\n      String instanceName = scopeStr.substring(scopeStr.lastIndexOf('/') + 1);\n      if (!ZKUtil.isInstanceSetup(zkClient, scope.getClusterName(), instanceName,\n          InstanceType.PARTICIPANT)) {\n        throw new HelixException(\"instance: \" + instanceName + \" is NOT setup in cluster: \"\n            + clusterName);\n      }\n    }\n\n    \r\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.setSimpleField(key, value);\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.getMapField(splits[1]).put(key, value);\n      }\n    }\n    ZKUtil.createOrMerge(zkClient, splits[0], update, true, true);\n  }\n","date":"2017-11-08 08:48:26","endLine":269,"groupId":"3790","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"set","params":"(ConfigScopescope@Map<String@String>keyValueMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/ef/4669fdd4fdef4525689126141a31d49df3c5dc.src","preCode":"  public void set(ConfigScope scope, Map<String, String> keyValueMap) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster: \" + clusterName + \" is NOT setup.\");\n    }\n\n    if (scope.getScope() == ConfigScopeProperty.PARTICIPANT) {\n      String scopeStr = scope.getScopeStr();\n      String instanceName = scopeStr.substring(scopeStr.lastIndexOf('/') + 1);\n      if (!ZKUtil.isInstanceSetup(zkClient, scope.getClusterName(), instanceName,\n          InstanceType.PARTICIPANT)) {\n        throw new HelixException(\"instance: \" + instanceName + \" is NOT setup in cluster: \"\n            + clusterName);\n      }\n    }\n\n    \r\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.setSimpleField(key, value);\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.getMapField(splits[1]).put(key, value);\n      }\n    }\n    ZKUtil.createOrUpdate(zkClient, splits[0], update, true, true);\n    return;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/ConfigAccessor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":227,"status":"M"},{"authorDate":"2017-11-08 08:48:26","commitOrder":2,"curCode":"  public void remove(ConfigScope scope, List<String> keys) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster \" + clusterName + \" is not setup yet\");\n    }\n\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      \r\n      for (String key : keys) {\n        update.setSimpleField(key, \"\");\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      \r\n      for (String key : keys) {\n        update.getMapField(splits[1]).put(key, \"\");\n      }\n    }\n\n    ZKUtil.subtract(zkClient, splits[0], update);\n  }\n","date":"2017-11-08 08:48:26","endLine":372,"groupId":"4382","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"remove","params":"(ConfigScopescope@List<String>keys)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/ef/4669fdd4fdef4525689126141a31d49df3c5dc.src","preCode":"  public void remove(ConfigScope scope, List<String> keys) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster \" + clusterName + \" is not setup yet\");\n    }\n\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      \r\n      for (String key : keys) {\n        update.setSimpleField(key, \"\");\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      \r\n      for (String key : keys) {\n        update.getMapField(splits[1]).put(key, \"\");\n      }\n    }\n\n    ZKUtil.subtract(zkClient, splits[0], update);\n    return;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/ConfigAccessor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":340,"status":"M"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"M","submitter":"Junkai Xue"},{"authorTime":"2019-11-19 06:03:02","codes":[{"authorDate":"2019-11-19 06:03:02","commitOrder":3,"curCode":"  public void set(ConfigScope scope, Map<String, String> keyValueMap) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) {\n      throw new HelixException(\"cluster: \" + clusterName + \" is NOT setup.\");\n    }\n\n    if (scope.getScope() == ConfigScopeProperty.PARTICIPANT) {\n      String scopeStr = scope.getScopeStr();\n      String instanceName = scopeStr.substring(scopeStr.lastIndexOf('/') + 1);\n      if (!ZKUtil.isInstanceSetup(_zkClient, scope.getClusterName(), instanceName,\n          InstanceType.PARTICIPANT)) {\n        throw new HelixException(\"instance: \" + instanceName + \" is NOT setup in cluster: \"\n            + clusterName);\n      }\n    }\n\n    \r\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.setSimpleField(key, value);\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.getMapField(splits[1]).put(key, value);\n      }\n    }\n    ZKUtil.createOrMerge(_zkClient, splits[0], update, true, true);\n  }\n","date":"2019-11-19 06:03:02","endLine":289,"groupId":"3790","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"set","params":"(ConfigScopescope@Map<String@String>keyValueMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/96/fc9ec36df408d456a43fd3a0abefe6693eb679.src","preCode":"  public void set(ConfigScope scope, Map<String, String> keyValueMap) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster: \" + clusterName + \" is NOT setup.\");\n    }\n\n    if (scope.getScope() == ConfigScopeProperty.PARTICIPANT) {\n      String scopeStr = scope.getScopeStr();\n      String instanceName = scopeStr.substring(scopeStr.lastIndexOf('/') + 1);\n      if (!ZKUtil.isInstanceSetup(zkClient, scope.getClusterName(), instanceName,\n          InstanceType.PARTICIPANT)) {\n        throw new HelixException(\"instance: \" + instanceName + \" is NOT setup in cluster: \"\n            + clusterName);\n      }\n    }\n\n    \r\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.setSimpleField(key, value);\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.getMapField(splits[1]).put(key, value);\n      }\n    }\n    ZKUtil.createOrMerge(zkClient, splits[0], update, true, true);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/ConfigAccessor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":247,"status":"M"},{"authorDate":"2019-11-19 06:03:02","commitOrder":3,"curCode":"  public void remove(ConfigScope scope, List<String> keys) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) {\n      throw new HelixException(\"cluster \" + clusterName + \" is not setup yet\");\n    }\n\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      \r\n      for (String key : keys) {\n        update.setSimpleField(key, \"\");\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      \r\n      for (String key : keys) {\n        update.getMapField(splits[1]).put(key, \"\");\n      }\n    }\n\n    ZKUtil.subtract(_zkClient, splits[0], update);\n  }\n","date":"2019-11-19 06:03:02","endLine":392,"groupId":"4382","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"remove","params":"(ConfigScopescope@List<String>keys)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/96/fc9ec36df408d456a43fd3a0abefe6693eb679.src","preCode":"  public void remove(ConfigScope scope, List<String> keys) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, zkClient)) {\n      throw new HelixException(\"cluster \" + clusterName + \" is not setup yet\");\n    }\n\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      \r\n      for (String key : keys) {\n        update.setSimpleField(key, \"\");\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      \r\n      for (String key : keys) {\n        update.getMapField(splits[1]).put(key, \"\");\n      }\n    }\n\n    ZKUtil.subtract(zkClient, splits[0], update);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/ConfigAccessor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":360,"status":"M"}],"commitId":"9ebdaf709d6b9ffd6dedef7f1aab4cae72ed7290","commitMessage":"@@@Add a ZkAddress-based constructor for ConfigAccessor (#592)\n\nIn order to allow users to not take on the burden of creating an instance of HelixZkClient to use Helix data access APIs (like ConfigAccessor).  we need to add a constructor that takes in a ZK connect string instead.\n\nThis approach has advantages such as 1) the user doesn't have to maintain the lifecycle of the ZkClient 2) add a layer of indirection between ZK and the user where Helix logic could be injected.\n\nAlso close() is added so that the user could close after use.","date":"2019-11-19 06:03:02","modifiedFileCount":"1","status":"M","submitter":"Hunter Lee"},{"authorTime":"2020-03-12 04:25:50","codes":[{"authorDate":"2020-03-12 04:25:50","commitOrder":4,"curCode":"  public void set(ConfigScope scope, Map<String, String> keyValueMap) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null.\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) {\n      throw new HelixException(\"cluster: \" + clusterName + \" is NOT setup.\");\n    }\n\n    if (scope.getScope() == ConfigScopeProperty.PARTICIPANT) {\n      String scopeStr = scope.getScopeStr();\n      String instanceName = scopeStr.substring(scopeStr.lastIndexOf('/') + 1);\n      if (!ZKUtil.isInstanceSetup(_zkClient, scope.getClusterName(), instanceName,\n          InstanceType.PARTICIPANT)) {\n        throw new HelixException(\n            \"instance: \" + instanceName + \" is NOT setup in cluster: \" + clusterName);\n      }\n    }\n\n    \r\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.setSimpleField(key, value);\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.getMapField(splits[1]).put(key, value);\n      }\n    }\n    ZKUtil.createOrMerge(_zkClient, splits[0], update, true, true);\n  }\n","date":"2020-03-12 04:25:50","endLine":295,"groupId":"12698","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"set","params":"(ConfigScopescope@Map<String@String>keyValueMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/15/96ee382d38607b49bd74d61ab1c9c56f4937ed.src","preCode":"  public void set(ConfigScope scope, Map<String, String> keyValueMap) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) {\n      throw new HelixException(\"cluster: \" + clusterName + \" is NOT setup.\");\n    }\n\n    if (scope.getScope() == ConfigScopeProperty.PARTICIPANT) {\n      String scopeStr = scope.getScopeStr();\n      String instanceName = scopeStr.substring(scopeStr.lastIndexOf('/') + 1);\n      if (!ZKUtil.isInstanceSetup(_zkClient, scope.getClusterName(), instanceName,\n          InstanceType.PARTICIPANT)) {\n        throw new HelixException(\"instance: \" + instanceName + \" is NOT setup in cluster: \"\n            + clusterName);\n      }\n    }\n\n    \r\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.setSimpleField(key, value);\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      for (String key : keyValueMap.keySet()) {\n        String value = keyValueMap.get(key);\n        update.getMapField(splits[1]).put(key, value);\n      }\n    }\n    ZKUtil.createOrMerge(_zkClient, splits[0], update, true, true);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/ConfigAccessor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"},{"authorDate":"2020-03-12 04:25:50","commitOrder":4,"curCode":"  public void remove(ConfigScope scope, List<String> keys) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null.\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) {\n      throw new HelixException(\"cluster \" + clusterName + \" is not setup yet\");\n    }\n\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      \r\n      for (String key : keys) {\n        update.setSimpleField(key, \"\");\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      \r\n      for (String key : keys) {\n        update.getMapField(splits[1]).put(key, \"\");\n      }\n    }\n\n    ZKUtil.subtract(_zkClient, splits[0], update);\n  }\n","date":"2020-03-12 04:25:50","endLine":398,"groupId":"12698","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"remove","params":"(ConfigScopescope@List<String>keys)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/15/96ee382d38607b49bd74d61ab1c9c56f4937ed.src","preCode":"  public void remove(ConfigScope scope, List<String> keys) {\n    if (scope == null || scope.getScope() == null) {\n      LOG.error(\"Scope can't be null\");\n      return;\n    }\n\n    String clusterName = scope.getClusterName();\n    if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) {\n      throw new HelixException(\"cluster \" + clusterName + \" is not setup yet\");\n    }\n\n    String scopeStr = scope.getScopeStr();\n    String[] splits = scopeStr.split(\"\\\\|\");\n\n    String id = splits[0].substring(splits[0].lastIndexOf('/') + 1);\n    ZNRecord update = new ZNRecord(id);\n    if (splits.length == 1) {\n      \r\n      for (String key : keys) {\n        update.setSimpleField(key, \"\");\n      }\n    } else if (splits.length == 2) {\n      if (update.getMapField(splits[1]) == null) {\n        update.setMapField(splits[1], new TreeMap<String, String>());\n      }\n      \r\n      for (String key : keys) {\n        update.getMapField(splits[1]).put(key, \"\");\n      }\n    }\n\n    ZKUtil.subtract(_zkClient, splits[0], update);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/ConfigAccessor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":366,"status":"M"}],"commitId":"1651f9edddb86118834c7a1f47f47ed9f5a300ee","commitMessage":"@@@Standardize the logging message format in ClusterAccessor and ConfigAccessor (#886)\n\nThis PR takes advantage of parameterized message provided by slf4j to form logging messages in ClusterAccessor and ConfigAccessor. The parameterized message gives a clear syntax than simply concatenating the strings and variables.","date":"2020-03-12 04:25:50","modifiedFileCount":"2","status":"M","submitter":"Molly Gao"}]
