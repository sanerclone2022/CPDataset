[{"authorTime":"2013-07-27 05:15:04","codes":[{"authorDate":"2013-07-27 05:15:04","commitOrder":1,"curCode":"    private Map<Replica, Node> computeExistingNonPreferredPlacement(\n        Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          boolean skip = false;\n          for(Replica replica: node.preferred){\n            if(replica.partition.equals(partition)){\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          \r\n          for (int i = 0; i < count; i++) {\n            Replica replica = new Replica(partition, state, i);\n            if (_preferredAssignment.get(replica).id != node.id) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n      return existingNonPreferredAssignment;\n    }\n","date":"2013-07-27 05:15:04","endLine":334,"groupId":"2666","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/74/0d17de985c009958f044fecc018654bec377f3.src","preCode":"    private Map<Replica, Node> computeExistingNonPreferredPlacement(\n        Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          boolean skip = false;\n          for(Replica replica: node.preferred){\n            if(replica.partition.equals(partition)){\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          \r\n          for (int i = 0; i < count; i++) {\n            Replica replica = new Replica(partition, state, i);\n            if (_preferredAssignment.get(replica).id != node.id) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n      return existingNonPreferredAssignment;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":303,"status":"B"},{"authorDate":"2013-07-27 05:15:04","commitOrder":1,"curCode":"    private Map<Replica, Node> computeExistingPreferredPlacement(\n        final Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          node.currentlyAssigned = node.currentlyAssigned + 1;\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          \r\n          for (int i = 0; i < count; i++) {\n            Replica replica = new Replica(partition, state, i);\n            if (_preferredAssignment.containsKey(replica)\n                && !existingPreferredAssignment.containsKey(replica)\n                && _preferredAssignment.get(replica).id == node.id) {\n              existingPreferredAssignment.put(replica, node);\n              node.preferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n\n      return existingPreferredAssignment;\n    }\n","date":"2013-07-27 05:15:04","endLine":392,"groupId":"457","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/74/0d17de985c009958f044fecc018654bec377f3.src","preCode":"    private Map<Replica, Node> computeExistingPreferredPlacement(\n        final Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          node.currentlyAssigned = node.currentlyAssigned + 1;\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          \r\n          for (int i = 0; i < count; i++) {\n            Replica replica = new Replica(partition, state, i);\n            if (_preferredAssignment.containsKey(replica)\n                && !existingPreferredAssignment.containsKey(replica)\n                && _preferredAssignment.get(replica).id == node.id) {\n              existingPreferredAssignment.put(replica, node);\n              node.preferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n\n      return existingPreferredAssignment;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":367,"status":"B"}],"commitId":"6c4ba17b5b222ba31f3ec263f5f6c96184aa4ad8","commitMessage":"@@@HELIX-141: Autorebalance does not work reliably and fails when replica>1\n","date":"2013-07-27 05:15:04","modifiedFileCount":"0","status":"B","submitter":"zzhang"},{"authorTime":"2013-07-30 07:21:05","codes":[{"authorDate":"2013-07-30 07:21:05","commitOrder":2,"curCode":"    private Map<Replica, Node> computeExistingNonPreferredPlacement(\n        Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          boolean skip = false;\n          for(Replica replica: node.preferred){\n            if(replica.partition.equals(partition)){\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          \r\n          for (int i = 0; i < count; i++) {\n            int replicaId = _replicaIdMap.get(state).get(i);\n            Replica replica = new Replica(partition, state, replicaId);\n            if (_preferredAssignment.get(replica).id != node.id) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n      return existingNonPreferredAssignment;\n    }\n","date":"2013-07-30 07:21:05","endLine":360,"groupId":"2666","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/9a/998eb82492b269c3e6ee505bbbd0032a55223d.src","preCode":"    private Map<Replica, Node> computeExistingNonPreferredPlacement(\n        Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          boolean skip = false;\n          for(Replica replica: node.preferred){\n            if(replica.partition.equals(partition)){\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          \r\n          for (int i = 0; i < count; i++) {\n            Replica replica = new Replica(partition, state, i);\n            if (_preferredAssignment.get(replica).id != node.id) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n      return existingNonPreferredAssignment;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"M"},{"authorDate":"2013-07-30 07:21:05","commitOrder":2,"curCode":"    private Map<Replica, Node> computeExistingPreferredPlacement(\n        final Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          node.currentlyAssigned = node.currentlyAssigned + 1;\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          \r\n          for (int i = 0; i < count; i++) {\n            int replicaId = _replicaIdMap.get(state).get(i);\n            Replica replica = new Replica(partition, state, replicaId);\n            if (_preferredAssignment.containsKey(replica)\n                && !existingPreferredAssignment.containsKey(replica)\n                && _preferredAssignment.get(replica).id == node.id) {\n              existingPreferredAssignment.put(replica, node);\n              node.preferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n\n      return existingPreferredAssignment;\n    }\n","date":"2013-07-30 07:21:05","endLine":420,"groupId":"457","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/9a/998eb82492b269c3e6ee505bbbd0032a55223d.src","preCode":"    private Map<Replica, Node> computeExistingPreferredPlacement(\n        final Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          node.currentlyAssigned = node.currentlyAssigned + 1;\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          \r\n          for (int i = 0; i < count; i++) {\n            Replica replica = new Replica(partition, state, i);\n            if (_preferredAssignment.containsKey(replica)\n                && !existingPreferredAssignment.containsKey(replica)\n                && _preferredAssignment.get(replica).id == node.id) {\n              existingPreferredAssignment.put(replica, node);\n              node.preferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n\n      return existingPreferredAssignment;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":394,"status":"M"}],"commitId":"1a82168488b06f75506932f0171e9ca17423468c","commitMessage":"@@@HELIX-150: Auto rebalance might not evenly distribute states across nodes\n","date":"2013-07-30 07:21:05","modifiedFileCount":"1","status":"M","submitter":"zzhang"},{"authorTime":"2013-07-30 07:21:05","codes":[{"authorDate":"2013-08-02 04:31:32","commitOrder":3,"curCode":"    private Map<Replica, Node> computeExistingNonPreferredPlacement(\n        Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          boolean skip = false;\n          for(Replica replica: node.preferred){\n            if(replica.partition.equals(partition)){\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          \r\n          for (int i = 0; i < count; i++) {\n            int replicaId = _replicaIdMap.get(state).get(i);\n            Replica replica = new Replica(partition, state, replicaId);\n            if (_preferredAssignment.get(replica).id != node.id\n                && !existingNonPreferredAssignment.containsKey(replica)) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n      return existingNonPreferredAssignment;\n    }\n","date":"2013-08-02 04:31:32","endLine":366,"groupId":"2666","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/23/b451f0e2cbe748fec9c79b6dacb7e37a448881.src","preCode":"    private Map<Replica, Node> computeExistingNonPreferredPlacement(\n        Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          boolean skip = false;\n          for(Replica replica: node.preferred){\n            if(replica.partition.equals(partition)){\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          \r\n          for (int i = 0; i < count; i++) {\n            int replicaId = _replicaIdMap.get(state).get(i);\n            Replica replica = new Replica(partition, state, replicaId);\n            if (_preferredAssignment.get(replica).id != node.id) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n      return existingNonPreferredAssignment;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":333,"status":"M"},{"authorDate":"2013-07-30 07:21:05","commitOrder":3,"curCode":"    private Map<Replica, Node> computeExistingPreferredPlacement(\n        final Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          node.currentlyAssigned = node.currentlyAssigned + 1;\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          \r\n          for (int i = 0; i < count; i++) {\n            int replicaId = _replicaIdMap.get(state).get(i);\n            Replica replica = new Replica(partition, state, replicaId);\n            if (_preferredAssignment.containsKey(replica)\n                && !existingPreferredAssignment.containsKey(replica)\n                && _preferredAssignment.get(replica).id == node.id) {\n              existingPreferredAssignment.put(replica, node);\n              node.preferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n\n      return existingPreferredAssignment;\n    }\n","date":"2013-07-30 07:21:05","endLine":420,"groupId":"457","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/9a/998eb82492b269c3e6ee505bbbd0032a55223d.src","preCode":"    private Map<Replica, Node> computeExistingPreferredPlacement(\n        final Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          node.currentlyAssigned = node.currentlyAssigned + 1;\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          \r\n          for (int i = 0; i < count; i++) {\n            int replicaId = _replicaIdMap.get(state).get(i);\n            Replica replica = new Replica(partition, state, replicaId);\n            if (_preferredAssignment.containsKey(replica)\n                && !existingPreferredAssignment.containsKey(replica)\n                && _preferredAssignment.get(replica).id == node.id) {\n              existingPreferredAssignment.put(replica, node);\n              node.preferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n\n      return existingPreferredAssignment;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":394,"status":"N"}],"commitId":"edd4db8b7a61e6f711938e475e28e11678ed4d40","commitMessage":"@@@HELIX-149: Allow clients to pass in preferred placement strategies\n","date":"2013-08-02 04:31:32","modifiedFileCount":"2","status":"M","submitter":"zzhang"},{"authorTime":"2013-08-02 04:32:29","codes":[{"authorDate":"2013-08-02 04:32:29","commitOrder":4,"curCode":"    private Map<Replica, Node> computeExistingNonPreferredPlacement(\n        Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n      int count = countStateReplicas();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          boolean skip = false;\n          for(Replica replica: node.preferred){\n            if(replica.partition.equals(partition)){\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          \r\n          for (int replicaId = 0; replicaId < count; replicaId++) {\n            Replica replica = new Replica(partition, replicaId);\n            if (_preferredAssignment.get(replica).id != node.id\n                && !_existingPreferredAssignment.containsKey(replica)\n                && !existingNonPreferredAssignment.containsKey(replica)) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n      return existingNonPreferredAssignment;\n    }\n","date":"2013-08-02 04:32:29","endLine":365,"groupId":"3099","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/9d/0e2deb596330667102ce0a5a7171d5a3ad8c53.src","preCode":"    private Map<Replica, Node> computeExistingNonPreferredPlacement(\n        Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          boolean skip = false;\n          for(Replica replica: node.preferred){\n            if(replica.partition.equals(partition)){\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n          \r\n          for (int i = 0; i < count; i++) {\n            int replicaId = _replicaIdMap.get(state).get(i);\n            Replica replica = new Replica(partition, state, replicaId);\n            if (_preferredAssignment.get(replica).id != node.id\n                && !existingNonPreferredAssignment.containsKey(replica)) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n      return existingNonPreferredAssignment;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":333,"status":"M"},{"authorDate":"2013-08-02 04:32:29","commitOrder":4,"curCode":"    private Map<Replica, Node> computeExistingPreferredPlacement(\n        final Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n      int count = countStateReplicas();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          node.currentlyAssigned = node.currentlyAssigned + 1;\n          \r\n          for (int replicaId = 0; replicaId < count; replicaId++) {\n            Replica replica = new Replica(partition, replicaId);\n            if (_preferredAssignment.containsKey(replica)\n                && !existingPreferredAssignment.containsKey(replica)\n                && _preferredAssignment.get(replica).id == node.id) {\n              existingPreferredAssignment.put(replica, node);\n              node.preferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n\n      return existingPreferredAssignment;\n    }\n","date":"2013-08-02 04:32:29","endLine":416,"groupId":"5124","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/9d/0e2deb596330667102ce0a5a7171d5a3ad8c53.src","preCode":"    private Map<Replica, Node> computeExistingPreferredPlacement(\n        final Map<String, Map<String, String>> currentMapping) {\n      Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n      for (String partition : currentMapping.keySet()) {\n        Map<String, String> nodeStateMap = currentMapping.get(partition);\n        for (String nodeId : nodeStateMap.keySet()) {\n          Node node = _nodeMap.get(nodeId);\n          node.currentlyAssigned = node.currentlyAssigned + 1;\n          String state = nodeStateMap.get(nodeId);\n          Integer count = _states.get(state);\n          \r\n          for (int i = 0; i < count; i++) {\n            int replicaId = _replicaIdMap.get(state).get(i);\n            Replica replica = new Replica(partition, state, replicaId);\n            if (_preferredAssignment.containsKey(replica)\n                && !existingPreferredAssignment.containsKey(replica)\n                && _preferredAssignment.get(replica).id == node.id) {\n              existingPreferredAssignment.put(replica, node);\n              node.preferred.add(replica);\n              break;\n            }\n          }\n        }\n      }\n\n      return existingPreferredAssignment;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":392,"status":"M"}],"commitId":"955b99fa4533e861227cf0dbc3aaa7bdd8b3ce9f","commitMessage":"@@@HELIX-154: Auto rebalance algorithm should not depend on state\n","date":"2013-08-02 04:32:29","modifiedFileCount":"1","status":"M","submitter":"zzhang"},{"authorTime":"2014-04-17 07:55:17","codes":[{"authorDate":"2014-04-17 07:55:17","commitOrder":5,"curCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)\n              && !existingNonPreferredAssignment.containsKey(replica)) {\n            existingNonPreferredAssignment.put(replica, node);\n            node.nonPreferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","date":"2014-04-17 07:55:17","endLine":448,"groupId":"3099","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/8286ba4214eeca176d9bcdaf45c2a3dd1cb577.src","preCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)\n              && !existingNonPreferredAssignment.containsKey(replica)) {\n            existingNonPreferredAssignment.put(replica, node);\n            node.nonPreferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":415,"status":"M"},{"authorDate":"2014-04-17 07:55:17","commitOrder":5,"curCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","date":"2014-04-17 07:55:17","endLine":510,"groupId":"536","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/8286ba4214eeca176d9bcdaf45c2a3dd1cb577.src","preCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"M"}],"commitId":"9a1c205d986ca6a60609b2467d264222f01daa16","commitMessage":"@@@[HELIX-433] Fix how FULL_AUTO responds to untagging\n","date":"2014-04-17 07:55:17","modifiedFileCount":"2","status":"M","submitter":"Kanak Biscuitwala"},{"authorTime":"2014-04-17 07:55:17","codes":[{"authorDate":"2014-11-14 09:26:06","commitOrder":6,"curCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)) {\n            if (!existingNonPreferredAssignment.containsKey(replica)) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n            } else {\n              \r\n              \r\n              Node curNode = existingNonPreferredAssignment.get(replica);\n              int curHeadroom = curNode.capacity - curNode.currentlyAssigned;\n              int newHeadroon = node.capacity - node.currentlyAssigned;\n              if (newHeadroon > curHeadroom) {\n                existingNonPreferredAssignment.put(replica, node);\n                node.nonPreferred.add(replica);\n              }\n            }\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","date":"2014-11-14 09:26:06","endLine":462,"groupId":"3099","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/7f27596f9d80c2ebf3ef393c6c1d09de083a27.src","preCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)\n              && !existingNonPreferredAssignment.containsKey(replica)) {\n            existingNonPreferredAssignment.put(replica, node);\n            node.nonPreferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":418,"status":"M"},{"authorDate":"2014-04-17 07:55:17","commitOrder":6,"curCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","date":"2014-04-17 07:55:17","endLine":510,"groupId":"536","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/8286ba4214eeca176d9bcdaf45c2a3dd1cb577.src","preCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"N"}],"commitId":"961a9e1feb09b707160c7d2d5234549cf4677956","commitMessage":"@@@[HELIX-547] AutoRebalancer may not converge in some rare situation.  rb=28023\n","date":"2014-11-14 09:26:06","modifiedFileCount":"1","status":"M","submitter":"zzhang"},{"authorTime":"2014-04-17 07:55:17","codes":[{"authorDate":"2014-11-26 02:59:30","commitOrder":7,"curCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)\n              && !existingNonPreferredAssignment.containsKey(replica)) {\n            existingNonPreferredAssignment.put(replica, node);\n            node.nonPreferred.add(replica);\n\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","date":"2014-11-26 02:59:30","endLine":451,"groupId":"3099","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/65/78af04b561fb150e593512f1f1cf027f39087e.src","preCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)) {\n            if (!existingNonPreferredAssignment.containsKey(replica)) {\n              existingNonPreferredAssignment.put(replica, node);\n              node.nonPreferred.add(replica);\n            } else {\n              \r\n              \r\n              Node curNode = existingNonPreferredAssignment.get(replica);\n              int curHeadroom = curNode.capacity - curNode.currentlyAssigned;\n              int newHeadroon = node.capacity - node.currentlyAssigned;\n              if (newHeadroon > curHeadroom) {\n                existingNonPreferredAssignment.put(replica, node);\n                node.nonPreferred.add(replica);\n              }\n            }\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":417,"status":"M"},{"authorDate":"2014-04-17 07:55:17","commitOrder":7,"curCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","date":"2014-04-17 07:55:17","endLine":510,"groupId":"536","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/8286ba4214eeca176d9bcdaf45c2a3dd1cb577.src","preCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"N"}],"commitId":"5378afab5646a6451665c1d8d3edb699daea5c64","commitMessage":"@@@[HELIX-541] Fix possible livelock in Helix controller.  rb=28413\n","date":"2014-11-26 02:59:30","modifiedFileCount":"11","status":"M","submitter":"zzhang"},{"authorTime":"2014-04-17 07:55:17","codes":[{"authorDate":"2015-01-28 09:52:48","commitOrder":8,"curCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (!_preferredAssignment.containsKey(replica)) {\n\n            logger.info(\"partitions: \" + _partitions);\n            logger.info(\"currentMapping.keySet: \" + currentMapping.keySet());\n            throw new IllegalArgumentException(\"partition: \" + replica + \" is in currentMapping but not in partitions\");\n          }\n\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)\n              && !existingNonPreferredAssignment.containsKey(replica)) {\n            existingNonPreferredAssignment.put(replica, node);\n            node.nonPreferred.add(replica);\n\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","date":"2015-01-28 09:52:48","endLine":458,"groupId":"1884","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/11/b5b0d4a12de739b4cf0dd000e21d3db10daa62.src","preCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)\n              && !existingNonPreferredAssignment.containsKey(replica)) {\n            existingNonPreferredAssignment.put(replica, node);\n            node.nonPreferred.add(replica);\n\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":417,"status":"M"},{"authorDate":"2014-04-17 07:55:17","commitOrder":8,"curCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","date":"2014-04-17 07:55:17","endLine":510,"groupId":"536","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/8286ba4214eeca176d9bcdaf45c2a3dd1cb577.src","preCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"N"}],"commitId":"03d25dd5bdbd30df5d5c7b9807ccacc1462266fd","commitMessage":"@@@[HELIX-563] Throw more meaningful exceptions when AutoRebalanceStrategy#computePartitionAssignment inputs are invalid.  [HELIX-564] StateModelFactory is not removing empty map when a resource is dropped.  rb=30324\n","date":"2015-01-28 09:52:48","modifiedFileCount":"2","status":"M","submitter":"zzhang"},{"authorTime":"2014-04-17 07:55:17","codes":[{"authorDate":"2019-06-25 15:08:44","commitOrder":9,"curCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (!_preferredAssignment.containsKey(replica)) {\n\n            logger.warn(\"partitions: \" + _partitions);\n            logger.warn(\"currentMapping.keySet: \" + currentMapping.keySet());\n            throw new IllegalArgumentException(\n                \"partition: \" + replica + \" is in currentMapping but not in partitions\");\n          }\n\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)\n              && !existingNonPreferredAssignment.containsKey(replica)) {\n            existingNonPreferredAssignment.put(replica, node);\n            node.nonPreferred.add(replica);\n\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","date":"2019-06-25 15:08:44","endLine":464,"groupId":"10895","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"computeExistingNonPreferredPlacement","params":"(Map<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/d4/45664c0acc0e3f8bf36aa56a54468aa6a03a1e.src","preCode":"  private Map<Replica, Node> computeExistingNonPreferredPlacement(\n      Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingNonPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        boolean skip = false;\n        for (Replica replica : node.preferred) {\n          if (replica.partition.equals(partition)) {\n            skip = true;\n            break;\n          }\n        }\n        if (skip) {\n          continue;\n        }\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (!_preferredAssignment.containsKey(replica)) {\n\n            logger.info(\"partitions: \" + _partitions);\n            logger.info(\"currentMapping.keySet: \" + currentMapping.keySet());\n            throw new IllegalArgumentException(\"partition: \" + replica + \" is in currentMapping but not in partitions\");\n          }\n\n          if (_preferredAssignment.get(replica).id != node.id\n              && !_existingPreferredAssignment.containsKey(replica)\n              && !existingNonPreferredAssignment.containsKey(replica)) {\n            existingNonPreferredAssignment.put(replica, node);\n            node.nonPreferred.add(replica);\n\n            break;\n          }\n        }\n      }\n    }\n    return existingNonPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":422,"status":"M"},{"authorDate":"2014-04-17 07:55:17","commitOrder":9,"curCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","date":"2014-04-17 07:55:17","endLine":510,"groupId":"10895","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"computeExistingPreferredPlacement","params":"(finalMap<String@Map<String@String>>currentMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/8286ba4214eeca176d9bcdaf45c2a3dd1cb577.src","preCode":"  private Map<Replica, Node> computeExistingPreferredPlacement(\n      final Map<String, Map<String, String>> currentMapping) {\n    Map<Replica, Node> existingPreferredAssignment = new TreeMap<Replica, Node>();\n    int count = countStateReplicas();\n    for (String partition : currentMapping.keySet()) {\n      Map<String, String> nodeStateMap = currentMapping.get(partition);\n      nodeStateMap.keySet().retainAll(_nodeMap.keySet());\n      for (String nodeId : nodeStateMap.keySet()) {\n        Node node = _nodeMap.get(nodeId);\n        node.currentlyAssigned = node.currentlyAssigned + 1;\n        \r\n        for (int replicaId = 0; replicaId < count; replicaId++) {\n          Replica replica = new Replica(partition, replicaId);\n          if (_preferredAssignment.containsKey(replica)\n              && !existingPreferredAssignment.containsKey(replica)\n              && _preferredAssignment.get(replica).id == node.id) {\n            existingPreferredAssignment.put(replica, node);\n            node.preferred.add(replica);\n            break;\n          }\n        }\n      }\n    }\n\n    return existingPreferredAssignment;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"N"}],"commitId":"aa77f5c0bfc3cafb6482b1cef4a1689191cbd846","commitMessage":"@@@Merge differences with another branch\n\nThere are multiple branches against which Helix devs have been doing development work. We wish to consolidate them into one by reconciling all differences. This diff makes such changes. This diff does not contain any changes in logic or functionality.\n","date":"2019-06-25 15:08:44","modifiedFileCount":"62","status":"M","submitter":"Hunter Lee"}]
