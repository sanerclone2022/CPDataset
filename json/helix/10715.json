[{"authorTime":"2018-07-14 05:45:41","codes":[{"authorDate":"2018-07-10 03:09:30","commitOrder":6,"curCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingState(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n","date":"2018-07-10 04:48:53","endLine":158,"groupId":"5266","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getTgtPartitionAssignment","params":"(CurrentStateOutputcurrStateOutput@Iterable<String>instances@IdealStatetgtIs@Set<String>tgtStates@Set<Integer>includeSet@JobContextjobCtx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/0c/e60121805ce969b3261ebd7f85504826837542.src","preCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingState(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"NB"},{"authorDate":"2018-07-14 05:45:41","commitOrder":6,"curCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, JobConfig jobCfg, JobContext jobContext,\n      Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    Map<String, AssignableInstance> assignableInstanceMap =\n        _assignableInstanceManager.getAssignableInstanceMap();\n    String quotaType = jobCfg.getQuotaType();\n    if (quotaType == null || quotaType.equals(\"\") || quotaType.equals(\"null\")) {\n      quotaType = AssignableInstance.DEFAULT_QUOTA_TYPE;\n    }\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingState(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (assignableInstanceMap.containsKey(prevInstance)) {\n                  assignableInstanceMap.get(prevInstance).release(taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (assignableInstanceMap.containsKey(instance)) {\n              AssignableInstance assignableInstance = assignableInstanceMap.get(instance);\n              \r\n              TaskAssignResult taskAssignResult =\n                  assignableInstance.tryAssign(taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                assignableInstance.assign(taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2018-07-14 08:38:58","endLine":319,"groupId":"889","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"computeAssignmentAndChargeResource","params":"(CurrentStateOutputcurrStateOutput@ResourceAssignmentprevAssignment@Collection<String>liveInstances@JobConfigjobCfg@JobContextjobContext@Set<Integer>taskPartitionSet@Map<String@IdealState>idealStateMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/e7/dd95905b13ae27ae4f991b5f827938a523dcf7.src","preCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, JobConfig jobCfg, JobContext jobContext,\n      Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    Map<String, AssignableInstance> assignableInstanceMap =\n        _assignableInstanceManager.getAssignableInstanceMap();\n    String quotaType = jobCfg.getQuotaType();\n    if (quotaType == null || quotaType.equals(\"\") || quotaType.equals(\"null\")) {\n      quotaType = AssignableInstance.DEFAULT_QUOTA_TYPE;\n    }\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingState(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (assignableInstanceMap.containsKey(prevInstance)) {\n                  assignableInstanceMap.get(prevInstance).release(taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (assignableInstanceMap.containsKey(instance)) {\n              AssignableInstance assignableInstance = assignableInstanceMap.get(instance);\n              \r\n              TaskAssignResult taskAssignResult =\n                  assignableInstance.tryAssign(taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                assignableInstance.assign(taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"B"}],"commitId":"4db61b56e473b64ec9956f694dd2ac6a8d328ed4","commitMessage":"@@@[HELIX-730] Add ThreadCountBasedAssignmentCalculator and integrate with Workflow/JobRebalancer and fix rebalancing logic\n\nFor quota-based scheduling of tasks.  we have added the TaskAssigner interface that takes into account AssignableInstances by way of AssignableInstanceManager. In order to use this in the currently-existing pipeline prior to Task Framework 2.0.  GenericTaskAssignmentCalculator was replaced with ThreadCountBasedAssignmentCalculator.  which is a wrapper around TaskAssigner. Necessary adjustments were made in Workflow/JobRebalancer for this replacement. Also the rebalance logic in Workflow/JobRebalancer was reviewed and fixed. Additionally.  TestQuotaBasedScheduling is added to test quota-based task scheduling. Note that quotas will apply to both generic and targeted jobs.\n\nA few bugs were uncovered during this process such as the faulty retry logic that never really got tasks to restart. For more details.  see the changelist below:\n\nChangelist:\n    1. Add ThreadCountBasedAssignmentCalculator.  a wrapper around ThreadCountBasedTaskAssigner\n    2. Make logic changes in JobRebalancer to enable the use of ThreadCountBasedAssignmentCalculator\n    3. Fix the failing test by using a thread-safe map and rename TestGenericTaskAssignmentCalculator to TestTaskAssignmentCalculator to better reflect what its tests are doing\n    4. Add retry logic that was previously absent for INIT and DROPPED tasks in JobRebalancer\n    5. Add TestQuotaBasedScheduling to test that jobs and tasks were being assigned and scheduled per quota config set in ClusterConfig\n    6. Add more log messages to aid with task-scheduling debugging in AssignableInstance\n    7. In AbstractTaskDispatcher.  for tasks that are STOPPED.  TIMED_OUT.  TASK_ERROR.  the retry logic was newly implemented so that they get re-started correctly\n    8. In AbstractTaskDispatcher.  when enforcing overlapAssign for jobs with isAllowOverlapAssignment().  a fix was implemented so that only jobs whose state is IN_PROGRESS are considered\n    9. In AbstractTaskDispatcher.  isWorkflowFinished() method was modified so that non-active jobs will have their tasks' resource freed from AssignableInstances to prevent resource leak\n   10. In markJobFailed() and markJobCompleted().  non-active jobs will have their tasks' resource freed from AssignableInstances to prevent resource leak\n   11. Fix the logic so that quotas do not apply to targeted jobs\n   12. Fix TestTaskRebalancer (assumes Consistent Hashing.  which is no longer used)\n   13. Fix TestIndependentTaskRebalancer (assumes Consistent Hashing.  no longer used)\n   14. Assignment logic was improved so that incomplete tasks whose assigned participants are no longer live will be re-assigned accordingly\n   15. Fix TestTaskRebalanceFailover (tasks on non-live instances will be re-assigned promptly)\n   16. Fix TestRebalanceRunningTask (targeted jobs will get tasks reassigned upon liveInstance and currentState change)\n   17. Fix a bug in FixedAssignmentCalculator and assignment logic for targeted jobs such that a task index will no longer be assigned multiple times\n   18. Fix TestJobFailureTaskNotStarted (tasks were not being assigned at all due to having reached maximum capacity for quota)\n   19. Add targetedTaskConfigMap field in JobConfig to cache TaskConfig objects for targeted tasks to reduce object creation and GC overload\n   20. Fix JobConfig so that it doesn't write quotaType to ZooKeeper when quotaType is null or not set\n   21. Fix deleteWorkflow() in TaskUtil so that the earliest delete failure will render the entire method as failed (and return prematurely to prevent breaking other ZNodes from incomplete deletion)\n   22. Fix TestDeleteWorkflow by adding another removeProperty() clause to lower failure rate\n","date":"2018-07-14 08:38:58","modifiedFileCount":"36","status":"M","submitter":"Hunter Lee"},{"authorTime":"2018-07-18 04:36:18","codes":[{"authorDate":"2018-07-10 03:09:30","commitOrder":7,"curCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingState(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n","date":"2018-07-10 04:48:53","endLine":158,"groupId":"5266","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getTgtPartitionAssignment","params":"(CurrentStateOutputcurrStateOutput@Iterable<String>instances@IdealStatetgtIs@Set<String>tgtStates@Set<Integer>includeSet@JobContextjobCtx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/0c/e60121805ce969b3261ebd7f85504826837542.src","preCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingState(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"N"},{"authorDate":"2018-07-18 04:36:18","commitOrder":7,"curCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, WorkflowConfig workflowCfg, JobConfig jobCfg,\n      JobContext jobContext, Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    Map<String, AssignableInstance> assignableInstanceMap =\n        _assignableInstanceManager.getAssignableInstanceMap();\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingState(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (assignableInstanceMap.containsKey(prevInstance)) {\n                  assignableInstanceMap.get(prevInstance).release(taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (assignableInstanceMap.containsKey(instance)) {\n              AssignableInstance assignableInstance = assignableInstanceMap.get(instance);\n              \r\n              TaskAssignResult taskAssignResult =\n                  assignableInstance.tryAssign(taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                assignableInstance.assign(taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2018-07-18 06:37:40","endLine":316,"groupId":"889","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"computeAssignmentAndChargeResource","params":"(CurrentStateOutputcurrStateOutput@ResourceAssignmentprevAssignment@Collection<String>liveInstances@WorkflowConfigworkflowCfg@JobConfigjobCfg@JobContextjobContext@Set<Integer>taskPartitionSet@Map<String@IdealState>idealStateMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/87/b57c7d14648e2b691f6606515a110feb1cd4c8.src","preCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, JobConfig jobCfg, JobContext jobContext,\n      Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    Map<String, AssignableInstance> assignableInstanceMap =\n        _assignableInstanceManager.getAssignableInstanceMap();\n    String quotaType = jobCfg.getQuotaType();\n    if (quotaType == null || quotaType.equals(\"\") || quotaType.equals(\"null\")) {\n      quotaType = AssignableInstance.DEFAULT_QUOTA_TYPE;\n    }\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingState(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (assignableInstanceMap.containsKey(prevInstance)) {\n                  assignableInstanceMap.get(prevInstance).release(taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (assignableInstanceMap.containsKey(instance)) {\n              AssignableInstance assignableInstance = assignableInstanceMap.get(instance);\n              \r\n              TaskAssignResult taskAssignResult =\n                  assignableInstance.tryAssign(taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                assignableInstance.assign(taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"M"}],"commitId":"36ab2a6028dad39b32d3a15da942b4385ff9fd1d","commitMessage":"@@@[HELIX-738] Remove quotaType APIs and make jobs inherit type from workflows\n\nFor quota-based task scheduling.  for each job.  we provided get/setQuotaType APIs. However.  the use case for workflow types and job types were similar enough that we decided to merge them and begin using workflow/job types for quota-based scheduling. Job types will now be used as quota types.  and all jobs will inherit the type.  if set.  from their parent workflow.  at assignment and schedule time.\n\nChangelist:\n1. Remove APIs around quotaType in Workflow/JobConfig\n2. Add an internal method in TaskAssignmentCalculator that includes logic for determining which quota type each job should use\n3. Adjust tests so that they test and pass successfully\n","date":"2018-07-18 06:37:40","modifiedFileCount":"10","status":"M","submitter":"Hunter Lee"},{"authorTime":"2018-04-25 09:18:40","codes":[{"authorDate":"2018-04-25 09:18:40","commitOrder":8,"curCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingMessage(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2018-09-18 06:08:28","endLine":174,"groupId":"374","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getTgtPartitionAssignment","params":"(CurrentStateOutputcurrStateOutput@Iterable<String>instances@IdealStatetgtIs@Set<String>tgtStates@Set<Integer>includeSet@JobContextjobCtx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/43/89484354630709dc9d5a982d2b10c465579d1b.src","preCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingState(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"},{"authorDate":"2018-04-25 09:18:40","commitOrder":8,"curCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, WorkflowConfig workflowCfg, JobConfig jobCfg,\n      JobContext jobContext, Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    Map<String, AssignableInstance> assignableInstanceMap =\n        _assignableInstanceManager.getAssignableInstanceMap();\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingMessage(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (assignableInstanceMap.containsKey(prevInstance)) {\n                  assignableInstanceMap.get(prevInstance).release(taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (assignableInstanceMap.containsKey(instance)) {\n              AssignableInstance assignableInstance = assignableInstanceMap.get(instance);\n              \r\n              TaskAssignResult taskAssignResult =\n                  assignableInstance.tryAssign(taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                assignableInstance.assign(taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2018-09-18 06:08:28","endLine":316,"groupId":"1483","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"computeAssignmentAndChargeResource","params":"(CurrentStateOutputcurrStateOutput@ResourceAssignmentprevAssignment@Collection<String>liveInstances@WorkflowConfigworkflowCfg@JobConfigjobCfg@JobContextjobContext@Set<Integer>taskPartitionSet@Map<String@IdealState>idealStateMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/43/89484354630709dc9d5a982d2b10c465579d1b.src","preCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, WorkflowConfig workflowCfg, JobConfig jobCfg,\n      JobContext jobContext, Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    Map<String, AssignableInstance> assignableInstanceMap =\n        _assignableInstanceManager.getAssignableInstanceMap();\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingState(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (assignableInstanceMap.containsKey(prevInstance)) {\n                  assignableInstanceMap.get(prevInstance).release(taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (assignableInstanceMap.containsKey(instance)) {\n              AssignableInstance assignableInstance = assignableInstanceMap.get(instance);\n              \r\n              TaskAssignResult taskAssignResult =\n                  assignableInstance.tryAssign(taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                assignableInstance.assign(taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"M"}],"commitId":"880f885121afecab4e186282fbf94a146a2cf04a","commitMessage":"@@@Fix P2P message logic in controller to avoid sending duplicated messages to participants.\n","date":"2018-09-18 06:08:28","modifiedFileCount":"21","status":"M","submitter":"Lei Xia"},{"authorTime":"2018-11-09 06:53:05","codes":[{"authorDate":"2018-04-25 09:18:40","commitOrder":9,"curCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingMessage(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2018-09-18 06:08:28","endLine":174,"groupId":"374","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"getTgtPartitionAssignment","params":"(CurrentStateOutputcurrStateOutput@Iterable<String>instances@IdealStatetgtIs@Set<String>tgtStates@Set<Integer>includeSet@JobContextjobCtx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/43/89484354630709dc9d5a982d2b10c465579d1b.src","preCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingMessage(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"N"},{"authorDate":"2018-11-09 06:53:05","commitOrder":9,"curCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, WorkflowConfig workflowCfg, JobConfig jobCfg,\n      JobContext jobContext, Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingMessage(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (_assignableInstanceManager.getAssignableInstanceNames()\n                    .contains(prevInstance)) {\n                  _assignableInstanceManager.release(prevInstance, taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (_assignableInstanceManager.getAssignableInstanceNames().contains(instance)) {\n              \r\n              TaskAssignResult taskAssignResult =\n                  _assignableInstanceManager.tryAssign(instance, taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                _assignableInstanceManager.assign(instance, taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2019-02-26 08:38:08","endLine":314,"groupId":"1483","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"computeAssignmentAndChargeResource","params":"(CurrentStateOutputcurrStateOutput@ResourceAssignmentprevAssignment@Collection<String>liveInstances@WorkflowConfigworkflowCfg@JobConfigjobCfg@JobContextjobContext@Set<Integer>taskPartitionSet@Map<String@IdealState>idealStateMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/b1/b038ed709f477495d63cd0e446f69c39fa70c2.src","preCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, WorkflowConfig workflowCfg, JobConfig jobCfg,\n      JobContext jobContext, Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    Map<String, AssignableInstance> assignableInstanceMap =\n        _assignableInstanceManager.getAssignableInstanceMap();\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingMessage(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (assignableInstanceMap.containsKey(prevInstance)) {\n                  assignableInstanceMap.get(prevInstance).release(taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (assignableInstanceMap.containsKey(instance)) {\n              AssignableInstance assignableInstance = assignableInstanceMap.get(instance);\n              \r\n              TaskAssignResult taskAssignResult =\n                  assignableInstance.tryAssign(taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                assignableInstance.assign(taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"M"}],"commitId":"cff8cb78f6b1ae1194de319a189494e4fc34de0e","commitMessage":"@@@Refactor AssignableInstanceManager\n\nCurrent code structure is hard to have global quota number. For optimize our pipeline computation.  we need to skip the workflow computation when there is no quota left. In this case.  this rb contains the refactoring for AssignableInstanceManager as central place to operate quota management.\n","date":"2019-02-26 08:38:08","modifiedFileCount":"9","status":"M","submitter":"Junkai Xue"},{"authorTime":"2020-06-11 02:26:09","codes":[{"authorDate":"2018-04-25 09:18:40","commitOrder":10,"curCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingMessage(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2018-09-18 06:08:28","endLine":174,"groupId":"374","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"getTgtPartitionAssignment","params":"(CurrentStateOutputcurrStateOutput@Iterable<String>instances@IdealStatetgtIs@Set<String>tgtStates@Set<Integer>includeSet@JobContextjobCtx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/43/89484354630709dc9d5a982d2b10c465579d1b.src","preCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingMessage(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"N"},{"authorDate":"2020-06-11 02:26:09","commitOrder":10,"curCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, Collection<String> liveInstances,\n      WorkflowConfig workflowCfg, JobConfig jobCfg, JobContext jobContext,\n      Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingMessage(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n\n            \r\n            \r\n            String prevAssignedInstance = jobContext.getAssignedParticipant(targetPartitionId);\n            TaskPartitionState taskState = jobContext.getPartitionState(targetPartitionId);\n\n            if (prevAssignedInstance != null && taskState != null\n                && (taskState.equals(TaskPartitionState.INIT)\n                    || taskState.equals(TaskPartitionState.RUNNING))) {\n              \r\n              \r\n              \r\n              if (!prevAssignedInstance.equals(instance)) {\n                if (_assignableInstanceManager.getAssignableInstanceNames()\n                    .contains(prevAssignedInstance)) {\n                  _assignableInstanceManager.release(prevAssignedInstance, taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignedInstance, instance, prevAssignedInstance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (_assignableInstanceManager.getAssignableInstanceNames().contains(instance)) {\n              \r\n              TaskAssignResult taskAssignResult =\n                  _assignableInstanceManager.tryAssign(instance, taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                _assignableInstanceManager.assign(instance, taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2020-08-05 05:14:24","endLine":325,"groupId":"3645","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"computeAssignmentAndChargeResource","params":"(CurrentStateOutputcurrStateOutput@Collection<String>liveInstances@WorkflowConfigworkflowCfg@JobConfigjobCfg@JobContextjobContext@Set<Integer>taskPartitionSet@Map<String@IdealState>idealStateMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/8a/29232d36cc3f0510825396b55dd6c73da63d32.src","preCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, ResourceAssignment prevAssignment,\n      Collection<String> liveInstances, WorkflowConfig workflowCfg, JobConfig jobCfg,\n      JobContext jobContext, Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingMessage(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n            Map<String, String> instanceMap = prevAssignment.getReplicaMap(new Partition(pName));\n            Iterator<String> itr = instanceMap.keySet().iterator();\n            \r\n            \r\n            if (itr.hasNext()) {\n              String prevInstance = itr.next();\n              if (!prevInstance.equals(instance)) {\n                \r\n                \r\n                if (_assignableInstanceManager.getAssignableInstanceNames()\n                    .contains(prevInstance)) {\n                  _assignableInstanceManager.release(prevInstance, taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignment, instance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (_assignableInstanceManager.getAssignableInstanceNames().contains(instance)) {\n              \r\n              TaskAssignResult taskAssignResult =\n                  _assignableInstanceManager.tryAssign(instance, taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                _assignableInstanceManager.assign(instance, taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":195,"status":"M"}],"commitId":"cb8c696e3e7e1b6a984a4eda0e789f5518591f06","commitMessage":"@@@Remove previousAssignment from FixedTargetTaskAssignmentCalculator (#1061)\n\nRemove previousAssignment from FixedTargetTaskAssignmentCalculator\n\nThe FixedTargetTaskAssignmentCalculator class is relying on the previousAssignment.\nIn this commit.  this class has been modified and previousAssignment has been\nreplaced with the context information.\nAlso several legacy job and workflow rebalancers have been removed.","date":"2020-08-05 05:14:24","modifiedFileCount":"7","status":"M","submitter":"Ali Reza Zamani Zadeh Najari"},{"authorTime":"2020-12-04 12:47:50","codes":[{"authorDate":"2018-04-25 09:18:40","commitOrder":11,"curCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingMessage(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2018-09-18 06:08:28","endLine":174,"groupId":"10715","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"getTgtPartitionAssignment","params":"(CurrentStateOutputcurrStateOutput@Iterable<String>instances@IdealStatetgtIs@Set<String>tgtStates@Set<Integer>includeSet@JobContextjobCtx)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/43/89484354630709dc9d5a982d2b10c465579d1b.src","preCode":"  private static Map<String, SortedSet<Integer>> getTgtPartitionAssignment(\n      CurrentStateOutput currStateOutput, Iterable<String> instances, IdealState tgtIs,\n      Set<String> tgtStates, Set<Integer> includeSet, JobContext jobCtx) {\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : instances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    Map<String, List<Integer>> partitionsByTarget = jobCtx.getPartitionsByTarget();\n    for (String pName : tgtIs.getPartitionSet()) {\n      List<Integer> partitions = partitionsByTarget.get(pName);\n      if (partitions == null || partitions.size() < 1) {\n        continue;\n      }\n      int pId = partitions.get(0);\n      if (includeSet.contains(pId)) {\n        for (String instance : instances) {\n          Message pendingMessage = currStateOutput.getPendingMessage(tgtIs.getResourceName(),\n              new Partition(pName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          String s = currStateOutput.getCurrentState(tgtIs.getResourceName(), new Partition(pName),\n              instance);\n          if (s != null && (tgtStates == null || tgtStates.contains(s))) {\n            result.get(instance).add(pId);\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"N"},{"authorDate":"2020-12-04 12:47:50","commitOrder":11,"curCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, Collection<String> liveInstances,\n      WorkflowConfig workflowCfg, JobConfig jobCfg, JobContext jobContext,\n      Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job {}!\",\n          jobContext != null ? jobContext.getName() : \"null\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingMessage(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n\n            \r\n            \r\n            String prevAssignedInstance = jobContext.getAssignedParticipant(targetPartitionId);\n            TaskPartitionState taskState = jobContext.getPartitionState(targetPartitionId);\n\n            if (prevAssignedInstance != null && taskState != null\n                && (taskState.equals(TaskPartitionState.INIT)\n                    || taskState.equals(TaskPartitionState.RUNNING))) {\n              \r\n              \r\n              \r\n              if (!prevAssignedInstance.equals(instance)) {\n                if (_assignableInstanceManager.getAssignableInstanceNames()\n                    .contains(prevAssignedInstance)) {\n                  _assignableInstanceManager.release(prevAssignedInstance, taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignedInstance, instance, prevAssignedInstance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (_assignableInstanceManager.getAssignableInstanceNames().contains(instance)) {\n              \r\n              TaskAssignResult taskAssignResult =\n                  _assignableInstanceManager.tryAssign(instance, taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                _assignableInstanceManager.assign(instance, taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","date":"2020-12-04 12:47:50","endLine":333,"groupId":"10715","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"computeAssignmentAndChargeResource","params":"(CurrentStateOutputcurrStateOutput@Collection<String>liveInstances@WorkflowConfigworkflowCfg@JobConfigjobCfg@JobContextjobContext@Set<Integer>taskPartitionSet@Map<String@IdealState>idealStateMap)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/68/50220fffbb9ee90f7ce3d84ef5c6a8f32e3878.src","preCode":"  private Map<String, SortedSet<Integer>> computeAssignmentAndChargeResource(\n      CurrentStateOutput currStateOutput, Collection<String> liveInstances,\n      WorkflowConfig workflowCfg, JobConfig jobCfg, JobContext jobContext,\n      Set<Integer> taskPartitionSet, Map<String, IdealState> idealStateMap) {\n\n    \r\n    \r\n    String quotaType = getQuotaType(workflowCfg, jobCfg);\n\n    \r\n    IdealState targetIdealState = idealStateMap.get(jobCfg.getTargetResource());\n    if (targetIdealState == null) {\n      LOG.warn(\"Missing target resource for the scheduled job!\");\n      return Collections.emptyMap();\n    }\n\n    \r\n    \r\n    Set<String> targetStates = jobCfg.getTargetPartitionStates();\n\n    Map<String, SortedSet<Integer>> result = new HashMap<>();\n    for (String instance : liveInstances) {\n      result.put(instance, new TreeSet<Integer>());\n    }\n\n    \r\n    Map<String, List<Integer>> partitionsByTarget = jobContext.getPartitionsByTarget();\n    for (String targetResourcePartitionName : targetIdealState.getPartitionSet()) {\n      \r\n      List<Integer> taskPartitions = partitionsByTarget.get(targetResourcePartitionName);\n      if (taskPartitions == null || taskPartitions.size() < 1) {\n        continue; \r\n      }\n      \r\n      int targetPartitionId = taskPartitions.get(0);\n      \r\n      if (taskPartitionSet.contains(targetPartitionId)) {\n        for (String instance : liveInstances) {\n          \r\n          \r\n          \r\n          \r\n          Message pendingMessage =\n              currStateOutput.getPendingMessage(targetIdealState.getResourceName(),\n                  new Partition(targetResourcePartitionName), instance);\n          if (pendingMessage != null) {\n            continue;\n          }\n\n          \r\n          String currentState = currStateOutput.getCurrentState(targetIdealState.getResourceName(),\n              new Partition(targetResourcePartitionName), instance);\n          if (currentState != null\n              && (targetStates == null || targetStates.contains(currentState))) {\n\n            \r\n            String pName = String.format(\"%s_%s\", jobCfg.getJobId(), targetPartitionId);\n            if (!jobCfg.getTaskConfigMap().containsKey(pName)) {\n              jobCfg.getTaskConfigMap().put(pName,\n                  new TaskConfig(null, null, pName, targetResourcePartitionName));\n            }\n            TaskConfig taskConfig = jobCfg.getTaskConfigMap().get(pName);\n\n            \r\n            \r\n            \r\n            \r\n\n            \r\n            \r\n            String prevAssignedInstance = jobContext.getAssignedParticipant(targetPartitionId);\n            TaskPartitionState taskState = jobContext.getPartitionState(targetPartitionId);\n\n            if (prevAssignedInstance != null && taskState != null\n                && (taskState.equals(TaskPartitionState.INIT)\n                    || taskState.equals(TaskPartitionState.RUNNING))) {\n              \r\n              \r\n              \r\n              if (!prevAssignedInstance.equals(instance)) {\n                if (_assignableInstanceManager.getAssignableInstanceNames()\n                    .contains(prevAssignedInstance)) {\n                  _assignableInstanceManager.release(prevAssignedInstance, taskConfig, quotaType);\n                } else {\n                  \r\n                  LOG.warn(\n                      \"Task {} was reassigned from old instance: {} to new instance: {}. However, old instance: {} is not found in AssignableInstanceMap. The old instance is possibly no longer a LiveInstance. This task will not be released.\",\n                      pName, prevAssignedInstance, instance, prevAssignedInstance);\n                }\n              } else {\n                \r\n                \r\n                break;\n              }\n            }\n\n            \r\n            if (_assignableInstanceManager.getAssignableInstanceNames().contains(instance)) {\n              \r\n              TaskAssignResult taskAssignResult =\n                  _assignableInstanceManager.tryAssign(instance, taskConfig, quotaType);\n              if (taskAssignResult.isSuccessful()) {\n                \r\n                _assignableInstanceManager.assign(instance, taskAssignResult);\n                result.get(instance).add(targetPartitionId);\n                \r\n                \r\n                break;\n              } else if ((!taskAssignResult.isSuccessful() && taskAssignResult\n                  .getFailureReason() == TaskAssignResult.FailureReason.TASK_ALREADY_ASSIGNED)) {\n                \r\n                \r\n                \r\n                result.get(instance).add(targetPartitionId);\n                break;\n              } else {\n                LOG.warn(\n                    \"Unable to assign the task to this AssignableInstance. Skipping this instance. Task: {}, Instance: {}, TaskAssignResult: {}\",\n                    pName, instance, taskAssignResult);\n              }\n            } else {\n              LOG.error(\n                  \"AssignableInstance does not exist for this LiveInstance: {}. This should never happen! Will not assign to this instance.\",\n                  instance);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"M"}],"commitId":"2e30348d1447f0a107e6c19f59e38d37662787fa","commitMessage":"@@@Refine task framework log (#1565)\n\nRefine task framework log.\n\n","date":"2020-12-04 12:47:50","modifiedFileCount":"14","status":"M","submitter":"xyuanlu"}]
