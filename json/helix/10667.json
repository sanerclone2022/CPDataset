[{"authorTime":"2017-01-29 08:34:53","codes":[{"authorDate":"2017-03-13 07:33:06","commitOrder":8,"curCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","date":"2017-03-13 07:33:06","endLine":327,"groupId":"5545","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"removeEntryWithIgnoredStates","params":"(Iterator<Map.Entry<String@Map<String@String>>>partitionInstanceStateMapIter@Set<String>ignoredStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/6c/79bedfd01b4e605897892d5f9e709589338cab.src","preCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":308,"status":"B"},{"authorDate":"2017-01-29 08:34:53","commitOrder":8,"curCode":"  static boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n      Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n    try {\n      Builder keyBuilder = accessor.keyBuilder();\n      \r\n      ClusterDataCache cache = new ClusterDataCache();\n      cache.refresh(accessor);\n\n      Map<String, IdealState> idealStates = cache.getIdealStates();\n      if (idealStates == null) {\n        \r\n        idealStates = Collections.emptyMap();\n      }\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (resources != null && !resources.isEmpty()) {\n        idealStates.keySet().retainAll(resources);\n        extViews.keySet().retainAll(resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          idealStates.put(resource, new IdealState(resource));\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput =\n          ClusterStateVerifier.calcBestPossState(cache, resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (errStates != null) {\n        for (String resourceName : errStates.keySet()) {\n          Map<String, String> partErrStates = errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      \r\n\n      for (String resourceName : idealStates.keySet()) {\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          IdealState is = idealStates.get(resourceName);\n          if (is.isExternalViewDisabled()) {\n            continue;\n          } else {\n            LOG.info(\"externalView for \" + resourceName + \" is not available\");\n            return false;\n          }\n        }\n\n        \r\n        Map<Partition, Map<String, String>> bpStateMap =\n            bestPossOutput.getResourceMap(resourceName);\n        Iterator<Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n        while (iter.hasNext()) {\n          Map.Entry<Partition, Map<String, String>> entry = iter.next();\n          Map<String, String> instanceStateMap = entry.getValue();\n          if (instanceStateMap.isEmpty()) {\n            iter.remove();\n          } else {\n            \r\n            Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n            while (insIter.hasNext()) {\n              Map.Entry<String, String> insEntry = insIter.next();\n              String state = insEntry.getValue();\n              if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                insIter.remove();\n              }\n            }\n          }\n        }\n\n        \r\n\n        \r\n        int extViewSize = extView.getRecord().getMapFields().size();\n        int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n        if (extViewSize != bestPossStateSize) {\n          LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n              + bestPossStateSize + \") for resource: \" + resourceName);\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return false;\n        }\n\n        \r\n        for (String partition : extView.getRecord().getMapFields().keySet()) {\n          Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n          Map<String, String> bpInstanceStateMap =\n              bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n          boolean result =\n              ClusterStateVerifier.<String, String> compareMap(evInstanceStateMap,\n                  bpInstanceStateMap);\n          if (result == false) {\n            LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n            \r\n            \r\n            \r\n            return false;\n          }\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n\n  }\n","date":"2017-01-29 08:34:53","endLine":398,"groupId":"2641","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/a8/7740e33fdc9698ef67f4c8786a80192ebfa995.src","preCode":"  static boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n      Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n    try {\n      Builder keyBuilder = accessor.keyBuilder();\n      \r\n      ClusterDataCache cache = new ClusterDataCache();\n      cache.refresh(accessor);\n\n      Map<String, IdealState> idealStates = cache.getIdealStates();\n      if (idealStates == null) {\n        \r\n        idealStates = Collections.emptyMap();\n      }\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (resources != null && !resources.isEmpty()) {\n        idealStates.keySet().retainAll(resources);\n        extViews.keySet().retainAll(resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          idealStates.put(resource, new IdealState(resource));\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput =\n          ClusterStateVerifier.calcBestPossState(cache, resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (errStates != null) {\n        for (String resourceName : errStates.keySet()) {\n          Map<String, String> partErrStates = errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      \r\n\n      for (String resourceName : idealStates.keySet()) {\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          IdealState is = idealStates.get(resourceName);\n          if (is.isExternalViewDisabled()) {\n            continue;\n          } else {\n            LOG.info(\"externalView for \" + resourceName + \" is not available\");\n            return false;\n          }\n        }\n\n        \r\n        Map<Partition, Map<String, String>> bpStateMap =\n            bestPossOutput.getResourceMap(resourceName);\n        Iterator<Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n        while (iter.hasNext()) {\n          Map.Entry<Partition, Map<String, String>> entry = iter.next();\n          Map<String, String> instanceStateMap = entry.getValue();\n          if (instanceStateMap.isEmpty()) {\n            iter.remove();\n          } else {\n            \r\n            Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n            while (insIter.hasNext()) {\n              Map.Entry<String, String> insEntry = insIter.next();\n              String state = insEntry.getValue();\n              if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                insIter.remove();\n              }\n            }\n          }\n        }\n\n        \r\n\n        \r\n        int extViewSize = extView.getRecord().getMapFields().size();\n        int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n        if (extViewSize != bestPossStateSize) {\n          LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n              + bestPossStateSize + \") for resource: \" + resourceName);\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return false;\n        }\n\n        \r\n        for (String partition : extView.getRecord().getMapFields().keySet()) {\n          Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n          Map<String, String> bpInstanceStateMap =\n              bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n          boolean result =\n              ClusterStateVerifier.<String, String> compareMap(evInstanceStateMap,\n                  bpInstanceStateMap);\n          if (result == false) {\n            LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n            \r\n            \r\n            \r\n            return false;\n          }\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":251,"status":"NB"}],"commitId":"015a73cef3480e924fa9c68d838fa05aeb6057d1","commitMessage":"@@@Add deprecated clusterStateVerifiers classes back to their original packages for back-compatiblilty.  marked them all as deprecated.\n","date":"2017-03-13 07:33:06","modifiedFileCount":"91","status":"M","submitter":"Lei Xia"},{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2017-03-13 07:33:06","commitOrder":9,"curCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","date":"2017-03-13 07:33:06","endLine":327,"groupId":"5545","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"removeEntryWithIgnoredStates","params":"(Iterator<Map.Entry<String@Map<String@String>>>partitionInstanceStateMapIter@Set<String>ignoredStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/6c/79bedfd01b4e605897892d5f9e709589338cab.src","preCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":308,"status":"N"},{"authorDate":"2017-11-08 08:48:26","commitOrder":9,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ClusterDataCache cache = new ClusterDataCache(clusterName);\n        cache.refresh(accessor);\n        cache.setTaskCache(false);\n\n        Map<String, IdealState> idealStates = cache.getIdealStates();\n        if (idealStates == null) {\n          \r\n          idealStates = Collections.emptyMap();\n        }\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2017-11-08 08:48:26","endLine":331,"groupId":"2641","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/87/e7645110a2d8d4ad7bf039dfcc3cc4e99e345c.src","preCode":"  static boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n      Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n    try {\n      Builder keyBuilder = accessor.keyBuilder();\n      \r\n      ClusterDataCache cache = new ClusterDataCache();\n      cache.refresh(accessor);\n\n      Map<String, IdealState> idealStates = cache.getIdealStates();\n      if (idealStates == null) {\n        \r\n        idealStates = Collections.emptyMap();\n      }\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (resources != null && !resources.isEmpty()) {\n        idealStates.keySet().retainAll(resources);\n        extViews.keySet().retainAll(resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          idealStates.put(resource, new IdealState(resource));\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput =\n          ClusterStateVerifier.calcBestPossState(cache, resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (errStates != null) {\n        for (String resourceName : errStates.keySet()) {\n          Map<String, String> partErrStates = errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      \r\n\n      for (String resourceName : idealStates.keySet()) {\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          IdealState is = idealStates.get(resourceName);\n          if (is.isExternalViewDisabled()) {\n            continue;\n          } else {\n            LOG.info(\"externalView for \" + resourceName + \" is not available\");\n            return false;\n          }\n        }\n\n        \r\n        Map<Partition, Map<String, String>> bpStateMap =\n            bestPossOutput.getResourceMap(resourceName);\n        Iterator<Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n        while (iter.hasNext()) {\n          Map.Entry<Partition, Map<String, String>> entry = iter.next();\n          Map<String, String> instanceStateMap = entry.getValue();\n          if (instanceStateMap.isEmpty()) {\n            iter.remove();\n          } else {\n            \r\n            Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n            while (insIter.hasNext()) {\n              Map.Entry<String, String> insEntry = insIter.next();\n              String state = insEntry.getValue();\n              if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                insIter.remove();\n              }\n            }\n          }\n        }\n\n        \r\n\n        \r\n        int extViewSize = extView.getRecord().getMapFields().size();\n        int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n        if (extViewSize != bestPossStateSize) {\n          LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n              + bestPossStateSize + \") for resource: \" + resourceName);\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          return false;\n        }\n\n        \r\n        for (String partition : extView.getRecord().getMapFields().keySet()) {\n          Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n          Map<String, String> bpInstanceStateMap =\n              bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n          boolean result =\n              ClusterStateVerifier.<String, String> compareMap(evInstanceStateMap,\n                  bpInstanceStateMap);\n          if (result == false) {\n            LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n            \r\n            \r\n            \r\n            return false;\n          }\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":187,"status":"M"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"M","submitter":"Junkai Xue"},{"authorTime":"2018-05-31 01:22:10","codes":[{"authorDate":"2017-03-13 07:33:06","commitOrder":10,"curCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","date":"2017-03-13 07:33:06","endLine":327,"groupId":"5545","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"removeEntryWithIgnoredStates","params":"(Iterator<Map.Entry<String@Map<String@String>>>partitionInstanceStateMapIter@Set<String>ignoredStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/6c/79bedfd01b4e605897892d5f9e709589338cab.src","preCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":308,"status":"N"},{"authorDate":"2018-05-31 01:22:10","commitOrder":10,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ClusterDataCache cache = new ClusterDataCache(clusterName);\n        cache.refresh(accessor);\n        cache.setTaskCache(false);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2018-07-12 06:23:03","endLine":330,"groupId":"2641","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/cc/508ef54aa5eb9444b3cfe61404ddd133d96dcd.src","preCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ClusterDataCache cache = new ClusterDataCache(clusterName);\n        cache.refresh(accessor);\n        cache.setTaskCache(false);\n\n        Map<String, IdealState> idealStates = cache.getIdealStates();\n        if (idealStates == null) {\n          \r\n          idealStates = Collections.emptyMap();\n        }\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"M"}],"commitId":"8527a5ae03053d2c1293bad1e60f351681f7ad0b","commitMessage":"@@@Fix bugs in ClusterStateVerifier and StrictMatchExternalViewVerifier.\n","date":"2018-07-12 06:23:03","modifiedFileCount":"2","status":"M","submitter":"Lei Xia"},{"authorTime":"2019-02-26 09:36:00","codes":[{"authorDate":"2017-03-13 07:33:06","commitOrder":11,"curCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","date":"2017-03-13 07:33:06","endLine":327,"groupId":"5545","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"removeEntryWithIgnoredStates","params":"(Iterator<Map.Entry<String@Map<String@String>>>partitionInstanceStateMapIter@Set<String>ignoredStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/6c/79bedfd01b4e605897892d5f9e709589338cab.src","preCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":308,"status":"N"},{"authorDate":"2019-02-26 09:36:00","commitOrder":11,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2019-02-26 09:36:00","endLine":333,"groupId":"2641","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/85/bd49f95904a33e591cdc84bb7472f3ebc107f4.src","preCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ClusterDataCache cache = new ClusterDataCache(clusterName);\n        cache.refresh(accessor);\n        cache.setTaskCache(false);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":194,"status":"M"}],"commitId":"fbb679c5f4804652ea730bf5cd4ee6bf1329efc3","commitMessage":"@@@split data cache\n","date":"2019-02-26 09:36:00","modifiedFileCount":"95","status":"M","submitter":"Harry Zhang"},{"authorTime":"2019-02-26 09:36:00","codes":[{"authorDate":"2019-04-04 08:12:56","commitOrder":12,"curCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      \r\n      Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n      while (insIter.hasNext()) {\n        String state = insIter.next().getValue();\n        if (ignoredStates.contains(state)) {\n          insIter.remove();\n        }\n      }\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      }\n    }\n  }\n","date":"2019-05-25 09:19:20","endLine":345,"groupId":"2140","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"removeEntryWithIgnoredStates","params":"(Iterator<Map.Entry<String@Map<String@String>>>partitionInstanceStateMapIter@Set<String>ignoredStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/74/b9b3c08b55e361509c0357e3dc817d09f3db05.src","preCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      } else {\n        \r\n        Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n        while (insIter.hasNext()) {\n          String state = insIter.next().getValue();\n          if (ignoredStates.contains(state)) {\n            insIter.remove();\n          }\n        }\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":327,"status":"M"},{"authorDate":"2019-02-26 09:36:00","commitOrder":12,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2019-02-26 09:36:00","endLine":333,"groupId":"2641","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/85/bd49f95904a33e591cdc84bb7472f3ebc107f4.src","preCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":194,"status":"N"}],"commitId":"4e5884d9e88ad55eeecbeb2db9830cef0539e082","commitMessage":"@@@Fix faulty logic in BestPossibleExternalViewVerifier\n\nremoveEntryWithIgnoredStates() was not really doing what it was supposed to do. This diff fixes this.\nAlso.  a small delay added to make TestDrop more stable.\n\nRB=1619153\nG=helix-reviewers\nA=jxue\n\nSigned-off-by: Hunter Lee <hulee@linkedin.com>\n","date":"2019-05-25 09:19:20","modifiedFileCount":"2","status":"M","submitter":"Hunter Lee"},{"authorTime":"2020-05-15 08:34:22","codes":[{"authorDate":"2019-04-04 08:12:56","commitOrder":13,"curCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      \r\n      Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n      while (insIter.hasNext()) {\n        String state = insIter.next().getValue();\n        if (ignoredStates.contains(state)) {\n          insIter.remove();\n        }\n      }\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      }\n    }\n  }\n","date":"2019-05-25 09:19:20","endLine":345,"groupId":"10667","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"removeEntryWithIgnoredStates","params":"(Iterator<Map.Entry<String@Map<String@String>>>partitionInstanceStateMapIter@Set<String>ignoredStates)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/74/b9b3c08b55e361509c0357e3dc817d09f3db05.src","preCode":"  private void removeEntryWithIgnoredStates(\n      Iterator<Map.Entry<String, Map<String, String>>> partitionInstanceStateMapIter,\n      Set<String> ignoredStates) {\n    while (partitionInstanceStateMapIter.hasNext()) {\n      Map.Entry<String, Map<String, String>> entry = partitionInstanceStateMapIter.next();\n      Map<String, String> instanceStateMap = entry.getValue();\n      \r\n      Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n      while (insIter.hasNext()) {\n        String state = insIter.next().getValue();\n        if (ignoredStates.contains(state)) {\n          insIter.remove();\n        }\n      }\n      if (instanceStateMap.isEmpty()) {\n        partitionInstanceStateMapIter.remove();\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":327,"status":"N"},{"authorDate":"2020-05-15 08:34:22","commitOrder":13,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews =\n            accessor.getChildValuesMap(keyBuilder.externalViews(), true);\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2020-05-15 08:34:22","endLine":336,"groupId":"10667","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/5d/8d1a04c92500c2c194fd9684815059bd3b28e5.src","preCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"M"}],"commitId":"6ff99f5a181fb5fe91340968f93ca2cd5329a90a","commitMessage":"@@@Enforce result check for data accessors batch get calls to prevent partial batch read. (#974)\n\nThis will help to ensure the main Helix logic does not calculate based on incomplete input.","date":"2020-05-15 08:34:22","modifiedFileCount":"49","status":"M","submitter":"Jiajun Wang"}]
