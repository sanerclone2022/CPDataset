[{"authorTime":"2018-10-31 06:55:20","codes":[{"authorDate":"2018-10-31 06:55:20","commitOrder":1,"curCode":"  private void updateCachedTopStateLocation(ClusterDataCache cache, String resourceName,\n      Partition partition, String currentTopStateInstance) {\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (!lastTopStateMap.containsKey(resourceName)) {\n      lastTopStateMap.put(resourceName, new HashMap<String, String>());\n    }\n    lastTopStateMap.get(resourceName).put(partition.getPartitionName(), currentTopStateInstance);\n  }\n","date":"2018-10-31 06:58:45","endLine":173,"groupId":"3631","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"updateCachedTopStateLocation","params":"(ClusterDataCachecache@StringresourceName@Partitionpartition@StringcurrentTopStateInstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/69/9f2a891874185f789926330765e36a53f832c3.src","preCode":"  private void updateCachedTopStateLocation(ClusterDataCache cache, String resourceName,\n      Partition partition, String currentTopStateInstance) {\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (!lastTopStateMap.containsKey(resourceName)) {\n      lastTopStateMap.put(resourceName, new HashMap<String, String>());\n    }\n    lastTopStateMap.get(resourceName).put(partition.getPartitionName(), currentTopStateInstance);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/stages/TopStateHandoffReportStage.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":166,"status":"B"},{"authorDate":"2018-10-31 06:55:20","commitOrder":1,"curCode":"  private void reportTopStateMissing(ClusterDataCache cache, String resourceName, Partition partition,\n      String topState, CurrentStateOutput currentStateOutput) {\n    Map<String, Map<String, MissingTopStateRecord>> missingTopStateMap = cache.getMissingTopStateMap();\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (missingTopStateMap.containsKey(resourceName) && missingTopStateMap.get(resourceName)\n        .containsKey(partition.getPartitionName())) {\n      \r\n      return;\n    }\n\n    long startTime = TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED;\n    long fromTopStateUserLatency = DEFAULT_HANDOFF_USER_LATENCY;\n    boolean isGraceful = true;\n\n    \r\n    String missingStateInstance = null;\n    if (lastTopStateMap.containsKey(resourceName)) {\n      missingStateInstance = lastTopStateMap.get(resourceName).get(partition.getPartitionName());\n    }\n\n    if (missingStateInstance != null) {\n      Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n      if (liveInstances.containsKey(missingStateInstance)) {\n        CurrentState currentState = cache.getCurrentState(missingStateInstance,\n            liveInstances.get(missingStateInstance).getSessionId()).get(resourceName);\n\n        if (currentState != null\n            && currentState.getPreviousState(partition.getPartitionName()) != null && currentState\n            .getPreviousState(partition.getPartitionName()).equalsIgnoreCase(topState)) {\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          long fromTopStateStartTime = currentState.getStartTime(partition.getPartitionName());\n          if (fromTopStateStartTime > startTime) {\n            startTime = fromTopStateStartTime;\n            fromTopStateUserLatency =\n                currentState.getEndTime(partition.getPartitionName()) - startTime;\n          }\n          startTime = Math.max(startTime, currentState.getStartTime(partition.getPartitionName()));\n        } \r\n      } else {\n        \r\n        \r\n        \r\n        isGraceful = false;\n        Map<String, Long> offlineMap = cache.getInstanceOfflineTimeMap();\n        if (offlineMap.containsKey(missingStateInstance)) {\n          startTime = Math.max(startTime, offlineMap.get(missingStateInstance));\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      for (Message message : currentStateOutput.getPendingMessageMap(resourceName, partition)\n          .values()) {\n        \r\n        \r\n        if (message.getToState().equals(topState)) {\n          startTime = Math.max(startTime, message.getCreateTimeStamp());\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      LogUtil.logWarn(LOG, _eventId,\n          \"Cannot confirm top state missing start time. Use the current system time as the start time.\");\n      startTime = System.currentTimeMillis();\n    }\n\n    if (!missingTopStateMap.containsKey(resourceName)) {\n      missingTopStateMap.put(resourceName, new HashMap<String, MissingTopStateRecord>());\n    }\n\n    missingTopStateMap.get(resourceName).put(partition.getPartitionName(),\n        new MissingTopStateRecord(startTime, fromTopStateUserLatency, isGraceful));\n  }\n","date":"2018-10-31 06:58:45","endLine":427,"groupId":"3631","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"reportTopStateMissing","params":"(ClusterDataCachecache@StringresourceName@Partitionpartition@StringtopState@CurrentStateOutputcurrentStateOutput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/69/9f2a891874185f789926330765e36a53f832c3.src","preCode":"  private void reportTopStateMissing(ClusterDataCache cache, String resourceName, Partition partition,\n      String topState, CurrentStateOutput currentStateOutput) {\n    Map<String, Map<String, MissingTopStateRecord>> missingTopStateMap = cache.getMissingTopStateMap();\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (missingTopStateMap.containsKey(resourceName) && missingTopStateMap.get(resourceName)\n        .containsKey(partition.getPartitionName())) {\n      \r\n      return;\n    }\n\n    long startTime = TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED;\n    long fromTopStateUserLatency = DEFAULT_HANDOFF_USER_LATENCY;\n    boolean isGraceful = true;\n\n    \r\n    String missingStateInstance = null;\n    if (lastTopStateMap.containsKey(resourceName)) {\n      missingStateInstance = lastTopStateMap.get(resourceName).get(partition.getPartitionName());\n    }\n\n    if (missingStateInstance != null) {\n      Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n      if (liveInstances.containsKey(missingStateInstance)) {\n        CurrentState currentState = cache.getCurrentState(missingStateInstance,\n            liveInstances.get(missingStateInstance).getSessionId()).get(resourceName);\n\n        if (currentState != null\n            && currentState.getPreviousState(partition.getPartitionName()) != null && currentState\n            .getPreviousState(partition.getPartitionName()).equalsIgnoreCase(topState)) {\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          long fromTopStateStartTime = currentState.getStartTime(partition.getPartitionName());\n          if (fromTopStateStartTime > startTime) {\n            startTime = fromTopStateStartTime;\n            fromTopStateUserLatency =\n                currentState.getEndTime(partition.getPartitionName()) - startTime;\n          }\n          startTime = Math.max(startTime, currentState.getStartTime(partition.getPartitionName()));\n        } \r\n      } else {\n        \r\n        \r\n        \r\n        isGraceful = false;\n        Map<String, Long> offlineMap = cache.getInstanceOfflineTimeMap();\n        if (offlineMap.containsKey(missingStateInstance)) {\n          startTime = Math.max(startTime, offlineMap.get(missingStateInstance));\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      for (Message message : currentStateOutput.getPendingMessageMap(resourceName, partition)\n          .values()) {\n        \r\n        \r\n        if (message.getToState().equals(topState)) {\n          startTime = Math.max(startTime, message.getCreateTimeStamp());\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      LogUtil.logWarn(LOG, _eventId,\n          \"Cannot confirm top state missing start time. Use the current system time as the start time.\");\n      startTime = System.currentTimeMillis();\n    }\n\n    if (!missingTopStateMap.containsKey(resourceName)) {\n      missingTopStateMap.put(resourceName, new HashMap<String, MissingTopStateRecord>());\n    }\n\n    missingTopStateMap.get(resourceName).put(partition.getPartitionName(),\n        new MissingTopStateRecord(startTime, fromTopStateUserLatency, isGraceful));\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/stages/TopStateHandoffReportStage.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":337,"status":"B"}],"commitId":"7e49f995e29ea200fcc42ce6af148ed521979f5c","commitMessage":"@@@[HELIX-771] More detailed top state handoff metrics\n","date":"2018-10-31 06:58:45","modifiedFileCount":"9","status":"B","submitter":"Harry Zhang"},{"authorTime":"2019-02-26 09:36:00","codes":[{"authorDate":"2019-02-26 09:36:00","commitOrder":2,"curCode":"  private void updateCachedTopStateLocation(ResourceControllerDataProvider cache, String resourceName,\n      Partition partition, String currentTopStateInstance) {\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (!lastTopStateMap.containsKey(resourceName)) {\n      lastTopStateMap.put(resourceName, new HashMap<String, String>());\n    }\n    lastTopStateMap.get(resourceName).put(partition.getPartitionName(), currentTopStateInstance);\n  }\n","date":"2019-02-26 09:36:00","endLine":177,"groupId":"3631","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"updateCachedTopStateLocation","params":"(ResourceControllerDataProvidercache@StringresourceName@Partitionpartition@StringcurrentTopStateInstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/54/3e8398b3540fad0f68ee0a204449cda362d514.src","preCode":"  private void updateCachedTopStateLocation(ClusterDataCache cache, String resourceName,\n      Partition partition, String currentTopStateInstance) {\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (!lastTopStateMap.containsKey(resourceName)) {\n      lastTopStateMap.put(resourceName, new HashMap<String, String>());\n    }\n    lastTopStateMap.get(resourceName).put(partition.getPartitionName(), currentTopStateInstance);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/stages/TopStateHandoffReportStage.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"},{"authorDate":"2019-02-26 09:36:00","commitOrder":2,"curCode":"  private void reportTopStateMissing(ResourceControllerDataProvider cache, String resourceName, Partition partition,\n      String topState, CurrentStateOutput currentStateOutput) {\n    Map<String, Map<String, MissingTopStateRecord>> missingTopStateMap = cache.getMissingTopStateMap();\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (missingTopStateMap.containsKey(resourceName) && missingTopStateMap.get(resourceName)\n        .containsKey(partition.getPartitionName())) {\n      \r\n      return;\n    }\n\n    long startTime = TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED;\n    long fromTopStateUserLatency = DEFAULT_HANDOFF_USER_LATENCY;\n    boolean isGraceful = true;\n\n    \r\n    String missingStateInstance = null;\n    if (lastTopStateMap.containsKey(resourceName)) {\n      missingStateInstance = lastTopStateMap.get(resourceName).get(partition.getPartitionName());\n    }\n\n    if (missingStateInstance != null) {\n      Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n      if (liveInstances.containsKey(missingStateInstance)) {\n        CurrentState currentState = cache.getCurrentState(missingStateInstance,\n            liveInstances.get(missingStateInstance).getSessionId()).get(resourceName);\n\n        if (currentState != null\n            && currentState.getPreviousState(partition.getPartitionName()) != null && currentState\n            .getPreviousState(partition.getPartitionName()).equalsIgnoreCase(topState)) {\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          long fromTopStateStartTime = currentState.getStartTime(partition.getPartitionName());\n          if (fromTopStateStartTime > startTime) {\n            startTime = fromTopStateStartTime;\n            fromTopStateUserLatency =\n                currentState.getEndTime(partition.getPartitionName()) - startTime;\n          }\n          startTime = Math.max(startTime, currentState.getStartTime(partition.getPartitionName()));\n        } \r\n      } else {\n        \r\n        \r\n        \r\n        isGraceful = false;\n        Map<String, Long> offlineMap = cache.getInstanceOfflineTimeMap();\n        if (offlineMap.containsKey(missingStateInstance)) {\n          startTime = Math.max(startTime, offlineMap.get(missingStateInstance));\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      for (Message message : currentStateOutput.getPendingMessageMap(resourceName, partition)\n          .values()) {\n        \r\n        \r\n        if (message.getToState().equals(topState)) {\n          startTime = Math.max(startTime, message.getCreateTimeStamp());\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      LogUtil.logWarn(LOG, _eventId,\n          \"Cannot confirm top state missing start time. Use the current system time as the start time.\");\n      startTime = System.currentTimeMillis();\n    }\n\n    if (!missingTopStateMap.containsKey(resourceName)) {\n      missingTopStateMap.put(resourceName, new HashMap<String, MissingTopStateRecord>());\n    }\n\n    missingTopStateMap.get(resourceName).put(partition.getPartitionName(),\n        new MissingTopStateRecord(startTime, fromTopStateUserLatency, isGraceful));\n  }\n","date":"2019-02-26 09:36:00","endLine":431,"groupId":"3631","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"reportTopStateMissing","params":"(ResourceControllerDataProvidercache@StringresourceName@Partitionpartition@StringtopState@CurrentStateOutputcurrentStateOutput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/54/3e8398b3540fad0f68ee0a204449cda362d514.src","preCode":"  private void reportTopStateMissing(ClusterDataCache cache, String resourceName, Partition partition,\n      String topState, CurrentStateOutput currentStateOutput) {\n    Map<String, Map<String, MissingTopStateRecord>> missingTopStateMap = cache.getMissingTopStateMap();\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (missingTopStateMap.containsKey(resourceName) && missingTopStateMap.get(resourceName)\n        .containsKey(partition.getPartitionName())) {\n      \r\n      return;\n    }\n\n    long startTime = TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED;\n    long fromTopStateUserLatency = DEFAULT_HANDOFF_USER_LATENCY;\n    boolean isGraceful = true;\n\n    \r\n    String missingStateInstance = null;\n    if (lastTopStateMap.containsKey(resourceName)) {\n      missingStateInstance = lastTopStateMap.get(resourceName).get(partition.getPartitionName());\n    }\n\n    if (missingStateInstance != null) {\n      Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n      if (liveInstances.containsKey(missingStateInstance)) {\n        CurrentState currentState = cache.getCurrentState(missingStateInstance,\n            liveInstances.get(missingStateInstance).getSessionId()).get(resourceName);\n\n        if (currentState != null\n            && currentState.getPreviousState(partition.getPartitionName()) != null && currentState\n            .getPreviousState(partition.getPartitionName()).equalsIgnoreCase(topState)) {\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          long fromTopStateStartTime = currentState.getStartTime(partition.getPartitionName());\n          if (fromTopStateStartTime > startTime) {\n            startTime = fromTopStateStartTime;\n            fromTopStateUserLatency =\n                currentState.getEndTime(partition.getPartitionName()) - startTime;\n          }\n          startTime = Math.max(startTime, currentState.getStartTime(partition.getPartitionName()));\n        } \r\n      } else {\n        \r\n        \r\n        \r\n        isGraceful = false;\n        Map<String, Long> offlineMap = cache.getInstanceOfflineTimeMap();\n        if (offlineMap.containsKey(missingStateInstance)) {\n          startTime = Math.max(startTime, offlineMap.get(missingStateInstance));\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      for (Message message : currentStateOutput.getPendingMessageMap(resourceName, partition)\n          .values()) {\n        \r\n        \r\n        if (message.getToState().equals(topState)) {\n          startTime = Math.max(startTime, message.getCreateTimeStamp());\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      LogUtil.logWarn(LOG, _eventId,\n          \"Cannot confirm top state missing start time. Use the current system time as the start time.\");\n      startTime = System.currentTimeMillis();\n    }\n\n    if (!missingTopStateMap.containsKey(resourceName)) {\n      missingTopStateMap.put(resourceName, new HashMap<String, MissingTopStateRecord>());\n    }\n\n    missingTopStateMap.get(resourceName).put(partition.getPartitionName(),\n        new MissingTopStateRecord(startTime, fromTopStateUserLatency, isGraceful));\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/stages/TopStateHandoffReportStage.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":341,"status":"M"}],"commitId":"fbb679c5f4804652ea730bf5cd4ee6bf1329efc3","commitMessage":"@@@split data cache\n","date":"2019-02-26 09:36:00","modifiedFileCount":"95","status":"M","submitter":"Harry Zhang"},{"authorTime":"2019-06-18 05:37:02","codes":[{"authorDate":"2019-02-26 09:36:00","commitOrder":3,"curCode":"  private void updateCachedTopStateLocation(ResourceControllerDataProvider cache, String resourceName,\n      Partition partition, String currentTopStateInstance) {\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (!lastTopStateMap.containsKey(resourceName)) {\n      lastTopStateMap.put(resourceName, new HashMap<String, String>());\n    }\n    lastTopStateMap.get(resourceName).put(partition.getPartitionName(), currentTopStateInstance);\n  }\n","date":"2019-02-26 09:36:00","endLine":177,"groupId":"10850","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"updateCachedTopStateLocation","params":"(ResourceControllerDataProvidercache@StringresourceName@Partitionpartition@StringcurrentTopStateInstance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/54/3e8398b3540fad0f68ee0a204449cda362d514.src","preCode":"  private void updateCachedTopStateLocation(ResourceControllerDataProvider cache, String resourceName,\n      Partition partition, String currentTopStateInstance) {\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (!lastTopStateMap.containsKey(resourceName)) {\n      lastTopStateMap.put(resourceName, new HashMap<String, String>());\n    }\n    lastTopStateMap.get(resourceName).put(partition.getPartitionName(), currentTopStateInstance);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/stages/TopStateHandoffReportStage.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"N"},{"authorDate":"2019-06-18 05:37:02","commitOrder":3,"curCode":"  private void reportTopStateMissing(ResourceControllerDataProvider cache, String resourceName, Partition partition,\n      String topState, CurrentStateOutput currentStateOutput) {\n    Map<String, Map<String, MissingTopStateRecord>> missingTopStateMap = cache.getMissingTopStateMap();\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (missingTopStateMap.containsKey(resourceName) && missingTopStateMap.get(resourceName)\n        .containsKey(partition.getPartitionName())) {\n      \r\n      return;\n    }\n\n    long startTime = TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED;\n    long fromTopStateUserLatency = DEFAULT_HANDOFF_USER_LATENCY;\n    boolean isGraceful = true;\n\n    \r\n    String missingStateInstance = null;\n    if (lastTopStateMap.containsKey(resourceName)) {\n      missingStateInstance = lastTopStateMap.get(resourceName).get(partition.getPartitionName());\n    }\n\n    if (missingStateInstance != null) {\n      Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n      if (liveInstances.containsKey(missingStateInstance)) {\n        CurrentState currentState = cache.getCurrentState(missingStateInstance,\n            liveInstances.get(missingStateInstance).getEphemeralOwner()).get(resourceName);\n\n        if (currentState != null\n            && currentState.getPreviousState(partition.getPartitionName()) != null && currentState\n            .getPreviousState(partition.getPartitionName()).equalsIgnoreCase(topState)) {\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          long fromTopStateStartTime = currentState.getStartTime(partition.getPartitionName());\n          if (fromTopStateStartTime > startTime) {\n            startTime = fromTopStateStartTime;\n            fromTopStateUserLatency =\n                currentState.getEndTime(partition.getPartitionName()) - startTime;\n          }\n          startTime = Math.max(startTime, currentState.getStartTime(partition.getPartitionName()));\n        } \r\n      } else {\n        \r\n        \r\n        \r\n        isGraceful = false;\n        Map<String, Long> offlineMap = cache.getInstanceOfflineTimeMap();\n        if (offlineMap.containsKey(missingStateInstance)) {\n          startTime = Math.max(startTime, offlineMap.get(missingStateInstance));\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      for (Message message : currentStateOutput.getPendingMessageMap(resourceName, partition)\n          .values()) {\n        \r\n        \r\n        if (message.getToState().equals(topState)) {\n          startTime = Math.max(startTime, message.getCreateTimeStamp());\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      LogUtil.logWarn(LOG, _eventId,\n          \"Cannot confirm top state missing start time. Use the current system time as the start time.\");\n      startTime = System.currentTimeMillis();\n    }\n\n    if (!missingTopStateMap.containsKey(resourceName)) {\n      missingTopStateMap.put(resourceName, new HashMap<String, MissingTopStateRecord>());\n    }\n\n    missingTopStateMap.get(resourceName).put(partition.getPartitionName(),\n        new MissingTopStateRecord(startTime, fromTopStateUserLatency, isGraceful));\n  }\n","date":"2019-06-25 07:46:15","endLine":432,"groupId":"10850","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"reportTopStateMissing","params":"(ResourceControllerDataProvidercache@StringresourceName@Partitionpartition@StringtopState@CurrentStateOutputcurrentStateOutput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f2/b49e50d967336bcbf451a85861ee1aed14a666.src","preCode":"  private void reportTopStateMissing(ResourceControllerDataProvider cache, String resourceName, Partition partition,\n      String topState, CurrentStateOutput currentStateOutput) {\n    Map<String, Map<String, MissingTopStateRecord>> missingTopStateMap = cache.getMissingTopStateMap();\n    Map<String, Map<String, String>> lastTopStateMap = cache.getLastTopStateLocationMap();\n    if (missingTopStateMap.containsKey(resourceName) && missingTopStateMap.get(resourceName)\n        .containsKey(partition.getPartitionName())) {\n      \r\n      return;\n    }\n\n    long startTime = TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED;\n    long fromTopStateUserLatency = DEFAULT_HANDOFF_USER_LATENCY;\n    boolean isGraceful = true;\n\n    \r\n    String missingStateInstance = null;\n    if (lastTopStateMap.containsKey(resourceName)) {\n      missingStateInstance = lastTopStateMap.get(resourceName).get(partition.getPartitionName());\n    }\n\n    if (missingStateInstance != null) {\n      Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n      if (liveInstances.containsKey(missingStateInstance)) {\n        CurrentState currentState = cache.getCurrentState(missingStateInstance,\n            liveInstances.get(missingStateInstance).getSessionId()).get(resourceName);\n\n        if (currentState != null\n            && currentState.getPreviousState(partition.getPartitionName()) != null && currentState\n            .getPreviousState(partition.getPartitionName()).equalsIgnoreCase(topState)) {\n\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          \r\n          long fromTopStateStartTime = currentState.getStartTime(partition.getPartitionName());\n          if (fromTopStateStartTime > startTime) {\n            startTime = fromTopStateStartTime;\n            fromTopStateUserLatency =\n                currentState.getEndTime(partition.getPartitionName()) - startTime;\n          }\n          startTime = Math.max(startTime, currentState.getStartTime(partition.getPartitionName()));\n        } \r\n      } else {\n        \r\n        \r\n        \r\n        isGraceful = false;\n        Map<String, Long> offlineMap = cache.getInstanceOfflineTimeMap();\n        if (offlineMap.containsKey(missingStateInstance)) {\n          startTime = Math.max(startTime, offlineMap.get(missingStateInstance));\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      for (Message message : currentStateOutput.getPendingMessageMap(resourceName, partition)\n          .values()) {\n        \r\n        \r\n        if (message.getToState().equals(topState)) {\n          startTime = Math.max(startTime, message.getCreateTimeStamp());\n        }\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    if (startTime == TopStateHandoffReportStage.TIMESTAMP_NOT_RECORDED) {\n      LogUtil.logWarn(LOG, _eventId,\n          \"Cannot confirm top state missing start time. Use the current system time as the start time.\");\n      startTime = System.currentTimeMillis();\n    }\n\n    if (!missingTopStateMap.containsKey(resourceName)) {\n      missingTopStateMap.put(resourceName, new HashMap<String, MissingTopStateRecord>());\n    }\n\n    missingTopStateMap.get(resourceName).put(partition.getPartitionName(),\n        new MissingTopStateRecord(startTime, fromTopStateUserLatency, isGraceful));\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/stages/TopStateHandoffReportStage.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":342,"status":"M"}],"commitId":"ad0c2edb31a4d0e5c455d1fa0f96658bac1382d5","commitMessage":"@@@Always try reading from EphemeralOwner state first while reading the session ID from a live instance node.\n\nThis is to avoid inconsistent session ID in the node content and the emphemeral owner state.\nNote that in order to ensure backward compatiblity and some test cases.  the newly introduced method will still read from the node content if the ephemeral owner state is empty (-1 or 0).\n\nRB=1704942\nBUG=HELIX-1969\nG=helix-reviewers\nA=jxue\n\nSigned-off-by: Hunter Lee <hulee@linkedin.com>\n","date":"2019-06-25 07:46:15","modifiedFileCount":"33","status":"M","submitter":"Jiajun Wang"}]
