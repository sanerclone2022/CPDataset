[{"authorTime":"2019-03-29 03:27:52","codes":[{"authorDate":"2018-07-17 02:48:19","commitOrder":5,"curCode":"  public void testTransitionThrottleOnErrorPartition() throws Exception {\n    String clusterName = getShortClassName() + \"testMaxErrorPartition\";\n    MockParticipantManager[] participants = new MockParticipantManager[participantCount];\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    final ZKHelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    setupCluster(clusterName, accessor);\n\n    \r\n    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n    ClusterConfig clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n    throttleConfigs.add(\n        new StateTransitionThrottleConfig(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE,\n            StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    \r\n    Map<String, Set<String>> errPartitions = new HashMap<>();\n    errPartitions.put(\"OFFLINE-SLAVE\", TestHelper.setOf(resourceName + \"_0\"));\n\n    \r\n    for (int i = 0; i < participantCount - 1; i++) {\n      participants[i] =\n          new MockParticipantManager(ZK_ADDR, clusterName, \"localhost_\" + (12918 + i));\n      if (i == 0) {\n        participants[i].setTransition(new ErrTransition(errPartitions));\n      }\n      participants[i].syncStart();\n    }\n\n    ClusterControllerManager controller =\n        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n    controller.syncStart();\n\n    BestPossibleExternalViewVerifier verifier =\n        new BestPossibleExternalViewVerifier.Builder(clusterName).setZkClient(_gZkClient).build();\n    Assert.assertTrue(verifier.verify(3000));\n\n    \r\n    participants[participantCount - 1] = new MockParticipantManager(ZK_ADDR, clusterName,\n        \"localhost_\" + (12918 + participantCount - 1));\n    participants[participantCount - 1].syncStart();\n    \r\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 5000));\n\n    \r\n    clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setErrorPartitionThresholdForLoadBalance(1);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    _gSetupTool.rebalanceResource(clusterName, resourceName, 3);\n\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 3000));\n\n    \r\n    controller.syncStop();\n    for (int i = 0; i < participantCount; i++) {\n      participants[i].syncStop();\n    }\n    deleteCluster(clusterName);\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2018-07-17 05:55:31","endLine":191,"groupId":"7073","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionThrottleOnErrorPartition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/86/1eee0620fecaaeeda8fec8281b7f6b67d56fe0.src","preCode":"  public void testTransitionThrottleOnErrorPartition() throws Exception {\n    String clusterName = getShortClassName() + \"testMaxErrorPartition\";\n    MockParticipantManager[] participants = new MockParticipantManager[participantCount];\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    final ZKHelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    setupCluster(clusterName, accessor);\n\n    \r\n    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n    ClusterConfig clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n    throttleConfigs.add(\n        new StateTransitionThrottleConfig(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE,\n            StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    \r\n    Map<String, Set<String>> errPartitions = new HashMap<>();\n    errPartitions.put(\"OFFLINE-SLAVE\", TestHelper.setOf(resourceName + \"_0\"));\n\n    \r\n    for (int i = 0; i < participantCount - 1; i++) {\n      participants[i] =\n          new MockParticipantManager(ZK_ADDR, clusterName, \"localhost_\" + (12918 + i));\n      if (i == 0) {\n        participants[i].setTransition(new ErrTransition(errPartitions));\n      }\n      participants[i].syncStart();\n    }\n\n    ClusterControllerManager controller =\n        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n    controller.syncStart();\n\n    BestPossibleExternalViewVerifier verifier =\n        new BestPossibleExternalViewVerifier.Builder(clusterName).setZkClient(_gZkClient).build();\n    Assert.assertTrue(verifier.verify(3000));\n\n    \r\n    participants[participantCount - 1] = new MockParticipantManager(ZK_ADDR, clusterName,\n        \"localhost_\" + (12918 + participantCount - 1));\n    participants[participantCount - 1].syncStart();\n    \r\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 5000));\n\n    \r\n    clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setErrorPartitionThresholdForLoadBalance(1);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    _gSetupTool.rebalanceResource(clusterName, resourceName, 3);\n\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 3000));\n\n    \r\n    controller.syncStop();\n    for (int i = 0; i < participantCount; i++) {\n      participants[i].syncStop();\n    }\n    deleteCluster(clusterName);\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestStateTransitionThrottle.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"NB"},{"authorDate":"2019-03-29 03:27:52","commitOrder":5,"curCode":"  private void setThrottleConfigForRecoveryBalance() {\n    PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n    ClusterConfig clusterConfig = _accessor.getProperty(_accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 0));\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.INSTANCE, 0));\n\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    _accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n  }\n","date":"2019-03-29 03:27:52","endLine":301,"groupId":"7073","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setThrottleConfigForRecoveryBalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/73/bdcf8ae6aceee73d68e970ef3b87760ccf6cef.src","preCode":"  private void setThrottleConfigForRecoveryBalance() {\n    PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n    ClusterConfig clusterConfig = _accessor.getProperty(_accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 0));\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.INSTANCE, 0));\n\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    _accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestNoThrottleDisabledPartitions.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"B"}],"commitId":"de38fa1a4e13939807427694a538ea468f8abb36","commitMessage":"@@@HELIX: Recovery balance partitions with disabled top-state replicas\n\n    Previously.  disabling of partitions or disabled instances did not affect Helix's throttling logic. This was problematic because the ability to disable was designed in in order to move partitons/replicas out of the given instance as a measure to deal with unhealthy partitions/instances. This allows.  for partitions that are disabled.  to go into recovery balance.  and when the user has not set any throttling configs for recovery balance.  these types of state transitions will go through unthrottled.  avoiding downtime.\n    Changelist:\n    1. Add a check for determining rebalance type for a given partition\n    2. Add an integration test\n","date":"2019-03-29 03:27:52","modifiedFileCount":"1","status":"M","submitter":"Hunter Lee"},{"authorTime":"2019-03-29 03:27:52","codes":[{"authorDate":"2019-05-04 08:52:17","commitOrder":6,"curCode":"  public void testTransitionThrottleOnErrorPartition() throws Exception {\n    String clusterName = getShortClassName() + \"testMaxErrorPartition\";\n    MockParticipantManager[] participants = new MockParticipantManager[participantCount];\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    final ZKHelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n    setupCluster(clusterName, accessor);\n\n    \r\n    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n    ClusterConfig clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n    throttleConfigs.add(\n        new StateTransitionThrottleConfig(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE,\n            StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    \r\n    Map<String, Set<String>> errPartitions = new HashMap<>();\n    errPartitions.put(\"OFFLINE-SLAVE\", TestHelper.setOf(resourceName + \"_0\"));\n\n    \r\n    for (int i = 0; i < participantCount - 1; i++) {\n      participants[i] =\n          new MockParticipantManager(ZK_ADDR, clusterName, \"localhost_\" + (12918 + i));\n      if (i == 0) {\n        participants[i].setTransition(new ErrTransition(errPartitions));\n      }\n      participants[i].syncStart();\n    }\n\n    ClusterControllerManager controller =\n        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n    controller.syncStart();\n\n    BestPossibleExternalViewVerifier verifier =\n        new BestPossibleExternalViewVerifier.Builder(clusterName).setZkClient(_gZkClient).build();\n    Assert.assertTrue(verifier.verify(3000));\n\n    \r\n    participants[participantCount - 1] = new MockParticipantManager(ZK_ADDR, clusterName,\n        \"localhost_\" + (12918 + participantCount - 1));\n    participants[participantCount - 1].syncStart();\n    \r\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 5000));\n\n    \r\n    clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setErrorPartitionThresholdForLoadBalance(1);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    _gSetupTool.rebalanceResource(clusterName, resourceName, 3);\n\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 3000));\n\n    \r\n    controller.syncStop();\n    for (int i = 0; i < participantCount; i++) {\n      participants[i].syncStop();\n    }\n    deleteCluster(clusterName);\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2019-05-25 09:19:21","endLine":189,"groupId":"7073","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTransitionThrottleOnErrorPartition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f1/628f602412eb824847ce91fad1f57ca9e354d8.src","preCode":"  public void testTransitionThrottleOnErrorPartition() throws Exception {\n    String clusterName = getShortClassName() + \"testMaxErrorPartition\";\n    MockParticipantManager[] participants = new MockParticipantManager[participantCount];\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    final ZKHelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_gZkClient));\n    setupCluster(clusterName, accessor);\n\n    \r\n    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n    ClusterConfig clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n    throttleConfigs.add(\n        new StateTransitionThrottleConfig(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE,\n            StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    \r\n    Map<String, Set<String>> errPartitions = new HashMap<>();\n    errPartitions.put(\"OFFLINE-SLAVE\", TestHelper.setOf(resourceName + \"_0\"));\n\n    \r\n    for (int i = 0; i < participantCount - 1; i++) {\n      participants[i] =\n          new MockParticipantManager(ZK_ADDR, clusterName, \"localhost_\" + (12918 + i));\n      if (i == 0) {\n        participants[i].setTransition(new ErrTransition(errPartitions));\n      }\n      participants[i].syncStart();\n    }\n\n    ClusterControllerManager controller =\n        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n    controller.syncStart();\n\n    BestPossibleExternalViewVerifier verifier =\n        new BestPossibleExternalViewVerifier.Builder(clusterName).setZkClient(_gZkClient).build();\n    Assert.assertTrue(verifier.verify(3000));\n\n    \r\n    participants[participantCount - 1] = new MockParticipantManager(ZK_ADDR, clusterName,\n        \"localhost_\" + (12918 + participantCount - 1));\n    participants[participantCount - 1].syncStart();\n    \r\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 5000));\n\n    \r\n    clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setErrorPartitionThresholdForLoadBalance(1);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    _gSetupTool.rebalanceResource(clusterName, resourceName, 3);\n\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 3000));\n\n    \r\n    controller.syncStop();\n    for (int i = 0; i < participantCount; i++) {\n      participants[i].syncStop();\n    }\n    deleteCluster(clusterName);\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestStateTransitionThrottle.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2019-03-29 03:27:52","commitOrder":6,"curCode":"  private void setThrottleConfigForRecoveryBalance() {\n    PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n    ClusterConfig clusterConfig = _accessor.getProperty(_accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 0));\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.INSTANCE, 0));\n\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    _accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n  }\n","date":"2019-03-29 03:27:52","endLine":301,"groupId":"7073","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setThrottleConfigForRecoveryBalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/73/bdcf8ae6aceee73d68e970ef3b87760ccf6cef.src","preCode":"  private void setThrottleConfigForRecoveryBalance() {\n    PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n    ClusterConfig clusterConfig = _accessor.getProperty(_accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 0));\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.INSTANCE, 0));\n\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    _accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestNoThrottleDisabledPartitions.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"N"}],"commitId":"5ce3934c5b4655e90021061720adbb3a42b1bb6b","commitMessage":"@@@TEST: Groom and refactor Helix integration tests\n\nIt was observed that there was a lot of technical debt (improper and buggy cleanup) in Helix's unit and integration tests. There were also mock controller and participant threads that were never shut down properly. This was preventing mvn test suite from completing over a remote machine (TMC).  and even on local environments.  mvn test was not passing. This diff refactors tests and makes sure that ZK is cleaned up after tests.\n\nChangelist:\n1. Inspect and correct mock threads (controller.  participant.  spectator.  etc)\n2. Ensure there are no leftover garbage clusters from tests\n3. Java 8 syntax\n4. Style fixes in old tests using Helix open source style file (helix-style.xml)\n\nRB=1654905\nG=helix-reviewers\nA=jxue. eblumena\n\nSigned-off-by: Hunter Lee <hulee@linkedin.com>\n","date":"2019-05-25 09:19:21","modifiedFileCount":"122","status":"M","submitter":"Hunter Lee"},{"authorTime":"2019-03-29 03:27:52","codes":[{"authorDate":"2020-11-18 08:24:18","commitOrder":7,"curCode":"  public void testTransitionThrottleOnErrorPartition() throws Exception {\n    String clusterName = getShortClassName() + \"testMaxErrorPartition\";\n    MockParticipantManager[] participants = new MockParticipantManager[participantCount];\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    final ZKHelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n    setupCluster(clusterName, accessor);\n\n    \r\n    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n    ClusterConfig clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n    throttleConfigs.add(\n        new StateTransitionThrottleConfig(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE,\n            StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    \r\n    Map<String, Set<String>> errPartitions = new HashMap<>();\n    errPartitions.put(\"OFFLINE-SLAVE\", TestHelper.setOf(resourceName + \"_0\"));\n\n    \r\n    for (int i = 0; i < participantCount - 1; i++) {\n      participants[i] =\n          new MockParticipantManager(ZK_ADDR, clusterName, \"localhost_\" + (12918 + i));\n      if (i == 0) {\n        participants[i].setTransition(new ErrTransition(errPartitions));\n      }\n      participants[i].syncStart();\n    }\n\n    ClusterControllerManager controller =\n        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n    controller.syncStart();\n\n    BestPossibleExternalViewVerifier verifier =\n        new BestPossibleExternalViewVerifier.Builder(clusterName).setZkClient(_gZkClient)\n            .setWaitTillVerify(TestHelper.DEFAULT_REBALANCE_PROCESSING_WAIT_TIME)\n            .build();\n    Assert.assertTrue(verifier.verify(3000));\n\n    \r\n    participants[participantCount - 1] = new MockParticipantManager(ZK_ADDR, clusterName,\n        \"localhost_\" + (12918 + participantCount - 1));\n    participants[participantCount - 1].syncStart();\n    \r\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 5000));\n\n    \r\n    clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setErrorPartitionThresholdForLoadBalance(1);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    _gSetupTool.rebalanceResource(clusterName, resourceName, 3);\n\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 3000));\n\n    \r\n    controller.syncStop();\n    for (int i = 0; i < participantCount; i++) {\n      participants[i].syncStop();\n    }\n    deleteCluster(clusterName);\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2020-11-18 08:24:18","endLine":194,"groupId":"10443","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testTransitionThrottleOnErrorPartition","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/52/cc624010e608c000856bc43787876bc984a159.src","preCode":"  public void testTransitionThrottleOnErrorPartition() throws Exception {\n    String clusterName = getShortClassName() + \"testMaxErrorPartition\";\n    MockParticipantManager[] participants = new MockParticipantManager[participantCount];\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    final ZKHelixDataAccessor accessor =\n        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n    setupCluster(clusterName, accessor);\n\n    \r\n    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n    ClusterConfig clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n    throttleConfigs.add(\n        new StateTransitionThrottleConfig(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE,\n            StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 100));\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    \r\n    Map<String, Set<String>> errPartitions = new HashMap<>();\n    errPartitions.put(\"OFFLINE-SLAVE\", TestHelper.setOf(resourceName + \"_0\"));\n\n    \r\n    for (int i = 0; i < participantCount - 1; i++) {\n      participants[i] =\n          new MockParticipantManager(ZK_ADDR, clusterName, \"localhost_\" + (12918 + i));\n      if (i == 0) {\n        participants[i].setTransition(new ErrTransition(errPartitions));\n      }\n      participants[i].syncStart();\n    }\n\n    ClusterControllerManager controller =\n        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n    controller.syncStart();\n\n    BestPossibleExternalViewVerifier verifier =\n        new BestPossibleExternalViewVerifier.Builder(clusterName).setZkClient(_gZkClient).build();\n    Assert.assertTrue(verifier.verify(3000));\n\n    \r\n    participants[participantCount - 1] = new MockParticipantManager(ZK_ADDR, clusterName,\n        \"localhost_\" + (12918 + participantCount - 1));\n    participants[participantCount - 1].syncStart();\n    \r\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 5000));\n\n    \r\n    clusterConfig = accessor.getProperty(accessor.keyBuilder().clusterConfig());\n    clusterConfig.setErrorPartitionThresholdForLoadBalance(1);\n    accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n\n    _gSetupTool.rebalanceResource(clusterName, resourceName, 3);\n\n    Assert.assertTrue(pollForPartitionAssignment(accessor, participants[participantCount - 1],\n        resourceName, 3000));\n\n    \r\n    controller.syncStop();\n    for (int i = 0; i < participantCount; i++) {\n      participants[i].syncStop();\n    }\n    deleteCluster(clusterName);\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestStateTransitionThrottle.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"},{"authorDate":"2019-03-29 03:27:52","commitOrder":7,"curCode":"  private void setThrottleConfigForRecoveryBalance() {\n    PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n    ClusterConfig clusterConfig = _accessor.getProperty(_accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 0));\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.INSTANCE, 0));\n\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    _accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n  }\n","date":"2019-03-29 03:27:52","endLine":301,"groupId":"10443","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setThrottleConfigForRecoveryBalance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/73/bdcf8ae6aceee73d68e970ef3b87760ccf6cef.src","preCode":"  private void setThrottleConfigForRecoveryBalance() {\n    PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n    ClusterConfig clusterConfig = _accessor.getProperty(_accessor.keyBuilder().clusterConfig());\n    clusterConfig.setResourcePriorityField(\"Name\");\n    List<StateTransitionThrottleConfig> throttleConfigs = new ArrayList<>();\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.CLUSTER, 0));\n\n    \r\n    throttleConfigs.add(new StateTransitionThrottleConfig(\n        StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE,\n        StateTransitionThrottleConfig.ThrottleScope.INSTANCE, 0));\n\n    clusterConfig.setStateTransitionThrottleConfigs(throttleConfigs);\n    _accessor.setProperty(keyBuilder.clusterConfig(), clusterConfig);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestNoThrottleDisabledPartitions.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"N"}],"commitId":"1d6d6076550f4076c2108e7738c6f0d54bd4178d","commitMessage":"@@@Stabilizing several tests by giving a starting up waiting periods  (#1533)\n\nStabilizing several tests by giving a starting up waiting periods up-on constructing BestPossibleExternalViewVerifier.\n\nCo-authored-by: Kai Sun <ksun@ksun-mn1.linkedin.biz>","date":"2020-11-18 08:24:18","modifiedFileCount":"12","status":"M","submitter":"kaisun2000"}]
