[{"authorTime":"2018-07-10 06:08:12","codes":[{"authorDate":"2018-10-31 06:55:20","commitOrder":6,"curCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","date":"2018-10-31 06:58:45","endLine":389,"groupId":"4816","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"runPipeLine","params":"(Map<String@CurrentStateInfo>initialCurrentStates@Map<String@CurrentStateInfo>missingTopStates@Map<String@CurrentStateInfo>handOffCurrentStates@MissingStatesDataCacheInjecttestInjection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c1/cfce0560b92ff73ab9c3ab0359ab2cb9ffe43b.src","preCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestTopStateHandoffMetrics.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":373,"status":"B"},{"authorDate":"2018-07-10 06:08:12","commitOrder":6,"curCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _clusterDataCache.requireFullRefresh();\n      _clusterDataCache.refresh(_accessor);\n\n      Map<String, IdealState> idealStates = new HashMap<>(_clusterDataCache.getIdealStates());\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _clusterDataCache.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_clusterDataCache, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _clusterDataCache.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","date":"2018-07-18 02:52:50","endLine":303,"groupId":"3334","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/6e/73df6bc6b4971aae8ae87708fb72482d07775e.src","preCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _clusterDataCache.requireFullRefresh();\n      _clusterDataCache.refresh(_accessor);\n\n      Map<String, IdealState> idealStates = new HashMap<>(_clusterDataCache.getIdealStates());\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _clusterDataCache.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_clusterDataCache, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _clusterDataCache.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"NB"}],"commitId":"7e49f995e29ea200fcc42ce6af148ed521979f5c","commitMessage":"@@@[HELIX-771] More detailed top state handoff metrics\n","date":"2018-10-31 06:58:45","modifiedFileCount":"9","status":"M","submitter":"Harry Zhang"},{"authorTime":"2019-02-26 09:36:00","codes":[{"authorDate":"2018-10-31 06:55:20","commitOrder":7,"curCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","date":"2018-10-31 06:58:45","endLine":389,"groupId":"4816","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"runPipeLine","params":"(Map<String@CurrentStateInfo>initialCurrentStates@Map<String@CurrentStateInfo>missingTopStates@Map<String@CurrentStateInfo>handOffCurrentStates@MissingStatesDataCacheInjecttestInjection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c1/cfce0560b92ff73ab9c3ab0359ab2cb9ffe43b.src","preCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestTopStateHandoffMetrics.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":373,"status":"N"},{"authorDate":"2019-02-26 09:36:00","commitOrder":7,"curCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _dataProvider.requireFullRefresh();\n      _dataProvider.refresh(_accessor);\n\n      Map<String, IdealState> idealStates = new HashMap<>(_dataProvider.getIdealStates());\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _dataProvider.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_dataProvider, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _dataProvider.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","date":"2019-02-26 09:36:00","endLine":308,"groupId":"2620","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/18/a0081967f96b6a35de9ffd170bfd6fddba414f.src","preCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _clusterDataCache.requireFullRefresh();\n      _clusterDataCache.refresh(_accessor);\n\n      Map<String, IdealState> idealStates = new HashMap<>(_clusterDataCache.getIdealStates());\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _clusterDataCache.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_clusterDataCache, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _clusterDataCache.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"fbb679c5f4804652ea730bf5cd4ee6bf1329efc3","commitMessage":"@@@split data cache\n","date":"2019-02-26 09:36:00","modifiedFileCount":"95","status":"M","submitter":"Harry Zhang"},{"authorTime":"2019-01-31 02:48:29","codes":[{"authorDate":"2018-10-31 06:55:20","commitOrder":8,"curCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","date":"2018-10-31 06:58:45","endLine":389,"groupId":"4816","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"runPipeLine","params":"(Map<String@CurrentStateInfo>initialCurrentStates@Map<String@CurrentStateInfo>missingTopStates@Map<String@CurrentStateInfo>handOffCurrentStates@MissingStatesDataCacheInjecttestInjection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c1/cfce0560b92ff73ab9c3ab0359ab2cb9ffe43b.src","preCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestTopStateHandoffMetrics.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":373,"status":"N"},{"authorDate":"2019-01-31 02:48:29","commitOrder":8,"curCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _dataProvider.requireFullRefresh();\n      _dataProvider.refresh(_accessor);\n      _dataProvider.setClusterEventId(\"ClusterStateVerifier\");\n\n      Map<String, IdealState> idealStates = new HashMap<>(_dataProvider.getIdealStates());\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _dataProvider.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_dataProvider, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _dataProvider.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","date":"2019-02-27 09:18:02","endLine":309,"groupId":"2620","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/77/cbcca1e53ca0535291c64b6d6f364b11268503.src","preCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _dataProvider.requireFullRefresh();\n      _dataProvider.refresh(_accessor);\n\n      Map<String, IdealState> idealStates = new HashMap<>(_dataProvider.getIdealStates());\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _dataProvider.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_dataProvider, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _dataProvider.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"19b6d7c1db3fdce261e9f035c87e155e06315b80","commitMessage":"@@@Fix race condition in P2P message handling that can cause long mastership handoff problem.\n","date":"2019-02-27 09:18:02","modifiedFileCount":"12","status":"M","submitter":"Lei Xia"},{"authorTime":"2019-05-04 08:52:17","codes":[{"authorDate":"2018-10-31 06:55:20","commitOrder":9,"curCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","date":"2018-10-31 06:58:45","endLine":389,"groupId":"4816","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"runPipeLine","params":"(Map<String@CurrentStateInfo>initialCurrentStates@Map<String@CurrentStateInfo>missingTopStates@Map<String@CurrentStateInfo>handOffCurrentStates@MissingStatesDataCacheInjecttestInjection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c1/cfce0560b92ff73ab9c3ab0359ab2cb9ffe43b.src","preCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestTopStateHandoffMetrics.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":373,"status":"N"},{"authorDate":"2019-05-04 08:52:17","commitOrder":9,"curCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _dataProvider.requireFullRefresh();\n      _dataProvider.refresh(_accessor);\n      _dataProvider.setClusterEventId(\"ClusterStateVerifier\");\n\n      Map<String, IdealState> idealStates = new HashMap<>(_dataProvider.getIdealStates());\n\n      \r\n      idealStates.entrySet()\n          .removeIf(pair -> pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME));\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _dataProvider.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_dataProvider, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _dataProvider.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","date":"2019-05-25 09:19:21","endLine":304,"groupId":"2620","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/52/ced19bae3158e0e7da0e706d12e08aadc2f0d7.src","preCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _dataProvider.requireFullRefresh();\n      _dataProvider.refresh(_accessor);\n      _dataProvider.setClusterEventId(\"ClusterStateVerifier\");\n\n      Map<String, IdealState> idealStates = new HashMap<>(_dataProvider.getIdealStates());\n\n      \r\n      Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n      while (it.hasNext()) {\n        Map.Entry<String, IdealState> pair = it.next();\n        if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n          it.remove();\n        }\n      }\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _dataProvider.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_dataProvider, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _dataProvider.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":193,"status":"M"}],"commitId":"5ce3934c5b4655e90021061720adbb3a42b1bb6b","commitMessage":"@@@TEST: Groom and refactor Helix integration tests\n\nIt was observed that there was a lot of technical debt (improper and buggy cleanup) in Helix's unit and integration tests. There were also mock controller and participant threads that were never shut down properly. This was preventing mvn test suite from completing over a remote machine (TMC).  and even on local environments.  mvn test was not passing. This diff refactors tests and makes sure that ZK is cleaned up after tests.\n\nChangelist:\n1. Inspect and correct mock threads (controller.  participant.  spectator.  etc)\n2. Ensure there are no leftover garbage clusters from tests\n3. Java 8 syntax\n4. Style fixes in old tests using Helix open source style file (helix-style.xml)\n\nRB=1654905\nG=helix-reviewers\nA=jxue. eblumena\n\nSigned-off-by: Hunter Lee <hulee@linkedin.com>\n","date":"2019-05-25 09:19:21","modifiedFileCount":"122","status":"M","submitter":"Hunter Lee"},{"authorTime":"2020-05-15 08:34:22","codes":[{"authorDate":"2018-10-31 06:55:20","commitOrder":10,"curCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","date":"2018-10-31 06:58:45","endLine":389,"groupId":"1096","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"runPipeLine","params":"(Map<String@CurrentStateInfo>initialCurrentStates@Map<String@CurrentStateInfo>missingTopStates@Map<String@CurrentStateInfo>handOffCurrentStates@MissingStatesDataCacheInjecttestInjection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c1/cfce0560b92ff73ab9c3ab0359ab2cb9ffe43b.src","preCode":"  private void runPipeLine(Map<String, CurrentStateInfo> initialCurrentStates,\n      Map<String, CurrentStateInfo> missingTopStates,\n      Map<String, CurrentStateInfo> handOffCurrentStates,\n      MissingStatesDataCacheInject testInjection) {\n\n    if (initialCurrentStates != null && !initialCurrentStates.isEmpty()) {\n      doRunStages(initialCurrentStates, null);\n    }\n\n    if (missingTopStates != null && !missingTopStates.isEmpty()) {\n      doRunStages(missingTopStates, testInjection);\n    }\n\n    if (handOffCurrentStates != null && !handOffCurrentStates.isEmpty()) {\n      doRunStages(handOffCurrentStates, null);\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestTopStateHandoffMetrics.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":373,"status":"N"},{"authorDate":"2020-05-15 08:34:22","commitOrder":10,"curCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _dataProvider.requireFullRefresh();\n      _dataProvider.refresh(_accessor);\n      _dataProvider.setClusterEventId(\"ClusterStateVerifier\");\n\n      Map<String, IdealState> idealStates = new HashMap<>(_dataProvider.getIdealStates());\n\n      \r\n      idealStates.entrySet()\n          .removeIf(pair -> pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME));\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _dataProvider.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes\n              .toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews =\n          _accessor.getChildValuesMap(keyBuilder.externalViews(), true);\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_dataProvider, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _dataProvider.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","date":"2020-05-15 08:34:22","endLine":344,"groupId":"1096","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyState","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/aa/663bcce2355c477a7f2763edd08cad1b550a3d.src","preCode":"  protected synchronized boolean verifyState() {\n    try {\n      PropertyKey.Builder keyBuilder = _accessor.keyBuilder();\n\n      _dataProvider.requireFullRefresh();\n      _dataProvider.refresh(_accessor);\n      _dataProvider.setClusterEventId(\"ClusterStateVerifier\");\n\n      Map<String, IdealState> idealStates = new HashMap<>(_dataProvider.getIdealStates());\n\n      \r\n      idealStates.entrySet()\n          .removeIf(pair -> pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME));\n\n      \r\n      if (_expectLiveInstances != null && !_expectLiveInstances.isEmpty()) {\n        Set<String> actualLiveNodes = _dataProvider.getLiveInstances().keySet();\n        if (!_expectLiveInstances.equals(actualLiveNodes)) {\n          LOG.warn(\"Live instances are not as expected. Actual live nodes: \" + actualLiveNodes.toString());\n          return false;\n        }\n      }\n\n      Map<String, ExternalView> extViews = _accessor.getChildValuesMap(keyBuilder.externalViews());\n      if (extViews == null) {\n        extViews = Collections.emptyMap();\n      }\n\n      \r\n      if (_resources != null && !_resources.isEmpty()) {\n        idealStates.keySet().retainAll(_resources);\n        extViews.keySet().retainAll(_resources);\n      }\n\n      \r\n      \r\n      for (String resource : extViews.keySet()) {\n        if (!idealStates.containsKey(resource)) {\n          ExternalView ev = extViews.get(resource);\n          IdealState is = new IdealState(resource);\n          is.getRecord().setSimpleFields(ev.getRecord().getSimpleFields());\n          idealStates.put(resource, is);\n        }\n      }\n\n      \r\n      BestPossibleStateOutput bestPossOutput = calcBestPossState(_dataProvider, _resources);\n      Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n          bestPossOutput.getStateMap();\n\n      \r\n      if (_errStates != null) {\n        for (String resourceName : _errStates.keySet()) {\n          Map<String, String> partErrStates = _errStates.get(resourceName);\n          for (String partitionName : partErrStates.keySet()) {\n            String instanceName = partErrStates.get(partitionName);\n\n            if (!bestPossStateMap.containsKey(resourceName)) {\n              bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n            }\n            Partition partition = new Partition(partitionName);\n            if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n              bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n            }\n            bestPossStateMap.get(resourceName).get(partition)\n                .put(instanceName, HelixDefinedState.ERROR.toString());\n          }\n        }\n      }\n\n      for (String resourceName : idealStates.keySet()) {\n        IdealState is = idealStates.get(resourceName);\n        ExternalView extView = extViews.get(resourceName);\n        if (extView == null) {\n          if (is.isExternalViewDisabled()) {\n            continue;\n          }\n          LOG.warn(\"externalView for \" + resourceName\n              + \" is not available, check if best possible state is available.\");\n          extView = new ExternalView(resourceName);\n        }\n\n        \r\n        PartitionStateMap bpStateMap =\n            bestPossOutput.getPartitionStateMap(resourceName);\n\n        StateModelDefinition stateModelDef = _dataProvider.getStateModelDef(is.getStateModelDefRef());\n        if (stateModelDef == null) {\n          LOG.error(\n              \"State model definition \" + is.getStateModelDefRef() + \" for resource not found!\" + is\n                  .getResourceName());\n          return false;\n        }\n\n        boolean result = verifyExternalView(extView, bpStateMap, stateModelDef);\n        if (!result) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"verifyExternalView fails for \" + resourceName + \"! ExternalView: \" + extView\n                + \" BestPossibleState: \" + bpStateMap);\n          } else {\n            LOG.warn(\"verifyExternalView fails for \" + resourceName\n                + \"! ExternalView does not match BestPossibleState\");\n          }\n          return false;\n        }\n      }\n      return true;\n    } catch (Exception e) {\n      LOG.error(\"exception in verification\", e);\n      return false;\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":231,"status":"M"}],"commitId":"6ff99f5a181fb5fe91340968f93ca2cd5329a90a","commitMessage":"@@@Enforce result check for data accessors batch get calls to prevent partial batch read. (#974)\n\nThis will help to ensure the main Helix logic does not calculate based on incomplete input.","date":"2020-05-15 08:34:22","modifiedFileCount":"49","status":"M","submitter":"Jiajun Wang"}]
