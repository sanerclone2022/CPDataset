[{"authorTime":"2012-10-25 07:14:36","codes":[{"authorDate":"2012-10-25 07:14:36","commitOrder":1,"curCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception\n  {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                   clusterName,\n                                   \"localhost_8901\");\n    String extViewPath =\n        PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                     clusterName,\n                                     \"localhost_8901\",\n                                     \"session_0\",\n                                     \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++)\n    {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++)\n      {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2012-10-25 07:14:36","endLine":200,"groupId":"4266","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testHappyPathExtOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/55/cdc700c515b234459f01a4bb7958de4545c945.src","preCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception\n  {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                   clusterName,\n                                   \"localhost_8901\");\n    String extViewPath =\n        PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                     clusterName,\n                                     \"localhost_8901\",\n                                     \"session_0\",\n                                     \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++)\n    {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++)\n      {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":27,"status":"B"},{"authorDate":"2012-10-25 07:14:36","commitOrder":1,"curCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception\n  {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                   clusterName,\n                                   \"localhost_8901\");\n    String extViewPath =\n        PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                     clusterName,\n                                     \"localhost_8901\",\n                                     \"session_0\",\n                                     \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n\r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++)\n    {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++)\n      {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++)\n    {\n      for (int i = 0; i < 10; i++)\n      {\n        String path =\n            PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\"\n                + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2012-10-25 07:14:36","endLine":380,"groupId":"3833","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testHappyPathSelfOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/55/cdc700c515b234459f01a4bb7958de4545c945.src","preCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception\n  {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                   clusterName,\n                                   \"localhost_8901\");\n    String extViewPath =\n        PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                     clusterName,\n                                     \"localhost_8901\",\n                                     \"session_0\",\n                                     \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n\r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++)\n    {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++)\n      {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++)\n    {\n      for (int i = 0; i < 10; i++)\n      {\n        String path =\n            PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\"\n                + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"B"}],"commitId":"437eb42eac35e181ae6793dd17390df33565e4dd","commitMessage":"@@@Refactoring the package names and removing jsql parser\n","date":"2012-10-25 07:14:36","modifiedFileCount":"0","status":"B","submitter":"Kishore Gopalakrishna"},{"authorTime":"2012-10-25 07:14:36","codes":[{"authorDate":"2013-04-06 08:30:58","commitOrder":2,"curCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception\n  {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                   clusterName,\n                                   \"localhost_8901\");\n    String extViewPath =\n        PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                     clusterName,\n                                     \"localhost_8901\",\n                                     \"session_0\",\n                                     \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++)\n    {\n        \r\n    \tret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \tif (ret == true)\n    \t\tbreak;\n        Thread.sleep(100);\n    }\n    \n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++)\n    {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++)\n      {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2013-04-06 08:30:58","endLine":223,"groupId":"3830","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testHappyPathExtOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/92/05282a8946f8747bc3df0d35a85e231a010708.src","preCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception\n  {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                   clusterName,\n                                   \"localhost_8901\");\n    String extViewPath =\n        PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                     clusterName,\n                                     \"localhost_8901\",\n                                     \"session_0\",\n                                     \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++)\n    {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++)\n      {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2012-10-25 07:14:36","commitOrder":2,"curCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception\n  {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                   clusterName,\n                                   \"localhost_8901\");\n    String extViewPath =\n        PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                     clusterName,\n                                     \"localhost_8901\",\n                                     \"session_0\",\n                                     \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n\r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++)\n    {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++)\n      {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++)\n    {\n      for (int i = 0; i < 10; i++)\n      {\n        String path =\n            PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\"\n                + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2012-10-25 07:14:36","endLine":380,"groupId":"3833","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testHappyPathSelfOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/55/cdc700c515b234459f01a4bb7958de4545c945.src","preCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception\n  {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                   clusterName,\n                                   \"localhost_8901\");\n    String extViewPath =\n        PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor =\n        new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++)\n    {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES,\n                                     clusterName,\n                                     \"localhost_8901\",\n                                     \"session_0\",\n                                     \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n\r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++)\n    {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++)\n      {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++)\n    {\n      for (int i = 0; i < 10; i++)\n      {\n        String path =\n            PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\"\n                + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++)\n      {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths,\n                                 accessor._zkCache._cache,\n                                 _gZkClient,\n                                 true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++)\n    {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++)\n    {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \"\n        + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":203,"status":"N"}],"commitId":"f3e32551094e4edfd73364e3c79e3aba980a8208","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/incubator-helix\n","date":"2013-04-06 08:30:58","modifiedFileCount":"129","status":"M","submitter":"Swaroop Jagadish"},{"authorTime":"2017-01-29 08:55:24","codes":[{"authorDate":"2017-01-29 08:55:24","commitOrder":3,"curCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath =\n        PropertyPathBuilder.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathBuilder.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\",\n              \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret == true)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2017-02-02 12:19:43","endLine":177,"groupId":"0","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testHappyPathExtOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/b3/5c7e0a12edb84787812d41f03edc0b39255639.src","preCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\",\n              \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret == true)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"M"},{"authorDate":"2017-01-29 08:55:24","commitOrder":3,"curCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath =\n        PropertyPathBuilder.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathBuilder.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\",\n              \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n            _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path =\n            PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2017-02-02 12:19:43","endLine":319,"groupId":"0","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testHappyPathSelfOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/b3/5c7e0a12edb84787812d41f03edc0b39255639.src","preCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath =\n        PropertyPathConfig.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathConfig.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\",\n              \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n            _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path =\n            PropertyPathConfig.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"M"}],"commitId":"0b7a1a0fc93bf1f4699c45b7427663a17e94fc99","commitMessage":"@@@Rename PropertyPathConfig to PropertyPathBuilder\n","date":"2017-02-02 12:19:43","modifiedFileCount":"33","status":"M","submitter":"Junkai Xue"},{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2017-11-08 08:48:26","commitOrder":4,"curCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret == true)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2017-11-08 08:48:26","endLine":172,"groupId":"2385","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testHappyPathExtOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/0e/c8a664ad20e495545c767d753964a149ab047f.src","preCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath =\n        PropertyPathBuilder.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathBuilder.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\",\n              \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret == true)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"M"},{"authorDate":"2017-11-08 08:48:26","commitOrder":4,"curCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n            _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2017-11-08 08:48:26","endLine":310,"groupId":"2386","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testHappyPathSelfOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/0e/c8a664ad20e495545c767d753964a149ab047f.src","preCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath =\n        PropertyPathBuilder.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path =\n          PropertyPathBuilder.getPath(PropertyType.CURRENTSTATES, clusterName, \"localhost_8901\",\n              \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n            _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path =\n            PropertyPathBuilder.getPath(PropertyType.EXTERNALVIEW, clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"M"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"M","submitter":"Junkai Xue"},{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2018-09-27 02:39:42","commitOrder":5,"curCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    HelixZkClient extZkclient = SharedZkClientFactory.getInstance()\n        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret == true)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2018-10-30 09:15:22","endLine":173,"groupId":"2385","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testHappyPathExtOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/26/444e3704eb1280558eea1ec67ee4f2f200e79f.src","preCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    ZkClient extZkclient = new ZkClient(ZK_ADDR);\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret == true)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"M"},{"authorDate":"2017-11-08 08:48:26","commitOrder":5,"curCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n            _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","date":"2017-11-08 08:48:26","endLine":310,"groupId":"2386","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testHappyPathSelfOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/0e/c8a664ad20e495545c767d753964a149ab047f.src","preCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n            _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"N"}],"commitId":"9d7364d7abba3932a1b25e96e4eb9dd3e203cec9","commitMessage":"@@@Using HelixZkClient to replace ZkClient in helix-core and helix-rest.\n\n1. Replace as much usage as possible. For the raw ZkClient tests.  the usages are kept.\n2. For backward compatibility.  some public interfaces still returns ZkClient. Marks them as Deprecated.\n","date":"2018-10-30 09:15:22","modifiedFileCount":"60","status":"M","submitter":"Jiajun Wang"},{"authorTime":"2019-05-04 08:52:17","codes":[{"authorDate":"2019-05-04 08:52:17","commitOrder":6,"curCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    HelixZkClient extZkclient = SharedZkClientFactory.getInstance()\n        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(extZkclient);\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<>();\n    List<ZNRecord> records = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n          \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2019-05-25 09:19:21","endLine":174,"groupId":"1233","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testHappyPathExtOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/48/e099846ec9958e8c7250e5c4344c78b3b0b0d1.src","preCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    HelixZkClient extZkclient = SharedZkClientFactory.getInstance()\n        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<ZNRecord>(extZkclient);\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret == true)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"M"},{"authorDate":"2019-05-04 08:52:17","commitOrder":6,"curCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<>();\n    List<ZNRecord> records = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n          \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n        _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2019-05-25 09:19:21","endLine":312,"groupId":"2806","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testHappyPathSelfOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/48/e099846ec9958e8c7250e5c4344c78b3b0b0d1.src","preCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<ZNRecord>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<String>();\n    List<ZNRecord> records = new ArrayList<ZNRecord>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\", \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<DataUpdater<ZNRecord>>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n            _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"}],"commitId":"5ce3934c5b4655e90021061720adbb3a42b1bb6b","commitMessage":"@@@TEST: Groom and refactor Helix integration tests\n\nIt was observed that there was a lot of technical debt (improper and buggy cleanup) in Helix's unit and integration tests. There were also mock controller and participant threads that were never shut down properly. This was preventing mvn test suite from completing over a remote machine (TMC).  and even on local environments.  mvn test was not passing. This diff refactors tests and makes sure that ZK is cleaned up after tests.\n\nChangelist:\n1. Inspect and correct mock threads (controller.  participant.  spectator.  etc)\n2. Ensure there are no leftover garbage clusters from tests\n3. Java 8 syntax\n4. Style fixes in old tests using Helix open source style file (helix-style.xml)\n\nRB=1654905\nG=helix-reviewers\nA=jxue. eblumena\n\nSigned-off-by: Hunter Lee <hulee@linkedin.com>\n","date":"2019-05-25 09:19:21","modifiedFileCount":"122","status":"M","submitter":"Hunter Lee"},{"authorTime":"2020-05-15 08:34:22","codes":[{"authorDate":"2019-05-04 08:52:17","commitOrder":7,"curCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    HelixZkClient extZkclient = SharedZkClientFactory.getInstance()\n        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(extZkclient);\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<>();\n    List<ZNRecord> records = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n          \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2019-05-25 09:19:21","endLine":174,"groupId":"10238","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testHappyPathExtOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/48/e099846ec9958e8c7250e5c4344c78b3b0b0d1.src","preCode":"  public void testHappyPathExtOpZkCacheBaseDataAccessor() throws Exception {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    HelixZkClient extZkclient = SharedZkClientFactory.getInstance()\n        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n    extZkclient.setZkSerializer(new ZNRecordSerializer());\n    ZkBaseDataAccessor<ZNRecord> extBaseAccessor = new ZkBaseDataAccessor<>(extZkclient);\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    extBaseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<>();\n    List<ZNRecord> records = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n          \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = extBaseAccessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    for (int i = 0; i < 10; i++) {\n      \r\n      ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n      if (ret)\n        break;\n      Thread.sleep(100);\n    }\n\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = extBaseAccessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n    success = extBaseAccessor.setChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n\n      paths.add(path);\n    }\n    success = extBaseAccessor.remove(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in remove: \" + paths.get(i));\n    }\n\n    \r\n    Thread.sleep(100);\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    extZkclient.close();\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"N"},{"authorDate":"2020-05-15 08:34:22","commitOrder":7,"curCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<>();\n    List<ZNRecord> records = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n          \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n        _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0, true);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0, 0, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2020-05-15 08:34:22","endLine":401,"groupId":"10238","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testHappyPathSelfOpZkCacheBaseDataAccessor","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/14/2af2f06458d98365b97d8b0795e4c90463a63c.src","preCode":"  public void testHappyPathSelfOpZkCacheBaseDataAccessor() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n\n    \r\n    String curStatePath = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\");\n    String extViewPath = PropertyPathBuilder.externalView(clusterName);\n\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    baseAccessor.create(curStatePath, null, AccessOption.PERSISTENT);\n\n    List<String> zkCacheInitPaths = Arrays.asList(curStatePath, extViewPath);\n    ZkCacheBaseDataAccessor<ZNRecord> accessor =\n        new ZkCacheBaseDataAccessor<>(baseAccessor, null, null, zkCacheInitPaths);\n\n    \r\n    boolean ret =\n        TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<String> paths = new ArrayList<>();\n    List<ZNRecord> records = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = PropertyPathBuilder.instanceCurrentState(clusterName, \"localhost_8901\",\n          \"session_0\", \"TestDB\" + i);\n      ZNRecord record = new ZNRecord(\"TestDB\" + i);\n\n      paths.add(path);\n      records.add(record);\n    }\n\n    boolean[] success = accessor.createChildren(paths, records, AccessOption.PERSISTENT);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should succeed in create: \" + paths.get(i));\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, false);\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    List<DataUpdater<ZNRecord>> updaters = new ArrayList<>();\n    for (int j = 0; j < 10; j++) {\n      paths.clear();\n      updaters.clear();\n      for (int i = 0; i < 10; i++) {\n        String path = curStatePath + \"/session_0/TestDB\" + i;\n        ZNRecord newRecord = new ZNRecord(\"TestDB\" + i);\n        newRecord.setSimpleField(\"\" + j, \"\" + j);\n        DataUpdater<ZNRecord> updater = new ZNRecordUpdater(newRecord);\n        paths.add(path);\n        updaters.add(updater);\n      }\n      success = accessor.updateChildren(paths, updaters, AccessOption.PERSISTENT);\n\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in update: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, zkCacheInitPaths, accessor._zkCache._cache,\n        _gZkClient, true);\n    \r\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int j = 0; j < 10; j++) {\n      for (int i = 0; i < 10; i++) {\n        String path = PropertyPathBuilder.externalView(clusterName, \"TestDB\" + i);\n        ZNRecord record = new ZNRecord(\"TestDB\" + i);\n        record.setSimpleField(\"setKey\", \"\" + j);\n\n        paths.add(path);\n        records.add(record);\n      }\n      success = accessor.setChildren(paths, records, AccessOption.PERSISTENT);\n      for (int i = 0; i < 10; i++) {\n        Assert.assertTrue(success[i], \"Should succeed in set: \" + paths.get(i));\n      }\n    }\n\n    \r\n    \r\n    ret = TestHelper.verifyZkCache(zkCacheInitPaths, accessor._zkCache._cache, _gZkClient, true);\n    \r\n    Assert.assertTrue(ret, \"zkCache doesn't match data on Zk\");\n\n    \r\n    paths.clear();\n    records.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = extViewPath + \"/TestDB\" + i;\n      paths.add(path);\n    }\n\n    records = accessor.get(paths, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    records.clear();\n    records = accessor.getChildren(extViewPath, null, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertEquals(records.get(i).getId(), \"TestDB\" + i);\n    }\n\n    \r\n    paths.clear();\n    for (int i = 0; i < 10; i++) {\n      String path = curStatePath + \"/session_0/TestDB\" + i;\n      \r\n      \r\n      \r\n      \r\n      \r\n      paths.add(path);\n    }\n    success = accessor.exists(paths, 0);\n    for (int i = 0; i < 10; i++) {\n      Assert.assertTrue(success[i], \"Should exits: \" + paths.get(i));\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":266,"status":"M"}],"commitId":"6ff99f5a181fb5fe91340968f93ca2cd5329a90a","commitMessage":"@@@Enforce result check for data accessors batch get calls to prevent partial batch read. (#974)\n\nThis will help to ensure the main Helix logic does not calculate based on incomplete input.","date":"2020-05-15 08:34:22","modifiedFileCount":"49","status":"M","submitter":"Jiajun Wang"}]
