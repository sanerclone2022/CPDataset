[{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2017-11-08 08:48:26","commitOrder":1,"curCode":"  public void testSchedulerMsg2() throws Exception {\n    _factory._results.clear();\n    Thread.sleep(2000);\n    HelixManager manager = null;\n    for (int i = 0; i < NODE_NR; i++) {\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          _factory.getMessageType(), _factory);\n\n      manager = _participants[i]; \r\n    }\n\n    Message schedulerMessage =\n        new Message(MessageType.SCHEDULER_MSG + \"\", UUID.randomUUID().toString());\n    schedulerMessage.setTgtSessionId(\"*\");\n    schedulerMessage.setTgtName(\"CONTROLLER\");\n    \r\n    schedulerMessage.setSrcName(\"CONTROLLER\");\n\n    \r\n    Message msg = new Message(_factory.getMessageType(), \"Template\");\n    msg.setTgtSessionId(\"*\");\n    msg.setMsgState(MessageState.NEW);\n\n    \r\n    Criteria cr = new Criteria();\n    cr.setInstanceName(\"localhost_%\");\n    cr.setRecipientInstanceType(InstanceType.PARTICIPANT);\n    cr.setSessionSpecific(false);\n    cr.setResource(\"%\");\n    cr.setPartition(\"%\");\n\n    ObjectMapper mapper = new ObjectMapper();\n    SerializationConfig serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    StringWriter sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    String crString = sw.toString();\n\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    schedulerMessage.getRecord().setMapField(\"MessageTemplate\", msg.getRecord().getSimpleFields());\n    schedulerMessage.getRecord().setSimpleField(\"TIMEOUT\", \"-1\");\n    schedulerMessage.getRecord().setSimpleField(\"WAIT_ALL\", \"true\");\n\n    Criteria cr2 = new Criteria();\n    cr2.setRecipientInstanceType(InstanceType.CONTROLLER);\n    cr2.setInstanceName(\"*\");\n    cr2.setSessionSpecific(false);\n\n    schedulerMessage.getRecord().setSimpleField(\n        DefaultSchedulerMessageHandlerFactory.SCHEDULER_TASK_QUEUE, \"TestSchedulerMsg2\");\n    TestSchedulerMessage.MockAsyncCallback callback = new TestSchedulerMessage.MockAsyncCallback();\n    manager.getMessagingService().sendAndWait(cr2, schedulerMessage, callback, -1);\n    String msgId =\n        callback._message.getResultMap()\n            .get(DefaultSchedulerMessageHandlerFactory.SCHEDULER_MSG_ID);\n\n    HelixDataAccessor helixDataAccessor = manager.getHelixDataAccessor();\n    PropertyKey.Builder keyBuilder = helixDataAccessor.keyBuilder();\n    for (int i = 0; i < 10; i++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"Summary\")) {\n        break;\n      }\n    }\n\n    Assert.assertEquals(_PARTITIONS, _factory._results.size());\n    PropertyKey controllerTaskStatus =\n        keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n    ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n    Assert.assertTrue(statusUpdate.getMapField(\"SentMessageCount\").get(\"MessageCount\")\n        .equals(\"\" + (_PARTITIONS * 3)));\n    int messageResultCount = 0;\n    for (String key : statusUpdate.getMapFields().keySet()) {\n      if (key.startsWith(\"MessageResult \")) {\n        messageResultCount++;\n      }\n    }\n    Assert.assertEquals(messageResultCount, _PARTITIONS * 3);\n\n    int count = 0;\n    for (Set<String> val : _factory._results.values()) {\n      count += val.size();\n    }\n    Assert.assertEquals(count, _PARTITIONS * 3);\n  }\n","date":"2017-11-08 08:48:26","endLine":136,"groupId":"4970","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSchedulerMsg2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/36/913841f4c93c4befcdebcea861116fbd246ae5.src","preCode":"  public void testSchedulerMsg2() throws Exception {\n    _factory._results.clear();\n    Thread.sleep(2000);\n    HelixManager manager = null;\n    for (int i = 0; i < NODE_NR; i++) {\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          _factory.getMessageType(), _factory);\n\n      manager = _participants[i]; \r\n    }\n\n    Message schedulerMessage =\n        new Message(MessageType.SCHEDULER_MSG + \"\", UUID.randomUUID().toString());\n    schedulerMessage.setTgtSessionId(\"*\");\n    schedulerMessage.setTgtName(\"CONTROLLER\");\n    \r\n    schedulerMessage.setSrcName(\"CONTROLLER\");\n\n    \r\n    Message msg = new Message(_factory.getMessageType(), \"Template\");\n    msg.setTgtSessionId(\"*\");\n    msg.setMsgState(MessageState.NEW);\n\n    \r\n    Criteria cr = new Criteria();\n    cr.setInstanceName(\"localhost_%\");\n    cr.setRecipientInstanceType(InstanceType.PARTICIPANT);\n    cr.setSessionSpecific(false);\n    cr.setResource(\"%\");\n    cr.setPartition(\"%\");\n\n    ObjectMapper mapper = new ObjectMapper();\n    SerializationConfig serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    StringWriter sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    String crString = sw.toString();\n\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    schedulerMessage.getRecord().setMapField(\"MessageTemplate\", msg.getRecord().getSimpleFields());\n    schedulerMessage.getRecord().setSimpleField(\"TIMEOUT\", \"-1\");\n    schedulerMessage.getRecord().setSimpleField(\"WAIT_ALL\", \"true\");\n\n    Criteria cr2 = new Criteria();\n    cr2.setRecipientInstanceType(InstanceType.CONTROLLER);\n    cr2.setInstanceName(\"*\");\n    cr2.setSessionSpecific(false);\n\n    schedulerMessage.getRecord().setSimpleField(\n        DefaultSchedulerMessageHandlerFactory.SCHEDULER_TASK_QUEUE, \"TestSchedulerMsg2\");\n    TestSchedulerMessage.MockAsyncCallback callback = new TestSchedulerMessage.MockAsyncCallback();\n    manager.getMessagingService().sendAndWait(cr2, schedulerMessage, callback, -1);\n    String msgId =\n        callback._message.getResultMap()\n            .get(DefaultSchedulerMessageHandlerFactory.SCHEDULER_MSG_ID);\n\n    HelixDataAccessor helixDataAccessor = manager.getHelixDataAccessor();\n    PropertyKey.Builder keyBuilder = helixDataAccessor.keyBuilder();\n    for (int i = 0; i < 10; i++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"Summary\")) {\n        break;\n      }\n    }\n\n    Assert.assertEquals(_PARTITIONS, _factory._results.size());\n    PropertyKey controllerTaskStatus =\n        keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n    ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n    Assert.assertTrue(statusUpdate.getMapField(\"SentMessageCount\").get(\"MessageCount\")\n        .equals(\"\" + (_PARTITIONS * 3)));\n    int messageResultCount = 0;\n    for (String key : statusUpdate.getMapFields().keySet()) {\n      if (key.startsWith(\"MessageResult \")) {\n        messageResultCount++;\n      }\n    }\n    Assert.assertEquals(messageResultCount, _PARTITIONS * 3);\n\n    int count = 0;\n    for (Set<String> val : _factory._results.values()) {\n      count += val.size();\n    }\n    Assert.assertEquals(count, _PARTITIONS * 3);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage2.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"B"},{"authorDate":"2017-11-08 08:48:26","commitOrder":1,"curCode":"  public void testSchedulerMsgContraints() throws Exception {\n    TestSchedulerMessage.TestMessagingHandlerFactoryLatch factory =\n        new TestSchedulerMessage.TestMessagingHandlerFactoryLatch();\n    HelixManager manager = null;\n    for (int i = 0; i < NODE_NR; i++) {\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          factory.getMessageType(), factory);\n\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          factory.getMessageType(), factory);\n\n      manager = _participants[i]; \r\n    }\n\n    Message schedulerMessage =\n        new Message(MessageType.SCHEDULER_MSG + \"\", UUID.randomUUID().toString());\n    schedulerMessage.setTgtSessionId(\"*\");\n    schedulerMessage.setTgtName(\"CONTROLLER\");\n    \r\n    schedulerMessage.setSrcName(\"CONTROLLER\");\n\n    \r\n    Message msg = new Message(factory.getMessageType(), \"Template\");\n    msg.setTgtSessionId(\"*\");\n    msg.setMsgState(MessageState.NEW);\n\n    \r\n    Criteria cr = new Criteria();\n    cr.setInstanceName(\"localhost_%\");\n    cr.setRecipientInstanceType(InstanceType.PARTICIPANT);\n    cr.setSessionSpecific(false);\n    cr.setResource(\"%\");\n    cr.setPartition(\"%\");\n\n    ObjectMapper mapper = new ObjectMapper();\n    SerializationConfig serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    StringWriter sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    String crString = sw.toString();\n\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    schedulerMessage.getRecord().setMapField(\"MessageTemplate\", msg.getRecord().getSimpleFields());\n    schedulerMessage.getRecord().setSimpleField(\"TIMEOUT\", \"-1\");\n    schedulerMessage.getRecord().setSimpleField(\"WAIT_ALL\", \"true\");\n    schedulerMessage.getRecord().setSimpleField(\n        DefaultSchedulerMessageHandlerFactory.SCHEDULER_TASK_QUEUE, \"TestSchedulerMsgContraints\");\n\n    Criteria cr2 = new Criteria();\n    cr2.setRecipientInstanceType(InstanceType.CONTROLLER);\n    cr2.setInstanceName(\"*\");\n    cr2.setSessionSpecific(false);\n\n    TestSchedulerMessage.MockAsyncCallback callback = new TestSchedulerMessage.MockAsyncCallback();\n    mapper = new ObjectMapper();\n    serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    HelixDataAccessor helixDataAccessor = manager.getHelixDataAccessor();\n    PropertyKey.Builder keyBuilder = helixDataAccessor.keyBuilder();\n\n    \r\n    Map<String, String> constraints = new TreeMap<String, String>();\n    constraints.put(\"MESSAGE_TYPE\", \"STATE_TRANSITION\");\n    constraints.put(\"TRANSITION\", \"OFFLINE-COMPLETED\");\n    constraints.put(\"CONSTRAINT_VALUE\", \"1\");\n    constraints.put(\"INSTANCE\", \".*\");\n    manager.getClusterManagmentTool().setConstraint(manager.getClusterName(),\n        ConstraintType.MESSAGE_CONSTRAINT, \"constraint1\", new ConstraintItem(constraints));\n\n    \r\n    crString = sw.toString();\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    manager.getMessagingService().sendAndWait(cr2, schedulerMessage, callback, -1);\n    String msgId =\n        callback._message.getResultMap()\n            .get(DefaultSchedulerMessageHandlerFactory.SCHEDULER_MSG_ID);\n\n    for (int j = 0; j < 10; j++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"SentMessageCount\")) {\n        Assert.assertEquals(\n            statusUpdate.getMapFields().get(\"SentMessageCount\").get(\"MessageCount\"), \"\"\n                + (_PARTITIONS * 3));\n        break;\n      }\n    }\n\n    for (int i = 0; i < _PARTITIONS * 3 / 5; i++) {\n      for (int j = 0; j < 10; j++) {\n        Thread.sleep(300);\n        if (factory._messageCount == 5 * (i + 1))\n          break;\n      }\n      Thread.sleep(300);\n      Assert.assertEquals(factory._messageCount, 5 * (i + 1));\n      factory.signal();\n      \r\n    }\n\n    for (int j = 0; j < 10; j++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"Summary\")) {\n        break;\n      }\n    }\n\n    Assert.assertEquals(_PARTITIONS, factory._results.size());\n    PropertyKey controllerTaskStatus =\n        keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n    ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n    Assert.assertTrue(statusUpdate.getMapField(\"SentMessageCount\").get(\"MessageCount\")\n        .equals(\"\" + (_PARTITIONS * 3)));\n    int messageResultCount = 0;\n    for (String key : statusUpdate.getMapFields().keySet()) {\n      if (key.startsWith(\"MessageResult \")) {\n        messageResultCount++;\n      }\n    }\n    Assert.assertEquals(messageResultCount, _PARTITIONS * 3);\n\n    int count = 0;\n    for (Set<String> val : factory._results.values()) {\n      count += val.size();\n    }\n    Assert.assertEquals(count, _PARTITIONS * 3);\n\n    manager.getClusterManagmentTool().removeConstraint(manager.getClusterName(),\n        ConstraintType.MESSAGE_CONSTRAINT, \"constraint1\");\n\n  }\n","date":"2017-11-08 08:48:26","endLine":190,"groupId":"7217","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSchedulerMsgContraints","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c2/833010b04d1dbbc74646a6698051d8decb97cc.src","preCode":"  public void testSchedulerMsgContraints() throws Exception {\n    TestSchedulerMessage.TestMessagingHandlerFactoryLatch factory =\n        new TestSchedulerMessage.TestMessagingHandlerFactoryLatch();\n    HelixManager manager = null;\n    for (int i = 0; i < NODE_NR; i++) {\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          factory.getMessageType(), factory);\n\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          factory.getMessageType(), factory);\n\n      manager = _participants[i]; \r\n    }\n\n    Message schedulerMessage =\n        new Message(MessageType.SCHEDULER_MSG + \"\", UUID.randomUUID().toString());\n    schedulerMessage.setTgtSessionId(\"*\");\n    schedulerMessage.setTgtName(\"CONTROLLER\");\n    \r\n    schedulerMessage.setSrcName(\"CONTROLLER\");\n\n    \r\n    Message msg = new Message(factory.getMessageType(), \"Template\");\n    msg.setTgtSessionId(\"*\");\n    msg.setMsgState(MessageState.NEW);\n\n    \r\n    Criteria cr = new Criteria();\n    cr.setInstanceName(\"localhost_%\");\n    cr.setRecipientInstanceType(InstanceType.PARTICIPANT);\n    cr.setSessionSpecific(false);\n    cr.setResource(\"%\");\n    cr.setPartition(\"%\");\n\n    ObjectMapper mapper = new ObjectMapper();\n    SerializationConfig serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    StringWriter sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    String crString = sw.toString();\n\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    schedulerMessage.getRecord().setMapField(\"MessageTemplate\", msg.getRecord().getSimpleFields());\n    schedulerMessage.getRecord().setSimpleField(\"TIMEOUT\", \"-1\");\n    schedulerMessage.getRecord().setSimpleField(\"WAIT_ALL\", \"true\");\n    schedulerMessage.getRecord().setSimpleField(\n        DefaultSchedulerMessageHandlerFactory.SCHEDULER_TASK_QUEUE, \"TestSchedulerMsgContraints\");\n\n    Criteria cr2 = new Criteria();\n    cr2.setRecipientInstanceType(InstanceType.CONTROLLER);\n    cr2.setInstanceName(\"*\");\n    cr2.setSessionSpecific(false);\n\n    TestSchedulerMessage.MockAsyncCallback callback = new TestSchedulerMessage.MockAsyncCallback();\n    mapper = new ObjectMapper();\n    serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    HelixDataAccessor helixDataAccessor = manager.getHelixDataAccessor();\n    PropertyKey.Builder keyBuilder = helixDataAccessor.keyBuilder();\n\n    \r\n    Map<String, String> constraints = new TreeMap<String, String>();\n    constraints.put(\"MESSAGE_TYPE\", \"STATE_TRANSITION\");\n    constraints.put(\"TRANSITION\", \"OFFLINE-COMPLETED\");\n    constraints.put(\"CONSTRAINT_VALUE\", \"1\");\n    constraints.put(\"INSTANCE\", \".*\");\n    manager.getClusterManagmentTool().setConstraint(manager.getClusterName(),\n        ConstraintType.MESSAGE_CONSTRAINT, \"constraint1\", new ConstraintItem(constraints));\n\n    \r\n    crString = sw.toString();\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    manager.getMessagingService().sendAndWait(cr2, schedulerMessage, callback, -1);\n    String msgId =\n        callback._message.getResultMap()\n            .get(DefaultSchedulerMessageHandlerFactory.SCHEDULER_MSG_ID);\n\n    for (int j = 0; j < 10; j++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"SentMessageCount\")) {\n        Assert.assertEquals(\n            statusUpdate.getMapFields().get(\"SentMessageCount\").get(\"MessageCount\"), \"\"\n                + (_PARTITIONS * 3));\n        break;\n      }\n    }\n\n    for (int i = 0; i < _PARTITIONS * 3 / 5; i++) {\n      for (int j = 0; j < 10; j++) {\n        Thread.sleep(300);\n        if (factory._messageCount == 5 * (i + 1))\n          break;\n      }\n      Thread.sleep(300);\n      Assert.assertEquals(factory._messageCount, 5 * (i + 1));\n      factory.signal();\n      \r\n    }\n\n    for (int j = 0; j < 10; j++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"Summary\")) {\n        break;\n      }\n    }\n\n    Assert.assertEquals(_PARTITIONS, factory._results.size());\n    PropertyKey controllerTaskStatus =\n        keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n    ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n    Assert.assertTrue(statusUpdate.getMapField(\"SentMessageCount\").get(\"MessageCount\")\n        .equals(\"\" + (_PARTITIONS * 3)));\n    int messageResultCount = 0;\n    for (String key : statusUpdate.getMapFields().keySet()) {\n      if (key.startsWith(\"MessageResult \")) {\n        messageResultCount++;\n      }\n    }\n    Assert.assertEquals(messageResultCount, _PARTITIONS * 3);\n\n    int count = 0;\n    for (Set<String> val : factory._results.values()) {\n      count += val.size();\n    }\n    Assert.assertEquals(count, _PARTITIONS * 3);\n\n    manager.getClusterManagmentTool().removeConstraint(manager.getClusterName(),\n        ConstraintType.MESSAGE_CONSTRAINT, \"constraint1\");\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMsgContraints.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"B"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"B","submitter":"Junkai Xue"},{"authorTime":"2020-08-21 10:06:09","codes":[{"authorDate":"2020-08-21 10:06:09","commitOrder":2,"curCode":"  public void testSchedulerMsg2() throws Exception {\n    _factory._results.clear();\n    Thread.sleep(2000);\n    HelixManager manager = null;\n    for (int i = 0; i < NODE_NR; i++) {\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          _factory.getMessageType(), _factory);\n\n      manager = _participants[i]; \r\n    }\n\n    Message schedulerMessage =\n        new Message(MessageType.SCHEDULER_MSG + \"\", UUID.randomUUID().toString());\n    schedulerMessage.setTgtSessionId(\"*\");\n    schedulerMessage.setTgtName(\"CONTROLLER\");\n    \r\n    schedulerMessage.setSrcName(\"CONTROLLER\");\n\n    \r\n    Message msg = new Message(_factory.getMessageType(), \"Template\");\n    msg.setTgtSessionId(\"*\");\n    msg.setMsgState(MessageState.NEW);\n\n    \r\n    Criteria cr = new Criteria();\n    cr.setInstanceName(\"localhost_%\");\n    cr.setRecipientInstanceType(InstanceType.PARTICIPANT);\n    cr.setSessionSpecific(false);\n    cr.setResource(\"%\");\n    cr.setPartition(\"%\");\n\n    ObjectMapper mapper = new ObjectMapper();\n    mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n    StringWriter sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    String crString = sw.toString();\n\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    schedulerMessage.getRecord().setMapField(\"MessageTemplate\", msg.getRecord().getSimpleFields());\n    schedulerMessage.getRecord().setSimpleField(\"TIMEOUT\", \"-1\");\n    schedulerMessage.getRecord().setSimpleField(\"WAIT_ALL\", \"true\");\n\n    Criteria cr2 = new Criteria();\n    cr2.setRecipientInstanceType(InstanceType.CONTROLLER);\n    cr2.setInstanceName(\"*\");\n    cr2.setSessionSpecific(false);\n\n    schedulerMessage.getRecord().setSimpleField(\n        DefaultSchedulerMessageHandlerFactory.SCHEDULER_TASK_QUEUE, \"TestSchedulerMsg2\");\n    TestSchedulerMessage.MockAsyncCallback callback = new TestSchedulerMessage.MockAsyncCallback();\n    manager.getMessagingService().sendAndWait(cr2, schedulerMessage, callback, -1);\n    String msgId =\n        callback._message.getResultMap()\n            .get(DefaultSchedulerMessageHandlerFactory.SCHEDULER_MSG_ID);\n\n    HelixDataAccessor helixDataAccessor = manager.getHelixDataAccessor();\n    PropertyKey.Builder keyBuilder = helixDataAccessor.keyBuilder();\n    for (int i = 0; i < 10; i++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"Summary\")) {\n        break;\n      }\n    }\n\n    Assert.assertEquals(_PARTITIONS, _factory._results.size());\n    PropertyKey controllerTaskStatus =\n        keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n    ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n    Assert.assertTrue(statusUpdate.getMapField(\"SentMessageCount\").get(\"MessageCount\")\n        .equals(\"\" + (_PARTITIONS * 3)));\n    int messageResultCount = 0;\n    for (String key : statusUpdate.getMapFields().keySet()) {\n      if (key.startsWith(\"MessageResult \")) {\n        messageResultCount++;\n      }\n    }\n    Assert.assertEquals(messageResultCount, _PARTITIONS * 3);\n\n    int count = 0;\n    for (Set<String> val : _factory._results.values()) {\n      count += val.size();\n    }\n    Assert.assertEquals(count, _PARTITIONS * 3);\n  }\n","date":"2020-08-21 10:06:09","endLine":135,"groupId":"10619","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testSchedulerMsg2","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c3/b134513cedc2192ecd417102c1b4e30685cfa0.src","preCode":"  public void testSchedulerMsg2() throws Exception {\n    _factory._results.clear();\n    Thread.sleep(2000);\n    HelixManager manager = null;\n    for (int i = 0; i < NODE_NR; i++) {\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          _factory.getMessageType(), _factory);\n\n      manager = _participants[i]; \r\n    }\n\n    Message schedulerMessage =\n        new Message(MessageType.SCHEDULER_MSG + \"\", UUID.randomUUID().toString());\n    schedulerMessage.setTgtSessionId(\"*\");\n    schedulerMessage.setTgtName(\"CONTROLLER\");\n    \r\n    schedulerMessage.setSrcName(\"CONTROLLER\");\n\n    \r\n    Message msg = new Message(_factory.getMessageType(), \"Template\");\n    msg.setTgtSessionId(\"*\");\n    msg.setMsgState(MessageState.NEW);\n\n    \r\n    Criteria cr = new Criteria();\n    cr.setInstanceName(\"localhost_%\");\n    cr.setRecipientInstanceType(InstanceType.PARTICIPANT);\n    cr.setSessionSpecific(false);\n    cr.setResource(\"%\");\n    cr.setPartition(\"%\");\n\n    ObjectMapper mapper = new ObjectMapper();\n    SerializationConfig serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    StringWriter sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    String crString = sw.toString();\n\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    schedulerMessage.getRecord().setMapField(\"MessageTemplate\", msg.getRecord().getSimpleFields());\n    schedulerMessage.getRecord().setSimpleField(\"TIMEOUT\", \"-1\");\n    schedulerMessage.getRecord().setSimpleField(\"WAIT_ALL\", \"true\");\n\n    Criteria cr2 = new Criteria();\n    cr2.setRecipientInstanceType(InstanceType.CONTROLLER);\n    cr2.setInstanceName(\"*\");\n    cr2.setSessionSpecific(false);\n\n    schedulerMessage.getRecord().setSimpleField(\n        DefaultSchedulerMessageHandlerFactory.SCHEDULER_TASK_QUEUE, \"TestSchedulerMsg2\");\n    TestSchedulerMessage.MockAsyncCallback callback = new TestSchedulerMessage.MockAsyncCallback();\n    manager.getMessagingService().sendAndWait(cr2, schedulerMessage, callback, -1);\n    String msgId =\n        callback._message.getResultMap()\n            .get(DefaultSchedulerMessageHandlerFactory.SCHEDULER_MSG_ID);\n\n    HelixDataAccessor helixDataAccessor = manager.getHelixDataAccessor();\n    PropertyKey.Builder keyBuilder = helixDataAccessor.keyBuilder();\n    for (int i = 0; i < 10; i++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"Summary\")) {\n        break;\n      }\n    }\n\n    Assert.assertEquals(_PARTITIONS, _factory._results.size());\n    PropertyKey controllerTaskStatus =\n        keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n    ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n    Assert.assertTrue(statusUpdate.getMapField(\"SentMessageCount\").get(\"MessageCount\")\n        .equals(\"\" + (_PARTITIONS * 3)));\n    int messageResultCount = 0;\n    for (String key : statusUpdate.getMapFields().keySet()) {\n      if (key.startsWith(\"MessageResult \")) {\n        messageResultCount++;\n      }\n    }\n    Assert.assertEquals(messageResultCount, _PARTITIONS * 3);\n\n    int count = 0;\n    for (Set<String> val : _factory._results.values()) {\n      count += val.size();\n    }\n    Assert.assertEquals(count, _PARTITIONS * 3);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage2.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"},{"authorDate":"2020-08-21 10:06:09","commitOrder":2,"curCode":"  public void testSchedulerMsgContraints() throws Exception {\n    TestSchedulerMessage.TestMessagingHandlerFactoryLatch factory =\n        new TestSchedulerMessage.TestMessagingHandlerFactoryLatch();\n    HelixManager manager = null;\n    for (int i = 0; i < NODE_NR; i++) {\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          factory.getMessageType(), factory);\n\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          factory.getMessageType(), factory);\n\n      manager = _participants[i]; \r\n    }\n\n    Message schedulerMessage =\n        new Message(MessageType.SCHEDULER_MSG + \"\", UUID.randomUUID().toString());\n    schedulerMessage.setTgtSessionId(\"*\");\n    schedulerMessage.setTgtName(\"CONTROLLER\");\n    \r\n    schedulerMessage.setSrcName(\"CONTROLLER\");\n\n    \r\n    Message msg = new Message(factory.getMessageType(), \"Template\");\n    msg.setTgtSessionId(\"*\");\n    msg.setMsgState(MessageState.NEW);\n\n    \r\n    Criteria cr = new Criteria();\n    cr.setInstanceName(\"localhost_%\");\n    cr.setRecipientInstanceType(InstanceType.PARTICIPANT);\n    cr.setSessionSpecific(false);\n    cr.setResource(\"%\");\n    cr.setPartition(\"%\");\n\n    ObjectMapper mapper = new ObjectMapper();\n    mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n    StringWriter sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    String crString = sw.toString();\n\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    schedulerMessage.getRecord().setMapField(\"MessageTemplate\", msg.getRecord().getSimpleFields());\n    schedulerMessage.getRecord().setSimpleField(\"TIMEOUT\", \"-1\");\n    schedulerMessage.getRecord().setSimpleField(\"WAIT_ALL\", \"true\");\n    schedulerMessage.getRecord().setSimpleField(\n        DefaultSchedulerMessageHandlerFactory.SCHEDULER_TASK_QUEUE, \"TestSchedulerMsgContraints\");\n\n    Criteria cr2 = new Criteria();\n    cr2.setRecipientInstanceType(InstanceType.CONTROLLER);\n    cr2.setInstanceName(\"*\");\n    cr2.setSessionSpecific(false);\n\n    TestSchedulerMessage.MockAsyncCallback callback = new TestSchedulerMessage.MockAsyncCallback();\n    mapper = new ObjectMapper();\n    mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n    sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    HelixDataAccessor helixDataAccessor = manager.getHelixDataAccessor();\n    PropertyKey.Builder keyBuilder = helixDataAccessor.keyBuilder();\n\n    \r\n    Map<String, String> constraints = new TreeMap<String, String>();\n    constraints.put(\"MESSAGE_TYPE\", \"STATE_TRANSITION\");\n    constraints.put(\"TRANSITION\", \"OFFLINE-COMPLETED\");\n    constraints.put(\"CONSTRAINT_VALUE\", \"1\");\n    constraints.put(\"INSTANCE\", \".*\");\n    manager.getClusterManagmentTool().setConstraint(manager.getClusterName(),\n        ConstraintType.MESSAGE_CONSTRAINT, \"constraint1\", new ConstraintItem(constraints));\n\n    \r\n    crString = sw.toString();\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    manager.getMessagingService().sendAndWait(cr2, schedulerMessage, callback, -1);\n    String msgId =\n        callback._message.getResultMap()\n            .get(DefaultSchedulerMessageHandlerFactory.SCHEDULER_MSG_ID);\n\n    for (int j = 0; j < 10; j++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"SentMessageCount\")) {\n        Assert.assertEquals(\n            statusUpdate.getMapFields().get(\"SentMessageCount\").get(\"MessageCount\"), \"\"\n                + (_PARTITIONS * 3));\n        break;\n      }\n    }\n\n    for (int i = 0; i < _PARTITIONS * 3 / 5; i++) {\n      for (int j = 0; j < 10; j++) {\n        Thread.sleep(300);\n        if (factory._messageCount == 5 * (i + 1))\n          break;\n      }\n      Thread.sleep(300);\n      Assert.assertEquals(factory._messageCount, 5 * (i + 1));\n      factory.signal();\n      \r\n    }\n\n    for (int j = 0; j < 10; j++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"Summary\")) {\n        break;\n      }\n    }\n\n    Assert.assertEquals(_PARTITIONS, factory._results.size());\n    PropertyKey controllerTaskStatus =\n        keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n    ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n    Assert.assertTrue(statusUpdate.getMapField(\"SentMessageCount\").get(\"MessageCount\")\n        .equals(\"\" + (_PARTITIONS * 3)));\n    int messageResultCount = 0;\n    for (String key : statusUpdate.getMapFields().keySet()) {\n      if (key.startsWith(\"MessageResult \")) {\n        messageResultCount++;\n      }\n    }\n    Assert.assertEquals(messageResultCount, _PARTITIONS * 3);\n\n    int count = 0;\n    for (Set<String> val : factory._results.values()) {\n      count += val.size();\n    }\n    Assert.assertEquals(count, _PARTITIONS * 3);\n\n    manager.getClusterManagmentTool().removeConstraint(manager.getClusterName(),\n        ConstraintType.MESSAGE_CONSTRAINT, \"constraint1\");\n\n  }\n","date":"2020-08-21 10:06:09","endLine":188,"groupId":"10619","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testSchedulerMsgContraints","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/8e/12d296c4474a3584a32c71c2c7e1d46b5acac8.src","preCode":"  public void testSchedulerMsgContraints() throws Exception {\n    TestSchedulerMessage.TestMessagingHandlerFactoryLatch factory =\n        new TestSchedulerMessage.TestMessagingHandlerFactoryLatch();\n    HelixManager manager = null;\n    for (int i = 0; i < NODE_NR; i++) {\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          factory.getMessageType(), factory);\n\n      _participants[i].getMessagingService().registerMessageHandlerFactory(\n          factory.getMessageType(), factory);\n\n      manager = _participants[i]; \r\n    }\n\n    Message schedulerMessage =\n        new Message(MessageType.SCHEDULER_MSG + \"\", UUID.randomUUID().toString());\n    schedulerMessage.setTgtSessionId(\"*\");\n    schedulerMessage.setTgtName(\"CONTROLLER\");\n    \r\n    schedulerMessage.setSrcName(\"CONTROLLER\");\n\n    \r\n    Message msg = new Message(factory.getMessageType(), \"Template\");\n    msg.setTgtSessionId(\"*\");\n    msg.setMsgState(MessageState.NEW);\n\n    \r\n    Criteria cr = new Criteria();\n    cr.setInstanceName(\"localhost_%\");\n    cr.setRecipientInstanceType(InstanceType.PARTICIPANT);\n    cr.setSessionSpecific(false);\n    cr.setResource(\"%\");\n    cr.setPartition(\"%\");\n\n    ObjectMapper mapper = new ObjectMapper();\n    SerializationConfig serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    StringWriter sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    String crString = sw.toString();\n\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    schedulerMessage.getRecord().setMapField(\"MessageTemplate\", msg.getRecord().getSimpleFields());\n    schedulerMessage.getRecord().setSimpleField(\"TIMEOUT\", \"-1\");\n    schedulerMessage.getRecord().setSimpleField(\"WAIT_ALL\", \"true\");\n    schedulerMessage.getRecord().setSimpleField(\n        DefaultSchedulerMessageHandlerFactory.SCHEDULER_TASK_QUEUE, \"TestSchedulerMsgContraints\");\n\n    Criteria cr2 = new Criteria();\n    cr2.setRecipientInstanceType(InstanceType.CONTROLLER);\n    cr2.setInstanceName(\"*\");\n    cr2.setSessionSpecific(false);\n\n    TestSchedulerMessage.MockAsyncCallback callback = new TestSchedulerMessage.MockAsyncCallback();\n    mapper = new ObjectMapper();\n    serializationConfig = mapper.getSerializationConfig();\n    serializationConfig.set(SerializationConfig.Feature.INDENT_OUTPUT, true);\n\n    sw = new StringWriter();\n    mapper.writeValue(sw, cr);\n\n    HelixDataAccessor helixDataAccessor = manager.getHelixDataAccessor();\n    PropertyKey.Builder keyBuilder = helixDataAccessor.keyBuilder();\n\n    \r\n    Map<String, String> constraints = new TreeMap<String, String>();\n    constraints.put(\"MESSAGE_TYPE\", \"STATE_TRANSITION\");\n    constraints.put(\"TRANSITION\", \"OFFLINE-COMPLETED\");\n    constraints.put(\"CONSTRAINT_VALUE\", \"1\");\n    constraints.put(\"INSTANCE\", \".*\");\n    manager.getClusterManagmentTool().setConstraint(manager.getClusterName(),\n        ConstraintType.MESSAGE_CONSTRAINT, \"constraint1\", new ConstraintItem(constraints));\n\n    \r\n    crString = sw.toString();\n    schedulerMessage.getRecord().setSimpleField(\"Criteria\", crString);\n    manager.getMessagingService().sendAndWait(cr2, schedulerMessage, callback, -1);\n    String msgId =\n        callback._message.getResultMap()\n            .get(DefaultSchedulerMessageHandlerFactory.SCHEDULER_MSG_ID);\n\n    for (int j = 0; j < 10; j++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"SentMessageCount\")) {\n        Assert.assertEquals(\n            statusUpdate.getMapFields().get(\"SentMessageCount\").get(\"MessageCount\"), \"\"\n                + (_PARTITIONS * 3));\n        break;\n      }\n    }\n\n    for (int i = 0; i < _PARTITIONS * 3 / 5; i++) {\n      for (int j = 0; j < 10; j++) {\n        Thread.sleep(300);\n        if (factory._messageCount == 5 * (i + 1))\n          break;\n      }\n      Thread.sleep(300);\n      Assert.assertEquals(factory._messageCount, 5 * (i + 1));\n      factory.signal();\n      \r\n    }\n\n    for (int j = 0; j < 10; j++) {\n      Thread.sleep(200);\n      PropertyKey controllerTaskStatus =\n          keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n      ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n      if (statusUpdate.getMapFields().containsKey(\"Summary\")) {\n        break;\n      }\n    }\n\n    Assert.assertEquals(_PARTITIONS, factory._results.size());\n    PropertyKey controllerTaskStatus =\n        keyBuilder.controllerTaskStatus(MessageType.SCHEDULER_MSG.name(), msgId);\n    ZNRecord statusUpdate = helixDataAccessor.getProperty(controllerTaskStatus).getRecord();\n    Assert.assertTrue(statusUpdate.getMapField(\"SentMessageCount\").get(\"MessageCount\")\n        .equals(\"\" + (_PARTITIONS * 3)));\n    int messageResultCount = 0;\n    for (String key : statusUpdate.getMapFields().keySet()) {\n      if (key.startsWith(\"MessageResult \")) {\n        messageResultCount++;\n      }\n    }\n    Assert.assertEquals(messageResultCount, _PARTITIONS * 3);\n\n    int count = 0;\n    for (Set<String> val : factory._results.values()) {\n      count += val.size();\n    }\n    Assert.assertEquals(count, _PARTITIONS * 3);\n\n    manager.getClusterManagmentTool().removeConstraint(manager.getClusterName(),\n        ConstraintType.MESSAGE_CONSTRAINT, \"constraint1\");\n\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMsgContraints.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"M"}],"commitId":"cd552d9f122dbe3fa4b3648d38b2fc615f663b84","commitMessage":"@@@Replace org.codehaus.jackson with FasterXML.jackson (#1293)\n\nReplace org.codehaus.jackson with FasterXML.jackson","date":"2020-08-21 10:06:09","modifiedFileCount":"86","status":"M","submitter":"xyuanlu"}]
