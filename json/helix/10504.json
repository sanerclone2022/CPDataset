[{"authorTime":"2018-07-14 05:45:41","codes":[{"authorDate":"2018-07-14 05:45:41","commitOrder":1,"curCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"B\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"C\", 9); \r\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setQuotaType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n  }\n","date":"2018-07-14 08:38:58","endLine":283,"groupId":"3864","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSchedulingQuotaBottleneck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/7f/256931668602ac48d2ef8f5ae9c952a8fda888.src","preCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"B\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"C\", 9); \r\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setQuotaType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"B"},{"authorDate":"2018-07-14 05:45:41","commitOrder":1,"curCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setQuotaType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n  }\n","date":"2018-07-14 08:38:58","endLine":354,"groupId":"3864","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkflowStuck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/7f/256931668602ac48d2ef8f5ae9c952a8fda888.src","preCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setQuotaType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":291,"status":"B"}],"commitId":"4db61b56e473b64ec9956f694dd2ac6a8d328ed4","commitMessage":"@@@[HELIX-730] Add ThreadCountBasedAssignmentCalculator and integrate with Workflow/JobRebalancer and fix rebalancing logic\n\nFor quota-based scheduling of tasks.  we have added the TaskAssigner interface that takes into account AssignableInstances by way of AssignableInstanceManager. In order to use this in the currently-existing pipeline prior to Task Framework 2.0.  GenericTaskAssignmentCalculator was replaced with ThreadCountBasedAssignmentCalculator.  which is a wrapper around TaskAssigner. Necessary adjustments were made in Workflow/JobRebalancer for this replacement. Also the rebalance logic in Workflow/JobRebalancer was reviewed and fixed. Additionally.  TestQuotaBasedScheduling is added to test quota-based task scheduling. Note that quotas will apply to both generic and targeted jobs.\n\nA few bugs were uncovered during this process such as the faulty retry logic that never really got tasks to restart. For more details.  see the changelist below:\n\nChangelist:\n    1. Add ThreadCountBasedAssignmentCalculator.  a wrapper around ThreadCountBasedTaskAssigner\n    2. Make logic changes in JobRebalancer to enable the use of ThreadCountBasedAssignmentCalculator\n    3. Fix the failing test by using a thread-safe map and rename TestGenericTaskAssignmentCalculator to TestTaskAssignmentCalculator to better reflect what its tests are doing\n    4. Add retry logic that was previously absent for INIT and DROPPED tasks in JobRebalancer\n    5. Add TestQuotaBasedScheduling to test that jobs and tasks were being assigned and scheduled per quota config set in ClusterConfig\n    6. Add more log messages to aid with task-scheduling debugging in AssignableInstance\n    7. In AbstractTaskDispatcher.  for tasks that are STOPPED.  TIMED_OUT.  TASK_ERROR.  the retry logic was newly implemented so that they get re-started correctly\n    8. In AbstractTaskDispatcher.  when enforcing overlapAssign for jobs with isAllowOverlapAssignment().  a fix was implemented so that only jobs whose state is IN_PROGRESS are considered\n    9. In AbstractTaskDispatcher.  isWorkflowFinished() method was modified so that non-active jobs will have their tasks' resource freed from AssignableInstances to prevent resource leak\n   10. In markJobFailed() and markJobCompleted().  non-active jobs will have their tasks' resource freed from AssignableInstances to prevent resource leak\n   11. Fix the logic so that quotas do not apply to targeted jobs\n   12. Fix TestTaskRebalancer (assumes Consistent Hashing.  which is no longer used)\n   13. Fix TestIndependentTaskRebalancer (assumes Consistent Hashing.  no longer used)\n   14. Assignment logic was improved so that incomplete tasks whose assigned participants are no longer live will be re-assigned accordingly\n   15. Fix TestTaskRebalanceFailover (tasks on non-live instances will be re-assigned promptly)\n   16. Fix TestRebalanceRunningTask (targeted jobs will get tasks reassigned upon liveInstance and currentState change)\n   17. Fix a bug in FixedAssignmentCalculator and assignment logic for targeted jobs such that a task index will no longer be assigned multiple times\n   18. Fix TestJobFailureTaskNotStarted (tasks were not being assigned at all due to having reached maximum capacity for quota)\n   19. Add targetedTaskConfigMap field in JobConfig to cache TaskConfig objects for targeted tasks to reduce object creation and GC overload\n   20. Fix JobConfig so that it doesn't write quotaType to ZooKeeper when quotaType is null or not set\n   21. Fix deleteWorkflow() in TaskUtil so that the earliest delete failure will render the entire method as failed (and return prematurely to prevent breaking other ZNodes from incomplete deletion)\n   22. Fix TestDeleteWorkflow by adding another removeProperty() clause to lower failure rate\n","date":"2018-07-14 08:38:58","modifiedFileCount":"36","status":"B","submitter":"Hunter Lee"},{"authorTime":"2018-07-17 06:48:38","codes":[{"authorDate":"2018-07-17 06:48:38","commitOrder":2,"curCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"B\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"C\", 9); \r\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setQuotaType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","date":"2018-07-18 02:46:04","endLine":288,"groupId":"3864","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSchedulingQuotaBottleneck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/8d/d24db045e0596e78f726517f793e7d4e3df07a.src","preCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"B\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"C\", 9); \r\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setQuotaType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"},{"authorDate":"2018-07-17 06:48:38","commitOrder":2,"curCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setQuotaType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","date":"2018-07-18 02:46:04","endLine":363,"groupId":"3864","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkflowStuck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/8d/d24db045e0596e78f726517f793e7d4e3df07a.src","preCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setQuotaType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":296,"status":"M"}],"commitId":"cc625065bffced9a66566eeccb3055ec28a74611","commitMessage":"@@@[HELIX-735] Make AssignmentCalculators non-static so that tests pass\n\nWith the introduction of quota-based scheduling.  every task that gets scheduled takes up a thread. However.  previously these AssignmentCalculators (both generic and fixed for generic jobs and targeted jobs) were stateless so they were instantiated statically. Since AssignmentCalculators now are stateful due to them operating on AssignableInstances' quota profile.  they were made non-static so that they would be re-instantiated every pipeline.\n\nThis problem is specific to the testing environment where static variables live on from test to test.  causing AssignmentCalculators to hold on to the very first reference to AssignableInstanceManager. Tasks were not being assigned and scheduled because the first set of AssignableInstances would get filled up and never get freed.\n\nChangelist:\n1. Make AssignmentCalculators non-static\n2. Adjust sleep duration for some tests for stability\n","date":"2018-07-18 02:46:04","modifiedFileCount":"4","status":"M","submitter":"Hunter Lee"},{"authorTime":"2018-07-18 04:36:18","codes":[{"authorDate":"2018-07-18 04:36:18","commitOrder":3,"curCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"B\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"C\", 9); \r\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setJobType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","date":"2018-07-18 06:37:40","endLine":288,"groupId":"3864","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testSchedulingQuotaBottleneck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/e2/da7d12156cf06fd3acf9b4315cb432ebb2d948.src","preCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"B\", 10); \r\n    clusterConfig.setTaskQuotaRatio(\"C\", 9); \r\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setQuotaType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"},{"authorDate":"2018-07-18 04:36:18","commitOrder":3,"curCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setJobType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","date":"2018-07-18 06:37:40","endLine":363,"groupId":"3864","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkflowStuck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/e2/da7d12156cf06fd3acf9b4315cb432ebb2d948.src","preCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setQuotaType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setQuotaType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setQuotaType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":296,"status":"M"}],"commitId":"36ab2a6028dad39b32d3a15da942b4385ff9fd1d","commitMessage":"@@@[HELIX-738] Remove quotaType APIs and make jobs inherit type from workflows\n\nFor quota-based task scheduling.  for each job.  we provided get/setQuotaType APIs. However.  the use case for workflow types and job types were similar enough that we decided to merge them and begin using workflow/job types for quota-based scheduling. Job types will now be used as quota types.  and all jobs will inherit the type.  if set.  from their parent workflow.  at assignment and schedule time.\n\nChangelist:\n1. Remove APIs around quotaType in Workflow/JobConfig\n2. Add an internal method in TaskAssignmentCalculator that includes logic for determining which quota type each job should use\n3. Adjust tests so that they test and pass successfully\n","date":"2018-07-18 06:37:40","modifiedFileCount":"10","status":"M","submitter":"Hunter Lee"},{"authorTime":"2018-07-25 05:06:20","codes":[{"authorDate":"2018-07-25 05:06:20","commitOrder":4,"curCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    clusterConfig.setTaskQuotaRatio(\"C\", 9);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n    _availableQuotaTypes = clusterConfig.getTaskQuotaRatioMap().keySet();\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setJobType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","date":"2018-07-25 08:45:50","endLine":334,"groupId":"3864","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testSchedulingQuotaBottleneck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/db/471ffaf5a2ce34b67afa61a688b43fb0600900.src","preCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    clusterConfig.setTaskQuotaRatio(\"C\", 9);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setJobType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":269,"status":"M"},{"authorDate":"2018-07-25 05:06:20","commitOrder":4,"curCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n    _availableQuotaTypes = clusterConfig.getTaskQuotaRatioMap().keySet();\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setJobType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","date":"2018-07-25 08:45:50","endLine":410,"groupId":"3864","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkflowStuck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/db/471ffaf5a2ce34b67afa61a688b43fb0600900.src","preCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setJobType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":342,"status":"M"}],"commitId":"6759040956907b197b6d65cb8b4759b7e8981883","commitMessage":"@@@[HELIX-744] Allow undefined workflow/job types to be assigned as DEFAULT type\n\nPreviously.  we ignored undefined types.  that is workflow/job types that are not defined in ClusterConfig. This is not backward-compatible because some users of Task Framework are setting types without any quota-related config set in ClusterConfig. The default behavior was changed so that each AssignableInstance will just treat these workflows/jobs as DEFAULT type.  which will make quota-based scheduling backward-compatible.\nChangelist:\n1. AssignableInstance treats undefined types as DEFAULT\n2. Appropriate log messages and logic change was applied to restoreTaskAssignResult logic\n3. A test case was added to TestQuotaBasedScheduling\n","date":"2018-07-25 08:45:50","modifiedFileCount":"3","status":"M","submitter":"Hunter Lee"},{"authorTime":"2018-11-03 05:02:02","codes":[{"authorDate":"2018-11-03 05:02:02","commitOrder":5,"curCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    clusterConfig.setTaskQuotaRatio(\"C\", 9);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n    _availableQuotaTypes = clusterConfig.getTaskQuotaRatioMap().keySet();\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setJobType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n  }\n","date":"2018-11-03 05:02:02","endLine":377,"groupId":"10504","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testSchedulingQuotaBottleneck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/60/8039972e3c411fd373d396d013659ea9ec336b.src","preCode":"  public void testSchedulingQuotaBottleneck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 1);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    clusterConfig.setTaskQuotaRatio(\"C\", 9);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n    _availableQuotaTypes = clusterConfig.getTaskQuotaRatioMap().keySet();\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    \r\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"ShortTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsC).setJobType(\"C\").setNumConcurrentTasksPerInstance(20);\n    workflowBuilder.addJob(\"JOB_C\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.COMPLETED);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.COMPLETED);\n\n    \r\n    TaskState jobState =\n        _driver.getWorkflowContext(workflowName).getJobState(workflowName + \"_JOB_C\");\n    Assert.assertEquals(jobState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":313,"status":"M"},{"authorDate":"2018-11-03 05:02:02","commitOrder":5,"curCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n    _availableQuotaTypes = clusterConfig.getTaskQuotaRatioMap().keySet();\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setJobType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n\n    \r\n    \r\n    _driver.pollForWorkflowState(\"secondWorkflow\", 2000L, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n  }\n","date":"2018-11-03 05:02:02","endLine":450,"groupId":"10504","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testWorkflowStuck","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/60/8039972e3c411fd373d396d013659ea9ec336b.src","preCode":"  public void testWorkflowStuck() throws InterruptedException {\n    ClusterConfig clusterConfig = _manager.getConfigAccessor().getClusterConfig(CLUSTER_NAME);\n    clusterConfig.resetTaskQuotaRatioMap();\n    clusterConfig.setTaskQuotaRatio(DEFAULT_QUOTA_TYPE, 10);\n    clusterConfig.setTaskQuotaRatio(\"A\", 10);\n    clusterConfig.setTaskQuotaRatio(\"B\", 10);\n    _manager.getConfigAccessor().setClusterConfig(CLUSTER_NAME, clusterConfig);\n    _availableQuotaTypes = clusterConfig.getTaskQuotaRatioMap().keySet();\n\n    String workflowName = TestHelper.getTestMethodName();\n    Workflow.Builder workflowBuilder = new Workflow.Builder(workflowName);\n    WorkflowConfig.Builder configBuilder = new WorkflowConfig.Builder(workflowName);\n    configBuilder.setAllowOverlapJobAssignment(true);\n    workflowBuilder.setWorkflowConfig(configBuilder.build());\n\n    \r\n    List<TaskConfig> taskConfigsA = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsA.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderA =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsA).setJobType(\"A\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_A\", jobBuilderA);\n\n    \r\n    List<TaskConfig> taskConfigsB = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsB.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderB =\n        new JobConfig.Builder().setCommand(JOB_COMMAND).setJobCommandConfigMap(_jobCommandMap)\n            .addTaskConfigs(taskConfigsB).setJobType(\"B\").setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_B\", jobBuilderB);\n\n    \r\n    List<TaskConfig> taskConfigsC = new ArrayList<>();\n    for (int i = 0; i < 50; i++) {\n      Map<String, String> taskConfigMap = Maps.newHashMap();\n      taskConfigsC.add(new TaskConfig(\"LongTask\", taskConfigMap));\n    }\n    JobConfig.Builder jobBuilderC = new JobConfig.Builder().setCommand(JOB_COMMAND)\n        .setJobCommandConfigMap(_jobCommandMap).addTaskConfigs(taskConfigsC)\n        .setJobType(DEFAULT_QUOTA_TYPE).setNumConcurrentTasksPerInstance(50);\n    workflowBuilder.addJob(\"JOB_DEFAULT\", jobBuilderC);\n\n    _driver.start(workflowBuilder.build());\n    \r\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_A\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_B\", TaskState.IN_PROGRESS);\n    _driver.pollForJobState(workflowName, workflowName + \"_JOB_DEFAULT\", TaskState.IN_PROGRESS);\n\n    \r\n    Workflow secondWorkflow =\n        createWorkflow(\"secondWorkflow\", true, DEFAULT_QUOTA_TYPE, 1, 1, \"ShortTask\");\n    _driver.start(secondWorkflow);\n    Thread.sleep(1000L); \r\n\n    \r\n    \r\n    TaskState secondWorkflowState = _driver.getWorkflowContext(\"secondWorkflow\").getWorkflowState();\n    Assert.assertEquals(secondWorkflowState, TaskState.IN_PROGRESS);\n\n    \r\n    _finishTask = true;\n    Thread.sleep(2000L);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TestQuotaBasedScheduling.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":385,"status":"M"}],"commitId":"bced0996ed65c9a886b5e04788e2cc1c88fc37b1","commitMessage":"@@@[HELIX-786] TEST: Make TestQuotaBasedScheduling stable\n\nBecause recent changes caused the Controller to run slower.  TestQuotaBasedScheduling was being unstable. This RB fixes this.\nChangelist:\n1. Use polling instead of Thread.sleep()\n","date":"2018-11-03 05:02:02","modifiedFileCount":"1","status":"M","submitter":"narendly"}]
