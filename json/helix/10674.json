[{"authorTime":"2019-01-30 09:33:31","codes":[{"authorDate":"2018-05-31 01:22:10","commitOrder":10,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ClusterDataCache cache = new ClusterDataCache(clusterName);\n        cache.refresh(accessor);\n        cache.setTaskCache(false);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2018-07-12 06:23:03","endLine":330,"groupId":"2641","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/cc/508ef54aa5eb9444b3cfe61404ddd133d96dcd.src","preCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ClusterDataCache cache = new ClusterDataCache(clusterName);\n        cache.refresh(accessor);\n        cache.setTaskCache(false);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":190,"status":"NB"},{"authorDate":"2019-01-30 09:33:31","commitOrder":10,"curCode":"  private void unregisterAllJobs() throws MalformedObjectNameException {\n    synchronized (_perTypeJobMonitorMap) {\n      Iterator<Map.Entry<String, JobMonitor>> jobIter = _perTypeJobMonitorMap.entrySet().iterator();\n      while (jobIter.hasNext()) {\n        Map.Entry<String, JobMonitor> jobEntry = jobIter.next();\n        unregister(getObjectName(getJobBeanName(jobEntry.getKey())));\n        jobIter.remove();\n      }\n    }\n  }\n","date":"2019-01-31 03:26:21","endLine":803,"groupId":"3784","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"unregisterAllJobs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/14/5503224bbc9b2589d0b59141d3dfb13301db92.src","preCode":"  private void unregisterAllJobs() throws MalformedObjectNameException {\n    synchronized (_perTypeJobMonitorMap) {\n      Iterator<Map.Entry<String, JobMonitor>> jobIter = _perTypeJobMonitorMap.entrySet().iterator();\n      while (jobIter.hasNext()) {\n        Map.Entry<String, JobMonitor> jobEntry = jobIter.next();\n        unregister(getObjectName(getJobBeanName(jobEntry.getKey())));\n        jobIter.remove();\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":794,"status":"B"}],"commitId":"f9ec24e994afbf834a4454dcb2cbe48af71e24dd","commitMessage":"@@@Fix some race condition issues in MBean management classes. Fix the listener adding sequence.\n\nStabilized the TestClusterStatusMonitorLifecycle accordingly.\n","date":"2019-01-31 03:26:21","modifiedFileCount":"7","status":"M","submitter":"jiajunwang"},{"authorTime":"2019-01-30 09:33:31","codes":[{"authorDate":"2019-02-26 09:36:00","commitOrder":11,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2019-02-26 09:36:00","endLine":333,"groupId":"2641","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/85/bd49f95904a33e591cdc84bb7472f3ebc107f4.src","preCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ClusterDataCache cache = new ClusterDataCache(clusterName);\n        cache.refresh(accessor);\n        cache.setTaskCache(false);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":194,"status":"M"},{"authorDate":"2019-01-30 09:33:31","commitOrder":11,"curCode":"  private void unregisterAllJobs() throws MalformedObjectNameException {\n    synchronized (_perTypeJobMonitorMap) {\n      Iterator<Map.Entry<String, JobMonitor>> jobIter = _perTypeJobMonitorMap.entrySet().iterator();\n      while (jobIter.hasNext()) {\n        Map.Entry<String, JobMonitor> jobEntry = jobIter.next();\n        unregister(getObjectName(getJobBeanName(jobEntry.getKey())));\n        jobIter.remove();\n      }\n    }\n  }\n","date":"2019-01-31 03:26:21","endLine":803,"groupId":"3784","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"unregisterAllJobs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/14/5503224bbc9b2589d0b59141d3dfb13301db92.src","preCode":"  private void unregisterAllJobs() throws MalformedObjectNameException {\n    synchronized (_perTypeJobMonitorMap) {\n      Iterator<Map.Entry<String, JobMonitor>> jobIter = _perTypeJobMonitorMap.entrySet().iterator();\n      while (jobIter.hasNext()) {\n        Map.Entry<String, JobMonitor> jobEntry = jobIter.next();\n        unregister(getObjectName(getJobBeanName(jobEntry.getKey())));\n        jobIter.remove();\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":794,"status":"N"}],"commitId":"fbb679c5f4804652ea730bf5cd4ee6bf1329efc3","commitMessage":"@@@split data cache\n","date":"2019-02-26 09:36:00","modifiedFileCount":"95","status":"M","submitter":"Harry Zhang"},{"authorTime":"2019-03-29 03:30:09","codes":[{"authorDate":"2019-02-26 09:36:00","commitOrder":12,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2019-02-26 09:36:00","endLine":333,"groupId":"2641","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/85/bd49f95904a33e591cdc84bb7472f3ebc107f4.src","preCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":194,"status":"N"},{"authorDate":"2019-03-29 03:30:09","commitOrder":12,"curCode":"  private void unregisterAllJobs() {\n    synchronized (_perTypeJobMonitorMap) {\n      Iterator<Map.Entry<String, JobMonitor>> jobIter = _perTypeJobMonitorMap.entrySet().iterator();\n      while (jobIter.hasNext()) {\n        Map.Entry<String, JobMonitor> jobEntry = jobIter.next();\n        jobEntry.getValue().unregister();\n        jobIter.remove();\n      }\n    }\n  }\n","date":"2019-03-29 03:30:14","endLine":817,"groupId":"3784","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"unregisterAllJobs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1d/778ee79913602778e41451e424f0f9ac6b5292.src","preCode":"  private void unregisterAllJobs() throws MalformedObjectNameException {\n    synchronized (_perTypeJobMonitorMap) {\n      Iterator<Map.Entry<String, JobMonitor>> jobIter = _perTypeJobMonitorMap.entrySet().iterator();\n      while (jobIter.hasNext()) {\n        Map.Entry<String, JobMonitor> jobEntry = jobIter.next();\n        unregister(getObjectName(getJobBeanName(jobEntry.getKey())));\n        jobIter.remove();\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":808,"status":"M"}],"commitId":"8ba4c9c19981fffe3c958c6851e2b8b8bf90bfbb","commitMessage":"@@@TASK2.0: Add performance metrics to JobMonitor\n\n    We want to add more metrics to Task Framework so that the user could understand what's going on in case of a slowdown.  or get a general sense of how fast the workload is moving.\n    Changelist:\n    1. Add SubmissionToProcessDelay\n    2. Add SubmissionToScheduleDelay\n    3. Add ControllerInducedDelay (for testing)\n    4. Add JobLatencyGauge\n    5. Change regular metrics to Dynamic metrics in JobMonitor\n    6. Add an integration test: TestTaskPerformanceMetrics\n","date":"2019-03-29 03:30:14","modifiedFileCount":"6","status":"M","submitter":"Hunter Lee"},{"authorTime":"2019-03-29 03:30:09","codes":[{"authorDate":"2020-05-15 08:34:22","commitOrder":13,"curCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews =\n            accessor.getChildValuesMap(keyBuilder.externalViews(), true);\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","date":"2020-05-15 08:34:22","endLine":336,"groupId":"10674","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyBestPossAndExtView","params":"(HelixDataAccessoraccessor@Map<String@Map<String@String>>errStates@StringclusterName@Set<String>resources)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/5d/8d1a04c92500c2c194fd9684815059bd3b28e5.src","preCode":"    private boolean verifyBestPossAndExtView(HelixDataAccessor accessor,\n        Map<String, Map<String, String>> errStates, String clusterName, Set<String> resources) {\n      try {\n        PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n        \r\n        ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n        cache.refresh(accessor);\n\n        Map<String, IdealState> idealStates = new HashMap<>(cache.getIdealStates());\n\n        \r\n        Iterator<Map.Entry<String, IdealState>> it = idealStates.entrySet().iterator();\n        while (it.hasNext()) {\n          Map.Entry<String, IdealState> pair = it.next();\n          if (pair.getValue().getStateModelDefRef().equals(TaskConstants.STATE_MODEL_NAME)) {\n            it.remove();\n          }\n        }\n\n        Map<String, ExternalView> extViews = accessor.getChildValuesMap(keyBuilder.externalViews());\n        if (extViews == null) {\n          extViews = Collections.emptyMap();\n        }\n\n        \r\n        if (resources != null && !resources.isEmpty()) {\n          idealStates.keySet().retainAll(resources);\n          extViews.keySet().retainAll(resources);\n        }\n\n        \r\n        \r\n        for (String resource : extViews.keySet()) {\n          if (!idealStates.containsKey(resource)) {\n            idealStates.put(resource, new IdealState(resource));\n          }\n        }\n\n        \r\n        BestPossibleStateOutput bestPossOutput = calcBestPossState(cache, resources);\n        Map<String, Map<Partition, Map<String, String>>> bestPossStateMap =\n            bestPossOutput.getStateMap();\n\n        \r\n        if (errStates != null) {\n          for (String resourceName : errStates.keySet()) {\n            Map<String, String> partErrStates = errStates.get(resourceName);\n            for (String partitionName : partErrStates.keySet()) {\n              String instanceName = partErrStates.get(partitionName);\n\n              if (!bestPossStateMap.containsKey(resourceName)) {\n                bestPossStateMap.put(resourceName, new HashMap<Partition, Map<String, String>>());\n              }\n              Partition partition = new Partition(partitionName);\n              if (!bestPossStateMap.get(resourceName).containsKey(partition)) {\n                bestPossStateMap.get(resourceName).put(partition, new HashMap<String, String>());\n              }\n              bestPossStateMap.get(resourceName).get(partition)\n                  .put(instanceName, HelixDefinedState.ERROR.toString());\n            }\n          }\n        }\n\n        \r\n\n        for (String resourceName : idealStates.keySet()) {\n          ExternalView extView = extViews.get(resourceName);\n          if (extView == null) {\n            IdealState is = idealStates.get(resourceName);\n            if (is.isExternalViewDisabled()) {\n              continue;\n            } else {\n              LOG.info(\"externalView for \" + resourceName + \" is not available\");\n              return false;\n            }\n          }\n\n          \r\n          Map<Partition, Map<String, String>> bpStateMap =\n              bestPossOutput.getResourceMap(resourceName);\n          Iterator<Map.Entry<Partition, Map<String, String>>> iter = bpStateMap.entrySet().iterator();\n          while (iter.hasNext()) {\n            Map.Entry<Partition, Map<String, String>> entry = iter.next();\n            Map<String, String> instanceStateMap = entry.getValue();\n            if (instanceStateMap.isEmpty()) {\n              iter.remove();\n            } else {\n              \r\n              Iterator<Map.Entry<String, String>> insIter = instanceStateMap.entrySet().iterator();\n              while (insIter.hasNext()) {\n                Map.Entry<String, String> insEntry = insIter.next();\n                String state = insEntry.getValue();\n                if (state.equalsIgnoreCase(HelixDefinedState.DROPPED.toString())) {\n                  insIter.remove();\n                }\n              }\n            }\n          }\n\n          \r\n\n          \r\n          int extViewSize = extView.getRecord().getMapFields().size();\n          int bestPossStateSize = bestPossOutput.getResourceMap(resourceName).size();\n          if (extViewSize != bestPossStateSize) {\n            LOG.info(\"exterView size (\" + extViewSize + \") is different from bestPossState size (\"\n                + bestPossStateSize + \") for resource: \" + resourceName);\n\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            return false;\n          }\n\n          \r\n          for (String partition : extView.getRecord().getMapFields().keySet()) {\n            Map<String, String> evInstanceStateMap = extView.getRecord().getMapField(partition);\n            Map<String, String> bpInstanceStateMap =\n                bestPossOutput.getInstanceStateMap(resourceName, new Partition(partition));\n\n            boolean result = compareMap(evInstanceStateMap, bpInstanceStateMap);\n            if (result == false) {\n              LOG.info(\"externalView is different from bestPossibleState for partition:\" + partition);\n\n              \r\n              \r\n              \r\n              return false;\n            }\n          }\n        }\n        return true;\n      } catch (Exception e) {\n        LOG.error(\"exception in verification\", e);\n        return false;\n      }\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":196,"status":"M"},{"authorDate":"2019-03-29 03:30:09","commitOrder":13,"curCode":"  private void unregisterAllJobs() {\n    synchronized (_perTypeJobMonitorMap) {\n      Iterator<Map.Entry<String, JobMonitor>> jobIter = _perTypeJobMonitorMap.entrySet().iterator();\n      while (jobIter.hasNext()) {\n        Map.Entry<String, JobMonitor> jobEntry = jobIter.next();\n        jobEntry.getValue().unregister();\n        jobIter.remove();\n      }\n    }\n  }\n","date":"2019-03-29 03:30:14","endLine":817,"groupId":"10674","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"unregisterAllJobs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1d/778ee79913602778e41451e424f0f9ac6b5292.src","preCode":"  private void unregisterAllJobs() {\n    synchronized (_perTypeJobMonitorMap) {\n      Iterator<Map.Entry<String, JobMonitor>> jobIter = _perTypeJobMonitorMap.entrySet().iterator();\n      while (jobIter.hasNext()) {\n        Map.Entry<String, JobMonitor> jobEntry = jobIter.next();\n        jobEntry.getValue().unregister();\n        jobIter.remove();\n      }\n    }\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":808,"status":"N"}],"commitId":"6ff99f5a181fb5fe91340968f93ca2cd5329a90a","commitMessage":"@@@Enforce result check for data accessors batch get calls to prevent partial batch read. (#974)\n\nThis will help to ensure the main Helix logic does not calculate based on incomplete input.","date":"2020-05-15 08:34:22","modifiedFileCount":"49","status":"M","submitter":"Jiajun Wang"}]
