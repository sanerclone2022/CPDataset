[{"authorTime":"2016-09-13 07:42:17","codes":[{"authorDate":"2016-09-13 07:42:17","commitOrder":10,"curCode":"  public IdealState computeNewIdealState(String resourceName, IdealState currentIdealState,\n      CurrentStateOutput currentStateOutput, ClusterDataCache clusterData) {\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = StateModelDefinition\n        .getStateCountMap(stateModelDef, liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":133,"groupId":"4495","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"computeNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@CurrentStateOutputcurrentStateOutput@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/80/96d5a9130edd8bdf088b870bcd1149c6c356e5.src","preCode":"  public IdealState computeNewIdealState(String resourceName, IdealState currentIdealState,\n      CurrentStateOutput currentStateOutput, ClusterDataCache clusterData) {\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = StateModelDefinition\n        .getStateCountMap(stateModelDef, liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":57,"status":"MB"},{"authorDate":"2016-09-13 07:42:17","commitOrder":10,"curCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":158,"groupId":"704","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"generateNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@ZNRecordnewMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/127bc0a9285530e88b9848f9481f0b874cec93.src","preCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"B"}],"commitId":"b0d1122841be3bd09276a546cfa3c5433ffefea9","commitMessage":"@@@New DelayedAutoRebalancer featured with delayed partition movements during rebalancing.\n","date":"2017-02-09 01:53:43","modifiedFileCount":"19","status":"M","submitter":"Lei Xia"},{"authorTime":"2016-09-13 07:42:17","codes":[{"authorDate":"2017-10-04 03:13:50","commitOrder":11,"curCode":"  @Override public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = StateModelDefinition\n        .getStateCountMap(stateModelDef, liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n    return newIdealState;\n  }\n","date":"2017-10-04 03:24:48","endLine":129,"groupId":"4495","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"computeNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@CurrentStateOutputcurrentStateOutput@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/9c/fcc819f3977819fa5228bb31ec9d508ba27daf.src","preCode":"  public IdealState computeNewIdealState(String resourceName, IdealState currentIdealState,\n      CurrentStateOutput currentStateOutput, ClusterDataCache clusterData) {\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = StateModelDefinition\n        .getStateCountMap(stateModelDef, liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"},{"authorDate":"2016-09-13 07:42:17","commitOrder":11,"curCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":158,"groupId":"704","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"generateNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@ZNRecordnewMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/127bc0a9285530e88b9848f9481f0b874cec93.src","preCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"N"}],"commitId":"b9de8362bc75c98aa49110c78ce17edf9ef52456","commitMessage":"@@@[HELIX-669] State Transition Cancellation Client side change Part II\n\nIn Helix.  there are many different scenrios which could make some pending state transitions not valid any more.  for example.  a resource is deleted while it still has some pending transitions.  or Helix calculates a new ideal mapping while there are still some pending transitions not matching new mapping.  In such cases.  Helix controller should proactively cancell these pending transitions instead of waiting them to finish.\n\nIn this rb:\n1. Support MessageHandlerFactory can be registered by different message type.\n2. Refactor related API\n3. Add unit test for multi message type registeration.\n","date":"2017-10-04 03:24:48","modifiedFileCount":"36","status":"M","submitter":"Junkai Xue"},{"authorTime":"2016-09-13 07:42:17","codes":[{"authorDate":"2017-11-08 08:48:26","commitOrder":12,"curCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-11-08 08:48:26","endLine":138,"groupId":"4495","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"computeNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@CurrentStateOutputcurrentStateOutput@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/74/17b3626414d9aabac7f44cdd80e5bd26d4aad1.src","preCode":"  @Override public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = StateModelDefinition\n        .getStateCountMap(stateModelDef, liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"},{"authorDate":"2016-09-13 07:42:17","commitOrder":12,"curCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":158,"groupId":"704","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"generateNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@ZNRecordnewMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/127bc0a9285530e88b9848f9481f0b874cec93.src","preCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"N"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"M","submitter":"Junkai Xue"},{"authorTime":"2016-09-13 07:42:17","codes":[{"authorDate":"2018-02-10 02:28:25","commitOrder":13,"curCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2018-03-24 02:21:16","endLine":146,"groupId":"4495","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"computeNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@CurrentStateOutputcurrentStateOutput@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1c/385dd621a808bbc01769a744c71884d7af43e8.src","preCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-09-13 07:42:17","commitOrder":13,"curCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":158,"groupId":"704","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"generateNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@ZNRecordnewMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/127bc0a9285530e88b9848f9481f0b874cec93.src","preCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"N"}],"commitId":"a5de29c2ac5b1a5567e50f2febbfec492a47c799","commitMessage":"@@@Retrieve cached idealMappings for all Rebalancers (AutoRebalancer.  DelayedRebalancer and CustomRebalancer) for any rebalance strategies. This will avoid recompute idealmapping (preference list) if there is no idealstate/instanceconfig/LiveInstances changes.\n","date":"2018-03-24 02:21:16","modifiedFileCount":"5","status":"M","submitter":"Lei Xia"},{"authorTime":"2016-09-13 07:42:17","codes":[{"authorDate":"2018-03-15 08:29:53","commitOrder":14,"curCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    int replicas = currentIdealState.getReplicaCount(liveInstance.size());\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), replicas);\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2018-03-24 02:57:07","endLine":146,"groupId":"4495","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"computeNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@CurrentStateOutputcurrentStateOutput@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1a/f159dc9f3d68cec82b36dc4eff532c2d7ee7b6.src","preCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    String replicas = currentIdealState.getReplicas();\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), Integer.parseInt(replicas));\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-09-13 07:42:17","commitOrder":14,"curCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":158,"groupId":"704","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"generateNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@ZNRecordnewMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/127bc0a9285530e88b9848f9481f0b874cec93.src","preCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"N"}],"commitId":"42557199a99feab1a0157569d49925f60a0955b1","commitMessage":"@@@Fix a bug in AutoRebalancer that it fails to compute ideal mapping if \"ANY_LIVEINSTANCE\" is specified as the replica.\n","date":"2018-03-24 02:57:07","modifiedFileCount":"1","status":"M","submitter":"Lei Xia"},{"authorTime":"2016-09-13 07:42:17","codes":[{"authorDate":"2018-11-02 07:28:23","commitOrder":15,"curCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    int replicas = currentIdealState.getReplicaCount(liveInstance.size());\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), replicas);\n    List<String> liveNodes = new ArrayList<>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<>(clusterData.getAllInstances());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2018-11-14 08:52:40","endLine":146,"groupId":"4495","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"computeNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@CurrentStateOutputcurrentStateOutput@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/d0/4c301cee1bcb23f07a4c72b978404c190a6398.src","preCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    int replicas = currentIdealState.getReplicaCount(liveInstance.size());\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), replicas);\n    List<String> liveNodes = new ArrayList<String>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<String>(clusterData.getInstanceConfigMap().keySet());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-09-13 07:42:17","commitOrder":15,"curCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":158,"groupId":"704","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"generateNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@ZNRecordnewMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/127bc0a9285530e88b9848f9481f0b874cec93.src","preCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"N"}],"commitId":"d5bf3ad410e0a54b1e79d9570d3e7897c0e2c947","commitMessage":"@@@Generalize topology domain to support graceful node swap.\n\nThere was a constraint that topology domain has to contain the instance name as the final path value. This constraint prevent configuring flexilbe topology for a dynamic cluster. In case of a node swap.  the topology has to be completely re-calculated.\nThis change decouple the domain from instance name. So even with some nodes swapped.  admin can still configure with the same topology. This will ensure a stable resource partition assignment.\n","date":"2018-11-14 08:52:40","modifiedFileCount":"10","status":"M","submitter":"Jiajun Wang"},{"authorTime":"2016-09-13 07:42:17","codes":[{"authorDate":"2019-02-26 09:36:00","commitOrder":16,"curCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ResourceControllerDataProvider clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = new ArrayList<>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    int replicas = currentIdealState.getReplicaCount(liveInstance.size());\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), replicas);\n    List<String> liveNodes = new ArrayList<>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<>(clusterData.getAllInstances());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<>(taggedNodes);\n      liveNodes = new ArrayList<>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2019-02-26 09:36:00","endLine":147,"groupId":"2845","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"computeNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@CurrentStateOutputcurrentStateOutput@ResourceControllerDataProviderclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/a6/495200900bc7f932f8592ca4b3a0d1c1670e1e.src","preCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ClusterDataCache clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = new ArrayList<String>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    int replicas = currentIdealState.getReplicaCount(liveInstance.size());\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), replicas);\n    List<String> liveNodes = new ArrayList<>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<>(clusterData.getAllInstances());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<String>(taggedNodes);\n      liveNodes = new ArrayList<String>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"},{"authorDate":"2016-09-13 07:42:17","commitOrder":16,"curCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":158,"groupId":"704","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"generateNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@ZNRecordnewMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/127bc0a9285530e88b9848f9481f0b874cec93.src","preCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"N"}],"commitId":"fbb679c5f4804652ea730bf5cd4ee6bf1329efc3","commitMessage":"@@@split data cache\n","date":"2019-02-26 09:36:00","modifiedFileCount":"95","status":"M","submitter":"Harry Zhang"},{"authorTime":"2016-09-13 07:42:17","codes":[{"authorDate":"2020-04-15 07:27:36","commitOrder":17,"curCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ResourceControllerDataProvider clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = getStablePartitionList(clusterData, currentIdealState);\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    int replicas = currentIdealState.getReplicaCount(liveInstance.size());\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), replicas);\n    List<String> liveNodes = new ArrayList<>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<>(clusterData.getAllInstances());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<>(taggedNodes);\n      liveNodes = new ArrayList<>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2020-04-15 07:27:36","endLine":146,"groupId":"10877","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"computeNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@CurrentStateOutputcurrentStateOutput@ResourceControllerDataProviderclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/cb/323a33f5145f222598f28d067438f97c4c42d5.src","preCode":"  public IdealState computeNewIdealState(String resourceName,\n      IdealState currentIdealState, CurrentStateOutput currentStateOutput,\n      ResourceControllerDataProvider clusterData) {\n\n    IdealState cachedIdealState = getCachedIdealState(resourceName, clusterData);\n    if (cachedIdealState != null) {\n      LOG.debug(\"Use cached IdealState for \" + resourceName);\n      return cachedIdealState;\n    }\n\n    LOG.info(\"Computing IdealState for \" + resourceName);\n\n    List<String> partitions = new ArrayList<>(currentIdealState.getPartitionSet());\n    String stateModelName = currentIdealState.getStateModelDefRef();\n    StateModelDefinition stateModelDef = clusterData.getStateModelDef(stateModelName);\n    if (stateModelDef == null) {\n      LOG.error(\"State Model Definition null for resource: \" + resourceName);\n      throw new HelixException(\"State Model Definition null for resource: \" + resourceName);\n    }\n    Map<String, LiveInstance> liveInstance = clusterData.getLiveInstances();\n    int replicas = currentIdealState.getReplicaCount(liveInstance.size());\n\n    LinkedHashMap<String, Integer> stateCountMap = stateModelDef\n        .getStateCountMap(liveInstance.size(), replicas);\n    List<String> liveNodes = new ArrayList<>(liveInstance.keySet());\n    List<String> allNodes = new ArrayList<>(clusterData.getAllInstances());\n    allNodes.removeAll(clusterData.getDisabledInstances());\n    liveNodes.retainAll(allNodes);\n\n    Map<String, Map<String, String>> currentMapping =\n        currentMapping(currentStateOutput, resourceName, partitions, stateCountMap);\n\n    \r\n    Set<String> taggedNodes = new HashSet<String>();\n    Set<String> taggedLiveNodes = new HashSet<String>();\n    if (currentIdealState.getInstanceGroupTag() != null) {\n      for (String instanceName : allNodes) {\n        if (clusterData.getInstanceConfigMap().get(instanceName)\n            .containsTag(currentIdealState.getInstanceGroupTag())) {\n          taggedNodes.add(instanceName);\n          if (liveInstance.containsKey(instanceName)) {\n            taggedLiveNodes.add(instanceName);\n          }\n        }\n      }\n      if (!taggedLiveNodes.isEmpty()) {\n        \r\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"found the following participants with tag \"\n              + currentIdealState.getInstanceGroupTag() + \" for \" + resourceName + \": \"\n              + taggedLiveNodes);\n        }\n      } else if (taggedNodes.isEmpty()) {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no configured participants have this tag\");\n      } else {\n        \r\n        LOG.warn(\"Resource \" + resourceName + \" has tag \" + currentIdealState.getInstanceGroupTag()\n            + \" but no live participants have this tag\");\n      }\n      allNodes = new ArrayList<>(taggedNodes);\n      liveNodes = new ArrayList<>(taggedLiveNodes);\n    }\n\n    \r\n    Collections.sort(allNodes);\n    Collections.sort(liveNodes);\n\n    int maxPartition = currentIdealState.getMaxPartitionsPerInstance();\n    _rebalanceStrategy =\n        getRebalanceStrategy(currentIdealState.getRebalanceStrategy(), partitions, resourceName,\n            stateCountMap, maxPartition);\n    ZNRecord newMapping = _rebalanceStrategy\n        .computePartitionAssignment(allNodes, liveNodes, currentMapping, clusterData);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"currentMapping: \" + currentMapping);\n      LOG.debug(\"stateCountMap: \" + stateCountMap);\n      LOG.debug(\"liveNodes: \" + liveNodes);\n      LOG.debug(\"allNodes: \" + allNodes);\n      LOG.debug(\"maxPartition: \" + maxPartition);\n      LOG.debug(\"newMapping: \" + newMapping);\n    }\n\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(RebalanceMode.FULL_AUTO);\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-09-13 07:42:17","commitOrder":17,"curCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","date":"2017-02-09 01:53:43","endLine":158,"groupId":"10877","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"generateNewIdealState","params":"(StringresourceName@IdealStatecurrentIdealState@ZNRecordnewMapping)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1e/127bc0a9285530e88b9848f9481f0b874cec93.src","preCode":"  private IdealState generateNewIdealState(String resourceName, IdealState currentIdealState,\n      ZNRecord newMapping) {\n    IdealState newIdealState = new IdealState(resourceName);\n    newIdealState.getRecord().setSimpleFields(currentIdealState.getRecord().getSimpleFields());\n    newIdealState.setRebalanceMode(currentIdealState.getRebalanceMode());\n    newIdealState.getRecord().setListFields(newMapping.getListFields());\n\n    return newIdealState;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":150,"status":"N"}],"commitId":"8d6586bc4ec8e74d6e4db65d60c9f75ba012588b","commitMessage":"@@@Fix unexpceted partition movements in the CrushEd strategy. (#941)\n\nThis is a workaround fix to ensure backward compatibility. An additional cache map is used to keep the stable partition list so as to remove the randomness in the algorithm input.\nNote that the right fix would be cleaner that we sort the list inside the strategy class. However.  that will also change all existing cluster assignments in production.","date":"2020-04-15 07:27:36","modifiedFileCount":"4","status":"M","submitter":"Jiajun Wang"}]
