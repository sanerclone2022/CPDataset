[{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2017-11-17 05:26:06","commitOrder":2,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursive(namespace);\n    }\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","date":"2018-01-25 10:31:40","endLine":88,"groupId":"504","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/58/036f0087d15b923a35948532ac516d41e9194a.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursive(namespace);\n    }\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestClusterInMaintenanceModeWhenReachingMaxPartition.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"B"},{"authorDate":"2017-11-08 08:48:26","commitOrder":2,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursive(namespace);\n    }\n    _setupTool = new ClusterSetup(_gZkClient);\n    _setupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _setupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","date":"2017-11-08 08:48:26","endLine":94,"groupId":"504","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/81/7c2071bd85399b794f8429f2d3d396e0931315.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursive(namespace);\n    }\n    _setupTool = new ClusterSetup(_gZkClient);\n    _setupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _setupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/DelayedAutoRebalancer/TestDelayedAutoRebalance.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"NB"}],"commitId":"de2e3e8be366984461c0b43c8dc6a28048c66157","commitMessage":"@@@Fix two tests for maintenance mode\n","date":"2018-01-25 10:31:40","modifiedFileCount":"0","status":"M","submitter":"Junkai Xue"},{"authorTime":"2018-03-09 06:04:42","codes":[{"authorDate":"2018-03-09 06:04:42","commitOrder":3,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursively(namespace);\n    }\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","date":"2018-03-20 07:43:31","endLine":88,"groupId":"504","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/97/69021803572439c7e82008dcb12e77096c68af.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursive(namespace);\n    }\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestClusterInMaintenanceModeWhenReachingMaxPartition.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2018-03-09 06:04:42","commitOrder":3,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursively(namespace);\n    }\n    _setupTool = new ClusterSetup(_gZkClient);\n    _setupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _setupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","date":"2018-03-20 07:43:31","endLine":94,"groupId":"504","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/f64b22bb0f1fb5eed75ef6fe69e1fca8140c9e.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursive(namespace);\n    }\n    _setupTool = new ClusterSetup(_gZkClient);\n    _setupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _setupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/DelayedAutoRebalancer/TestDelayedAutoRebalance.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"}],"commitId":"0e849035379a04b079ac1274bb8aaab473df1572","commitMessage":"@@@[HELIX-679] consolidate semantics of recursively delete path in ZkClient\n","date":"2018-03-20 07:43:31","modifiedFileCount":"57","status":"M","submitter":"hrzhang"},{"authorTime":"2018-06-08 08:15:54","codes":[{"authorDate":"2018-06-08 08:15:54","commitOrder":4,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","date":"2018-07-14 02:20:49","endLine":83,"groupId":"504","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c7/ef8fa7d7e3d986ceefb04594981007830f97f5.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursively(namespace);\n    }\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestClusterInMaintenanceModeWhenReachingMaxPartition.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":57,"status":"M"},{"authorDate":"2018-06-08 08:15:54","commitOrder":4,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","date":"2018-07-14 02:20:49","endLine":87,"groupId":"504","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/92/da126b08d47b5b3b7a142861393882fb98df7d.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    String namespace = \"/\" + CLUSTER_NAME;\n    if (_gZkClient.exists(namespace)) {\n      _gZkClient.deleteRecursively(namespace);\n    }\n    _setupTool = new ClusterSetup(_gZkClient);\n    _setupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _setupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/DelayedAutoRebalancer/TestDelayedAutoRebalance.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"}],"commitId":"c0d5792b745c67b6fee56ba79df02be89d1f049e","commitMessage":"@@@Properly remove clusters after each test.  and clean up duplicated codes in tests and move them into base test classes.\n","date":"2018-07-14 02:20:49","modifiedFileCount":"139","status":"M","submitter":"Lei Xia"},{"authorTime":"2019-10-02 03:08:56","codes":[{"authorDate":"2018-06-08 08:15:54","commitOrder":5,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","date":"2018-07-14 02:20:49","endLine":83,"groupId":"504","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c7/ef8fa7d7e3d986ceefb04594981007830f97f5.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestClusterInMaintenanceModeWhenReachingMaxPartition.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":57,"status":"N"},{"authorDate":"2019-10-02 03:08:56","commitOrder":5,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier = getClusterVerifier();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","date":"2020-02-08 04:24:22","endLine":89,"groupId":"504","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/45/3b661219e2e8545e9e5756a6471dae91bff569.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/DelayedAutoRebalancer/TestDelayedAutoRebalance.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"71948ec8fdb97c2b62fd41b0d944b653b46ae01c","commitMessage":"@@@Add delayed rebalance and user-defined preference list features to the WAGED rebalancer. (#456)\n\n- Add delayed rebalance and user-defined preference list features to the WAGED rebalancer.\n- Refine the delayed rebalance usage in the waged rebalancer.\n- Add the delayed rebalance scheduling logic.\n- Add the necessary tests. And fix TestMixedModeAutoRebalance and all delayed rebalance tests.","date":"2020-02-08 04:24:22","modifiedFileCount":"13","status":"M","submitter":"Jiajun Wang"},{"authorTime":"2019-11-08 03:29:30","codes":[{"authorDate":"2018-06-08 08:15:54","commitOrder":6,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","date":"2018-07-14 02:20:49","endLine":83,"groupId":"504","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c7/ef8fa7d7e3d986ceefb04594981007830f97f5.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestClusterInMaintenanceModeWhenReachingMaxPartition.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":57,"status":"N"},{"authorDate":"2019-11-08 03:29:30","commitOrder":6,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","date":"2020-02-08 04:24:22","endLine":90,"groupId":"504","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/af/cabdfd6394e40d6d3e4f9dc83bdde8c25f75e2.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier = getClusterVerifier();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/DelayedAutoRebalancer/TestDelayedAutoRebalance.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"0b1b337a32ffbcee76e1f73f20e42b9325e2dce7","commitMessage":"@@@Introduce Dry-run Waged Rebalancer for the verifiers and tests. (#573)\n\nUse a dry-run rebalancer to avoid updating the persisted rebalancer status in the verifiers or tests.\nAlso.  refine several rebalancer related interfaces so as to simplify the dry-run rebalancer implementation.\nConvert the test cases back to use the BestPossibleExternalViewVerifier.\n\nAdditional fixing:\n- Updating the rebalancer preference for every rebalancer.compute calls. Since the preference might be updated at runtime.\n- Fix one minor metric domain name bug in the WagedRebalancerMetricCollector.\n- Minor test case fix to make them more stable after the change.","date":"2020-02-08 04:24:22","modifiedFileCount":"22","status":"M","submitter":"Jiajun Wang"},{"authorTime":"2020-08-06 10:47:55","codes":[{"authorDate":"2020-08-06 10:47:55","commitOrder":7,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkClient(_gZkClient).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","date":"2020-08-06 10:47:55","endLine":83,"groupId":"504","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c8/3752a18ccd4c8cf4c90eef45c933f04ec14644.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestClusterInMaintenanceModeWhenReachingMaxPartition.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":57,"status":"M"},{"authorDate":"2020-08-06 10:47:55","commitOrder":7,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkClient(_gZkClient).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","date":"2020-08-06 10:47:55","endLine":90,"groupId":"504","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/02/61bd5c493d4ac0eeab31985a23d73dc385c718.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkAddr(ZK_ADDR).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/DelayedAutoRebalancer/TestDelayedAutoRebalance.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"}],"commitId":"56cf1259add5d00bb13fefb018a5de9679a1c6a7","commitMessage":"@@@Fix ZkHelixClusterVerifier related resource leakage (#1185)\n\nZkHelixClusterVerifier and its subclass built with ZK addres would\ncreate an internal ZkClient. Without properly closing the ZkClient\nor using global ZkClient in the test base. There would be four\nthreads and one ZooKeeper client object leaked. The leaked threads\nwould be in thousands and thus be one of the main contributor\npreventing the unit test from finishing. This pull request addresses\nthis issue.\n\nCo-authored-by: Kai Sun <ksun@ksun-mn1.linkedin.biz>","date":"2020-08-06 10:47:55","modifiedFileCount":"30","status":"M","submitter":"kaisun2000"},{"authorTime":"2020-10-08 07:58:42","codes":[{"authorDate":"2020-10-08 07:58:42","commitOrder":8,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkClient(_gZkClient)\n            .setWaitTillVerify(TestHelper.DEFAULT_REBALANCE_PROCESSING_WAIT_TIME)\n            .build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","date":"2020-10-08 07:58:42","endLine":86,"groupId":"10356","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/92/85f38fc446aeec6de4f4a4866580374d52620a.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkClient(_gZkClient).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n    _dataAccessor = new ZKHelixDataAccessor(CLUSTER_NAME, _baseAccessor);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestClusterInMaintenanceModeWhenReachingMaxPartition.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2020-10-08 07:58:42","commitOrder":8,"curCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkClient(_gZkClient)\n            .setWaitTillVerify(TestHelper.DEFAULT_REBALANCE_PROCESSING_WAIT_TIME)\n            .build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","date":"2020-10-08 07:58:42","endLine":93,"groupId":"10356","id":14,"instanceNumber":2,"isCurCommit":1,"methodName":"beforeClass","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/95/8f27c83dedfbb371c691caa1fd31b89f415a17.src","preCode":"  public void beforeClass() throws Exception {\n    System.out.println(\"START \" + CLASS_NAME + \" at \" + new Date(System.currentTimeMillis()));\n\n    _gSetupTool.addCluster(CLUSTER_NAME, true);\n\n    for (int i = 0; i < NUM_NODE; i++) {\n      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n\n      \r\n      MockParticipantManager participant =\n          new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, storageNodeName);\n      participant.syncStart();\n      _participants.add(participant);\n    }\n\n    \r\n    String controllerName = CONTROLLER_PREFIX + \"_0\";\n    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n    _controller.syncStart();\n\n    _clusterVerifier =\n        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkClient(_gZkClient).build();\n\n    enablePersistBestPossibleAssignment(_gZkClient, CLUSTER_NAME, true);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/rebalancer/DelayedAutoRebalancer/TestDelayedAutoRebalance.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":66,"status":"M"}],"commitId":"02e16baf3f559f62657a1c713e1cdcd5b029045e","commitMessage":"@@@HelixClusterVerifier verify() with default waitTillVerify time -- part one (#1449)\n\nHelixClusterVerifier verify() and related method may return\nprematurely. The reason is that verify the converging stable\ncondition too early before the controller has a chance to make\na change. Basically.  the previous stable state is mistaken as the\nexpected next stable state.\nThis commit fixes this issue by adding waitTillVerify() timeout in\nthe construction time of the verifier.","date":"2020-10-08 07:58:42","modifiedFileCount":"45","status":"M","submitter":"kaisun2000"}]
