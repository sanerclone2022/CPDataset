[{"authorTime":"2013-08-03 07:45:54","codes":[{"authorDate":"2016-06-17 03:06:34","commitOrder":5,"curCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n    int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : allNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < liveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(liveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(allNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    moveNonPreferredReplicasToPreferred();\n\n    assignOrphans();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","date":"2016-09-13 01:06:33","endLine":140,"groupId":"708","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>allNodes@finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/86/8d20728a6b7166ee456fdfa7f246914c7f6f1d.src","preCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n    int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : allNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < liveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(liveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(allNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    moveNonPreferredReplicasToPreferred();\n\n    assignOrphans();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"B"},{"authorDate":"2013-08-03 07:45:54","commitOrder":5,"curCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","date":"2013-08-03 07:45:54","endLine":201,"groupId":"708","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@finalList<String>allNodes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f0/1393782f8e22c8ad7d091be7ea2acb95d0b3d9.src","preCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"NB"}],"commitId":"7147ec874e912f27905c299fefe0d09ca31ebd42","commitMessage":"@@@[HELIX-568] Add new topology aware (rack-aware) rebalance strategy based on CRUSH algorithm.\nDesign doc is available at: https://cwiki.apache.org/confluence/display/HELIX/Helix+Topology-aware+Rebalance+Strategy\n","date":"2016-09-13 01:06:33","modifiedFileCount":"12","status":"M","submitter":"Lei Xia"},{"authorTime":"2013-08-03 07:45:54","codes":[{"authorDate":"2016-09-13 08:54:40","commitOrder":6,"curCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n    int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : allNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < liveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(liveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(allNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","date":"2016-10-05 10:31:58","endLine":139,"groupId":"708","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>allNodes@finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/8e/decdc940dbcaf7908c406ba6974c9289ba98d0.src","preCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n    int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : allNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < liveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(liveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(allNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    moveNonPreferredReplicasToPreferred();\n\n    assignOrphans();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2013-08-03 07:45:54","commitOrder":6,"curCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","date":"2013-08-03 07:45:54","endLine":201,"groupId":"708","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@finalList<String>allNodes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f0/1393782f8e22c8ad7d091be7ea2acb95d0b3d9.src","preCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"N"}],"commitId":"c0cb3424f08ebb03fd7358b569fcc503a9e8735e","commitMessage":"@@@[HELIX-631] AutoRebalanceStrategy does not work correctly all the time.\n","date":"2016-10-05 10:31:58","modifiedFileCount":"2","status":"M","submitter":"Lei Xia"},{"authorTime":"2013-08-03 07:45:54","codes":[{"authorDate":"2016-10-26 00:01:35","commitOrder":7,"curCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","date":"2016-10-26 00:04:30","endLine":150,"groupId":"708","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>allNodes@finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/03/85959f1f04e2c6a997fb22a531bd0d23cbae76.src","preCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n    int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : allNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < liveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(liveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(allNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":80,"status":"M"},{"authorDate":"2013-08-03 07:45:54","commitOrder":7,"curCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","date":"2013-08-03 07:45:54","endLine":201,"groupId":"708","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@finalList<String>allNodes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f0/1393782f8e22c8ad7d091be7ea2acb95d0b3d9.src","preCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"N"}],"commitId":"45ebe767533a9c014bf37c30e4a6a62652538b5a","commitMessage":"@@@[HELIX-543] Avoid moving partitions unnecessarily when auto-rebalancing.\n","date":"2016-10-26 00:04:30","modifiedFileCount":"3","status":"M","submitter":"Lei Xia"},{"authorTime":"2013-08-03 07:45:54","codes":[{"authorDate":"2017-05-10 02:38:36","commitOrder":8,"curCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    if (_orphaned.size() > 0) {\n      forceToAssignOrphans();\n    }\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","date":"2017-05-11 02:22:01","endLine":156,"groupId":"708","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>allNodes@finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/6d/17d77006d09b2e6a24e9233908389c6edc04e4.src","preCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2013-08-03 07:45:54","commitOrder":8,"curCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","date":"2013-08-03 07:45:54","endLine":201,"groupId":"708","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@finalList<String>allNodes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f0/1393782f8e22c8ad7d091be7ea2acb95d0b3d9.src","preCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"N"}],"commitId":"8d409fc7e466b583fe09774ef2d2c1ad850d6c56","commitMessage":"@@@[HELIX-631] Fix AutoRebalanceStrategy replica not assigned\n\nIn our current AutoRebalanceStrategy.  Helix uses greedy algorithm to assign replicas. With the constraint that two replicas from same partition should not assigned to same node and nodes' capacity calculated by evenly distributed. Thus there may some replicas are not assigned.\n\nWith this fix.  Helix will try to force assign the orphaned replicas to the node with minimum overload. This may cause imbalanced assignment.\n","date":"2017-05-11 02:22:01","modifiedFileCount":"1","status":"M","submitter":"Junkai Xue"},{"authorTime":"2013-08-03 07:45:54","codes":[{"authorDate":"2017-11-08 08:48:26","commitOrder":9,"curCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (_orphaned.size() > 0 && logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    if (_orphaned.size() > 0) {\n      forceToAssignOrphans();\n    }\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","date":"2017-11-08 08:48:26","endLine":156,"groupId":"708","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>allNodes@finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@ClusterDataCacheclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/da/607ace5c18c9b53625aa4a1f2ed6b4358bc96a.src","preCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    if (_orphaned.size() > 0) {\n      forceToAssignOrphans();\n    }\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2013-08-03 07:45:54","commitOrder":9,"curCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","date":"2013-08-03 07:45:54","endLine":201,"groupId":"708","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@finalList<String>allNodes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f0/1393782f8e22c8ad7d091be7ea2acb95d0b3d9.src","preCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"N"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"M","submitter":"Junkai Xue"},{"authorTime":"2013-08-03 07:45:54","codes":[{"authorDate":"2019-02-26 09:36:00","commitOrder":10,"curCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ResourceControllerDataProvider clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (_orphaned.size() > 0 && logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    if (_orphaned.size() > 0) {\n      forceToAssignOrphans();\n    }\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","date":"2019-02-26 09:36:00","endLine":157,"groupId":"708","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>allNodes@finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@ResourceControllerDataProviderclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/68/f116508c8660c59bf2b95f354bbe7a05373556.src","preCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ClusterDataCache clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (_orphaned.size() > 0 && logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    if (_orphaned.size() > 0) {\n      forceToAssignOrphans();\n    }\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"},{"authorDate":"2013-08-03 07:45:54","commitOrder":10,"curCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","date":"2013-08-03 07:45:54","endLine":201,"groupId":"708","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@finalList<String>allNodes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f0/1393782f8e22c8ad7d091be7ea2acb95d0b3d9.src","preCode":"    public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n        final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n      int numReplicas = countStateReplicas();\n      ZNRecord znRecord = new ZNRecord(_resourceName);\n      if (liveNodes.size() == 0) {\n        return znRecord;\n      }\n      int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n      int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n      _nodeMap = new HashMap<String, Node>();\n      _liveNodesList = new ArrayList<Node>();\n\n      for (String id : allNodes) {\n        Node node = new Node(id);\n        node.capacity = 0;\n        node.hasCeilingCapacity = false;\n        _nodeMap.put(id, node);\n      }\n      for (int i = 0; i < liveNodes.size(); i++) {\n        boolean usingCeiling = false;\n        int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n        if (distRemainder > 0 && targetSize < _maximumPerNode) {\n          targetSize += 1;\n          distRemainder = distRemainder - 1;\n          usingCeiling = true;\n        }\n        Node node = _nodeMap.get(liveNodes.get(i));\n        node.isAlive = true;\n        node.capacity = targetSize;\n        node.hasCeilingCapacity = usingCeiling;\n        _liveNodesList.add(node);\n      }\n\n      \r\n      _stateMap = generateStateMap();\n\n      \r\n      _preferredAssignment = computePreferredPlacement(allNodes);\n\n      \r\n      \r\n      \r\n      _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n      \r\n      _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n      \r\n      _orphaned = computeOrphaned();\n      if (logger.isInfoEnabled()) {\n        logger.info(\"orphan = \" + _orphaned);\n      }\n\n      moveNonPreferredReplicasToPreferred();\n\n      assignOrphans();\n\n      moveExcessReplicas();\n\n      prepareResult(znRecord);\n      return znRecord;\n    }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":140,"status":"N"}],"commitId":"fbb679c5f4804652ea730bf5cd4ee6bf1329efc3","commitMessage":"@@@split data cache\n","date":"2019-02-26 09:36:00","modifiedFileCount":"95","status":"M","submitter":"Harry Zhang"},{"authorTime":"2019-06-25 15:08:44","codes":[{"authorDate":"2019-02-26 09:36:00","commitOrder":11,"curCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ResourceControllerDataProvider clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (_orphaned.size() > 0 && logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    if (_orphaned.size() > 0) {\n      forceToAssignOrphans();\n    }\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","date":"2019-02-26 09:36:00","endLine":157,"groupId":"10880","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>allNodes@finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@ResourceControllerDataProviderclusterData)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/68/f116508c8660c59bf2b95f354bbe7a05373556.src","preCode":"  public ZNRecord computePartitionAssignment(final List<String> allNodes, final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, ResourceControllerDataProvider clusterData) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n\n    List<String> sortedAllNodes = new ArrayList<String>(allNodes);\n    Collections.sort(sortedAllNodes);\n\n    Comparator<String> currentStateNodeComparator =\n        new CurrentStateNodeComparator(currentMapping);\n\n    List<String> sortedLiveNodes = new ArrayList<String>(liveNodes);\n    Collections.sort(sortedLiveNodes, currentStateNodeComparator);\n\n    int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : sortedAllNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < sortedLiveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(sortedLiveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(sortedAllNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (_orphaned.size() > 0 && logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    assignOrphans();\n    moveNonPreferredReplicasToPreferred();\n\n    moveExcessReplicas();\n\n    if (_orphaned.size() > 0) {\n      forceToAssignOrphans();\n    }\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"N"},{"authorDate":"2019-06-25 15:08:44","commitOrder":11,"curCode":"  public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n    int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : allNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < liveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(liveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(allNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (_orphaned.size() > 0 && logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    moveNonPreferredReplicasToPreferred();\n\n    assignOrphans();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","date":"2019-06-25 15:08:44","endLine":143,"groupId":"10880","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"computePartitionAssignment","params":"(finalList<String>liveNodes@finalMap<String@Map<String@String>>currentMapping@finalList<String>allNodes)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/d4/45664c0acc0e3f8bf36aa56a54468aa6a03a1e.src","preCode":"  public ZNRecord computePartitionAssignment(final List<String> liveNodes,\n      final Map<String, Map<String, String>> currentMapping, final List<String> allNodes) {\n    int numReplicas = countStateReplicas();\n    ZNRecord znRecord = new ZNRecord(_resourceName);\n    if (liveNodes.size() == 0) {\n      return znRecord;\n    }\n    int distRemainder = (numReplicas * _partitions.size()) % liveNodes.size();\n    int distFloor = (numReplicas * _partitions.size()) / liveNodes.size();\n    _nodeMap = new HashMap<String, Node>();\n    _liveNodesList = new ArrayList<Node>();\n\n    for (String id : allNodes) {\n      Node node = new Node(id);\n      node.capacity = 0;\n      node.hasCeilingCapacity = false;\n      _nodeMap.put(id, node);\n    }\n    for (int i = 0; i < liveNodes.size(); i++) {\n      boolean usingCeiling = false;\n      int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor;\n      if (distRemainder > 0 && targetSize < _maximumPerNode) {\n        targetSize += 1;\n        distRemainder = distRemainder - 1;\n        usingCeiling = true;\n      }\n      Node node = _nodeMap.get(liveNodes.get(i));\n      node.isAlive = true;\n      node.capacity = targetSize;\n      node.hasCeilingCapacity = usingCeiling;\n      _liveNodesList.add(node);\n    }\n\n    \r\n    _stateMap = generateStateMap();\n\n    \r\n    _preferredAssignment = computePreferredPlacement(allNodes);\n\n    \r\n    \r\n    \r\n    _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping);\n\n    \r\n    _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping);\n\n    \r\n    _orphaned = computeOrphaned();\n    if (logger.isInfoEnabled()) {\n      logger.info(\"orphan = \" + _orphaned);\n    }\n\n    moveNonPreferredReplicasToPreferred();\n\n    assignOrphans();\n\n    moveExcessReplicas();\n\n    prepareResult(znRecord);\n    return znRecord;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/strategy/AutoRebalanceStrategy.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"}],"commitId":"aa77f5c0bfc3cafb6482b1cef4a1689191cbd846","commitMessage":"@@@Merge differences with another branch\n\nThere are multiple branches against which Helix devs have been doing development work. We wish to consolidate them into one by reconciling all differences. This diff makes such changes. This diff does not contain any changes in logic or functionality.\n","date":"2019-06-25 15:08:44","modifiedFileCount":"62","status":"M","submitter":"Hunter Lee"}]
