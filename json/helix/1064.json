[{"authorTime":"2020-04-03 00:43:15","codes":[{"authorDate":"2020-04-03 00:43:15","commitOrder":1,"curCode":"  public void testTwoRunningCurrentStates() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getTaskDataCache().getPreviousAssignment(JOB_NAME))\n        .thenReturn(mock._resourceAssignment);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(true);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.DROPPED.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"0\"));\n  }\n","date":"2020-04-03 00:43:15","endLine":114,"groupId":"6383","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testTwoRunningCurrentStates","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/04/28c812fd52fd9b3f604366ca1718e60f69a0d8.src","preCode":"  public void testTwoRunningCurrentStates() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getTaskDataCache().getPreviousAssignment(JOB_NAME))\n        .thenReturn(mock._resourceAssignment);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(true);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.DROPPED.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"0\"));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/task/TestTargetedTaskStateChange.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"B"},{"authorDate":"2020-04-03 00:43:15","commitOrder":1,"curCode":"  public void testOneRunningOneNull() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getTaskDataCache().getPreviousAssignment(JOB_NAME))\n        .thenReturn(mock._resourceAssignment2);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(false);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput2, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.RUNNING.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"1\"));\n  }\n","date":"2020-04-03 00:43:15","endLine":156,"groupId":"6385","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testOneRunningOneNull","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/04/28c812fd52fd9b3f604366ca1718e60f69a0d8.src","preCode":"  public void testOneRunningOneNull() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getTaskDataCache().getPreviousAssignment(JOB_NAME))\n        .thenReturn(mock._resourceAssignment2);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(false);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput2, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.RUNNING.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"1\"));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/task/TestTargetedTaskStateChange.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"B"}],"commitId":"184a50ac173c18e0ea3d40ffb5a0f93d31aa558f","commitMessage":"@@@Fix the scheduling decision for multiple currentStates (#923)\n\nFix the scheduling decision for multiple currentStates and prevAssignment\n\nIn this commit.  the problem of scheduling and dropping the tasks\non the slave node has been addressed.\nMultiple tests have been added.","date":"2020-04-03 00:43:15","modifiedFileCount":"1","status":"B","submitter":"Ali Reza Zamani Zadeh Najari"},{"authorTime":"2020-06-18 02:26:27","codes":[{"authorDate":"2020-06-18 02:26:27","commitOrder":2,"curCode":"  public void testTwoRunningCurrentStates() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(true);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.DROPPED.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"0\"));\n  }\n","date":"2020-08-05 05:14:24","endLine":109,"groupId":"6607","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testTwoRunningCurrentStates","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/b7/9dcb9e726d92eb45fd895da081e412292f6270.src","preCode":"  public void testTwoRunningCurrentStates() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getTaskDataCache().getPreviousAssignment(JOB_NAME))\n        .thenReturn(mock._resourceAssignment);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(true);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.DROPPED.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"0\"));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/task/TestTargetedTaskStateChange.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2020-06-18 02:26:27","commitOrder":2,"curCode":"  public void testOneRunningOneNull() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(false);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput2, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.RUNNING.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"1\"));\n  }\n","date":"2020-08-05 05:14:24","endLine":146,"groupId":"6385","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testOneRunningOneNull","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/b7/9dcb9e726d92eb45fd895da081e412292f6270.src","preCode":"  public void testOneRunningOneNull() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getTaskDataCache().getPreviousAssignment(JOB_NAME))\n        .thenReturn(mock._resourceAssignment2);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(false);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput2, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.RUNNING.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"1\"));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/task/TestTargetedTaskStateChange.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"}],"commitId":"f11243f693eee572c2e681ef4a3feafd3d2dd88d","commitMessage":"@@@Remove previousAssignment read/write to ZK (#1074)\n\nRemove previousAssignment read/write to ZK\n\nIn this commit.  the previousAssignment has been removed from codebase\nand controller will no longer read/write previousAssignment from/to ZK.","date":"2020-08-05 05:14:24","modifiedFileCount":"6","status":"M","submitter":"Ali Reza Zamani Zadeh Najari"},{"authorTime":"2020-07-22 04:01:47","codes":[{"authorDate":"2020-07-22 04:01:47","commitOrder":3,"curCode":"  public void testTwoRunningCurrentStates() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateOrMessageChange()).thenReturn(true);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.DROPPED.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"0\"));\n  }\n","date":"2020-08-05 05:14:24","endLine":109,"groupId":"1064","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testTwoRunningCurrentStates","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/e8/49be28c4b0e6f26be5f6538be06cef629e0f05.src","preCode":"  public void testTwoRunningCurrentStates() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(true);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.DROPPED.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"0\"));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/task/TestTargetedTaskStateChange.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2020-07-22 04:01:47","commitOrder":3,"curCode":"  public void testOneRunningOneNull() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateOrMessageChange()).thenReturn(false);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput2, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.RUNNING.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"1\"));\n  }\n","date":"2020-08-05 05:14:24","endLine":146,"groupId":"1064","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testOneRunningOneNull","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/e8/49be28c4b0e6f26be5f6538be06cef629e0f05.src","preCode":"  public void testOneRunningOneNull() {\n    MockTestInformation mock = new MockTestInformation();\n    when(mock._cache.getWorkflowConfig(WORKFLOW_NAME)).thenReturn(mock._workflowConfig);\n    when(mock._cache.getJobConfig(JOB_NAME)).thenReturn(mock._jobConfig);\n    when(mock._cache.getTaskDataCache()).thenReturn(mock._taskDataCache);\n    when(mock._cache.getJobContext(JOB_NAME)).thenReturn(mock._jobContext);\n    when(mock._cache.getIdealStates()).thenReturn(mock._idealStates);\n    when(mock._cache.getEnabledLiveInstances()).thenReturn(_liveInstances.keySet());\n    when(mock._cache.getInstanceConfigMap()).thenReturn(_instanceConfigs);\n    when(mock._cache.getClusterConfig()).thenReturn(_clusterConfig);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME)).thenReturn(mock._runtimeJobDag);\n    _assignableInstanceManager.buildAssignableInstances(_clusterConfig, mock._taskDataCache,\n        _liveInstances, _instanceConfigs);\n    when(mock._cache.getAssignableInstanceManager()).thenReturn(_assignableInstanceManager);\n    when(mock._cache.getExistsLiveInstanceOrCurrentStateChange()).thenReturn(false);\n    Set<String> inflightJobDag = new HashSet<>();\n    inflightJobDag.add(JOB_NAME);\n    when(mock._taskDataCache.getRuntimeJobDag(WORKFLOW_NAME).getInflightJobList())\n        .thenReturn(inflightJobDag);\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    WorkflowDispatcher workflowDispatcher = new WorkflowDispatcher();\n    workflowDispatcher.updateCache(mock._cache);\n    workflowDispatcher.updateWorkflowStatus(WORKFLOW_NAME, mock._workflowConfig,\n        mock._workflowContext, mock._currentStateOutput2, bestPossibleStateOutput);\n    Partition taskPartition = new Partition(JOB_NAME + \"_\" + PARTITION_NAME);\n    Assert.assertEquals(TaskPartitionState.RUNNING.name(), bestPossibleStateOutput\n        .getPartitionStateMap(JOB_NAME).getPartitionMap(taskPartition).get(INSTANCE_PREFIX + \"1\"));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/task/TestTargetedTaskStateChange.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"}],"commitId":"d39b4561080066993e04f54e83cba0cbcb9323be","commitMessage":"@@@Respect Maximum Number Of Attempts for the tasks (#1142)\n\nIn this commit.  several scheduling parts have been changed in order to\nenforce the scheduler to respect maximum number of attempts for\nthe tasks.\n\nAlso.  it has been observed that when a task being dropped and\nscheduled again.  max number of attempts is not being respected.\nin this commit.  further checks are added to avoid schedule the\ntasks again once we reach its maximum number of attempts.","date":"2020-08-05 05:14:24","modifiedFileCount":"6","status":"M","submitter":"Ali Reza Zamani Zadeh Najari"}]
