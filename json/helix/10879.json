[{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2017-11-08 08:48:26","commitOrder":1,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      Map<String, String> currentStateMap, Set<String> disabledInstancesForPartition,\n      IdealState idealState) {\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","date":"2017-11-08 08:48:26","endLine":182,"groupId":"1397","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@Map<String@String>currentStateMap@Set<String>disabledInstancesForPartition@IdealStateidealState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/7f/79f7ffa6539a5f156449b72ca2cc466152a860.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      Map<String, String> currentStateMap, Set<String> disabledInstancesForPartition,\n      IdealState idealState) {\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"B"},{"authorDate":"2017-11-08 08:48:26","commitOrder":1,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      Map<String, String> currentStateMap, Set<String> disabledInstancesForPartition,\n      IdealState idealState) {\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> instancesToMove = new ArrayList<String>(currentStateMap.keySet());\n    instancesToMove.removeAll(preferenceList);\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = instancesToMove.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (disabledInstancesForPartition.contains(instance) || state == null\n          || state.equals(HelixDefinedState.ERROR.name())\n          || state.equals(stateModelDef.getInitialState())\n          || disabledInstancesForPartition.contains(instance)) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n    \r\n    \r\n    \r\n    Collections.sort(instancesToMove, new PreferenceListNodeComparator(currentStateMap, stateModelDef));\n    List<String> combinedPreferenceList = new ArrayList<String>(preferenceList);\n    combinedPreferenceList.addAll(instancesToMove);\n\n    \r\n    Map<String, String> bestPossibleStateMap = computeBestPossibleMap(combinedPreferenceList, stateModelDef,\n        currentStateMap, liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    Map<String, String> targetInstanceMap = new HashMap<>(currentStateMap);\n    targetInstanceMap.keySet().retainAll(preferenceList);\n    if (migrationCompleted(preferenceList, stateModelDef, targetInstanceMap, idealState)) {\n      for (String instance : currentStateMap.keySet()) {\n        if (!preferenceList.contains(instance)) {\n          String state = currentStateMap.get(instance);\n          if (state != null) {\n            bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.toString());\n          }\n        }\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","date":"2017-11-08 08:48:26","endLine":490,"groupId":"1397","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@Map<String@String>currentStateMap@Set<String>disabledInstancesForPartition@IdealStateidealState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/ea/9678e370b5441d986d5e6cc3a318614a14e274.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      Map<String, String> currentStateMap, Set<String> disabledInstancesForPartition,\n      IdealState idealState) {\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> instancesToMove = new ArrayList<String>(currentStateMap.keySet());\n    instancesToMove.removeAll(preferenceList);\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = instancesToMove.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (disabledInstancesForPartition.contains(instance) || state == null\n          || state.equals(HelixDefinedState.ERROR.name())\n          || state.equals(stateModelDef.getInitialState())\n          || disabledInstancesForPartition.contains(instance)) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n    \r\n    \r\n    \r\n    Collections.sort(instancesToMove, new PreferenceListNodeComparator(currentStateMap, stateModelDef));\n    List<String> combinedPreferenceList = new ArrayList<String>(preferenceList);\n    combinedPreferenceList.addAll(instancesToMove);\n\n    \r\n    Map<String, String> bestPossibleStateMap = computeBestPossibleMap(combinedPreferenceList, stateModelDef,\n        currentStateMap, liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    Map<String, String> targetInstanceMap = new HashMap<>(currentStateMap);\n    targetInstanceMap.keySet().retainAll(preferenceList);\n    if (migrationCompleted(preferenceList, stateModelDef, targetInstanceMap, idealState)) {\n      for (String instance : currentStateMap.keySet()) {\n        if (!preferenceList.contains(instance)) {\n          String state = currentStateMap.get(instance);\n          if (state != null) {\n            bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.toString());\n          }\n        }\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":421,"status":"B"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"B","submitter":"Junkai Xue"},{"authorTime":"2018-06-29 05:27:32","codes":[{"authorDate":"2018-06-29 05:27:32","commitOrder":2,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap =\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","date":"2018-06-29 08:40:21","endLine":202,"groupId":"1397","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/02/277696f23fe39e3b75e8a649a4063ca4e483c9.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      Map<String, String> currentStateMap, Set<String> disabledInstancesForPartition,\n      IdealState idealState) {\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2018-06-29 05:27:32","commitOrder":2,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, numReplicas, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","date":"2018-06-29 08:40:21","endLine":547,"groupId":"236","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/02/f96f619647f1af0fa6bf02cedd1e9320fb0bd3.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      Map<String, String> currentStateMap, Set<String> disabledInstancesForPartition,\n      IdealState idealState) {\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> instancesToMove = new ArrayList<String>(currentStateMap.keySet());\n    instancesToMove.removeAll(preferenceList);\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = instancesToMove.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (disabledInstancesForPartition.contains(instance) || state == null\n          || state.equals(HelixDefinedState.ERROR.name())\n          || state.equals(stateModelDef.getInitialState())\n          || disabledInstancesForPartition.contains(instance)) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n    \r\n    \r\n    \r\n    Collections.sort(instancesToMove, new PreferenceListNodeComparator(currentStateMap, stateModelDef));\n    List<String> combinedPreferenceList = new ArrayList<String>(preferenceList);\n    combinedPreferenceList.addAll(instancesToMove);\n\n    \r\n    Map<String, String> bestPossibleStateMap = computeBestPossibleMap(combinedPreferenceList, stateModelDef,\n        currentStateMap, liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    Map<String, String> targetInstanceMap = new HashMap<>(currentStateMap);\n    targetInstanceMap.keySet().retainAll(preferenceList);\n    if (migrationCompleted(preferenceList, stateModelDef, targetInstanceMap, idealState)) {\n      for (String instance : currentStateMap.keySet()) {\n        if (!preferenceList.contains(instance)) {\n          String state = currentStateMap.get(instance);\n          if (state != null) {\n            bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.toString());\n          }\n        }\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":451,"status":"M"}],"commitId":"c97a97508c9c45a0bf51177988dca7f48e49ea32","commitMessage":"@@@Change migration strategy to N -> N+1 -> N model\n\n    Currently Helix takes N->2N->N strategy when migrating a partition.  where N equals to DB's replica count. When Helix decides to move a partition to N new instances.  it brings up all replicas in new instances first before drop all replicas in old instances (so there will be 2N replica existing at certain period of time). This approach gurantees the availability during migration but may require bigger disk footprint. It may also cause a partition having more than 6 replicas if the cluster topology keeps changing during migration.\n    What we proposed here is N -> N+1 -> N strategy.  where Helix will bootstrap a new replica in one of new instance.  then drop one from old instances. It then repeats the process until all replicas are moved to new instances. This will reduce disk usage.  but meanwhile still maintain at least N active replica during the process. The new strategy can also avoid partition having excessive replicas even there is toplogy changes during the migration.\n","date":"2018-06-29 08:40:21","modifiedFileCount":"14","status":"M","submitter":"Junkai Xue"},{"authorTime":"2019-02-02 05:23:35","codes":[{"authorDate":"2018-06-29 05:27:32","commitOrder":3,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap =\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","date":"2018-06-29 08:40:21","endLine":202,"groupId":"1397","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/02/277696f23fe39e3b75e8a649a4063ca4e483c9.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap =\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"N"},{"authorDate":"2019-02-02 05:23:35","commitOrder":3,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, preferenceList, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","date":"2019-02-27 03:45:28","endLine":551,"groupId":"236","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/62/ad37f546bfe9fca8f352367d501dfe61a3f699.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, numReplicas, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"M"}],"commitId":"b0f61507915f5052f53854ddbefcacac86f9c8d4","commitMessage":"@@@Add ERROR mapping for displaying in BestPossible and Intemediate assignment.\n\nWith adding this ERROR mapping replica.  it should not break any rules of assignment. It was purely serving for showing the ERROR partition targeted host.\n","date":"2019-02-27 03:45:28","modifiedFileCount":"2","status":"M","submitter":"Junkai Xue"},{"authorTime":"2019-02-07 04:08:46","codes":[{"authorDate":"2018-06-29 05:27:32","commitOrder":4,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap =\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","date":"2018-06-29 08:40:21","endLine":202,"groupId":"1397","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/02/277696f23fe39e3b75e8a649a4063ca4e483c9.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap =\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"N"},{"authorDate":"2019-02-07 04:08:46","commitOrder":4,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, numReplicas, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","date":"2019-02-27 03:45:33","endLine":551,"groupId":"236","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/1d/00d60cf29945b207f2bcea7aa9b175b1305fde.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, preferenceList, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"M"}],"commitId":"abd91cc3757d6bcb99f07b288264d68dbbf8cdb4","commitMessage":"@@@Revert back for N -> N+1 fix\n","date":"2019-02-27 03:45:33","modifiedFileCount":"1","status":"M","submitter":"Junkai Xue"},{"authorTime":"2019-03-29 03:24:44","codes":[{"authorDate":"2018-06-29 05:27:32","commitOrder":5,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap =\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","date":"2018-06-29 08:40:21","endLine":202,"groupId":"1397","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/02/277696f23fe39e3b75e8a649a4063ca4e483c9.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap =\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"N"},{"authorDate":"2019-03-29 03:24:44","commitOrder":5,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, preferenceList, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","date":"2019-03-29 03:24:44","endLine":551,"groupId":"236","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/65/b3f8451e8a211987c8b3689d26593c309e0a1e.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, numReplicas, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"M"}],"commitId":"be3dd97333fa36ddbd826e0326b33837e51abdf6","commitMessage":"@@@Fix N -> N + 1 extra bootstrap\n\nWhen rebalancing.  Helix does the following before dropping replicas that are not in the preference list:\n    1. Send a replica on a node that just came online from OFFLINE to SLAVE\n    2. Drop a replica on a node that just bootstrapped\n\nThis happened because of the rebalancer is trying to make all current states exactly match the states in the best possible mapping. Once conditions are met.  Helix started dropping replicas. This fix makes Helix guarantee that only the replicas in the preference list match the states in the best possible mapping. So the rebalancer does not have to wait and bootstrap extra replicas that are not in preference list.\n","date":"2019-03-29 03:24:44","modifiedFileCount":"3","status":"M","submitter":"Hunter Lee"},{"authorTime":"2020-05-29 06:55:33","codes":[{"authorDate":"2020-05-29 06:55:33","commitOrder":6,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n      AbnormalStateResolver resolver) {\n    Optional<Map<String, String>> optionalOverwrittenStates =\n        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n            idealState, partition, resolver);\n    if (optionalOverwrittenStates.isPresent()) {\n      return optionalOverwrittenStates.get();\n    }\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","date":"2020-06-16 07:41:09","endLine":214,"groupId":"236","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition@AbnormalStateResolverresolver)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/6f/dd0b6ddffb11175d85b453f5b06452c1803654.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap =\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition);\n\n    if (currentStateMap == null) {\n      currentStateMap = Collections.emptyMap();\n    }\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"},{"authorDate":"2020-05-29 06:55:33","commitOrder":6,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n      AbnormalStateResolver resolver) {\n    Optional<Map<String, String>> optionalOverwrittenStates =\n        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n            idealState, partition, resolver);\n    if (optionalOverwrittenStates.isPresent()) {\n      return optionalOverwrittenStates.get();\n    }\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, preferenceList, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","date":"2020-06-16 07:41:09","endLine":382,"groupId":"236","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition@AbnormalStateResolverresolver)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f1/69e07c2eff5c1fe2d813b0538b730b987c2ee3.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition) {\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n\n    \r\n    \r\n    if (preferenceList == null) {\n      return computeBestPossibleMapForDroppedResource(currentStateMap);\n    }\n\n    \r\n    if (!idealState.isEnabled()) {\n      return computeBestPossibleMapForDisabledResource(currentStateMap, stateModelDef);\n    }\n\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, preferenceList, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"}],"commitId":"dc75f228522c930cb40db1b0a16a69b3eb77d953","commitMessage":"@@@Add Abnormal States Resolver interface and configuration item. (#1028)\n\nThe Abnormal States Resolver defines a generic interface to find and recover if the partition has any abnormal current states. For example. \n- double masters\n- application data out of sync\nThe interface shall be implemented according to the requirement.\n\nThe resolver is applied in the rebalance process according to the corresponding cluster config item. For example. \n\"ABNORMAL_STATES_RESOLVER_MAP\" : {\n \"MASTERSLAVE\" : \"org.apache.helix.api.rebalancer.constraint.MasterSlaveAbnormalStateReslovler\"\n}\nThe default behavior without any configuration is not doing any recovery work.","date":"2020-06-16 07:41:09","modifiedFileCount":"9","status":"M","submitter":"Jiajun Wang"},{"authorTime":"2020-06-16 02:53:07","codes":[{"authorDate":"2020-06-16 02:53:07","commitOrder":7,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n      MonitoredAbnormalResolver monitoredResolver) {\n    Optional<Map<String, String>> optionalOverwrittenStates =\n        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n            idealState, partition, monitoredResolver);\n    if (optionalOverwrittenStates.isPresent()) {\n      return optionalOverwrittenStates.get();\n    }\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","date":"2020-06-16 07:41:09","endLine":214,"groupId":"10879","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition@MonitoredAbnormalResolvermonitoredResolver)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/f1/18bcbf595d66fca2a44bf3e3cf86831a7d68c6.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n      AbnormalStateResolver resolver) {\n    Optional<Map<String, String>> optionalOverwrittenStates =\n        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n            idealState, partition, resolver);\n    if (optionalOverwrittenStates.isPresent()) {\n      return optionalOverwrittenStates.get();\n    }\n\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n    return computeBestPossibleMap(preferenceList, stateModelDef, currentStateMap, liveInstances,\n        disabledInstancesForPartition);\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"},{"authorDate":"2020-06-16 02:53:07","commitOrder":7,"curCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n      MonitoredAbnormalResolver monitoredResolver) {\n    Optional<Map<String, String>> optionalOverwrittenStates =\n        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n            idealState, partition, monitoredResolver);\n    if (optionalOverwrittenStates.isPresent()) {\n      return optionalOverwrittenStates.get();\n    }\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, preferenceList, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","date":"2020-06-16 07:41:09","endLine":382,"groupId":"10879","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"computeBestPossibleStateForPartition","params":"(Set<String>liveInstances@StateModelDefinitionstateModelDef@List<String>preferenceList@CurrentStateOutputcurrentStateOutput@Set<String>disabledInstancesForPartition@IdealStateidealState@ClusterConfigclusterConfig@Partitionpartition@MonitoredAbnormalResolvermonitoredResolver)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/e0/fe24dba03a1a01e4c752503b259fb3baea2f58.src","preCode":"  protected Map<String, String> computeBestPossibleStateForPartition(Set<String> liveInstances,\n      StateModelDefinition stateModelDef, List<String> preferenceList,\n      CurrentStateOutput currentStateOutput, Set<String> disabledInstancesForPartition,\n      IdealState idealState, ClusterConfig clusterConfig, Partition partition,\n      AbnormalStateResolver resolver) {\n    Optional<Map<String, String>> optionalOverwrittenStates =\n        computeStatesOverwriteForPartition(stateModelDef, preferenceList, currentStateOutput,\n            idealState, partition, resolver);\n    if (optionalOverwrittenStates.isPresent()) {\n      return optionalOverwrittenStates.get();\n    }\n    Map<String, String> currentStateMap = new HashMap<>(\n        currentStateOutput.getCurrentStateMap(idealState.getResourceName(), partition));\n    \r\n    List<String> currentInstances = new ArrayList<>(currentStateMap.keySet());\n    Collections.sort(currentInstances);\n    Map<String, String> pendingStates =\n        new HashMap<>(currentStateOutput.getPendingStateMap(idealState.getResourceName(), partition));\n    for (String instance : pendingStates.keySet()) {\n      if (!currentStateMap.containsKey(instance)) {\n        currentStateMap.put(instance, stateModelDef.getInitialState());\n        currentInstances.add(instance);\n      }\n    }\n\n    Set<String> instancesToDrop = new HashSet<>();\n    Iterator<String> it = currentInstances.iterator();\n    while (it.hasNext()) {\n      String instance = it.next();\n      String state = currentStateMap.get(instance);\n      if (state == null) {\n        it.remove();\n        instancesToDrop.add(instance); \r\n      }\n    }\n\n    \r\n    \r\n    \r\n\n    if (preferenceList == null) {\n      preferenceList = Collections.emptyList();\n    }\n\n    int numExtraReplicas = getNumExtraReplicas(clusterConfig);\n\n    \r\n    \r\n    int numReplicas = preferenceList.size();\n    List<String> instanceToAdd = new ArrayList<>(preferenceList);\n    instanceToAdd.removeAll(currentInstances);\n    List<String> combinedPreferenceList = new ArrayList<>();\n\n    if (currentInstances.size() <= numReplicas\n        && numReplicas + numExtraReplicas - currentInstances.size() > 0) {\n      int subListSize = numReplicas + numExtraReplicas - currentInstances.size();\n      combinedPreferenceList.addAll(instanceToAdd\n          .subList(0, subListSize <= instanceToAdd.size() ? subListSize : instanceToAdd.size()));\n    }\n\n    \r\n    Map<String, String> currentMapWithPreferenceList = new HashMap<>(currentStateMap);\n    currentMapWithPreferenceList.keySet().retainAll(preferenceList);\n\n    combinedPreferenceList.addAll(currentInstances);\n    Collections.sort(combinedPreferenceList,\n        new PreferenceListNodeComparator(currentStateMap, stateModelDef, preferenceList));\n\n    \r\n    Map<String, String> bestPossibleStateMap =\n        computeBestPossibleMap(combinedPreferenceList, stateModelDef, currentStateMap,\n            liveInstances, disabledInstancesForPartition);\n\n    for (String instance : instancesToDrop) {\n      bestPossibleStateMap.put(instance, HelixDefinedState.DROPPED.name());\n    }\n\n    \r\n    \r\n    if (!currentMapWithPreferenceList.values().contains(HelixDefinedState.ERROR.name())\n        && bestPossibleStateMap.size() > numReplicas && readyToDrop(currentStateMap,\n        bestPossibleStateMap, preferenceList, combinedPreferenceList)) {\n      for (int i = 0; i < combinedPreferenceList.size() - numReplicas; i++) {\n        String instanceToDrop = combinedPreferenceList.get(combinedPreferenceList.size() - i - 1);\n        bestPossibleStateMap.put(instanceToDrop, HelixDefinedState.DROPPED.name());\n      }\n    }\n\n    \r\n    \r\n    \r\n    \r\n    for (String instance : combinedPreferenceList) {\n      if (currentStateMap.containsKey(instance) && currentStateMap.get(instance)\n          .equals(HelixDefinedState.ERROR.name())) {\n        bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.name());\n      }\n    }\n\n    return bestPossibleStateMap;\n  }\n","realPath":"helix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":282,"status":"M"}],"commitId":"f85cbd14702ada941709d0db00ce69a78bdf52e3","commitMessage":"@@@Add monitor to record the abnormal states processing. (#1059)\n\nExample ObjectName of the new monitor MBean: Rebalancer:ClusterName=<clusterName>.  EntityName=AbnormalStates.<StateModelDefName>\nAttributes. \n1. AbnormalStatePartitionCounter: record the total count of the partitions that have been found in abnormal status. Note that if one partition has been found to be abnormal twice.  then we will record it twice in this counter as well.\n2. RecoveryAttemptCounter: record the total count of successful recovery computation that has been done by the resolver.","date":"2020-06-16 07:41:09","modifiedFileCount":"9","status":"M","submitter":"Jiajun Wang"}]
