[{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2013-04-13 08:49:36","commitOrder":3,"curCode":"  public static void setupCluster(String uniqClusterName, String zkAddr, int numResources,\n      int numPartitionsPerResource, int numInstances, int replica, boolean doRebalance)\n      throws Exception\n  {\n    ZkClient zkClient = new ZkClient(zkAddr);\n    zkClient.setZkSerializer(new ZNRecordSerializer());\n\n    \r\n    String clusterName = uniqClusterName;\n    if (zkClient.exists(\"/\" + clusterName))\n    {\n      LOG.warn(\"test cluster already exists:\" + clusterName + \", test name:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up zk; deleting it\");\n      zkClient.deleteRecursive(\"/\" + clusterName);\n    }\n\n    if (_testInfoMap.containsKey(uniqClusterName))\n    {\n      LOG.warn(\"test info already exists:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up test info map; removing it\");\n      _testInfoMap.remove(uniqClusterName);\n    }\n    TestInfo testInfo = new TestInfo(clusterName, zkClient, numResources, numPartitionsPerResource,\n        numInstances, replica);\n    _testInfoMap.put(uniqClusterName, testInfo);\n\n    ClusterSetup setupTool = new ClusterSetup(zkAddr);\n    setupTool.addCluster(clusterName, true);\n\n    for (int i = 0; i < numInstances; i++)\n    {\n      int port = START_PORT + i;\n      setupTool.addInstanceToCluster(clusterName, PARTICIPANT_PREFIX + \"_\" + port);\n    }\n\n    for (int i = 0; i < numResources; i++)\n    {\n      String dbName = TEST_DB_PREFIX + i;\n      setupTool.addResourceToCluster(clusterName, dbName, numPartitionsPerResource,\n          STATE_MODEL);\n      if (doRebalance)\n      {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n      }\n    }\n  }\n","date":"2013-04-13 08:49:36","endLine":182,"groupId":"1378","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"setupCluster","params":"(StringuniqClusterName@StringzkAddr@intnumResources@intnumPartitionsPerResource@intnumInstances@intreplica@booleandoRebalance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/74/b3bdca4c4105535b9920ee6ac5205708f0371c.src","preCode":"  public static void setupCluster(String uniqClusterName, String zkAddr, int numResources,\n      int numPartitionsPerResource, int numInstances, int replica, boolean doRebalance)\n      throws Exception\n  {\n    ZkClient zkClient = new ZkClient(zkAddr);\n    zkClient.setZkSerializer(new ZNRecordSerializer());\n\n    \r\n    String clusterName = uniqClusterName;\n    if (zkClient.exists(\"/\" + clusterName))\n    {\n      LOG.warn(\"test cluster already exists:\" + clusterName + \", test name:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up zk; deleting it\");\n      zkClient.deleteRecursive(\"/\" + clusterName);\n    }\n\n    if (_testInfoMap.containsKey(uniqClusterName))\n    {\n      LOG.warn(\"test info already exists:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up test info map; removing it\");\n      _testInfoMap.remove(uniqClusterName);\n    }\n    TestInfo testInfo = new TestInfo(clusterName, zkClient, numResources, numPartitionsPerResource,\n        numInstances, replica);\n    _testInfoMap.put(uniqClusterName, testInfo);\n\n    ClusterSetup setupTool = new ClusterSetup(zkAddr);\n    setupTool.addCluster(clusterName, true);\n\n    for (int i = 0; i < numInstances; i++)\n    {\n      int port = START_PORT + i;\n      setupTool.addInstanceToCluster(clusterName, PARTICIPANT_PREFIX + \"_\" + port);\n    }\n\n    for (int i = 0; i < numResources; i++)\n    {\n      String dbName = TEST_DB_PREFIX + i;\n      setupTool.addResourceToCluster(clusterName, dbName, numPartitionsPerResource,\n          STATE_MODEL);\n      if (doRebalance)\n      {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n      }\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestDriver.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"NB"},{"authorDate":"2017-11-08 08:48:26","commitOrder":3,"curCode":"  private static void setupCluster(String clusterName, String ZkAddr, int startPort,\n      String participantNamePrefix, String resourceNamePrefix, int resourceNb, int partitionNb,\n      int nodesNb, int replica, String stateModelDef, boolean doRebalance) throws Exception {\n    if (_gZkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"Cluster already exists:\" + clusterName + \". Deleting it\");\n      _gZkClient.deleteRecursive(\"/\" + clusterName);\n    }\n\n    ClusterSetup setupTool = new ClusterSetup(ZkAddr);\n    setupTool.addCluster(clusterName, true);\n    setupTool.addStateModelDef(clusterName, \"Bootstrap\",\n        TestHelper.generateStateModelDefForBootstrap());\n\n    for (int i = 0; i < nodesNb; i++) {\n      int port = startPort + i;\n      setupTool.addInstanceToCluster(clusterName, participantNamePrefix + \"_\" + port);\n    }\n\n    for (int i = 0; i < resourceNb; i++) {\n      String dbName = resourceNamePrefix + i;\n      setupTool.addResourceToCluster(clusterName, dbName, partitionNb, stateModelDef);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n      }\n    }\n  }\n","date":"2017-11-08 08:48:26","endLine":112,"groupId":"6068","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setupCluster","params":"(StringclusterName@StringZkAddr@intstartPort@StringparticipantNamePrefix@StringresourceNamePrefix@intresourceNb@intpartitionNb@intnodesNb@intreplica@StringstateModelDef@booleandoRebalance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/19/f2bf4cc589ce64fc2cebe3628cd2b4b3e5317d.src","preCode":"  private static void setupCluster(String clusterName, String ZkAddr, int startPort,\n      String participantNamePrefix, String resourceNamePrefix, int resourceNb, int partitionNb,\n      int nodesNb, int replica, String stateModelDef, boolean doRebalance) throws Exception {\n    if (_gZkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"Cluster already exists:\" + clusterName + \". Deleting it\");\n      _gZkClient.deleteRecursive(\"/\" + clusterName);\n    }\n\n    ClusterSetup setupTool = new ClusterSetup(ZkAddr);\n    setupTool.addCluster(clusterName, true);\n    setupTool.addStateModelDef(clusterName, \"Bootstrap\",\n        TestHelper.generateStateModelDefForBootstrap());\n\n    for (int i = 0; i < nodesNb; i++) {\n      int port = startPort + i;\n      setupTool.addInstanceToCluster(clusterName, participantNamePrefix + \"_\" + port);\n    }\n\n    for (int i = 0; i < resourceNb; i++) {\n      String dbName = resourceNamePrefix + i;\n      setupTool.addResourceToCluster(clusterName, dbName, partitionNb, stateModelDef);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n      }\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/paticipant/TestNonOfflineInitState.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"B"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"M","submitter":"Junkai Xue"},{"authorTime":"2018-03-09 06:04:42","codes":[{"authorDate":"2018-03-09 06:04:42","commitOrder":4,"curCode":"  public static void setupCluster(String uniqClusterName, String zkAddr, int numResources,\n      int numPartitionsPerResource, int numInstances, int replica, boolean doRebalance)\n      throws Exception {\n    ZkClient zkClient = new ZkClient(zkAddr);\n    zkClient.setZkSerializer(new ZNRecordSerializer());\n\n    \r\n    String clusterName = uniqClusterName;\n    if (zkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"test cluster already exists:\" + clusterName + \", test name:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up zk; deleting it\");\n      zkClient.deleteRecursively(\"/\" + clusterName);\n    }\n\n    if (_testInfoMap.containsKey(uniqClusterName)) {\n      LOG.warn(\"test info already exists:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up test info map; removing it\");\n      _testInfoMap.remove(uniqClusterName);\n    }\n    TestInfo testInfo =\n        new TestInfo(clusterName, zkClient, numResources, numPartitionsPerResource, numInstances,\n            replica);\n    _testInfoMap.put(uniqClusterName, testInfo);\n\n    ClusterSetup setupTool = new ClusterSetup(zkAddr);\n    setupTool.addCluster(clusterName, true);\n\n    for (int i = 0; i < numInstances; i++) {\n      int port = START_PORT + i;\n      setupTool.addInstanceToCluster(clusterName, PARTICIPANT_PREFIX + \"_\" + port);\n    }\n\n    for (int i = 0; i < numResources; i++) {\n      String dbName = TEST_DB_PREFIX + i;\n      setupTool.addResourceToCluster(clusterName, dbName, numPartitionsPerResource, STATE_MODEL);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n      }\n    }\n  }\n","date":"2018-03-20 07:43:31","endLine":163,"groupId":"1378","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"setupCluster","params":"(StringuniqClusterName@StringzkAddr@intnumResources@intnumPartitionsPerResource@intnumInstances@intreplica@booleandoRebalance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/73/af2bb6f5371676e5715d968d5aa3815a964d96.src","preCode":"  public static void setupCluster(String uniqClusterName, String zkAddr, int numResources,\n      int numPartitionsPerResource, int numInstances, int replica, boolean doRebalance)\n      throws Exception {\n    ZkClient zkClient = new ZkClient(zkAddr);\n    zkClient.setZkSerializer(new ZNRecordSerializer());\n\n    \r\n    String clusterName = uniqClusterName;\n    if (zkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"test cluster already exists:\" + clusterName + \", test name:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up zk; deleting it\");\n      zkClient.deleteRecursive(\"/\" + clusterName);\n    }\n\n    if (_testInfoMap.containsKey(uniqClusterName)) {\n      LOG.warn(\"test info already exists:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up test info map; removing it\");\n      _testInfoMap.remove(uniqClusterName);\n    }\n    TestInfo testInfo =\n        new TestInfo(clusterName, zkClient, numResources, numPartitionsPerResource, numInstances,\n            replica);\n    _testInfoMap.put(uniqClusterName, testInfo);\n\n    ClusterSetup setupTool = new ClusterSetup(zkAddr);\n    setupTool.addCluster(clusterName, true);\n\n    for (int i = 0; i < numInstances; i++) {\n      int port = START_PORT + i;\n      setupTool.addInstanceToCluster(clusterName, PARTICIPANT_PREFIX + \"_\" + port);\n    }\n\n    for (int i = 0; i < numResources; i++) {\n      String dbName = TEST_DB_PREFIX + i;\n      setupTool.addResourceToCluster(clusterName, dbName, numPartitionsPerResource, STATE_MODEL);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n      }\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestDriver.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"},{"authorDate":"2018-03-09 06:04:42","commitOrder":4,"curCode":"  private static void setupCluster(String clusterName, String ZkAddr, int startPort,\n      String participantNamePrefix, String resourceNamePrefix, int resourceNb, int partitionNb,\n      int nodesNb, int replica, String stateModelDef, boolean doRebalance) throws Exception {\n    if (_gZkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"Cluster already exists:\" + clusterName + \". Deleting it\");\n      _gZkClient.deleteRecursively(\"/\" + clusterName);\n    }\n\n    ClusterSetup setupTool = new ClusterSetup(ZkAddr);\n    setupTool.addCluster(clusterName, true);\n    setupTool.addStateModelDef(clusterName, \"Bootstrap\",\n        TestHelper.generateStateModelDefForBootstrap());\n\n    for (int i = 0; i < nodesNb; i++) {\n      int port = startPort + i;\n      setupTool.addInstanceToCluster(clusterName, participantNamePrefix + \"_\" + port);\n    }\n\n    for (int i = 0; i < resourceNb; i++) {\n      String dbName = resourceNamePrefix + i;\n      setupTool.addResourceToCluster(clusterName, dbName, partitionNb, stateModelDef);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n      }\n    }\n  }\n","date":"2018-03-20 07:43:31","endLine":113,"groupId":"6068","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setupCluster","params":"(StringclusterName@StringZkAddr@intstartPort@StringparticipantNamePrefix@StringresourceNamePrefix@intresourceNb@intpartitionNb@intnodesNb@intreplica@StringstateModelDef@booleandoRebalance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/bd/9e1684b516444add7cc6109b263b37864ebe9a.src","preCode":"  private static void setupCluster(String clusterName, String ZkAddr, int startPort,\n      String participantNamePrefix, String resourceNamePrefix, int resourceNb, int partitionNb,\n      int nodesNb, int replica, String stateModelDef, boolean doRebalance) throws Exception {\n    if (_gZkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"Cluster already exists:\" + clusterName + \". Deleting it\");\n      _gZkClient.deleteRecursive(\"/\" + clusterName);\n    }\n\n    ClusterSetup setupTool = new ClusterSetup(ZkAddr);\n    setupTool.addCluster(clusterName, true);\n    setupTool.addStateModelDef(clusterName, \"Bootstrap\",\n        TestHelper.generateStateModelDefForBootstrap());\n\n    for (int i = 0; i < nodesNb; i++) {\n      int port = startPort + i;\n      setupTool.addInstanceToCluster(clusterName, participantNamePrefix + \"_\" + port);\n    }\n\n    for (int i = 0; i < resourceNb; i++) {\n      String dbName = resourceNamePrefix + i;\n      setupTool.addResourceToCluster(clusterName, dbName, partitionNb, stateModelDef);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n      }\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/paticipant/TestNonOfflineInitState.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"M"}],"commitId":"0e849035379a04b079ac1274bb8aaab473df1572","commitMessage":"@@@[HELIX-679] consolidate semantics of recursively delete path in ZkClient\n","date":"2018-03-20 07:43:31","modifiedFileCount":"57","status":"M","submitter":"hrzhang"},{"authorTime":"2018-06-08 08:15:54","codes":[{"authorDate":"2018-03-09 06:04:42","commitOrder":5,"curCode":"  public static void setupCluster(String uniqClusterName, String zkAddr, int numResources,\n      int numPartitionsPerResource, int numInstances, int replica, boolean doRebalance)\n      throws Exception {\n    ZkClient zkClient = new ZkClient(zkAddr);\n    zkClient.setZkSerializer(new ZNRecordSerializer());\n\n    \r\n    String clusterName = uniqClusterName;\n    if (zkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"test cluster already exists:\" + clusterName + \", test name:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up zk; deleting it\");\n      zkClient.deleteRecursively(\"/\" + clusterName);\n    }\n\n    if (_testInfoMap.containsKey(uniqClusterName)) {\n      LOG.warn(\"test info already exists:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up test info map; removing it\");\n      _testInfoMap.remove(uniqClusterName);\n    }\n    TestInfo testInfo =\n        new TestInfo(clusterName, zkClient, numResources, numPartitionsPerResource, numInstances,\n            replica);\n    _testInfoMap.put(uniqClusterName, testInfo);\n\n    ClusterSetup setupTool = new ClusterSetup(zkAddr);\n    setupTool.addCluster(clusterName, true);\n\n    for (int i = 0; i < numInstances; i++) {\n      int port = START_PORT + i;\n      setupTool.addInstanceToCluster(clusterName, PARTICIPANT_PREFIX + \"_\" + port);\n    }\n\n    for (int i = 0; i < numResources; i++) {\n      String dbName = TEST_DB_PREFIX + i;\n      setupTool.addResourceToCluster(clusterName, dbName, numPartitionsPerResource, STATE_MODEL);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n      }\n    }\n  }\n","date":"2018-03-20 07:43:31","endLine":163,"groupId":"1378","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"setupCluster","params":"(StringuniqClusterName@StringzkAddr@intnumResources@intnumPartitionsPerResource@intnumInstances@intreplica@booleandoRebalance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/73/af2bb6f5371676e5715d968d5aa3815a964d96.src","preCode":"  public static void setupCluster(String uniqClusterName, String zkAddr, int numResources,\n      int numPartitionsPerResource, int numInstances, int replica, boolean doRebalance)\n      throws Exception {\n    ZkClient zkClient = new ZkClient(zkAddr);\n    zkClient.setZkSerializer(new ZNRecordSerializer());\n\n    \r\n    String clusterName = uniqClusterName;\n    if (zkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"test cluster already exists:\" + clusterName + \", test name:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up zk; deleting it\");\n      zkClient.deleteRecursively(\"/\" + clusterName);\n    }\n\n    if (_testInfoMap.containsKey(uniqClusterName)) {\n      LOG.warn(\"test info already exists:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up test info map; removing it\");\n      _testInfoMap.remove(uniqClusterName);\n    }\n    TestInfo testInfo =\n        new TestInfo(clusterName, zkClient, numResources, numPartitionsPerResource, numInstances,\n            replica);\n    _testInfoMap.put(uniqClusterName, testInfo);\n\n    ClusterSetup setupTool = new ClusterSetup(zkAddr);\n    setupTool.addCluster(clusterName, true);\n\n    for (int i = 0; i < numInstances; i++) {\n      int port = START_PORT + i;\n      setupTool.addInstanceToCluster(clusterName, PARTICIPANT_PREFIX + \"_\" + port);\n    }\n\n    for (int i = 0; i < numResources; i++) {\n      String dbName = TEST_DB_PREFIX + i;\n      setupTool.addResourceToCluster(clusterName, dbName, numPartitionsPerResource, STATE_MODEL);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n      }\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestDriver.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"N"},{"authorDate":"2018-06-08 08:15:54","commitOrder":5,"curCode":"  private static void setupCluster(String clusterName, String ZkAddr, int startPort,\n      String participantNamePrefix, String resourceNamePrefix, int resourceNb, int partitionNb,\n      int nodesNb, int replica, String stateModelDef, boolean doRebalance) throws Exception {\n\n    _gSetupTool.addCluster(clusterName, true);\n    _gSetupTool.addStateModelDef(clusterName, \"Bootstrap\",\n        TestHelper.generateStateModelDefForBootstrap());\n\n    for (int i = 0; i < nodesNb; i++) {\n      int port = startPort + i;\n      _gSetupTool.addInstanceToCluster(clusterName, participantNamePrefix + \"_\" + port);\n    }\n\n    for (int i = 0; i < resourceNb; i++) {\n      String dbName = resourceNamePrefix + i;\n      _gSetupTool.addResourceToCluster(clusterName, dbName, partitionNb, stateModelDef);\n      if (doRebalance) {\n        _gSetupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n      }\n    }\n  }\n","date":"2018-07-14 02:20:49","endLine":108,"groupId":"6068","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setupCluster","params":"(StringclusterName@StringZkAddr@intstartPort@StringparticipantNamePrefix@StringresourceNamePrefix@intresourceNb@intpartitionNb@intnodesNb@intreplica@StringstateModelDef@booleandoRebalance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/a9/37c41fcd0c2fa6986570e30743636508570525.src","preCode":"  private static void setupCluster(String clusterName, String ZkAddr, int startPort,\n      String participantNamePrefix, String resourceNamePrefix, int resourceNb, int partitionNb,\n      int nodesNb, int replica, String stateModelDef, boolean doRebalance) throws Exception {\n    if (_gZkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"Cluster already exists:\" + clusterName + \". Deleting it\");\n      _gZkClient.deleteRecursively(\"/\" + clusterName);\n    }\n\n    ClusterSetup setupTool = new ClusterSetup(ZkAddr);\n    setupTool.addCluster(clusterName, true);\n    setupTool.addStateModelDef(clusterName, \"Bootstrap\",\n        TestHelper.generateStateModelDefForBootstrap());\n\n    for (int i = 0; i < nodesNb; i++) {\n      int port = startPort + i;\n      setupTool.addInstanceToCluster(clusterName, participantNamePrefix + \"_\" + port);\n    }\n\n    for (int i = 0; i < resourceNb; i++) {\n      String dbName = resourceNamePrefix + i;\n      setupTool.addResourceToCluster(clusterName, dbName, partitionNb, stateModelDef);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n      }\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/paticipant/TestNonOfflineInitState.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"M"}],"commitId":"c0d5792b745c67b6fee56ba79df02be89d1f049e","commitMessage":"@@@Properly remove clusters after each test.  and clean up duplicated codes in tests and move them into base test classes.\n","date":"2018-07-14 02:20:49","modifiedFileCount":"139","status":"M","submitter":"Lei Xia"},{"authorTime":"2018-06-08 08:15:54","codes":[{"authorDate":"2018-09-27 02:39:42","commitOrder":6,"curCode":"  public static void setupCluster(String uniqClusterName, String zkAddr, int numResources,\n      int numPartitionsPerResource, int numInstances, int replica, boolean doRebalance)\n      throws Exception {\n    HelixZkClient zkClient = SharedZkClientFactory.getInstance()\n        .buildZkClient(new HelixZkClient.ZkConnectionConfig(ZK_ADDR));\n\n    try {\n      zkClient.setZkSerializer(new ZNRecordSerializer());\n\n      \r\n      String clusterName = uniqClusterName;\n      if (zkClient.exists(\"/\" + clusterName)) {\n        LOG.warn(\"test cluster already exists:\" + clusterName + \", test name:\" + uniqClusterName + \" is not unique or test has been run without cleaning up zk; deleting it\");\n        zkClient.deleteRecursively(\"/\" + clusterName);\n      }\n\n      if (_testInfoMap.containsKey(uniqClusterName)) {\n        LOG.warn(\"test info already exists:\" + uniqClusterName + \" is not unique or test has been run without cleaning up test info map; removing it\");\n        _testInfoMap.remove(uniqClusterName);\n      }\n      TestInfo testInfo =\n          new TestInfo(clusterName, zkClient, numResources, numPartitionsPerResource, numInstances,\n              replica);\n      _testInfoMap.put(uniqClusterName, testInfo);\n\n      ClusterSetup setupTool = new ClusterSetup(zkAddr);\n      setupTool.addCluster(clusterName, true);\n\n      for (int i = 0; i < numInstances; i++) {\n        int port = START_PORT + i;\n        setupTool.addInstanceToCluster(clusterName, PARTICIPANT_PREFIX + \"_\" + port);\n      }\n\n      for (int i = 0; i < numResources; i++) {\n        String dbName = TEST_DB_PREFIX + i;\n        setupTool.addResourceToCluster(clusterName, dbName, numPartitionsPerResource, STATE_MODEL);\n        if (doRebalance) {\n          setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n\n          \r\n          \r\n          \r\n          \r\n          \r\n        }\n      }\n    } finally {\n      zkClient.close();\n    }\n  }\n","date":"2018-10-30 09:15:22","endLine":167,"groupId":"10202","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"setupCluster","params":"(StringuniqClusterName@StringzkAddr@intnumResources@intnumPartitionsPerResource@intnumInstances@intreplica@booleandoRebalance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/cc/8eef564441c0b5da8429b488a06196b3009b49.src","preCode":"  public static void setupCluster(String uniqClusterName, String zkAddr, int numResources,\n      int numPartitionsPerResource, int numInstances, int replica, boolean doRebalance)\n      throws Exception {\n    ZkClient zkClient = new ZkClient(zkAddr);\n    zkClient.setZkSerializer(new ZNRecordSerializer());\n\n    \r\n    String clusterName = uniqClusterName;\n    if (zkClient.exists(\"/\" + clusterName)) {\n      LOG.warn(\"test cluster already exists:\" + clusterName + \", test name:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up zk; deleting it\");\n      zkClient.deleteRecursively(\"/\" + clusterName);\n    }\n\n    if (_testInfoMap.containsKey(uniqClusterName)) {\n      LOG.warn(\"test info already exists:\" + uniqClusterName\n          + \" is not unique or test has been run without cleaning up test info map; removing it\");\n      _testInfoMap.remove(uniqClusterName);\n    }\n    TestInfo testInfo =\n        new TestInfo(clusterName, zkClient, numResources, numPartitionsPerResource, numInstances,\n            replica);\n    _testInfoMap.put(uniqClusterName, testInfo);\n\n    ClusterSetup setupTool = new ClusterSetup(zkAddr);\n    setupTool.addCluster(clusterName, true);\n\n    for (int i = 0; i < numInstances; i++) {\n      int port = START_PORT + i;\n      setupTool.addInstanceToCluster(clusterName, PARTICIPANT_PREFIX + \"_\" + port);\n    }\n\n    for (int i = 0; i < numResources; i++) {\n      String dbName = TEST_DB_PREFIX + i;\n      setupTool.addResourceToCluster(clusterName, dbName, numPartitionsPerResource, STATE_MODEL);\n      if (doRebalance) {\n        setupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n\n        \r\n        \r\n        \r\n        \r\n        \r\n      }\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/TestDriver.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"},{"authorDate":"2018-06-08 08:15:54","commitOrder":6,"curCode":"  private static void setupCluster(String clusterName, String ZkAddr, int startPort,\n      String participantNamePrefix, String resourceNamePrefix, int resourceNb, int partitionNb,\n      int nodesNb, int replica, String stateModelDef, boolean doRebalance) throws Exception {\n\n    _gSetupTool.addCluster(clusterName, true);\n    _gSetupTool.addStateModelDef(clusterName, \"Bootstrap\",\n        TestHelper.generateStateModelDefForBootstrap());\n\n    for (int i = 0; i < nodesNb; i++) {\n      int port = startPort + i;\n      _gSetupTool.addInstanceToCluster(clusterName, participantNamePrefix + \"_\" + port);\n    }\n\n    for (int i = 0; i < resourceNb; i++) {\n      String dbName = resourceNamePrefix + i;\n      _gSetupTool.addResourceToCluster(clusterName, dbName, partitionNb, stateModelDef);\n      if (doRebalance) {\n        _gSetupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n      }\n    }\n  }\n","date":"2018-07-14 02:20:49","endLine":108,"groupId":"10202","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"setupCluster","params":"(StringclusterName@StringZkAddr@intstartPort@StringparticipantNamePrefix@StringresourceNamePrefix@intresourceNb@intpartitionNb@intnodesNb@intreplica@StringstateModelDef@booleandoRebalance)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/a9/37c41fcd0c2fa6986570e30743636508570525.src","preCode":"  private static void setupCluster(String clusterName, String ZkAddr, int startPort,\n      String participantNamePrefix, String resourceNamePrefix, int resourceNb, int partitionNb,\n      int nodesNb, int replica, String stateModelDef, boolean doRebalance) throws Exception {\n\n    _gSetupTool.addCluster(clusterName, true);\n    _gSetupTool.addStateModelDef(clusterName, \"Bootstrap\",\n        TestHelper.generateStateModelDefForBootstrap());\n\n    for (int i = 0; i < nodesNb; i++) {\n      int port = startPort + i;\n      _gSetupTool.addInstanceToCluster(clusterName, participantNamePrefix + \"_\" + port);\n    }\n\n    for (int i = 0; i < resourceNb; i++) {\n      String dbName = resourceNamePrefix + i;\n      _gSetupTool.addResourceToCluster(clusterName, dbName, partitionNb, stateModelDef);\n      if (doRebalance) {\n        _gSetupTool.rebalanceStorageCluster(clusterName, dbName, replica);\n      }\n    }\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/paticipant/TestNonOfflineInitState.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":88,"status":"N"}],"commitId":"9d7364d7abba3932a1b25e96e4eb9dd3e203cec9","commitMessage":"@@@Using HelixZkClient to replace ZkClient in helix-core and helix-rest.\n\n1. Replace as much usage as possible. For the raw ZkClient tests.  the usages are kept.\n2. For backward compatibility.  some public interfaces still returns ZkClient. Marks them as Deprecated.\n","date":"2018-10-30 09:15:22","modifiedFileCount":"60","status":"M","submitter":"Jiajun Wang"}]
