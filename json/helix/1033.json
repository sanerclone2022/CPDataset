[{"authorTime":"2014-02-17 03:32:46","codes":[{"authorDate":"2014-02-17 03:32:46","commitOrder":1,"curCode":"  void testMultiGetOnFallbackPath() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<ZNRecord>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<String>();\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n          \"Should exist under fallback location\");\n      paths.add(path);\n    }\n\n    \r\n    boolean exists[] = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertTrue(exists[i]);\n    }\n\n    \r\n    Stat stats[] = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertNotNull(stats[i]);\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 10);\n    for (int i = 0; i < 10; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      Assert.assertNotNull(record);\n      Assert.assertEquals(record.getId(), Integer.toString(i));\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2014-02-17 03:32:46","endLine":448,"groupId":"2023","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiGetOnFallbackPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/d4/cb65842b392c5021be14c6d82cdb4f9cb31a90.src","preCode":"  void testMultiGetOnFallbackPath() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<ZNRecord>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<String>();\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n          \"Should exist under fallback location\");\n      paths.add(path);\n    }\n\n    \r\n    boolean exists[] = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertTrue(exists[i]);\n    }\n\n    \r\n    Stat stats[] = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertNotNull(stats[i]);\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 10);\n    for (int i = 0; i < 10; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      Assert.assertNotNull(record);\n      Assert.assertEquals(record.getId(), Integer.toString(i));\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/store/zk/TestAutoFallbackPropertyStore.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":393,"status":"B"},{"authorDate":"2014-02-17 03:32:46","commitOrder":1,"curCode":"  public void testFailOnMultiGet() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<ZNRecord>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<String>();\n    for (int i = 0; i < 20; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      if (i < 10) {\n        Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should exist under fallback location\");\n      } else {\n        Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should not exist under fallback location\");\n      }\n      paths.add(path);\n    }\n\n    \r\n    boolean exists[] = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertTrue(exists[i]);\n      } else {\n        Assert.assertFalse(exists[i]);\n      }\n    }\n\n    \r\n    Stat stats[] = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertNotNull(stats[i]);\n      } else {\n        Assert.assertNull(stats[i]);\n      }\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 20);\n    for (int i = 0; i < 20; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      if (i < 10) {\n        Assert.assertNotNull(record);\n        Assert.assertEquals(record.getId(), Integer.toString(i));\n      } else {\n        Assert.assertNull(record);\n      }\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2014-02-17 03:32:46","endLine":558,"groupId":"2023","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFailOnMultiGet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/d4/cb65842b392c5021be14c6d82cdb4f9cb31a90.src","preCode":"  public void testFailOnMultiGet() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<ZNRecord>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<String>();\n    for (int i = 0; i < 20; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      if (i < 10) {\n        Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should exist under fallback location\");\n      } else {\n        Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should not exist under fallback location\");\n      }\n      paths.add(path);\n    }\n\n    \r\n    boolean exists[] = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertTrue(exists[i]);\n      } else {\n        Assert.assertFalse(exists[i]);\n      }\n    }\n\n    \r\n    Stat stats[] = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertNotNull(stats[i]);\n      } else {\n        Assert.assertNull(stats[i]);\n      }\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 20);\n    for (int i = 0; i < 20; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      if (i < 10) {\n        Assert.assertNotNull(record);\n        Assert.assertEquals(record.getId(), Integer.toString(i));\n      } else {\n        Assert.assertNull(record);\n      }\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/store/zk/TestAutoFallbackPropertyStore.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":486,"status":"B"}],"commitId":"fc1512305c218cc7b95055676a2ecfef5ad9b79b","commitMessage":"@@@Merge branch 'helix-0.6.2-release' of https://git-wip-us.apache.org/repos/asf/helix into helix-0.6.2-release\n","date":"2014-02-17 03:32:46","modifiedFileCount":"9","status":"B","submitter":"Kanak Biscuitwala"},{"authorTime":"2019-05-04 08:52:17","codes":[{"authorDate":"2019-05-04 08:52:17","commitOrder":2,"curCode":"  void testMultiGetOnFallbackPath() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n          \"Should exist under fallback location\");\n      paths.add(path);\n    }\n\n    \r\n    boolean[] exists = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertTrue(exists[i]);\n    }\n\n    \r\n    Stat[] stats = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertNotNull(stats[i]);\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 10);\n    for (int i = 0; i < 10; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      Assert.assertNotNull(record);\n      Assert.assertEquals(record.getId(), Integer.toString(i));\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2019-05-25 09:19:21","endLine":463,"groupId":"4785","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiGetOnFallbackPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/19/aa70c6698a1532348bc647bddedd7e874e6f1a.src","preCode":"  void testMultiGetOnFallbackPath() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<ZNRecord>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<String>();\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n          \"Should exist under fallback location\");\n      paths.add(path);\n    }\n\n    \r\n    boolean exists[] = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertTrue(exists[i]);\n    }\n\n    \r\n    Stat stats[] = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertNotNull(stats[i]);\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 10);\n    for (int i = 0; i < 10; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      Assert.assertNotNull(record);\n      Assert.assertEquals(record.getId(), Integer.toString(i));\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/store/zk/TestAutoFallbackPropertyStore.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":407,"status":"M"},{"authorDate":"2019-05-04 08:52:17","commitOrder":2,"curCode":"  public void testFailOnMultiGet() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      if (i < 10) {\n        Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should exist under fallback location\");\n      } else {\n        Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should not exist under fallback location\");\n      }\n      paths.add(path);\n    }\n\n    \r\n    boolean[] exists = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertTrue(exists[i]);\n      } else {\n        Assert.assertFalse(exists[i]);\n      }\n    }\n\n    \r\n    Stat[] stats = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertNotNull(stats[i]);\n      } else {\n        Assert.assertNull(stats[i]);\n      }\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 20);\n    for (int i = 0; i < 20; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      if (i < 10) {\n        Assert.assertNotNull(record);\n        Assert.assertEquals(record.getId(), Integer.toString(i));\n      } else {\n        Assert.assertNull(record);\n      }\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2019-05-25 09:19:21","endLine":575,"groupId":"4785","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testFailOnMultiGet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/19/aa70c6698a1532348bc647bddedd7e874e6f1a.src","preCode":"  public void testFailOnMultiGet() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<ZNRecord>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<String>();\n    for (int i = 0; i < 20; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      if (i < 10) {\n        Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should exist under fallback location\");\n      } else {\n        Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should not exist under fallback location\");\n      }\n      paths.add(path);\n    }\n\n    \r\n    boolean exists[] = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertTrue(exists[i]);\n      } else {\n        Assert.assertFalse(exists[i]);\n      }\n    }\n\n    \r\n    Stat stats[] = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertNotNull(stats[i]);\n      } else {\n        Assert.assertNull(stats[i]);\n      }\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 20);\n    for (int i = 0; i < 20; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      if (i < 10) {\n        Assert.assertNotNull(record);\n        Assert.assertEquals(record.getId(), Integer.toString(i));\n      } else {\n        Assert.assertNull(record);\n      }\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/store/zk/TestAutoFallbackPropertyStore.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":502,"status":"M"}],"commitId":"5ce3934c5b4655e90021061720adbb3a42b1bb6b","commitMessage":"@@@TEST: Groom and refactor Helix integration tests\n\nIt was observed that there was a lot of technical debt (improper and buggy cleanup) in Helix's unit and integration tests. There were also mock controller and participant threads that were never shut down properly. This was preventing mvn test suite from completing over a remote machine (TMC).  and even on local environments.  mvn test was not passing. This diff refactors tests and makes sure that ZK is cleaned up after tests.\n\nChangelist:\n1. Inspect and correct mock threads (controller.  participant.  spectator.  etc)\n2. Ensure there are no leftover garbage clusters from tests\n3. Java 8 syntax\n4. Style fixes in old tests using Helix open source style file (helix-style.xml)\n\nRB=1654905\nG=helix-reviewers\nA=jxue. eblumena\n\nSigned-off-by: Hunter Lee <hulee@linkedin.com>\n","date":"2019-05-25 09:19:21","modifiedFileCount":"122","status":"M","submitter":"Hunter Lee"},{"authorTime":"2020-05-15 08:34:22","codes":[{"authorDate":"2020-05-15 08:34:22","commitOrder":3,"curCode":"  void testMultiGetOnFallbackPath() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n          \"Should exist under fallback location\");\n      paths.add(path);\n    }\n\n    \r\n    boolean[] exists = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertTrue(exists[i]);\n    }\n\n    \r\n    Stat[] stats = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertNotNull(stats[i]);\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0, true);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 10);\n    for (int i = 0; i < 10; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      Assert.assertNotNull(record);\n      Assert.assertEquals(record.getId(), Integer.toString(i));\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2020-05-15 08:34:22","endLine":464,"groupId":"1033","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMultiGetOnFallbackPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/09/7086af1f857508455bf0f64132282d07459fc8.src","preCode":"  void testMultiGetOnFallbackPath() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<>();\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n          \"Should exist under fallback location\");\n      paths.add(path);\n    }\n\n    \r\n    boolean[] exists = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertTrue(exists[i]);\n    }\n\n    \r\n    Stat[] stats = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      Assert.assertNotNull(stats[i]);\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 10);\n    for (int i = 0; i < 10; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      Assert.assertNotNull(record);\n      Assert.assertEquals(record.getId(), Integer.toString(i));\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/store/zk/TestAutoFallbackPropertyStore.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"M"},{"authorDate":"2020-05-15 08:34:22","commitOrder":3,"curCode":"  public void testFailOnMultiGet() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      if (i < 10) {\n        Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should exist under fallback location\");\n      } else {\n        Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should not exist under fallback location\");\n      }\n      paths.add(path);\n    }\n\n    \r\n    boolean[] exists = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertTrue(exists[i]);\n      } else {\n        Assert.assertFalse(exists[i]);\n      }\n    }\n\n    \r\n    Stat[] stats = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertNotNull(stats[i]);\n      } else {\n        Assert.assertNull(stats[i]);\n      }\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0, true);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 20);\n    for (int i = 0; i < 20; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      if (i < 10) {\n        Assert.assertNotNull(record);\n        Assert.assertEquals(record.getId(), Integer.toString(i));\n      } else {\n        Assert.assertNull(record);\n      }\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","date":"2020-05-15 08:34:22","endLine":576,"groupId":"1033","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testFailOnMultiGet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/09/7086af1f857508455bf0f64132282d07459fc8.src","preCode":"  public void testFailOnMultiGet() {\n    String className = TestHelper.getTestClassName();\n    String methodName = TestHelper.getTestMethodName();\n    String clusterName = className + \"_\" + methodName;\n\n    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n    String root = String.format(\"/%s/%s\", clusterName, PropertyType.PROPERTYSTORE.name());\n    String fallbackRoot = String.format(\"/%s/%s\", clusterName, \"HELIX_PROPERTYSTORE\");\n    ZkBaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_gZkClient);\n\n    \r\n    for (int i = 0; i < 10; i++) {\n      String path = String.format(\"%s/%d\", fallbackRoot, i);\n      baseAccessor.create(path, new ZNRecord(Integer.toString(i)), AccessOption.PERSISTENT);\n    }\n\n    AutoFallbackPropertyStore<ZNRecord> store =\n        new AutoFallbackPropertyStore<>(baseAccessor, root, fallbackRoot);\n\n    List<String> paths = new ArrayList<>();\n    for (int i = 0; i < 20; i++) {\n      String path = String.format(\"/%d\", i);\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location\");\n      if (i < 10) {\n        Assert.assertTrue(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should exist under fallback location\");\n      } else {\n        Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", fallbackRoot, path), 0),\n            \"Should not exist under fallback location\");\n      }\n      paths.add(path);\n    }\n\n    \r\n    boolean[] exists = store.exists(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertTrue(exists[i]);\n      } else {\n        Assert.assertFalse(exists[i]);\n      }\n    }\n\n    \r\n    Stat[] stats = store.getStats(paths, 0);\n    for (int i = 0; i < paths.size(); i++) {\n      if (i < 10) {\n        Assert.assertNotNull(stats[i]);\n      } else {\n        Assert.assertNull(stats[i]);\n      }\n    }\n\n    \r\n    List<ZNRecord> records = store.get(paths, null, 0);\n    Assert.assertNotNull(records);\n    Assert.assertEquals(records.size(), 20);\n    for (int i = 0; i < 20; i++) {\n      ZNRecord record = records.get(i);\n      String path = paths.get(i);\n      if (i < 10) {\n        Assert.assertNotNull(record);\n        Assert.assertEquals(record.getId(), Integer.toString(i));\n      } else {\n        Assert.assertNull(record);\n      }\n      Assert.assertFalse(baseAccessor.exists(String.format(\"%s%s\", root, path), 0),\n          \"Should not exist under new location after get\");\n    }\n\n    deleteCluster(clusterName);\n    System.out.println(\"END \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/store/zk/TestAutoFallbackPropertyStore.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":503,"status":"M"}],"commitId":"6ff99f5a181fb5fe91340968f93ca2cd5329a90a","commitMessage":"@@@Enforce result check for data accessors batch get calls to prevent partial batch read. (#974)\n\nThis will help to ensure the main Helix logic does not calculate based on incomplete input.","date":"2020-05-15 08:34:22","modifiedFileCount":"49","status":"M","submitter":"Jiajun Wang"}]
