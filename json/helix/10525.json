[{"authorTime":"2016-01-20 10:15:07","codes":[{"authorDate":"2016-02-11 08:33:08","commitOrder":2,"curCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    cfgMap.put(WorkflowConfig.RECURRENCE_INTERVAL, String.valueOf(60));\n    cfgMap.put(WorkflowConfig.RECURRENCE_UNIT, \"SECONDS\");\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    \r\n    \r\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","date":"2016-04-14 01:43:23","endLine":244,"groupId":"5691","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"buildRecurrentJobQueue","params":"(StringjobQueueName@intdelayStart)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/c5/dd09912cb1e8be56d5860bd06130749e77f7a8.src","preCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    cfgMap.put(WorkflowConfig.RECURRENCE_INTERVAL, String.valueOf(60));\n    cfgMap.put(WorkflowConfig.RECURRENCE_UNIT, \"SECONDS\");\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    \r\n    \r\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"NB"},{"authorDate":"2016-01-20 10:15:07","commitOrder":2,"curCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","date":"2016-07-06 05:33:42","endLine":260,"groupId":"5691","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"buildJobQueue","params":"(StringjobQueueName@intdelayStart)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/11/677b84ebb9f8a0e69e150c4267adaabe3307c0.src","preCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":250,"status":"B"}],"commitId":"760f8e3caca39aeb53a171303ec24334cd59bf47","commitMessage":"@@@Fix task framework unit tests.\n","date":"2016-07-06 05:33:42","modifiedFileCount":"3","status":"M","submitter":"Lei Xia"},{"authorTime":"2016-01-20 10:15:07","codes":[{"authorDate":"2016-01-27 01:57:43","commitOrder":3,"curCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    cfgMap.put(WorkflowConfig.RECURRENCE_INTERVAL, String.valueOf(recurrenInSeconds));\n    cfgMap.put(WorkflowConfig.RECURRENCE_UNIT, \"SECONDS\");\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","date":"2016-07-06 05:34:59","endLine":254,"groupId":"5691","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"buildRecurrentJobQueue","params":"(StringjobQueueName@intdelayStart@intrecurrenInSeconds)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/06/b9751a14dd49812689e72bb947cf019abe2cab.src","preCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    cfgMap.put(WorkflowConfig.RECURRENCE_INTERVAL, String.valueOf(60));\n    cfgMap.put(WorkflowConfig.RECURRENCE_UNIT, \"SECONDS\");\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    \r\n    \r\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"M"},{"authorDate":"2016-01-20 10:15:07","commitOrder":3,"curCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","date":"2016-07-06 05:33:42","endLine":260,"groupId":"5691","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"buildJobQueue","params":"(StringjobQueueName@intdelayStart)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/11/677b84ebb9f8a0e69e150c4267adaabe3307c0.src","preCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":250,"status":"N"}],"commitId":"7a47070362c536126e945138f10fb077215f706e","commitMessage":"@@@Support changes of workflow configuration.\n","date":"2016-07-06 05:34:59","modifiedFileCount":"6","status":"M","submitter":"Lei Xia"},{"authorTime":"2016-01-28 02:10:31","codes":[{"authorDate":"2016-01-27 01:57:43","commitOrder":4,"curCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    cfgMap.put(WorkflowConfig.RECURRENCE_INTERVAL, String.valueOf(recurrenInSeconds));\n    cfgMap.put(WorkflowConfig.RECURRENCE_UNIT, \"SECONDS\");\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","date":"2016-07-06 05:34:59","endLine":254,"groupId":"5691","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"buildRecurrentJobQueue","params":"(StringjobQueueName@intdelayStart@intrecurrenInSeconds)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/06/b9751a14dd49812689e72bb947cf019abe2cab.src","preCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    cfgMap.put(WorkflowConfig.RECURRENCE_INTERVAL, String.valueOf(recurrenInSeconds));\n    cfgMap.put(WorkflowConfig.RECURRENCE_UNIT, \"SECONDS\");\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":241,"status":"N"},{"authorDate":"2016-01-28 02:10:31","commitOrder":4,"curCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart, int failureThreshold) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    if (failureThreshold > 0) {\n      cfgMap.put(WorkflowConfig.FAILURE_THRESHOLD, String.valueOf(failureThreshold));\n    }\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","date":"2016-07-06 05:44:56","endLine":274,"groupId":"5691","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"buildJobQueue","params":"(StringjobQueueName@intdelayStart@intfailureThreshold)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/01/1f532b1b3356a8837218154d91ed3c26e19978.src","preCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":261,"status":"M"}],"commitId":"be660245fc1a9f4b22fba58c4b25a1af19555066","commitMessage":"@@@Add new job option to allow contining a job even its direct dependent job fails.\n","date":"2016-07-06 05:44:56","modifiedFileCount":"8","status":"M","submitter":"Lei Xia"},{"authorTime":"2016-02-24 09:06:35","codes":[{"authorDate":"2016-02-24 09:06:35","commitOrder":5,"curCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds, TargetState targetState) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder();\n    workflowCfgBuilder.setExpiry(120000);\n    if (targetState != null) {\n      workflowCfgBuilder.setTargetState(TargetState.STOP);\n    }\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    ScheduleConfig scheduleConfig =\n        ScheduleConfig.recurringFromDate(cal.getTime(), TimeUnit.SECONDS, recurrenInSeconds);\n    workflowCfgBuilder.setScheduleConfig(scheduleConfig);\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","date":"2016-07-06 05:48:35","endLine":262,"groupId":"3961","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"buildRecurrentJobQueue","params":"(StringjobQueueName@intdelayStart@intrecurrenInSeconds@TargetStatetargetState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/3e/5385ce7465beb72ac0f1744861fe0117d3a84a.src","preCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    cfgMap.put(WorkflowConfig.RECURRENCE_INTERVAL, String.valueOf(recurrenInSeconds));\n    cfgMap.put(WorkflowConfig.RECURRENCE_UNIT, \"SECONDS\");\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"M"},{"authorDate":"2016-02-24 09:06:35","commitOrder":5,"curCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart,\n      int failureThreshold) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder();\n    workflowCfgBuilder.setExpiry(120000);\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    workflowCfgBuilder.setScheduleConfig(ScheduleConfig.oneTimeDelayedStart(cal.getTime()));\n\n    if (failureThreshold > 0) {\n      workflowCfgBuilder.setFailureThreshold(failureThreshold);\n    }\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","date":"2016-07-06 05:48:35","endLine":283,"groupId":"5212","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"buildJobQueue","params":"(StringjobQueueName@intdelayStart@intfailureThreshold)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/3e/5385ce7465beb72ac0f1744861fe0117d3a84a.src","preCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart, int failureThreshold) {\n    Map<String, String> cfgMap = new HashMap<String, String>();\n    cfgMap.put(WorkflowConfig.EXPIRY, String.valueOf(120000));\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    cfgMap.put(WorkflowConfig.START_TIME,\n        WorkflowConfig.getDefaultDateFormat().format(cal.getTime()));\n    if (failureThreshold > 0) {\n      cfgMap.put(WorkflowConfig.FAILURE_THRESHOLD, String.valueOf(failureThreshold));\n    }\n    return new JobQueue.Builder(jobQueueName).fromMap(cfgMap);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":268,"status":"M"}],"commitId":"d386aff394f2e4e7202f13fe2ed5e6533a8cfb29","commitMessage":"@@@Refactor Workflow and Jobqueue builders to make the builder API more clean.\n","date":"2016-07-06 05:48:35","modifiedFileCount":"16","status":"M","submitter":"Lei Xia"},{"authorTime":"2017-01-31 07:02:24","codes":[{"authorDate":"2016-02-24 09:06:35","commitOrder":6,"curCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds, TargetState targetState) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder();\n    workflowCfgBuilder.setExpiry(120000);\n    if (targetState != null) {\n      workflowCfgBuilder.setTargetState(TargetState.STOP);\n    }\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    ScheduleConfig scheduleConfig =\n        ScheduleConfig.recurringFromDate(cal.getTime(), TimeUnit.SECONDS, recurrenInSeconds);\n    workflowCfgBuilder.setScheduleConfig(scheduleConfig);\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","date":"2016-07-06 05:48:35","endLine":262,"groupId":"3961","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"buildRecurrentJobQueue","params":"(StringjobQueueName@intdelayStart@intrecurrenInSeconds@TargetStatetargetState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/3e/5385ce7465beb72ac0f1744861fe0117d3a84a.src","preCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds, TargetState targetState) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder();\n    workflowCfgBuilder.setExpiry(120000);\n    if (targetState != null) {\n      workflowCfgBuilder.setTargetState(TargetState.STOP);\n    }\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    ScheduleConfig scheduleConfig =\n        ScheduleConfig.recurringFromDate(cal.getTime(), TimeUnit.SECONDS, recurrenInSeconds);\n    workflowCfgBuilder.setScheduleConfig(scheduleConfig);\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":246,"status":"N"},{"authorDate":"2017-01-31 07:02:24","commitOrder":6,"curCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart,\n      int failureThreshold, int capacity) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder();\n    workflowCfgBuilder.setExpiry(120000);\n    workflowCfgBuilder.setCapacity(capacity);\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    workflowCfgBuilder.setScheduleConfig(ScheduleConfig.oneTimeDelayedStart(cal.getTime()));\n\n    if (failureThreshold > 0) {\n      workflowCfgBuilder.setFailureThreshold(failureThreshold);\n    }\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","date":"2017-10-07 03:23:47","endLine":230,"groupId":"5212","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"buildJobQueue","params":"(StringjobQueueName@intdelayStart@intfailureThreshold@intcapacity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/60/367324dd8d4e0964a8589d1144fbcfefd87639.src","preCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart,\n      int failureThreshold) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder();\n    workflowCfgBuilder.setExpiry(120000);\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    workflowCfgBuilder.setScheduleConfig(ScheduleConfig.oneTimeDelayedStart(cal.getTime()));\n\n    if (failureThreshold > 0) {\n      workflowCfgBuilder.setFailureThreshold(failureThreshold);\n    }\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":214,"status":"M"}],"commitId":"e530bf5183e7ad2f3a27d0e75448b88e8554efe8","commitMessage":"@@@Clean up jobs in a jobqueue automatically after the job completes and passes its expiry time.\n","date":"2017-10-07 03:23:47","modifiedFileCount":"15","status":"M","submitter":"Lei Xia"},{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2017-11-08 08:48:26","commitOrder":7,"curCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds, TargetState targetState) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder(jobQueueName);\n    workflowCfgBuilder.setExpiry(120000);\n    if (targetState != null) {\n      workflowCfgBuilder.setTargetState(TargetState.STOP);\n    }\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    ScheduleConfig scheduleConfig =\n        ScheduleConfig.recurringFromDate(cal.getTime(), TimeUnit.SECONDS, recurrenInSeconds);\n    workflowCfgBuilder.setScheduleConfig(scheduleConfig);\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","date":"2017-11-08 08:48:26","endLine":214,"groupId":"3961","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"buildRecurrentJobQueue","params":"(StringjobQueueName@intdelayStart@intrecurrenInSeconds@TargetStatetargetState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/f0e322c4b32debd5b814b06091a2a9c9f559fc.src","preCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds, TargetState targetState) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder();\n    workflowCfgBuilder.setExpiry(120000);\n    if (targetState != null) {\n      workflowCfgBuilder.setTargetState(TargetState.STOP);\n    }\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    ScheduleConfig scheduleConfig =\n        ScheduleConfig.recurringFromDate(cal.getTime(), TimeUnit.SECONDS, recurrenInSeconds);\n    workflowCfgBuilder.setScheduleConfig(scheduleConfig);\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":198,"status":"M"},{"authorDate":"2017-11-08 08:48:26","commitOrder":7,"curCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart,\n      int failureThreshold, int capacity) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder(jobQueueName);\n    workflowCfgBuilder.setExpiry(120000);\n    workflowCfgBuilder.setCapacity(capacity);\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    workflowCfgBuilder.setScheduleConfig(ScheduleConfig.oneTimeDelayedStart(cal.getTime()));\n\n    if (failureThreshold > 0) {\n      workflowCfgBuilder.setFailureThreshold(failureThreshold);\n    }\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","date":"2017-11-08 08:48:26","endLine":236,"groupId":"5212","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"buildJobQueue","params":"(StringjobQueueName@intdelayStart@intfailureThreshold@intcapacity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/f0e322c4b32debd5b814b06091a2a9c9f559fc.src","preCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart,\n      int failureThreshold, int capacity) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder();\n    workflowCfgBuilder.setExpiry(120000);\n    workflowCfgBuilder.setCapacity(capacity);\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    workflowCfgBuilder.setScheduleConfig(ScheduleConfig.oneTimeDelayedStart(cal.getTime()));\n\n    if (failureThreshold > 0) {\n      workflowCfgBuilder.setFailureThreshold(failureThreshold);\n    }\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"M"}],"commitId":"fe0b6e800e24c52d514c78d1fbab3d6b0800803f","commitMessage":"@@@Merge branch 'helixli/master'\n\nConflicts:\n\thelix-admin-webapp/helix-admin-webapp-0.6.10-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.6-SNAPSHOT.ivy\n\thelix-admin-webapp/helix-admin-webapp-0.6.9-SNAPSHOT.ivy\n\thelix-admin-webapp/pom.xml\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/JobResource.java\n\thelix-admin-webapp/src/main/java/org/apache/helix/webapp/resources/SchedulerTasksResource.java\n\thelix-admin-webapp/src/test/java/org/apache/helix/webapp/TestClusterManagementWebapp.java\n\thelix-agent/helix-agent-0.6.10-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.6-SNAPSHOT.ivy\n\thelix-agent/helix-agent-0.6.9-SNAPSHOT.ivy\n\thelix-agent/pom.xml\n\thelix-core/helix-core-0.6.10-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.6-SNAPSHOT.ivy\n\thelix-core/helix-core-0.6.9-SNAPSHOT.ivy\n\thelix-core/pom.xml\n\thelix-core/src/main/java/org/apache/helix/BaseDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/ConfigAccessor.java\n\thelix-core/src/main/java/org/apache/helix/HelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/HelixConstants.java\n\thelix-core/src/main/java/org/apache/helix/HelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/NotificationContext.java\n\thelix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java\n\thelix-core/src/main/java/org/apache/helix/ZNRecord.java\n\thelix-core/src/main/java/org/apache/helix/api/config/RebalanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionThrottleConfig.java\n\thelix-core/src/main/java/org/apache/helix/api/config/StateTransitionTimeoutConfig.java\n\thelix-core/src/main/java/org/apache/helix/controller/GenericHelixController.java\n\thelix-core/src/main/java/org/apache/helix/controller/common/PartitionStateMap.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/AutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/DelayedAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/SemiAutoRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/AutoRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/CrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/MultiRoundCrushRebalanceStrategy.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/strategy/crushMapping/CRUSHPlacementAlgorithm.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Node.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java\n\thelix-core/src/main/java/org/apache/helix/controller/rebalancer/util/RebalanceScheduler.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/BestPossibleStateOutput.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ClusterDataCache.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/CurrentStateComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ExternalViewComputeStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/IntermediateStateCalcStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/MessageSelectionStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/PersistAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ReadClusterDataStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/ResourceComputationStage.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/StateTransitionThrottleController.java\n\thelix-core/src/main/java/org/apache/helix/controller/stages/TaskAssignmentStage.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/CallbackHandler.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixDataAccessor.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZKUtil.java\n\thelix-core/src/main/java/org/apache/helix/manager/zk/ZkClient.java\n\thelix-core/src/main/java/org/apache/helix/messaging/DefaultMessagingService.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTask.java\n\thelix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java\n\thelix-core/src/main/java/org/apache/helix/model/ClusterConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/IdealState.java\n\thelix-core/src/main/java/org/apache/helix/model/InstanceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/LeaderHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java\n\thelix-core/src/main/java/org/apache/helix/model/ResourceConfig.java\n\thelix-core/src/main/java/org/apache/helix/model/StateModelDefinition.java\n\thelix-core/src/main/java/org/apache/helix/model/builder/IdealStateBuilder.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/ParticipantStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ClusterStatusMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/InstanceMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/JobMonitor.java\n\thelix-core/src/main/java/org/apache/helix/monitoring/mbeans/ParticipantMessageMonitor.java\n\thelix-core/src/main/java/org/apache/helix/participant/statemachine/StateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/DeprecatedTaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/FixedTargetTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/GenericTaskAssignmentCalculator.java\n\thelix-core/src/main/java/org/apache/helix/task/JobConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/JobContext.java\n\thelix-core/src/main/java/org/apache/helix/task/JobRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskConstants.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskDriver.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskState.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModel.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java\n\thelix-core/src/main/java/org/apache/helix/task/TaskUtil.java\n\thelix-core/src/main/java/org/apache/helix/task/Workflow.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowConfig.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowContext.java\n\thelix-core/src/main/java/org/apache/helix/task/WorkflowRebalancer.java\n\thelix-core/src/main/java/org/apache/helix/task/beans/JobBean.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterLiveNodesVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterStateVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/BestPossibleExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/StrictMatchExternalViewVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/ClusterVerifiers/ZkHelixClusterVerifier.java\n\thelix-core/src/main/java/org/apache/helix/tools/IntegrationTestUtil.java\n\thelix-core/src/main/java/org/apache/helix/util/HelixUtil.java\n\thelix-core/src/test/java/org/apache/helix/Mocks.java\n\thelix-core/src/test/java/org/apache/helix/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/TestPropertyPathBuilder.java\n\thelix-core/src/test/java/org/apache/helix/ZkUnitTestBase.java\n\thelix-core/src/test/java/org/apache/helix/controller/rebalancer/TestAutoRebalanceStrategy.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleCalcStageCompatibility.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestBestPossibleStateCalcStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestCurrentStateComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestRebalancePipeline.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceComputationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/stages/TestResourceValidationStage.java\n\thelix-core/src/test/java/org/apache/helix/controller/strategy/TestTopology.java\n\thelix-core/src/test/java/org/apache/helix/integration/SinglePartitionLeaderStandByTest.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestAddNodeAfterControllerStart.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBatchMessageHandling.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestBucketizedResource.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestCarryOverBadCurState.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestClusterStartsup.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDriver.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestDrop.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnableCompression.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestEnablePartitionDuringDisable.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestNullReplica.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPartitionMovementThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestPersistAssignmentStage.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestRebalancerPersistAssignments.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestResourceGroupEndtoEnd.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStartMultipleControllersWithSameName.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestStateTransitionCancellation.java\n\thelix-core/src/test/java/org/apache/helix/integration/TestSyncSessionToController.java\n\thelix-core/src/test/java/org/apache/helix/integration/ZkIntegrationTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/MockParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestBatchMessageWrapper.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestMessageThrottle.java\n\thelix-core/src/test/java/org/apache/helix/integration/messaging/TestSchedulerMessage.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoIsWithEmptyMap.java\n\thelix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAutoRebalance.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/MockTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestBase.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestGenericTaskAssignmentCalculator.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestIndependentTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestJobQueueCleanUp.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRebalanceRunningTask.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRecurringJobQueue.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestRunJobsWithMissingTarget.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancer.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerParallel.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRebalancerStopResume.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskRetryDelay.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestTaskThrottling.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUnregisteredCommand.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestUserContentStore.java\n\thelix-core/src/test/java/org/apache/helix/integration/task/TestWorkflowJobDependency.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpMultiThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestWtCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZKUtil.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkBaseDataAccessor.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheAsyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkCacheSyncOpSingleThread.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkClient.java\n\thelix-core/src/test/java/org/apache/helix/manager/zk/TestZkHelixAdmin.java\n\thelix-core/src/test/java/org/apache/helix/messaging/TestDefaultMessagingService.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestConfigThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestHelixTaskExecutor.java\n\thelix-core/src/test/java/org/apache/helix/messaging/handling/TestResourceThreadpoolSize.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/TestParticipantMonitor.java\n\thelix-core/src/test/java/org/apache/helix/monitoring/mbeans/TestDisableResourceMbean.java\n\thelix-core/src/test/java/org/apache/helix/participant/TestDistControllerElection.java\n\thelix-core/src/test/java/org/apache/helix/task/TaskSynchronizedTestBase.java\n\thelix-core/src/test/java/org/apache/helix/task/TestCleanExpiredJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestScheduleDelayJobs.java\n\thelix-core/src/test/java/org/apache/helix/task/TestSemiAutoStateTransition.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterSetup.java\n\thelix-core/src/test/java/org/apache/helix/tools/TestClusterVerifier.java\n\tpom.xml\n\trecipes/distributed-lock-manager/pom.xml\n\trecipes/pom.xml\n\trecipes/rabbitmq-consumer-group/pom.xml\n\trecipes/rsync-replicated-file-system/pom.xml\n\trecipes/service-discovery/pom.xml\n\trecipes/task-execution/pom.xml\n","date":"2017-11-08 08:48:26","modifiedFileCount":"275","status":"M","submitter":"Junkai Xue"},{"authorTime":"2017-11-08 08:48:26","codes":[{"authorDate":"2019-03-29 03:31:25","commitOrder":8,"curCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenceInSeconds, TargetState targetState) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder(jobQueueName);\n    workflowCfgBuilder.setExpiry(120000);\n    if (targetState != null) {\n      workflowCfgBuilder.setTargetState(TargetState.STOP);\n    }\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    ScheduleConfig scheduleConfig =\n        ScheduleConfig.recurringFromDate(cal.getTime(), TimeUnit.SECONDS, recurrenceInSeconds);\n    workflowCfgBuilder.setScheduleConfig(scheduleConfig);\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","date":"2019-03-29 03:31:25","endLine":224,"groupId":"10525","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"buildRecurrentJobQueue","params":"(StringjobQueueName@intdelayStart@intrecurrenceInSeconds@TargetStatetargetState)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/47/b7cb8c52964c62105ac3b6666480da217afac8.src","preCode":"  public static JobQueue.Builder buildRecurrentJobQueue(String jobQueueName, int delayStart,\n      int recurrenInSeconds, TargetState targetState) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder(jobQueueName);\n    workflowCfgBuilder.setExpiry(120000);\n    if (targetState != null) {\n      workflowCfgBuilder.setTargetState(TargetState.STOP);\n    }\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    ScheduleConfig scheduleConfig =\n        ScheduleConfig.recurringFromDate(cal.getTime(), TimeUnit.SECONDS, recurrenInSeconds);\n    workflowCfgBuilder.setScheduleConfig(scheduleConfig);\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"M"},{"authorDate":"2017-11-08 08:48:26","commitOrder":8,"curCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart,\n      int failureThreshold, int capacity) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder(jobQueueName);\n    workflowCfgBuilder.setExpiry(120000);\n    workflowCfgBuilder.setCapacity(capacity);\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    workflowCfgBuilder.setScheduleConfig(ScheduleConfig.oneTimeDelayedStart(cal.getTime()));\n\n    if (failureThreshold > 0) {\n      workflowCfgBuilder.setFailureThreshold(failureThreshold);\n    }\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","date":"2017-11-08 08:48:26","endLine":236,"groupId":"10525","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"buildJobQueue","params":"(StringjobQueueName@intdelayStart@intfailureThreshold@intcapacity)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/76/f0e322c4b32debd5b814b06091a2a9c9f559fc.src","preCode":"  public static JobQueue.Builder buildJobQueue(String jobQueueName, int delayStart,\n      int failureThreshold, int capacity) {\n    WorkflowConfig.Builder workflowCfgBuilder = new WorkflowConfig.Builder(jobQueueName);\n    workflowCfgBuilder.setExpiry(120000);\n    workflowCfgBuilder.setCapacity(capacity);\n\n    Calendar cal = Calendar.getInstance();\n    cal.set(Calendar.MINUTE, cal.get(Calendar.MINUTE) + delayStart / 60);\n    cal.set(Calendar.SECOND, cal.get(Calendar.SECOND) + delayStart % 60);\n    cal.set(Calendar.MILLISECOND, 0);\n    workflowCfgBuilder.setScheduleConfig(ScheduleConfig.oneTimeDelayedStart(cal.getTime()));\n\n    if (failureThreshold > 0) {\n      workflowCfgBuilder.setFailureThreshold(failureThreshold);\n    }\n    return new JobQueue.Builder(jobQueueName).setWorkflowConfig(workflowCfgBuilder.build());\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/integration/task/TaskTestUtil.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":220,"status":"N"}],"commitId":"0ad8af404908a54f7b98ee945bf2dda8e83f002f","commitMessage":"@@@TASK2.0: Job scheduling core pipeline fixes\n\nTask Framework 2.0 had stability issues and race conditions that weren't being handled correctly. Also.  integration with RuntimeJobDag had some loopholes that needed to be fixed. This diff includes such fixes and improvements that makes it really show performance gains and cuts down on redundant computation.\nChangelist:\n1. Race condition when a job is enqueued.  only the new JobConfig is updated and not the DAG\n    Add a two-way selective update which ensures consistency between JobConfigs and parent DAGs\n2. Moved where getNextJob() is called in scheduleJobs() in WorkflowDispatcher\n    This ensures that once a RuntimeJobDag is rebuilt.  update for jobs happens in one pipeline run.  which removes any extra delay or slowness\n3. Race condition where the job you got from getNextJob is for some reason not schedulable\n    This is due to deleting and enqueuing a job of the same name\n    RuntimeJobDag has the old job name.  which conflicts with the dependency in the new DAG\n    This fixes the test: TestTaskRebalancerStopResume so that it does not enqueue a job of the same name\n4. JobRebalancer was throwing an NPE when calling processJobStatusUpdateAndAssignment()\n    This was sometimes making the Controller hang\n    Added a null check for JobConfig (job could have been deleted/purged)\n5. Fix bug with isWorkflowStopped\n    TargetState comparison was done in the opposite way\n    This fixes the test: TestRecurringJobQueue's testDeletingRecurrentQueueWithHistory()\n    Sometimes contexts do not get deleted cleanly but this does not affect correctness\n6. Add TestEnqueueJobs\n7. Fix unstable TestGetLastScheduledTaskExecInfo\n8. Other minor style fixes\n","date":"2019-03-29 03:31:25","modifiedFileCount":"12","status":"M","submitter":"Hunter Lee"}]
