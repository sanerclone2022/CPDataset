[{"authorTime":"2019-03-29 03:27:52","codes":[{"authorDate":"2019-03-29 03:27:52","commitOrder":1,"curCode":"  public void testResourceLevelPriorityForRecoveryBalance(\n      Map<String, String> resourceMap, String priorityField, List<String> expectedPriority) {\n    preSetup(StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE, resourceMap.keySet(),\n        priorityField, 10, 1);\n    event.addAttribute(AttributeName.RESOURCES.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n    event.addAttribute(AttributeName.RESOURCES_TO_REBALANCE.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n\n    \r\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    CurrentStateOutput currentStateOutput = new CurrentStateOutput();\n\n    for (String resource : resourceMap.keySet()) {\n      IdealState is = accessor.getProperty(accessor.keyBuilder().idealStates(resource));\n      is.getRecord().setSimpleField(priorityField, resourceMap.get(resource));\n      setSingleIdealState(is);\n\n      Map<String, List<String>> partitionMap = new HashMap<String, List<String>>();\n      Partition partition = new Partition(resource + \"_0\");\n      String instanceName = HOSTNAME_PREFIX + resource.split(\"_\")[1];\n      partitionMap.put(partition.getPartitionName(),\n          Collections.singletonList(instanceName));\n      bestPossibleStateOutput.setPreferenceLists(resource, partitionMap);\n      bestPossibleStateOutput.setState(resource, partition, instanceName, \"SLAVE\");\n      currentStateOutput.setCurrentState(resource, partition, instanceName, \"OFFLINE\");\n    }\n\n\n    event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.name(), bestPossibleStateOutput);\n    event.addAttribute(AttributeName.CURRENT_STATE.name(), currentStateOutput);\n    runStage(event, new ReadClusterDataStage());\n\n    \r\n    List<String> resourcePriority = new ArrayList<String>();\n    for (int i = 0; i < resourceMap.size(); i++) {\n      runStage(event, new IntermediateStateCalcStage());\n      updateCurrentStatesForRecoveryBalance(resourcePriority, currentStateOutput);\n    }\n\n    Assert.assertEquals(resourcePriority, expectedPriority);\n  }\n","date":"2019-03-29 03:27:52","endLine":94,"groupId":"2007","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testResourceLevelPriorityForRecoveryBalance","params":"(Map<String@String>resourceMap@StringpriorityField@List<String>expectedPriority)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/08/0e27013f47b74f16ec1fe3211131373915e360.src","preCode":"  public void testResourceLevelPriorityForRecoveryBalance(\n      Map<String, String> resourceMap, String priorityField, List<String> expectedPriority) {\n    preSetup(StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE, resourceMap.keySet(),\n        priorityField, 10, 1);\n    event.addAttribute(AttributeName.RESOURCES.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n    event.addAttribute(AttributeName.RESOURCES_TO_REBALANCE.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n\n    \r\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    CurrentStateOutput currentStateOutput = new CurrentStateOutput();\n\n    for (String resource : resourceMap.keySet()) {\n      IdealState is = accessor.getProperty(accessor.keyBuilder().idealStates(resource));\n      is.getRecord().setSimpleField(priorityField, resourceMap.get(resource));\n      setSingleIdealState(is);\n\n      Map<String, List<String>> partitionMap = new HashMap<String, List<String>>();\n      Partition partition = new Partition(resource + \"_0\");\n      String instanceName = HOSTNAME_PREFIX + resource.split(\"_\")[1];\n      partitionMap.put(partition.getPartitionName(),\n          Collections.singletonList(instanceName));\n      bestPossibleStateOutput.setPreferenceLists(resource, partitionMap);\n      bestPossibleStateOutput.setState(resource, partition, instanceName, \"SLAVE\");\n      currentStateOutput.setCurrentState(resource, partition, instanceName, \"OFFLINE\");\n    }\n\n\n    event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.name(), bestPossibleStateOutput);\n    event.addAttribute(AttributeName.CURRENT_STATE.name(), currentStateOutput);\n    runStage(event, new ReadClusterDataStage());\n\n    \r\n    List<String> resourcePriority = new ArrayList<String>();\n    for (int i = 0; i < resourceMap.size(); i++) {\n      runStage(event, new IntermediateStateCalcStage());\n      updateCurrentStatesForRecoveryBalance(resourcePriority, currentStateOutput);\n    }\n\n    Assert.assertEquals(resourcePriority, expectedPriority);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/controller/stages/TestStateTransitionPriority.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"B"},{"authorDate":"2019-03-29 03:27:52","commitOrder":1,"curCode":"  public void testResourceLevelPriorityForLoadBalance(\n      Map<String, String> resourceMap, String priorityField, List<String> expectedPriority) {\n    preSetup(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE, resourceMap.keySet(), priorityField,\n        10, 1);\n    event.addAttribute(AttributeName.RESOURCES.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n    event.addAttribute(AttributeName.RESOURCES_TO_REBALANCE.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n\n    \r\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    CurrentStateOutput currentStateOutput = new CurrentStateOutput();\n\n    for (String resource : resourceMap.keySet()) {\n      IdealState is = accessor.getProperty(accessor.keyBuilder().idealStates(resource));\n      is.getRecord().setSimpleField(priorityField, resourceMap.get(resource));\n      setSingleIdealState(is);\n\n      Map<String, List<String>> partitionMap = new HashMap<String, List<String>>();\n      Partition partition = new Partition(resource + \"_0\");\n      String instanceName = HOSTNAME_PREFIX + resource.split(\"_\")[1];\n      String nextInstanceName = HOSTNAME_PREFIX + (Integer.parseInt(resource.split(\"_\")[1]) + 1);\n      partitionMap.put(partition.getPartitionName(), Collections.singletonList(nextInstanceName));\n      bestPossibleStateOutput.setPreferenceLists(resource, partitionMap);\n      bestPossibleStateOutput.setState(resource, partition, nextInstanceName, \"MASTER\");\n      currentStateOutput.setCurrentState(resource, partition, instanceName, \"MASTER\");\n    }\n\n    event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.name(), bestPossibleStateOutput);\n    event.addAttribute(AttributeName.CURRENT_STATE.name(), currentStateOutput);\n    event.addAttribute(AttributeName.ControllerDataProvider.name(),\n        new ResourceControllerDataProvider());\n    runStage(event, new ReadClusterDataStage());\n\n    \r\n    List<String> resourcePriority = new ArrayList<String>();\n    for (int i = 0; i < resourceMap.size(); i++) {\n      runStage(event, new IntermediateStateCalcStage());\n      updateCurrentStatesForLoadBalance(resourcePriority, currentStateOutput);\n    }\n\n    Assert.assertEquals(resourcePriority, expectedPriority);\n  }\n","date":"2019-03-29 03:27:52","endLine":141,"groupId":"2007","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testResourceLevelPriorityForLoadBalance","params":"(Map<String@String>resourceMap@StringpriorityField@List<String>expectedPriority)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/08/0e27013f47b74f16ec1fe3211131373915e360.src","preCode":"  public void testResourceLevelPriorityForLoadBalance(\n      Map<String, String> resourceMap, String priorityField, List<String> expectedPriority) {\n    preSetup(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE, resourceMap.keySet(), priorityField,\n        10, 1);\n    event.addAttribute(AttributeName.RESOURCES.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n    event.addAttribute(AttributeName.RESOURCES_TO_REBALANCE.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n\n    \r\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    CurrentStateOutput currentStateOutput = new CurrentStateOutput();\n\n    for (String resource : resourceMap.keySet()) {\n      IdealState is = accessor.getProperty(accessor.keyBuilder().idealStates(resource));\n      is.getRecord().setSimpleField(priorityField, resourceMap.get(resource));\n      setSingleIdealState(is);\n\n      Map<String, List<String>> partitionMap = new HashMap<String, List<String>>();\n      Partition partition = new Partition(resource + \"_0\");\n      String instanceName = HOSTNAME_PREFIX + resource.split(\"_\")[1];\n      String nextInstanceName = HOSTNAME_PREFIX + (Integer.parseInt(resource.split(\"_\")[1]) + 1);\n      partitionMap.put(partition.getPartitionName(), Collections.singletonList(nextInstanceName));\n      bestPossibleStateOutput.setPreferenceLists(resource, partitionMap);\n      bestPossibleStateOutput.setState(resource, partition, nextInstanceName, \"MASTER\");\n      currentStateOutput.setCurrentState(resource, partition, instanceName, \"MASTER\");\n    }\n\n    event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.name(), bestPossibleStateOutput);\n    event.addAttribute(AttributeName.CURRENT_STATE.name(), currentStateOutput);\n    event.addAttribute(AttributeName.ControllerDataProvider.name(),\n        new ResourceControllerDataProvider());\n    runStage(event, new ReadClusterDataStage());\n\n    \r\n    List<String> resourcePriority = new ArrayList<String>();\n    for (int i = 0; i < resourceMap.size(); i++) {\n      runStage(event, new IntermediateStateCalcStage());\n      updateCurrentStatesForLoadBalance(resourcePriority, currentStateOutput);\n    }\n\n    Assert.assertEquals(resourcePriority, expectedPriority);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/controller/stages/TestStateTransitionPriority.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":97,"status":"B"}],"commitId":"de38fa1a4e13939807427694a538ea468f8abb36","commitMessage":"@@@HELIX: Recovery balance partitions with disabled top-state replicas\n\n    Previously.  disabling of partitions or disabled instances did not affect Helix's throttling logic. This was problematic because the ability to disable was designed in in order to move partitons/replicas out of the given instance as a measure to deal with unhealthy partitions/instances. This allows.  for partitions that are disabled.  to go into recovery balance.  and when the user has not set any throttling configs for recovery balance.  these types of state transitions will go through unthrottled.  avoiding downtime.\n    Changelist:\n    1. Add a check for determining rebalance type for a given partition\n    2. Add an integration test\n","date":"2019-03-29 03:27:52","modifiedFileCount":"1","status":"B","submitter":"Hunter Lee"},{"authorTime":"2021-05-26 01:19:08","codes":[{"authorDate":"2021-05-26 01:19:08","commitOrder":2,"curCode":"  public void testResourceLevelPriorityForRecoveryBalance(\n      Map<String, String> resourceMap, String priorityField, List<String> expectedPriority) {\n    preSetup(StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE, resourceMap.keySet(),\n        priorityField, 10, 1);\n    event.addAttribute(AttributeName.RESOURCES.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n    event.addAttribute(AttributeName.RESOURCES_TO_REBALANCE.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n\n    \r\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    MessageOutput messageSelectOutput = new MessageOutput();\n    CurrentStateOutput currentStateOutput = new CurrentStateOutput();\n\n    for (String resource : resourceMap.keySet()) {\n      IdealState is = accessor.getProperty(accessor.keyBuilder().idealStates(resource));\n      is.getRecord().setSimpleField(priorityField, resourceMap.get(resource));\n      setSingleIdealState(is);\n\n      Map<String, List<String>> partitionMap = new HashMap<String, List<String>>();\n      Partition partition = new Partition(resource + \"_0\");\n      String instanceName = HOSTNAME_PREFIX + resource.split(\"_\")[1];\n      partitionMap.put(partition.getPartitionName(),\n          Collections.singletonList(instanceName));\n      bestPossibleStateOutput.setPreferenceLists(resource, partitionMap);\n      bestPossibleStateOutput.setState(resource, partition, instanceName, \"SLAVE\");\n      messageSelectOutput.addMessage(resource, partition, generateMessage(\"OFFLINE\", \"SLAVE\", instanceName));\n      currentStateOutput.setCurrentState(resource, partition, instanceName, \"OFFLINE\");\n    }\n\n\n    event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.name(), bestPossibleStateOutput);\n    event.addAttribute(AttributeName.MESSAGES_SELECTED.name(), messageSelectOutput);\n    event.addAttribute(AttributeName.CURRENT_STATE.name(), currentStateOutput);\n    runStage(event, new ReadClusterDataStage());\n\n    \r\n    List<String> resourcePriority = new ArrayList<String>();\n    for (int i = 0; i < resourceMap.size(); i++) {\n      runStage(event, new IntermediateStateCalcStage());\n      updateCurrentStatesForRecoveryBalance(resourcePriority, currentStateOutput);\n    }\n\n    Assert.assertEquals(resourcePriority, expectedPriority);\n  }\n","date":"2021-06-02 02:44:29","endLine":98,"groupId":"10280","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testResourceLevelPriorityForRecoveryBalance","params":"(Map<String@String>resourceMap@StringpriorityField@List<String>expectedPriority)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/22/c20f7dd2a29111084482e8a1666da97ce3ee18.src","preCode":"  public void testResourceLevelPriorityForRecoveryBalance(\n      Map<String, String> resourceMap, String priorityField, List<String> expectedPriority) {\n    preSetup(StateTransitionThrottleConfig.RebalanceType.RECOVERY_BALANCE, resourceMap.keySet(),\n        priorityField, 10, 1);\n    event.addAttribute(AttributeName.RESOURCES.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n    event.addAttribute(AttributeName.RESOURCES_TO_REBALANCE.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n\n    \r\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    CurrentStateOutput currentStateOutput = new CurrentStateOutput();\n\n    for (String resource : resourceMap.keySet()) {\n      IdealState is = accessor.getProperty(accessor.keyBuilder().idealStates(resource));\n      is.getRecord().setSimpleField(priorityField, resourceMap.get(resource));\n      setSingleIdealState(is);\n\n      Map<String, List<String>> partitionMap = new HashMap<String, List<String>>();\n      Partition partition = new Partition(resource + \"_0\");\n      String instanceName = HOSTNAME_PREFIX + resource.split(\"_\")[1];\n      partitionMap.put(partition.getPartitionName(),\n          Collections.singletonList(instanceName));\n      bestPossibleStateOutput.setPreferenceLists(resource, partitionMap);\n      bestPossibleStateOutput.setState(resource, partition, instanceName, \"SLAVE\");\n      currentStateOutput.setCurrentState(resource, partition, instanceName, \"OFFLINE\");\n    }\n\n\n    event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.name(), bestPossibleStateOutput);\n    event.addAttribute(AttributeName.CURRENT_STATE.name(), currentStateOutput);\n    runStage(event, new ReadClusterDataStage());\n\n    \r\n    List<String> resourcePriority = new ArrayList<String>();\n    for (int i = 0; i < resourceMap.size(); i++) {\n      runStage(event, new IntermediateStateCalcStage());\n      updateCurrentStatesForRecoveryBalance(resourcePriority, currentStateOutput);\n    }\n\n    Assert.assertEquals(resourcePriority, expectedPriority);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/controller/stages/TestStateTransitionPriority.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"},{"authorDate":"2021-05-26 01:19:08","commitOrder":2,"curCode":"  public void testResourceLevelPriorityForLoadBalance(\n      Map<String, String> resourceMap, String priorityField, List<String> expectedPriority) {\n    preSetup(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE, resourceMap.keySet(), priorityField,\n        10, 1);\n    event.addAttribute(AttributeName.RESOURCES.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n    event.addAttribute(AttributeName.RESOURCES_TO_REBALANCE.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n\n    \r\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    MessageOutput messageSelectOutput = new MessageOutput();\n    CurrentStateOutput currentStateOutput = new CurrentStateOutput();\n\n    for (String resource : resourceMap.keySet()) {\n      IdealState is = accessor.getProperty(accessor.keyBuilder().idealStates(resource));\n      is.getRecord().setSimpleField(priorityField, resourceMap.get(resource));\n      setSingleIdealState(is);\n\n      Map<String, List<String>> partitionMap = new HashMap<String, List<String>>();\n      Partition partition = new Partition(resource + \"_0\");\n      String instanceName = HOSTNAME_PREFIX + resource.split(\"_\")[1];\n      String nextInstanceName = HOSTNAME_PREFIX + (Integer.parseInt(resource.split(\"_\")[1]) + 1);\n      partitionMap.put(partition.getPartitionName(), Collections.singletonList(nextInstanceName));\n      bestPossibleStateOutput.setPreferenceLists(resource, partitionMap);\n      bestPossibleStateOutput.setState(resource, partition, instanceName, \"MASTER\");\n      bestPossibleStateOutput.setState(resource, partition, nextInstanceName, \"SLAVE\");\n      currentStateOutput.setCurrentState(resource, partition, instanceName, \"MASTER\");\n    }\n\n    event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.name(), bestPossibleStateOutput);\n    event.addAttribute(AttributeName.MESSAGES_SELECTED.name(), messageSelectOutput);\n    event.addAttribute(AttributeName.CURRENT_STATE.name(), currentStateOutput);\n    event.addAttribute(AttributeName.ControllerDataProvider.name(),\n        new ResourceControllerDataProvider());\n    runStage(event, new ReadClusterDataStage());\n\n    \r\n    List<String> resourcePriority = new ArrayList<String>();\n    for (int i = 0; i < resourceMap.size(); i++) {\n      event.addAttribute(AttributeName.MESSAGES_SELECTED.name(),\n          generateMessageMapForResource(bestPossibleStateOutput, currentStateOutput, resourcePriority));\n      runStage(event, new IntermediateStateCalcStage());\n      updateCurrentStatesForLoadBalance(resourcePriority, currentStateOutput, bestPossibleStateOutput);\n    }\n\n    Assert.assertEquals(resourcePriority, expectedPriority);\n  }\n","date":"2021-06-02 02:44:29","endLine":150,"groupId":"10280","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testResourceLevelPriorityForLoadBalance","params":"(Map<String@String>resourceMap@StringpriorityField@List<String>expectedPriority)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-helix-10-0.7/blobInfo/CC_OUT/blobs/22/c20f7dd2a29111084482e8a1666da97ce3ee18.src","preCode":"  public void testResourceLevelPriorityForLoadBalance(\n      Map<String, String> resourceMap, String priorityField, List<String> expectedPriority) {\n    preSetup(StateTransitionThrottleConfig.RebalanceType.LOAD_BALANCE, resourceMap.keySet(), priorityField,\n        10, 1);\n    event.addAttribute(AttributeName.RESOURCES.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n    event.addAttribute(AttributeName.RESOURCES_TO_REBALANCE.name(),\n        getResourceMap(resourceMap.keySet().toArray(new String[resourceMap.keySet().size()]), 1,\n            \"MasterSlave\"));\n\n    \r\n    BestPossibleStateOutput bestPossibleStateOutput = new BestPossibleStateOutput();\n    CurrentStateOutput currentStateOutput = new CurrentStateOutput();\n\n    for (String resource : resourceMap.keySet()) {\n      IdealState is = accessor.getProperty(accessor.keyBuilder().idealStates(resource));\n      is.getRecord().setSimpleField(priorityField, resourceMap.get(resource));\n      setSingleIdealState(is);\n\n      Map<String, List<String>> partitionMap = new HashMap<String, List<String>>();\n      Partition partition = new Partition(resource + \"_0\");\n      String instanceName = HOSTNAME_PREFIX + resource.split(\"_\")[1];\n      String nextInstanceName = HOSTNAME_PREFIX + (Integer.parseInt(resource.split(\"_\")[1]) + 1);\n      partitionMap.put(partition.getPartitionName(), Collections.singletonList(nextInstanceName));\n      bestPossibleStateOutput.setPreferenceLists(resource, partitionMap);\n      bestPossibleStateOutput.setState(resource, partition, nextInstanceName, \"MASTER\");\n      currentStateOutput.setCurrentState(resource, partition, instanceName, \"MASTER\");\n    }\n\n    event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.name(), bestPossibleStateOutput);\n    event.addAttribute(AttributeName.CURRENT_STATE.name(), currentStateOutput);\n    event.addAttribute(AttributeName.ControllerDataProvider.name(),\n        new ResourceControllerDataProvider());\n    runStage(event, new ReadClusterDataStage());\n\n    \r\n    List<String> resourcePriority = new ArrayList<String>();\n    for (int i = 0; i < resourceMap.size(); i++) {\n      runStage(event, new IntermediateStateCalcStage());\n      updateCurrentStatesForLoadBalance(resourcePriority, currentStateOutput);\n    }\n\n    Assert.assertEquals(resourcePriority, expectedPriority);\n  }\n","realPath":"helix-core/src/test/java/org/apache/helix/controller/stages/TestStateTransitionPriority.java","repoName":"helix","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"}],"commitId":"f49986e24c27c49d8c877457753e32dcf8b540f4","commitMessage":"@@@[Replica Level Throttle] Make Pipeline in a correct order and fixes tests (#1750)\n\n* Make Pipeline in a correct order and fixes tests\n\n1. Make pipeline running in a correct order to process computation\n2. Add \"DROPPED\" case in the mapping to reflect the real case.\n3. Fixes test cases.","date":"2021-06-02 02:44:29","modifiedFileCount":"15","status":"M","submitter":"Junkai Xue"}]
