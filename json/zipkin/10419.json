[{"authorTime":"2019-01-31 22:38:58","codes":[{"authorDate":"2019-04-14 16:15:45","commitOrder":3,"curCode":"  Call<List<String>> aggregatedFieldByServiceName(String serviceName, String term) {\n    if (serviceName.isEmpty() || !searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    \r\n    SearchRequest.Filters filters = new SearchRequest.Filters()\n      .addRange(\"timestamp_millis\", beginMillis, endMillis)\n      .addTerm(\"localEndpoint.serviceName\", serviceName.toLowerCase(Locale.ROOT));\n\n    SearchRequest request = SearchRequest.create(indices).filters(filters)\n      .addAggregation(Aggregation.terms(term, Integer.MAX_VALUE));\n\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","date":"2019-04-14 16:15:45","endLine":173,"groupId":"2743","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"aggregatedFieldByServiceName","params":"(StringserviceName@Stringterm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/9d/451bbdf12c7c696c1611d3d7f98887debc68a0.src","preCode":"  Call<List<String>> aggregatedFieldByServiceName(String serviceName, String term) {\n    if (serviceName.isEmpty() || !searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    \r\n    SearchRequest.Filters filters = new SearchRequest.Filters()\n      .addRange(\"timestamp_millis\", beginMillis, endMillis)\n      .addTerm(\"localEndpoint.serviceName\", serviceName.toLowerCase(Locale.ROOT));\n\n    SearchRequest request = SearchRequest.create(indices).filters(filters)\n      .addAggregation(Aggregation.terms(term, Integer.MAX_VALUE));\n\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"B"},{"authorDate":"2019-01-31 22:38:58","commitOrder":3,"curCode":"  @Override public Call<List<String>> getValues(String key) {\n    if (key == null) throw new NullPointerException(\"key == null\");\n    if (key.isEmpty()) throw new IllegalArgumentException(\"key was empty\");\n    if (!enabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n    List<String> indices =\n      indexNameFormatter.formatTypeAndRange(AUTOCOMPLETE, beginMillis, endMillis);\n\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest.Filters filters =\n      new SearchRequest.Filters().addTerm(\"tagKey\", key);\n\n    SearchRequest request = SearchRequest.create(indices)\n      .filters(filters)\n      .addAggregation(Aggregation.terms(\"tagValue\", Integer.MAX_VALUE));\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","date":"2019-01-31 22:38:58","endLine":66,"groupId":"744","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getValues","params":"(Stringkey)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/ec/2a22b65e702e3d599302d183bb6aea78d0b341.src","preCode":"  @Override public Call<List<String>> getValues(String key) {\n    if (key == null) throw new NullPointerException(\"key == null\");\n    if (key.isEmpty()) throw new IllegalArgumentException(\"key was empty\");\n    if (!enabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n    List<String> indices =\n      indexNameFormatter.formatTypeAndRange(AUTOCOMPLETE, beginMillis, endMillis);\n\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest.Filters filters =\n      new SearchRequest.Filters().addTerm(\"tagKey\", key);\n\n    SearchRequest request = SearchRequest.create(indices)\n      .filters(filters)\n      .addAggregation(Aggregation.terms(\"tagValue\", Integer.MAX_VALUE));\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchAutocompleteTags.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"NB"}],"commitId":"b8646142fa15c8c5f47ff2a2a48dc663c7bb65b3","commitMessage":"@@@De-conflate local from remote service names (#2484)\n\nEspecially mentioned in #1794.  local and remote service names are undeniably serving different use cases.  yet currently conflated in the api.\n\n/services -> only local serviceNames\n/remoteServices?serviceName=X -> new: only remote serviceNames for auto-complete\n/spans?remoteServiceName=X -> new: to restore functionality @llinder mentioned","date":"2019-04-14 16:15:45","modifiedFileCount":"67","status":"M","submitter":"Adrian Cole"},{"authorTime":"2019-10-01 19:13:42","codes":[{"authorDate":"2019-10-01 19:13:42","commitOrder":4,"curCode":"  Call<List<String>> aggregatedFieldByServiceName(String serviceName, String term) {\n    if (serviceName.isEmpty() || !searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(TYPE_SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    \r\n    SearchRequest.Filters filters = new SearchRequest.Filters()\n      .addRange(\"timestamp_millis\", beginMillis, endMillis)\n      .addTerm(\"localEndpoint.serviceName\", serviceName.toLowerCase(Locale.ROOT));\n\n    SearchRequest request = SearchRequest.create(indices).filters(filters)\n      .addAggregation(Aggregation.terms(term, Integer.MAX_VALUE));\n\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","date":"2019-10-01 19:13:42","endLine":193,"groupId":"10419","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"aggregatedFieldByServiceName","params":"(StringserviceName@Stringterm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/e5/47ee5233b1ee038b70960dee16ab373e7b4b9b.src","preCode":"  Call<List<String>> aggregatedFieldByServiceName(String serviceName, String term) {\n    if (serviceName.isEmpty() || !searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    \r\n    SearchRequest.Filters filters = new SearchRequest.Filters()\n      .addRange(\"timestamp_millis\", beginMillis, endMillis)\n      .addTerm(\"localEndpoint.serviceName\", serviceName.toLowerCase(Locale.ROOT));\n\n    SearchRequest request = SearchRequest.create(indices).filters(filters)\n      .addAggregation(Aggregation.terms(term, Integer.MAX_VALUE));\n\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"M"},{"authorDate":"2019-10-01 19:13:42","commitOrder":4,"curCode":"  @Override public Call<List<String>> getValues(String key) {\n    if (key == null) throw new NullPointerException(\"key == null\");\n    if (key.isEmpty()) throw new IllegalArgumentException(\"key was empty\");\n    if (!enabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n    List<String> indices =\n      indexNameFormatter.formatTypeAndRange(TYPE_AUTOCOMPLETE, beginMillis, endMillis);\n\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest.Filters filters =\n      new SearchRequest.Filters().addTerm(\"tagKey\", key);\n\n    SearchRequest request = SearchRequest.create(indices)\n      .filters(filters)\n      .addAggregation(Aggregation.terms(\"tagValue\", Integer.MAX_VALUE));\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","date":"2019-10-01 19:13:42","endLine":66,"groupId":"10419","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"getValues","params":"(Stringkey)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/ba/3944499df535988d468e6cee9b39ddcf5b0a21.src","preCode":"  @Override public Call<List<String>> getValues(String key) {\n    if (key == null) throw new NullPointerException(\"key == null\");\n    if (key.isEmpty()) throw new IllegalArgumentException(\"key was empty\");\n    if (!enabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n    List<String> indices =\n      indexNameFormatter.formatTypeAndRange(AUTOCOMPLETE, beginMillis, endMillis);\n\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest.Filters filters =\n      new SearchRequest.Filters().addTerm(\"tagKey\", key);\n\n    SearchRequest request = SearchRequest.create(indices)\n      .filters(filters)\n      .addAggregation(Aggregation.terms(\"tagValue\", Integer.MAX_VALUE));\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchAutocompleteTags.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":47,"status":"M"}],"commitId":"797f36d0ab169173d43de5de1cb7e7bd98dcd39a","commitMessage":"@@@Ensures index templates are verified before passing health. (#2827)\n\nCurrently.  we pass health checks which can hide errors provisioning\nindex templates.  and also worsen template provisioning race conditions.\n\nThis makes sure index templates are at least checked once per startup.\n\nThis also refactors the code so that someone can later do offline\ntemplate installation.\n\nFixes #2825","date":"2019-10-01 19:13:42","modifiedFileCount":"11","status":"M","submitter":"Adrian Cole"}]
