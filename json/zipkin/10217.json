[{"authorTime":"2020-03-11 18:07:43","codes":[{"authorDate":"2020-09-29 15:05:45","commitOrder":4,"curCode":"  List<List<Span>> traces() {\n    \r\n    Span span1 = Span.newBuilder().traceId(CLIENT_SPAN.traceId().substring(16)).id(\"1\")\n      .name(\"1\")\n      .putTag(\"foo\", \"1\")\n      .timestamp(TODAY * 1000L)\n      .localEndpoint(FRONTEND)\n      .build();\n    \r\n    Span span2 =\n      span1.toBuilder().traceId(CLIENT_SPAN.traceId()).name(\"2\").putTag(\"foo\", \"2\").build();\n    \r\n    Span span3 =\n      span1.toBuilder().traceId(\"1\" + span1.traceId()).name(\"3\").putTag(\"foo\", \"3\").build();\n\n    return new ArrayList<>(asList(asList(span1), asList(span2), asList(span3)));\n  }\n","date":"2020-09-29 15:05:45","endLine":86,"groupId":"2221","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"traces","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/42/0104f10bdb4514e3bbdb2b894865abe5e32ed8.src","preCode":"  List<List<Span>> traces() {\n    \r\n    Span span1 = Span.newBuilder().traceId(CLIENT_SPAN.traceId().substring(16)).id(\"1\")\n      .name(\"1\")\n      .putTag(\"foo\", \"1\")\n      .timestamp(TODAY * 1000L)\n      .localEndpoint(FRONTEND)\n      .build();\n    \r\n    Span span2 =\n      span1.toBuilder().traceId(CLIENT_SPAN.traceId()).name(\"2\").putTag(\"foo\", \"2\").build();\n    \r\n    Span span3 =\n      span1.toBuilder().traceId(\"1\" + span1.traceId()).name(\"3\").putTag(\"foo\", \"3\").build();\n\n    return new ArrayList<>(asList(asList(span1), asList(span2), asList(span3)));\n  }\n","realPath":"zipkin-tests/src/test/java/zipkin2/storage/StrictTraceIdTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"B"},{"authorDate":"2020-03-11 18:07:43","commitOrder":4,"curCode":"  @Test protected void getTraces_considersBitsAbove64bit() throws IOException {\n    \r\n    Span span1 = Span.newBuilder().traceId(CLIENT_SPAN.traceId().substring(16)).id(\"1\")\n      .putTag(\"foo\", \"1\")\n      .timestamp(TODAY * 1000L)\n      .localEndpoint(FRONTEND)\n      .build();\n    \r\n    Span span2 = span1.toBuilder().traceId(CLIENT_SPAN.traceId()).putTag(\"foo\", \"2\").build();\n    \r\n    Span span3 = span1.toBuilder().traceId(\"1\" + span1.traceId()).putTag(\"foo\", \"3\").build();\n\n    accept(span1, span2, span3);\n\n    for (Span span : Arrays.asList(span1, span2, span3)) {\n      assertThat(store().getTraces(requestBuilder()\n        .serviceName(\"frontend\")\n        .parseAnnotationQuery(\"foo=\" + span.tags().get(\"foo\")).build()\n      ).execute()).flatExtracting(t -> t).containsExactly(span);\n    }\n  }\n","date":"2020-03-11 18:07:43","endLine":162,"groupId":"832","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getTraces_considersBitsAbove64bit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/96/ef18602349647d6476416852890ef243bfd11d.src","preCode":"  @Test protected void getTraces_considersBitsAbove64bit() throws IOException {\n    \r\n    Span span1 = Span.newBuilder().traceId(CLIENT_SPAN.traceId().substring(16)).id(\"1\")\n      .putTag(\"foo\", \"1\")\n      .timestamp(TODAY * 1000L)\n      .localEndpoint(FRONTEND)\n      .build();\n    \r\n    Span span2 = span1.toBuilder().traceId(CLIENT_SPAN.traceId()).putTag(\"foo\", \"2\").build();\n    \r\n    Span span3 = span1.toBuilder().traceId(\"1\" + span1.traceId()).putTag(\"foo\", \"3\").build();\n\n    accept(span1, span2, span3);\n\n    for (Span span : Arrays.asList(span1, span2, span3)) {\n      assertThat(store().getTraces(requestBuilder()\n        .serviceName(\"frontend\")\n        .parseAnnotationQuery(\"foo=\" + span.tags().get(\"foo\")).build()\n      ).execute()).flatExtracting(t -> t).containsExactly(span);\n    }\n  }\n","realPath":"zipkin-tests/src/main/java/zipkin2/storage/ITSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"NB"}],"commitId":"95ace09d004c92c225ffcf70782ea42a5825760a","commitMessage":"@@@Allows use of JDK 15+ (#3216)\n\nThis allows builds to work with JDK 15+ even if that JDK cannot compile\nJava 1.6 anymore. Specifically.  this removes Retrolambda.  which formerly\nrewrote our main tree to 1.6 bytecode. We had to do this as Retrolambda\nno longer works in JDK 15.\n\nIn order to publish a JRE compatible 1.6 jar to Maven Central.  we use\nJDK during the release process (Travis). To ensure normal usage and\nDocker can use JDK 15.  we change our GitHub actions to use JDK 15.\n\nThis also adds a RATIONALE.md which covers the major aspects around\nsource.  largely duplicated from Brave (though not exactly the same as\ncontext slightly differs here.)","date":"2020-09-29 15:05:45","modifiedFileCount":"31","status":"M","submitter":"Adrian Cole"},{"authorTime":"2020-10-21 10:53:01","codes":[{"authorDate":"2020-09-29 15:05:45","commitOrder":5,"curCode":"  List<List<Span>> traces() {\n    \r\n    Span span1 = Span.newBuilder().traceId(CLIENT_SPAN.traceId().substring(16)).id(\"1\")\n      .name(\"1\")\n      .putTag(\"foo\", \"1\")\n      .timestamp(TODAY * 1000L)\n      .localEndpoint(FRONTEND)\n      .build();\n    \r\n    Span span2 =\n      span1.toBuilder().traceId(CLIENT_SPAN.traceId()).name(\"2\").putTag(\"foo\", \"2\").build();\n    \r\n    Span span3 =\n      span1.toBuilder().traceId(\"1\" + span1.traceId()).name(\"3\").putTag(\"foo\", \"3\").build();\n\n    return new ArrayList<>(asList(asList(span1), asList(span2), asList(span3)));\n  }\n","date":"2020-09-29 15:05:45","endLine":86,"groupId":"10217","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"traces","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/42/0104f10bdb4514e3bbdb2b894865abe5e32ed8.src","preCode":"  List<List<Span>> traces() {\n    \r\n    Span span1 = Span.newBuilder().traceId(CLIENT_SPAN.traceId().substring(16)).id(\"1\")\n      .name(\"1\")\n      .putTag(\"foo\", \"1\")\n      .timestamp(TODAY * 1000L)\n      .localEndpoint(FRONTEND)\n      .build();\n    \r\n    Span span2 =\n      span1.toBuilder().traceId(CLIENT_SPAN.traceId()).name(\"2\").putTag(\"foo\", \"2\").build();\n    \r\n    Span span3 =\n      span1.toBuilder().traceId(\"1\" + span1.traceId()).name(\"3\").putTag(\"foo\", \"3\").build();\n\n    return new ArrayList<>(asList(asList(span1), asList(span2), asList(span3)));\n  }\n","realPath":"zipkin-tests/src/test/java/zipkin2/storage/StrictTraceIdTest.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"N"},{"authorDate":"2020-10-21 10:53:01","commitOrder":5,"curCode":"  @Test protected void getTraces_considersBitsAbove64bit(TestInfo testInfo) throws Exception {\n    String testSuffix = testSuffix(testInfo);\n    String traceId = newTraceId();\n    Endpoint frontend = suffixServiceName(TestObjects.FRONTEND, testSuffix);\n\n    \r\n    Span span1 = Span.newBuilder().traceId(traceId.substring(16)).id(\"1\")\n      .putTag(\"foo\", \"1\")\n      .timestamp(TODAY * 1000L)\n      .localEndpoint(frontend)\n      .build();\n    \r\n    Span span2 = span1.toBuilder().traceId(traceId).putTag(\"foo\", \"2\").build();\n    \r\n    Span span3 = span1.toBuilder().traceId(\"1\" + span1.traceId()).putTag(\"foo\", \"3\").build();\n\n    accept(span1, span2, span3);\n\n    for (Span span : Arrays.asList(span1, span2, span3)) {\n      assertGetTracesReturns(\n        requestBuilder().serviceName(frontend.serviceName())\n          .parseAnnotationQuery(\"foo=\" + span.tags().get(\"foo\"))\n          .build(),\n        asList(span));\n    }\n  }\n","date":"2020-10-21 10:53:01","endLine":168,"groupId":"10217","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getTraces_considersBitsAbove64bit","params":"(TestInfotestInfo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/87/fe48d363de664b28196f167c663bd0ee5ef641.src","preCode":"  @Test protected void getTraces_considersBitsAbove64bit() throws IOException {\n    \r\n    Span span1 = Span.newBuilder().traceId(CLIENT_SPAN.traceId().substring(16)).id(\"1\")\n      .putTag(\"foo\", \"1\")\n      .timestamp(TODAY * 1000L)\n      .localEndpoint(FRONTEND)\n      .build();\n    \r\n    Span span2 = span1.toBuilder().traceId(CLIENT_SPAN.traceId()).putTag(\"foo\", \"2\").build();\n    \r\n    Span span3 = span1.toBuilder().traceId(\"1\" + span1.traceId()).putTag(\"foo\", \"3\").build();\n\n    accept(span1, span2, span3);\n\n    for (Span span : Arrays.asList(span1, span2, span3)) {\n      assertThat(store().getTraces(requestBuilder()\n        .serviceName(\"frontend\")\n        .parseAnnotationQuery(\"foo=\" + span.tags().get(\"foo\")).build()\n      ).execute()).flatExtracting(t -> t).containsExactly(span);\n    }\n  }\n","realPath":"zipkin-tests/src/main/java/zipkin2/storage/ITSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":143,"status":"M"}],"commitId":"eeb17681af780e563b44503d5af1eadb3ca6abfc","commitMessage":"@@@Refactors integration tests to be more isolated (#3249)\n\nThis makes all integration tests use unique data. Notably.  they no\nlonger use constant trace ID or service names.  as this can lead to\ndifficulty when a keyspace is re-used. For example.  service names and\ntrace IDs are often partitions. When debugging it is easier when test\ndata is isolated by a service name as it can be easily queried.\n\nThis also pulls the heaviest tests into their own classes so that they\ndon't overload the storage containers used by the bulk of our tests.\n\nFinally.  this fixes a few glitches in the v1 cassandra storage.","date":"2020-10-21 10:53:01","modifiedFileCount":"46","status":"M","submitter":"Adrian Cole"}]
