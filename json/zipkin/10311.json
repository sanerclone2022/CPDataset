[{"authorTime":"2019-05-11 14:01:28","codes":[{"authorDate":"2019-05-11 14:01:28","commitOrder":1,"curCode":"  public static Span decodeOne(CodedInputStream input) throws IOException {\n    Span.Builder span = Span.newBuilder();\n\n    boolean done = false;\n    while (!done) {\n      int tag = input.readTag();\n      switch (tag) {\n        case 0:\n          done = true;\n          break;\n        case 10: {\n          span.traceId(readHexString(input));\n          break;\n        }\n        case 18: {\n          span.parentId(readHexString(input));\n          break;\n        }\n        case 26: {\n          span.id(readHexString(input));\n          break;\n        }\n        case 32: {\n          int kind = input.readEnum();\n          if (kind == 0) break;\n          if (kind > Span.Kind.values().length) break;\n          span.kind(Span.Kind.values()[kind - 1]);\n          break;\n        }\n        case 42: {\n          span.name(input.readStringRequireUtf8());\n          break;\n        }\n        case 49: {\n          span.timestamp(input.readFixed64());\n          break;\n        }\n        case 56: {\n          span.duration(input.readUInt64());\n          break;\n        }\n        case 66: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          span.localEndpoint(decodeEndpoint(input));\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 74: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          span.remoteEndpoint(decodeEndpoint(input));\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 82: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          decodeAnnotation(input, span);\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 90: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          decodeTag(input, span);\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 96: {\n          span.debug(input.readBool());\n          break;\n        }\n        case 104: {\n          span.shared(input.readBool());\n          break;\n        }\n        default: {\n          logAndSkip(input, tag);\n          break;\n        }\n      }\n    }\n\n    return span.build();\n  }\n","date":"2019-05-11 14:01:28","endLine":228,"groupId":"1345","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"decodeOne","params":"(CodedInputStreaminput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/f6/3d62ced49b6c2b6a5664417e4ffa9a4a650389.src","preCode":"  public static Span decodeOne(CodedInputStream input) throws IOException {\n    Span.Builder span = Span.newBuilder();\n\n    boolean done = false;\n    while (!done) {\n      int tag = input.readTag();\n      switch (tag) {\n        case 0:\n          done = true;\n          break;\n        case 10: {\n          span.traceId(readHexString(input));\n          break;\n        }\n        case 18: {\n          span.parentId(readHexString(input));\n          break;\n        }\n        case 26: {\n          span.id(readHexString(input));\n          break;\n        }\n        case 32: {\n          int kind = input.readEnum();\n          if (kind == 0) break;\n          if (kind > Span.Kind.values().length) break;\n          span.kind(Span.Kind.values()[kind - 1]);\n          break;\n        }\n        case 42: {\n          span.name(input.readStringRequireUtf8());\n          break;\n        }\n        case 49: {\n          span.timestamp(input.readFixed64());\n          break;\n        }\n        case 56: {\n          span.duration(input.readUInt64());\n          break;\n        }\n        case 66: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          span.localEndpoint(decodeEndpoint(input));\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 74: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          span.remoteEndpoint(decodeEndpoint(input));\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 82: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          decodeAnnotation(input, span);\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 90: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          decodeTag(input, span);\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 96: {\n          span.debug(input.readBool());\n          break;\n        }\n        case 104: {\n          span.shared(input.readBool());\n          break;\n        }\n        default: {\n          logAndSkip(input, tag);\n          break;\n        }\n      }\n    }\n\n    return span.build();\n  }\n","realPath":"benchmarks/src/main/java/zipkin2/codec/ProtobufSpanDecoder.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"B"},{"authorDate":"2019-05-11 14:01:28","commitOrder":1,"curCode":"  public static Span decodeOne(ProtoReader input) throws IOException {\n    Span.Builder span = Span.newBuilder();\n\n    boolean done = false;\n    while (!done) {\n      int tag = input.nextTag();\n      switch (tag) {\n        case -1:\n          done = true;\n          break;\n        case 1: {\n          span.traceId(readHexString(input));\n          break;\n        }\n        case 2: {\n          span.parentId(readHexString(input));\n          break;\n        }\n        case 3: {\n          span.id(readHexString(input));\n          break;\n        }\n        case 4: {\n          int kind = input.readVarint32();\n          if (kind == 0) break;\n          if (kind > Span.Kind.values().length) break;\n          span.kind(Span.Kind.values()[kind - 1]);\n          break;\n        }\n        case 5: {\n          String name = input.readString();\n          span.name(name);\n          break;\n        }\n        case 6: {\n          span.timestamp(input.readFixed64());\n          break;\n        }\n        case 7: {\n          span.duration(input.readVarint64());\n          break;\n        }\n        case 8: {\n          long token = input.beginMessage();\n\n          span.localEndpoint(decodeEndpoint(input));\n\n          input.endMessage(token);\n          break;\n        }\n        case 9: {\n          long token = input.beginMessage();\n\n          span.remoteEndpoint(decodeEndpoint(input));\n\n          input.endMessage(token);\n          break;\n        }\n        case 10: {\n          long token = input.beginMessage();\n\n          decodeAnnotation(input, span);\n\n          input.endMessage(token);\n          break;\n        }\n        case 11: {\n          long token = input.beginMessage();\n\n          decodeTag(input, span);\n\n          input.endMessage(token);\n          break;\n        }\n        case 12: {\n          span.debug(ProtoAdapter.BOOL.decode(input));\n          break;\n        }\n        case 13: {\n          span.shared(ProtoAdapter.BOOL.decode(input));\n          break;\n        }\n        default: {\n          logAndSkip(input, tag);\n          break;\n        }\n      }\n    }\n\n    return span.build();\n  }\n","date":"2019-05-11 14:01:28","endLine":221,"groupId":"1391","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"decodeOne","params":"(ProtoReaderinput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/a7/e7a24d03f270e37aaf0b00c8dea87ba630f110.src","preCode":"  public static Span decodeOne(ProtoReader input) throws IOException {\n    Span.Builder span = Span.newBuilder();\n\n    boolean done = false;\n    while (!done) {\n      int tag = input.nextTag();\n      switch (tag) {\n        case -1:\n          done = true;\n          break;\n        case 1: {\n          span.traceId(readHexString(input));\n          break;\n        }\n        case 2: {\n          span.parentId(readHexString(input));\n          break;\n        }\n        case 3: {\n          span.id(readHexString(input));\n          break;\n        }\n        case 4: {\n          int kind = input.readVarint32();\n          if (kind == 0) break;\n          if (kind > Span.Kind.values().length) break;\n          span.kind(Span.Kind.values()[kind - 1]);\n          break;\n        }\n        case 5: {\n          String name = input.readString();\n          span.name(name);\n          break;\n        }\n        case 6: {\n          span.timestamp(input.readFixed64());\n          break;\n        }\n        case 7: {\n          span.duration(input.readVarint64());\n          break;\n        }\n        case 8: {\n          long token = input.beginMessage();\n\n          span.localEndpoint(decodeEndpoint(input));\n\n          input.endMessage(token);\n          break;\n        }\n        case 9: {\n          long token = input.beginMessage();\n\n          span.remoteEndpoint(decodeEndpoint(input));\n\n          input.endMessage(token);\n          break;\n        }\n        case 10: {\n          long token = input.beginMessage();\n\n          decodeAnnotation(input, span);\n\n          input.endMessage(token);\n          break;\n        }\n        case 11: {\n          long token = input.beginMessage();\n\n          decodeTag(input, span);\n\n          input.endMessage(token);\n          break;\n        }\n        case 12: {\n          span.debug(ProtoAdapter.BOOL.decode(input));\n          break;\n        }\n        case 13: {\n          span.shared(ProtoAdapter.BOOL.decode(input));\n          break;\n        }\n        default: {\n          logAndSkip(input, tag);\n          break;\n        }\n      }\n    }\n\n    return span.build();\n  }\n","realPath":"benchmarks/src/main/java/zipkin2/codec/WireSpanDecoder.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"B"}],"commitId":"6f6cb328107ba0e77494c80ebca51165d97caa9c","commitMessage":"@@@Benchmark bytes / bytebuffer.  protobuf vs zipkin vs wire. (#2579)\n\n* Benchmark bytes / bytebuffer.  protobuf vs zipkin vs wire.\n\n* Add wire-based decoder too.\n\n* polish\n\n* changes to more realistic max message size\n","date":"2019-05-11 14:01:28","modifiedFileCount":"0","status":"B","submitter":"Anuraag Agrawal"},{"authorTime":"2019-10-03 15:39:23","codes":[{"authorDate":"2019-05-11 14:01:28","commitOrder":2,"curCode":"  public static Span decodeOne(CodedInputStream input) throws IOException {\n    Span.Builder span = Span.newBuilder();\n\n    boolean done = false;\n    while (!done) {\n      int tag = input.readTag();\n      switch (tag) {\n        case 0:\n          done = true;\n          break;\n        case 10: {\n          span.traceId(readHexString(input));\n          break;\n        }\n        case 18: {\n          span.parentId(readHexString(input));\n          break;\n        }\n        case 26: {\n          span.id(readHexString(input));\n          break;\n        }\n        case 32: {\n          int kind = input.readEnum();\n          if (kind == 0) break;\n          if (kind > Span.Kind.values().length) break;\n          span.kind(Span.Kind.values()[kind - 1]);\n          break;\n        }\n        case 42: {\n          span.name(input.readStringRequireUtf8());\n          break;\n        }\n        case 49: {\n          span.timestamp(input.readFixed64());\n          break;\n        }\n        case 56: {\n          span.duration(input.readUInt64());\n          break;\n        }\n        case 66: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          span.localEndpoint(decodeEndpoint(input));\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 74: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          span.remoteEndpoint(decodeEndpoint(input));\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 82: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          decodeAnnotation(input, span);\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 90: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          decodeTag(input, span);\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 96: {\n          span.debug(input.readBool());\n          break;\n        }\n        case 104: {\n          span.shared(input.readBool());\n          break;\n        }\n        default: {\n          logAndSkip(input, tag);\n          break;\n        }\n      }\n    }\n\n    return span.build();\n  }\n","date":"2019-05-11 14:01:28","endLine":228,"groupId":"10311","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"decodeOne","params":"(CodedInputStreaminput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/f6/3d62ced49b6c2b6a5664417e4ffa9a4a650389.src","preCode":"  public static Span decodeOne(CodedInputStream input) throws IOException {\n    Span.Builder span = Span.newBuilder();\n\n    boolean done = false;\n    while (!done) {\n      int tag = input.readTag();\n      switch (tag) {\n        case 0:\n          done = true;\n          break;\n        case 10: {\n          span.traceId(readHexString(input));\n          break;\n        }\n        case 18: {\n          span.parentId(readHexString(input));\n          break;\n        }\n        case 26: {\n          span.id(readHexString(input));\n          break;\n        }\n        case 32: {\n          int kind = input.readEnum();\n          if (kind == 0) break;\n          if (kind > Span.Kind.values().length) break;\n          span.kind(Span.Kind.values()[kind - 1]);\n          break;\n        }\n        case 42: {\n          span.name(input.readStringRequireUtf8());\n          break;\n        }\n        case 49: {\n          span.timestamp(input.readFixed64());\n          break;\n        }\n        case 56: {\n          span.duration(input.readUInt64());\n          break;\n        }\n        case 66: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          span.localEndpoint(decodeEndpoint(input));\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 74: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          span.remoteEndpoint(decodeEndpoint(input));\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 82: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          decodeAnnotation(input, span);\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 90: {\n          int length = input.readRawVarint32();\n          int oldLimit = input.pushLimit(length);\n\n          decodeTag(input, span);\n\n          input.checkLastTagWas(0);\n          input.popLimit(oldLimit);\n          break;\n        }\n        case 96: {\n          span.debug(input.readBool());\n          break;\n        }\n        case 104: {\n          span.shared(input.readBool());\n          break;\n        }\n        default: {\n          logAndSkip(input, tag);\n          break;\n        }\n      }\n    }\n\n    return span.build();\n  }\n","realPath":"benchmarks/src/main/java/zipkin2/codec/ProtobufSpanDecoder.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":131,"status":"N"},{"authorDate":"2019-10-03 15:39:23","commitOrder":2,"curCode":"  public static Span decodeOne(ProtoReader input) throws IOException {\n    Span.Builder span = Span.newBuilder();\n\n    boolean done = false;\n    while (!done) {\n      int tag = input.nextTag();\n      switch (tag) {\n        case -1:\n          done = true;\n          break;\n        case 1: {\n          span.traceId(readHexString(input));\n          break;\n        }\n        case 2: {\n          span.parentId(readHexString(input));\n          break;\n        }\n        case 3: {\n          span.id(readHexString(input));\n          break;\n        }\n        case 4: {\n          int kind = input.readVarint32();\n          if (kind == 0) break;\n          if (kind > Span.Kind.values().length) break;\n          span.kind(Span.Kind.values()[kind - 1]);\n          break;\n        }\n        case 5: {\n          String name = input.readString();\n          span.name(name);\n          break;\n        }\n        case 6: {\n          span.timestamp(input.readFixed64());\n          break;\n        }\n        case 7: {\n          span.duration(input.readVarint64());\n          break;\n        }\n        case 8: {\n          long token = input.beginMessage();\n\n          span.localEndpoint(decodeEndpoint(input));\n\n          input.endMessageAndGetUnknownFields(token);\n          break;\n        }\n        case 9: {\n          long token = input.beginMessage();\n\n          span.remoteEndpoint(decodeEndpoint(input));\n\n          input.endMessageAndGetUnknownFields(token);\n          break;\n        }\n        case 10: {\n          long token = input.beginMessage();\n\n          decodeAnnotation(input, span);\n\n          input.endMessageAndGetUnknownFields(token);\n          break;\n        }\n        case 11: {\n          long token = input.beginMessage();\n\n          decodeTag(input, span);\n\n          input.endMessageAndGetUnknownFields(token);\n          break;\n        }\n        case 12: {\n          span.debug(ProtoAdapter.BOOL.decode(input));\n          break;\n        }\n        case 13: {\n          span.shared(ProtoAdapter.BOOL.decode(input));\n          break;\n        }\n        default: {\n          logAndSkip(input, tag);\n          break;\n        }\n      }\n    }\n\n    return span.build();\n  }\n","date":"2019-10-03 15:39:23","endLine":220,"groupId":"10311","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"decodeOne","params":"(ProtoReaderinput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/45/2ba740155e8cfe8c16836d22158629b6716914.src","preCode":"  public static Span decodeOne(ProtoReader input) throws IOException {\n    Span.Builder span = Span.newBuilder();\n\n    boolean done = false;\n    while (!done) {\n      int tag = input.nextTag();\n      switch (tag) {\n        case -1:\n          done = true;\n          break;\n        case 1: {\n          span.traceId(readHexString(input));\n          break;\n        }\n        case 2: {\n          span.parentId(readHexString(input));\n          break;\n        }\n        case 3: {\n          span.id(readHexString(input));\n          break;\n        }\n        case 4: {\n          int kind = input.readVarint32();\n          if (kind == 0) break;\n          if (kind > Span.Kind.values().length) break;\n          span.kind(Span.Kind.values()[kind - 1]);\n          break;\n        }\n        case 5: {\n          String name = input.readString();\n          span.name(name);\n          break;\n        }\n        case 6: {\n          span.timestamp(input.readFixed64());\n          break;\n        }\n        case 7: {\n          span.duration(input.readVarint64());\n          break;\n        }\n        case 8: {\n          long token = input.beginMessage();\n\n          span.localEndpoint(decodeEndpoint(input));\n\n          input.endMessage(token);\n          break;\n        }\n        case 9: {\n          long token = input.beginMessage();\n\n          span.remoteEndpoint(decodeEndpoint(input));\n\n          input.endMessage(token);\n          break;\n        }\n        case 10: {\n          long token = input.beginMessage();\n\n          decodeAnnotation(input, span);\n\n          input.endMessage(token);\n          break;\n        }\n        case 11: {\n          long token = input.beginMessage();\n\n          decodeTag(input, span);\n\n          input.endMessage(token);\n          break;\n        }\n        case 12: {\n          span.debug(ProtoAdapter.BOOL.decode(input));\n          break;\n        }\n        case 13: {\n          span.shared(ProtoAdapter.BOOL.decode(input));\n          break;\n        }\n        default: {\n          logAndSkip(input, tag);\n          break;\n        }\n      }\n    }\n\n    return span.build();\n  }\n","realPath":"benchmarks/src/main/java/zipkin2/codec/WireSpanDecoder.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"M"}],"commitId":"115af54a382d6d5427a70007d96f8d3cf52c732d","commitMessage":"@@@Updates to latests versions.  notably to Armeria 0.94 (#2832)\n\n","date":"2019-10-03 15:39:23","modifiedFileCount":"10","status":"M","submitter":"Adrian Cole"}]
