[{"authorTime":"2018-07-13 04:25:22","codes":[{"authorDate":"2019-03-01 14:41:42","commitOrder":2,"curCode":"  static boolean contains(byte[] bytes, byte[] subsequence) {\n    bytes:\n    for (int i = 0; i < bytes.length - subsequence.length + 1; i++) {\n      for (int j = 0; j < subsequence.length; j++) {\n        if (bytes[i + j] != subsequence[j]) {\n          continue bytes;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n","date":"2019-03-01 14:41:42","endLine":239,"groupId":"3206","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"contains","params":"(byte[]bytes@byte[]subsequence)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/ca/77dd6f1e569d55f5c08ccc4083b9d0d396440d.src","preCode":"  static boolean contains(byte[] bytes, byte[] subsequence) {\n    bytes:\n    for (int i = 0; i < bytes.length - subsequence.length + 1; i++) {\n      for (int j = 0; j < subsequence.length; j++) {\n        if (bytes[i + j] != subsequence[j]) {\n          continue bytes;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n","realPath":"zipkin-server/src/main/java/zipkin2/server/internal/ZipkinHttpCollector.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"B"},{"authorDate":"2018-07-13 04:25:22","commitOrder":2,"curCode":"  static boolean contains(byte[] bytes, byte[] subsequence) {\n    bytes:\n    for (int i = 0; i < bytes.length - subsequence.length + 1; i++) {\n      for (int j = 0; j < subsequence.length; j++) {\n        if (bytes[i + j] != subsequence[j]) {\n          continue bytes;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n","date":"2018-07-13 04:25:22","endLine":102,"groupId":"3206","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"contains","params":"(byte[]bytes@byte[]subsequence)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/99/f0ca923347510bf6b7e6d0993d1154dd0883a7.src","preCode":"  static boolean contains(byte[] bytes, byte[] subsequence) {\n    bytes:\n    for (int i = 0; i < bytes.length - subsequence.length + 1; i++) {\n      for (int j = 0; j < subsequence.length; j++) {\n        if (bytes[i + j] != subsequence[j]) {\n          continue bytes;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n","realPath":"zipkin/src/main/java/zipkin2/SpanBytesDecoderDetector.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":91,"status":"NB"}],"commitId":"4f36b2e4a73734a60184473811b8ec2c08a2529f","commitMessage":"@@@Fails on incorrect format sent to http endpoints (#2421)\n\n\n","date":"2019-03-01 14:41:42","modifiedFileCount":"2","status":"M","submitter":"Adrian Cole"},{"authorTime":"2019-05-15 20:44:27","codes":[{"authorDate":"2019-05-15 20:44:27","commitOrder":3,"curCode":"  static boolean contains(ByteBuffer bytes, byte[] subsequence) {\n    bytes:\n    for (int i = 0; i < bytes.remaining() - subsequence.length + 1; i++) {\n      for (int j = 0; j < subsequence.length; j++) {\n        if (bytes.get(bytes.position() + i + j) != subsequence[j]) {\n          continue bytes;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n","date":"2019-05-15 20:44:27","endLine":282,"groupId":"1061","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"contains","params":"(ByteBufferbytes@byte[]subsequence)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/e8/94104500bdfdf3d611d4f36c0d1e50d83d9138.src","preCode":"  static boolean contains(byte[] bytes, byte[] subsequence) {\n    bytes:\n    for (int i = 0; i < bytes.length - subsequence.length + 1; i++) {\n      for (int j = 0; j < subsequence.length; j++) {\n        if (bytes[i + j] != subsequence[j]) {\n          continue bytes;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n","realPath":"zipkin-server/src/main/java/zipkin2/server/internal/ZipkinHttpCollector.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":271,"status":"M"},{"authorDate":"2019-05-15 20:44:27","commitOrder":3,"curCode":"  static boolean contains(ByteBuffer bytes, byte[] subsequence) {\n    bytes:\n    for (int i = 0; i < bytes.remaining() - subsequence.length + 1; i++) {\n      for (int j = 0; j < subsequence.length; j++) {\n        if (bytes.get(bytes.position() + i + j) != subsequence[j]) {\n          continue bytes;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n","date":"2019-05-15 20:44:27","endLine":114,"groupId":"1061","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"contains","params":"(ByteBufferbytes@byte[]subsequence)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/42/e2aa30d553ae12319ec699b95dcd0e41518da2.src","preCode":"  static boolean contains(byte[] bytes, byte[] subsequence) {\n    bytes:\n    for (int i = 0; i < bytes.length - subsequence.length + 1; i++) {\n      for (int j = 0; j < subsequence.length; j++) {\n        if (bytes[i + j] != subsequence[j]) {\n          continue bytes;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n","realPath":"zipkin/src/main/java/zipkin2/SpanBytesDecoderDetector.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"}],"commitId":"a4d145dfcb27e763d4593f6f5cb5a6d7df83c1be","commitMessage":"@@@Decode ByteBuffer directly where possible. (#2595)\n\n* Decode ByteBuffer directly where possible.\n\n* Move empty check after empty JSON massaging.  and don't increment dropped messages both before returning an exception and when handling the exception.\n\n* Fix bytebuffer wrapping.\n","date":"2019-05-15 20:44:27","modifiedFileCount":"2","status":"M","submitter":"Anuraag Agrawal"}]
