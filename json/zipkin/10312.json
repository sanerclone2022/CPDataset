[{"authorTime":"2019-05-12 17:07:43","codes":[{"authorDate":"2019-05-12 17:07:43","commitOrder":3,"curCode":"  private static String readHexString(CodedInputStream input) throws IOException {\n    int size = input.readRawVarint32();\n    int length = size * 2;\n\n    \r\n    if (length > 32) {\n      throw new AssertionError(\"hex field greater than 32 chars long: \" + length);\n    }\n\n    char[] result = Platform.shortStringBuffer();\n\n    for (int i = 0; i < length; i += 2) {\n      byte b = input.readRawByte();\n      result[i] = HEX_DIGITS[(b >> 4) & 0xf];\n      result[i + 1] = HEX_DIGITS[b & 0xf];\n    }\n\n    return new String(result, 0, length);\n  }\n","date":"2019-05-12 17:07:43","endLine":291,"groupId":"1349","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"readHexString","params":"(CodedInputStreaminput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/e5/3b8f87119db31da56fb3ab9e7201834dc4dcef.src","preCode":"  private static String readHexString(CodedInputStream input) throws IOException {\n    int size = input.readRawVarint32();\n    int length = size * 2;\n\n    \r\n    if (length > 32) {\n      throw new AssertionError(\"hex field greater than 32 chars long: \" + length);\n    }\n\n    char[] result = Platform.shortStringBuffer();\n\n    for (int i = 0; i < length; i += 2) {\n      byte b = input.readRawByte();\n      result[i] = HEX_DIGITS[(b >> 4) & 0xf];\n      result[i + 1] = HEX_DIGITS[b & 0xf];\n    }\n\n    return new String(result, 0, length);\n  }\n","realPath":"benchmarks/src/main/java/zipkin2/codec/ProtobufSpanDecoder.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":273,"status":"MB"},{"authorDate":"2019-05-12 17:07:43","commitOrder":3,"curCode":"  private static String readHexString(ProtoReader input) throws IOException {\n    ByteString bytes = input.readBytes();\n    int length = bytes.size() * 2;\n\n    \r\n    if (length > 32) {\n      throw new AssertionError(\"hex field greater than 32 chars long: \" + length);\n    }\n\n    char[] result = Platform.shortStringBuffer();\n\n    for (int i = 0; i < bytes.size(); i ++) {\n      byte b = bytes.getByte(i);\n      result[2 * i] = HEX_DIGITS[(b >> 4) & 0xf];\n      result[2 * i + 1] = HEX_DIGITS[b & 0xf];\n    }\n\n    return new String(result, 0, length);\n  }\n","date":"2019-05-12 17:07:43","endLine":306,"groupId":"124","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"readHexString","params":"(ProtoReaderinput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/52/a5f8f1115a07a0782fbbd3d5eaeebbbf676d8e.src","preCode":"  private static String readHexString(ProtoReader input) throws IOException {\n    ByteString bytes = input.readBytes();\n    int length = bytes.size() * 2;\n\n    \r\n    if (length > 32) {\n      throw new AssertionError(\"hex field greater than 32 chars long: \" + length);\n    }\n\n    char[] result = Platform.shortStringBuffer();\n\n    for (int i = 0; i < bytes.size(); i ++) {\n      byte b = bytes.getByte(i);\n      result[2 * i] = HEX_DIGITS[(b >> 4) & 0xf];\n      result[2 * i + 1] = HEX_DIGITS[b & 0xf];\n    }\n\n    return new String(result, 0, length);\n  }\n","realPath":"benchmarks/src/main/java/zipkin2/codec/WireSpanDecoder.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":288,"status":"MB"}],"commitId":"e4eb56792c2efb402a6764c5b80a19eff27268e0","commitMessage":"@@@Consolidates buffers and generally improves string decoding (#2588)\n\n\n","date":"2019-05-12 17:07:43","modifiedFileCount":"23","status":"M","submitter":"Adrian Cole"},{"authorTime":"2020-09-29 15:05:45","codes":[{"authorDate":"2020-09-29 15:05:45","commitOrder":4,"curCode":"  private static String readHexString(CodedInputStream input) throws IOException {\n    int size = input.readRawVarint32();\n    int length = size * 2;\n\n    \r\n    if (length > 32) {\n      throw new AssertionError(\"hex field greater than 32 chars long: \" + length);\n    }\n\n    char[] result = RecyclableBuffers.shortStringBuffer();\n\n    for (int i = 0; i < length; i += 2) {\n      byte b = input.readRawByte();\n      result[i] = HEX_DIGITS[(b >> 4) & 0xf];\n      result[i + 1] = HEX_DIGITS[b & 0xf];\n    }\n\n    return new String(result, 0, length);\n  }\n","date":"2020-09-29 15:05:45","endLine":288,"groupId":"10312","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"readHexString","params":"(CodedInputStreaminput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/95/a179c56f42f2a390f18740800ac9a69f61e990.src","preCode":"  private static String readHexString(CodedInputStream input) throws IOException {\n    int size = input.readRawVarint32();\n    int length = size * 2;\n\n    \r\n    if (length > 32) {\n      throw new AssertionError(\"hex field greater than 32 chars long: \" + length);\n    }\n\n    char[] result = Platform.shortStringBuffer();\n\n    for (int i = 0; i < length; i += 2) {\n      byte b = input.readRawByte();\n      result[i] = HEX_DIGITS[(b >> 4) & 0xf];\n      result[i + 1] = HEX_DIGITS[b & 0xf];\n    }\n\n    return new String(result, 0, length);\n  }\n","realPath":"benchmarks/src/main/java/zipkin2/codec/ProtobufSpanDecoder.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":270,"status":"M"},{"authorDate":"2020-09-29 15:05:45","commitOrder":4,"curCode":"  private static String readHexString(ProtoReader input) throws IOException {\n    ByteString bytes = input.readBytes();\n    int length = bytes.size() * 2;\n\n    \r\n    if (length > 32) {\n      throw new AssertionError(\"hex field greater than 32 chars long: \" + length);\n    }\n\n    char[] result = RecyclableBuffers.shortStringBuffer();\n\n    for (int i = 0; i < bytes.size(); i ++) {\n      byte b = bytes.getByte(i);\n      result[2 * i] = HEX_DIGITS[(b >> 4) & 0xf];\n      result[2 * i + 1] = HEX_DIGITS[b & 0xf];\n    }\n\n    return new String(result, 0, length);\n  }\n","date":"2020-09-29 15:05:45","endLine":303,"groupId":"10312","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"readHexString","params":"(ProtoReaderinput)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/b1/c71ff56a9f943eaf4f62945563fbe5c64ed21c.src","preCode":"  private static String readHexString(ProtoReader input) throws IOException {\n    ByteString bytes = input.readBytes();\n    int length = bytes.size() * 2;\n\n    \r\n    if (length > 32) {\n      throw new AssertionError(\"hex field greater than 32 chars long: \" + length);\n    }\n\n    char[] result = Platform.shortStringBuffer();\n\n    for (int i = 0; i < bytes.size(); i ++) {\n      byte b = bytes.getByte(i);\n      result[2 * i] = HEX_DIGITS[(b >> 4) & 0xf];\n      result[2 * i + 1] = HEX_DIGITS[b & 0xf];\n    }\n\n    return new String(result, 0, length);\n  }\n","realPath":"benchmarks/src/main/java/zipkin2/codec/WireSpanDecoder.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":285,"status":"M"}],"commitId":"95ace09d004c92c225ffcf70782ea42a5825760a","commitMessage":"@@@Allows use of JDK 15+ (#3216)\n\nThis allows builds to work with JDK 15+ even if that JDK cannot compile\nJava 1.6 anymore. Specifically.  this removes Retrolambda.  which formerly\nrewrote our main tree to 1.6 bytecode. We had to do this as Retrolambda\nno longer works in JDK 15.\n\nIn order to publish a JRE compatible 1.6 jar to Maven Central.  we use\nJDK during the release process (Travis). To ensure normal usage and\nDocker can use JDK 15.  we change our GitHub actions to use JDK 15.\n\nThis also adds a RATIONALE.md which covers the major aspects around\nsource.  largely duplicated from Brave (though not exactly the same as\ncontext slightly differs here.)","date":"2020-09-29 15:05:45","modifiedFileCount":"31","status":"M","submitter":"Adrian Cole"}]
