[{"authorTime":"2019-01-01 12:49:57","codes":[{"authorDate":"2018-07-12 06:07:10","commitOrder":2,"curCode":"  @Test public void skipsRedundantIndexingInATrace() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .timestamp(\n        trace[0].timestamp() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n\n    \r\n    accept(storage.toBuilder().strictTraceId(false).build().spanConsumer(), trace);\n\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L); \r\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L);\n  }\n","date":"2018-07-13 02:17:11","endLine":85,"groupId":"423","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"skipsRedundantIndexingInATrace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/fd/ca472cf24961981e5b97893151fea38f1ebde3.src","preCode":"  @Test public void skipsRedundantIndexingInATrace() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .timestamp(\n        trace[0].timestamp() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n\n    \r\n    accept(storage.toBuilder().strictTraceId(false).build().spanConsumer(), trace);\n\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L); \r\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L);\n  }\n","realPath":"zipkin-storage/cassandra/src/test/java/zipkin2/storage/cassandra/ITSpanConsumer.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"NB"},{"authorDate":"2019-01-01 12:49:57","commitOrder":2,"curCode":"  public void insertTags_SelectTags_CalculateCount() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .putTag(\"environment\", \"dev\")\n      .putTag(\"a\", \"b\")\n      .timestamp(\n        trace[0].timestamp() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n\n    assertThat(rowCountForTags(storage))\n      .isEqualTo(1L); \r\n\n    assertThat(getTagValue(storage, \"environment\")).isEqualTo(\"dev\");\n\n  }\n","date":"2019-01-01 12:49:57","endLine":114,"groupId":"425","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"insertTags_SelectTags_CalculateCount","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/85/829cf19d8981929f58ed10e06ca8ffb864e93b.src","preCode":"  public void insertTags_SelectTags_CalculateCount() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .putTag(\"environment\", \"dev\")\n      .putTag(\"a\", \"b\")\n      .timestamp(\n        trace[0].timestamp() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n\n    assertThat(rowCountForTags(storage))\n      .isEqualTo(1L); \r\n\n    assertThat(getTagValue(storage, \"environment\")).isEqualTo(\"dev\");\n\n  }\n","realPath":"zipkin-storage/cassandra/src/test/java/zipkin2/storage/cassandra/ITSpanConsumer.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":89,"status":"B"}],"commitId":"93163b1fc9f4e6c0429c74a822d53709e1515abb","commitMessage":"@@@Adds Cassandra support for Autocomplete tags (#2309)\n\n\n","date":"2019-01-01 12:49:57","modifiedFileCount":"24","status":"M","submitter":"Raja Sundaram"},{"authorTime":"2020-10-18 06:38:49","codes":[{"authorDate":"2020-10-18 06:38:49","commitOrder":3,"curCode":"  @Test public void skipsRedundantIndexingInATrace() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .timestamp(\n        trace[0].timestamp() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n\n    CassandraSpanConsumer withoutStrictTraceId = new CassandraSpanConsumer(\n      storage.session(), storage.metadata(),\n      false , storage.searchEnabled,\n      storage.autocompleteKeys, storage.autocompleteTtl, storage.autocompleteCardinality\n    );\n\n    \r\n    accept(withoutStrictTraceId, trace);\n\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L); \r\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L);\n  }\n","date":"2020-10-18 06:38:49","endLine":100,"groupId":"423","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"skipsRedundantIndexingInATrace","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/2a/01b6132da7200e4ce1e5c2c900bf8d488129ef.src","preCode":"  @Test public void skipsRedundantIndexingInATrace() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .timestamp(\n        trace[0].timestamp() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n\n    \r\n    accept(storage.toBuilder().strictTraceId(false).build().spanConsumer(), trace);\n\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L); \r\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L);\n\n  }\n","realPath":"zipkin-storage/cassandra/src/test/java/zipkin2/storage/cassandra/ITSpanConsumer.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"M"},{"authorDate":"2020-10-18 06:38:49","commitOrder":3,"curCode":"  @Test public void insertTags_SelectTags_CalculateCount() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .putTag(\"environment\", \"dev\")\n      .putTag(\"a\", \"b\")\n      .timestamp(trace[0].timestampAsLong() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n\n    assertThat(rowCountForTags(storage))\n      .isEqualTo(1L); \r\n\n    assertThat(getTagValue(storage, \"environment\")).isEqualTo(\"dev\");\n  }\n","date":"2020-10-18 06:38:49","endLine":125,"groupId":"425","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"insertTags_SelectTags_CalculateCount","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/2a/01b6132da7200e4ce1e5c2c900bf8d488129ef.src","preCode":"  public void insertTags_SelectTags_CalculateCount() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .putTag(\"environment\", \"dev\")\n      .putTag(\"a\", \"b\")\n      .timestamp(\n        trace[0].timestamp() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n\n    assertThat(rowCountForTags(storage))\n      .isEqualTo(1L); \r\n\n    assertThat(getTagValue(storage, \"environment\")).isEqualTo(\"dev\");\n\n  }\n","realPath":"zipkin-storage/cassandra/src/test/java/zipkin2/storage/cassandra/ITSpanConsumer.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":102,"status":"M"}],"commitId":"12cae10958370b64fbbc450ae31c1a0a642114f4","commitMessage":"@@@Refactors Cassandra queries so they are cheaper and easier to migrate (#3243)\n\nBefore.  we used labels a lot.  and generally a lot of query builder code.\nThis switches most to positional syntax.  which is cheaper and easier to\nmigrate to cassandra driver 4.\n\nThis also reformats everything to make the migration feel like less\nchange.\n\nFinally.  this consolidates as much code as possible.  notably repetitive\ninserts and queries.  again to reduce the heft needed to upgrade later.\n","date":"2020-10-18 06:38:49","modifiedFileCount":"72","status":"M","submitter":"Adrian Cole"},{"authorTime":"2020-10-21 10:53:01","codes":[{"authorDate":"2020-10-21 10:53:01","commitOrder":4,"curCode":"  @Test public void skipsRedundantIndexingInATrace(TestInfo testInfo) throws Exception {\n    String testSuffix = testSuffix(testInfo);\n    Span[] trace = new Span[101];\n    trace[0] = newClientSpan(testSuffix).toBuilder().kind(SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(i + 1)\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(trace[0].localEndpoint())\n      .timestamp(trace[0].timestampAsLong() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(trace);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n\n    CassandraSpanConsumer withoutStrictTraceId = new CassandraSpanConsumer(\n      storage.session(), storage.metadata(),\n      false , storage.searchEnabled,\n      storage.autocompleteKeys, storage.autocompleteTtl, storage.autocompleteCardinality\n    );\n\n    \r\n    withoutStrictTraceId.accept(asList(trace)).execute();\n    blockWhileInFlight();\n\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L); \r\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L);\n  }\n","date":"2020-10-21 10:53:01","endLine":92,"groupId":"10349","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"skipsRedundantIndexingInATrace","params":"(TestInfotestInfo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/f5/3b254cd370f3c017d57b7411aefbdccb4b9cd4.src","preCode":"  @Test public void skipsRedundantIndexingInATrace() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .timestamp(\n        trace[0].timestamp() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(4L);\n\n    CassandraSpanConsumer withoutStrictTraceId = new CassandraSpanConsumer(\n      storage.session(), storage.metadata(),\n      false , storage.searchEnabled,\n      storage.autocompleteKeys, storage.autocompleteTtl, storage.autocompleteCardinality\n    );\n\n    \r\n    accept(withoutStrictTraceId, trace);\n\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L); \r\n    assertThat(rowCountForTraceByServiceSpan(storage))\n      .isGreaterThanOrEqualTo(120L);\n  }\n","realPath":"zipkin-storage/cassandra/src/test/java/zipkin2/storage/cassandra/ITSpanConsumer.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"},{"authorDate":"2020-10-21 10:53:01","commitOrder":4,"curCode":"  @Test public void insertTags_SelectTags_CalculateCount(TestInfo testInfo) throws Exception {\n    String testSuffix = testSuffix(testInfo);\n    Span[] trace = new Span[101];\n    trace[0] = newClientSpan(testSuffix).toBuilder().kind(SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(i + 1)\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(trace[0].localEndpoint())\n      .putTag(\"environment\", \"dev\")\n      .putTag(\"a\", \"b\")\n      .timestamp(trace[0].timestampAsLong() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(trace);\n\n    assertThat(rowCountForTags(storage))\n      .isEqualTo(1L); \r\n\n    assertThat(getTagValue(storage, \"environment\")).isEqualTo(\"dev\");\n  }\n","date":"2020-10-21 10:53:01","endLine":118,"groupId":"10349","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"insertTags_SelectTags_CalculateCount","params":"(TestInfotestInfo)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/f5/3b254cd370f3c017d57b7411aefbdccb4b9cd4.src","preCode":"  @Test public void insertTags_SelectTags_CalculateCount() throws IOException {\n    Span[] trace = new Span[101];\n    trace[0] = TestObjects.CLIENT_SPAN.toBuilder().kind(Span.Kind.SERVER).build();\n\n    IntStream.range(0, 100).forEach(i -> trace[i + 1] = Span.newBuilder()\n      .traceId(trace[0].traceId())\n      .parentId(trace[0].id())\n      .id(Long.toHexString(i))\n      .name(\"get\")\n      .kind(Span.Kind.CLIENT)\n      .localEndpoint(FRONTEND)\n      .putTag(\"environment\", \"dev\")\n      .putTag(\"a\", \"b\")\n      .timestamp(trace[0].timestampAsLong() + i * 1000) \r\n      .duration(10L)\n      .build());\n\n    accept(storage.spanConsumer(), trace);\n\n    assertThat(rowCountForTags(storage))\n      .isEqualTo(1L); \r\n\n    assertThat(getTagValue(storage, \"environment\")).isEqualTo(\"dev\");\n  }\n","realPath":"zipkin-storage/cassandra/src/test/java/zipkin2/storage/cassandra/ITSpanConsumer.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"}],"commitId":"eeb17681af780e563b44503d5af1eadb3ca6abfc","commitMessage":"@@@Refactors integration tests to be more isolated (#3249)\n\nThis makes all integration tests use unique data. Notably.  they no\nlonger use constant trace ID or service names.  as this can lead to\ndifficulty when a keyspace is re-used. For example.  service names and\ntrace IDs are often partitions. When debugging it is easier when test\ndata is isolated by a service name as it can be easily queried.\n\nThis also pulls the heaviest tests into their own classes so that they\ndon't overload the storage containers used by the bulk of our tests.\n\nFinally.  this fixes a few glitches in the v1 cassandra storage.","date":"2020-10-21 10:53:01","modifiedFileCount":"46","status":"M","submitter":"Adrian Cole"}]
