[{"authorTime":"2019-04-14 16:15:45","codes":[{"authorDate":"2019-04-14 16:15:45","commitOrder":4,"curCode":"  @Override public Call<List<String>> getServiceNames() {\n    if (!searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest request = SearchRequest.create(indices)\n      .filters(new SearchRequest.Filters().addRange(\"timestamp_millis\", beginMillis, endMillis))\n      .addAggregation(Aggregation.terms(\"localEndpoint.serviceName\", Integer.MAX_VALUE));\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","date":"2019-04-14 16:15:45","endLine":145,"groupId":"774","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getServiceNames","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/9d/451bbdf12c7c696c1611d3d7f98887debc68a0.src","preCode":"  @Override public Call<List<String>> getServiceNames() {\n    if (!searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest request = SearchRequest.create(indices)\n      .filters(new SearchRequest.Filters().addRange(\"timestamp_millis\", beginMillis, endMillis))\n      .addAggregation(Aggregation.terms(\"localEndpoint.serviceName\", Integer.MAX_VALUE));\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"MB"},{"authorDate":"2019-04-14 16:15:45","commitOrder":4,"curCode":"  Call<List<String>> aggregatedFieldByServiceName(String serviceName, String term) {\n    if (serviceName.isEmpty() || !searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    \r\n    SearchRequest.Filters filters = new SearchRequest.Filters()\n      .addRange(\"timestamp_millis\", beginMillis, endMillis)\n      .addTerm(\"localEndpoint.serviceName\", serviceName.toLowerCase(Locale.ROOT));\n\n    SearchRequest request = SearchRequest.create(indices).filters(filters)\n      .addAggregation(Aggregation.terms(term, Integer.MAX_VALUE));\n\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","date":"2019-04-14 16:15:45","endLine":173,"groupId":"2743","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"aggregatedFieldByServiceName","params":"(StringserviceName@Stringterm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/9d/451bbdf12c7c696c1611d3d7f98887debc68a0.src","preCode":"  Call<List<String>> aggregatedFieldByServiceName(String serviceName, String term) {\n    if (serviceName.isEmpty() || !searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    \r\n    SearchRequest.Filters filters = new SearchRequest.Filters()\n      .addRange(\"timestamp_millis\", beginMillis, endMillis)\n      .addTerm(\"localEndpoint.serviceName\", serviceName.toLowerCase(Locale.ROOT));\n\n    SearchRequest request = SearchRequest.create(indices).filters(filters)\n      .addAggregation(Aggregation.terms(term, Integer.MAX_VALUE));\n\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"B"}],"commitId":"b8646142fa15c8c5f47ff2a2a48dc663c7bb65b3","commitMessage":"@@@De-conflate local from remote service names (#2484)\n\nEspecially mentioned in #1794.  local and remote service names are undeniably serving different use cases.  yet currently conflated in the api.\n\n/services -> only local serviceNames\n/remoteServices?serviceName=X -> new: only remote serviceNames for auto-complete\n/spans?remoteServiceName=X -> new: to restore functionality @llinder mentioned","date":"2019-04-14 16:15:45","modifiedFileCount":"67","status":"M","submitter":"Adrian Cole"},{"authorTime":"2019-10-01 19:13:42","codes":[{"authorDate":"2019-10-01 19:13:42","commitOrder":5,"curCode":"  @Override public Call<List<String>> getServiceNames() {\n    if (!searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(TYPE_SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest request = SearchRequest.create(indices)\n      .filters(new SearchRequest.Filters().addRange(\"timestamp_millis\", beginMillis, endMillis))\n      .addAggregation(Aggregation.terms(\"localEndpoint.serviceName\", Integer.MAX_VALUE));\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","date":"2019-10-01 19:13:42","endLine":165,"groupId":"10417","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"getServiceNames","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/e5/47ee5233b1ee038b70960dee16ab373e7b4b9b.src","preCode":"  @Override public Call<List<String>> getServiceNames() {\n    if (!searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest request = SearchRequest.create(indices)\n      .filters(new SearchRequest.Filters().addRange(\"timestamp_millis\", beginMillis, endMillis))\n      .addAggregation(Aggregation.terms(\"localEndpoint.serviceName\", Integer.MAX_VALUE));\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":152,"status":"M"},{"authorDate":"2019-10-01 19:13:42","commitOrder":5,"curCode":"  Call<List<String>> aggregatedFieldByServiceName(String serviceName, String term) {\n    if (serviceName.isEmpty() || !searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(TYPE_SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    \r\n    SearchRequest.Filters filters = new SearchRequest.Filters()\n      .addRange(\"timestamp_millis\", beginMillis, endMillis)\n      .addTerm(\"localEndpoint.serviceName\", serviceName.toLowerCase(Locale.ROOT));\n\n    SearchRequest request = SearchRequest.create(indices).filters(filters)\n      .addAggregation(Aggregation.terms(term, Integer.MAX_VALUE));\n\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","date":"2019-10-01 19:13:42","endLine":193,"groupId":"10417","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"aggregatedFieldByServiceName","params":"(StringserviceName@Stringterm)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/e5/47ee5233b1ee038b70960dee16ab373e7b4b9b.src","preCode":"  Call<List<String>> aggregatedFieldByServiceName(String serviceName, String term) {\n    if (serviceName.isEmpty() || !searchEnabled) return Call.emptyList();\n\n    long endMillis = System.currentTimeMillis();\n    long beginMillis = endMillis - namesLookback;\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    \r\n    SearchRequest.Filters filters = new SearchRequest.Filters()\n      .addRange(\"timestamp_millis\", beginMillis, endMillis)\n      .addTerm(\"localEndpoint.serviceName\", serviceName.toLowerCase(Locale.ROOT));\n\n    SearchRequest request = SearchRequest.create(indices).filters(filters)\n      .addAggregation(Aggregation.terms(term, Integer.MAX_VALUE));\n\n    return search.newCall(request, BodyConverters.KEYS);\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":175,"status":"M"}],"commitId":"797f36d0ab169173d43de5de1cb7e7bd98dcd39a","commitMessage":"@@@Ensures index templates are verified before passing health. (#2827)\n\nCurrently.  we pass health checks which can hide errors provisioning\nindex templates.  and also worsen template provisioning race conditions.\n\nThis makes sure index templates are at least checked once per startup.\n\nThis also refactors the code so that someone can later do offline\ntemplate installation.\n\nFixes #2825","date":"2019-10-01 19:13:42","modifiedFileCount":"11","status":"M","submitter":"Adrian Cole"}]
