[{"authorTime":"2018-07-02 17:25:49","codes":[{"authorDate":"2018-07-02 16:40:04","commitOrder":2,"curCode":"  @Override public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    Call<List<List<Span>>> result =\n      dataSourceCallFactory\n        .create(selectFromSpansAndAnnotationsFactory.create(request))\n        .map(groupByTraceId);\n\n    return strictTraceId ? result.map(StrictTraceId.filterTraces(request)) : result;\n  }\n","date":"2019-09-19 10:56:54","endLine":59,"groupId":"981","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getTraces","params":"(QueryRequestrequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/9c/a938bb4a8a795fa5211f89288b30dcc3cba430.src","preCode":"  @Override public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    Call<List<List<Span>>> result =\n      dataSourceCallFactory\n        .create(selectFromSpansAndAnnotationsFactory.create(request))\n        .map(groupByTraceId);\n\n    return strictTraceId ? result.map(StrictTraceId.filterTraces(request)) : result;\n  }\n","realPath":"zipkin-storage/mysql-v1/src/main/java/zipkin2/storage/mysql/v1/MySQLSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"NB"},{"authorDate":"2018-07-02 17:25:49","commitOrder":2,"curCode":"  public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    long endMillis = request.endTs();\n    long beginMillis = Math.max(endMillis - request.lookback(), EARLIEST_MS);\n\n    SearchRequest.Filters filters = new SearchRequest.Filters();\n    filters.addRange(\"timestamp_millis\", beginMillis, endMillis);\n    if (request.serviceName() != null) {\n      filters.addTerm(\"localEndpoint.serviceName\", request.serviceName());\n    }\n\n    if (request.remoteServiceName() != null) {\n      filters.addTerm(\"remoteEndpoint.serviceName\", request.remoteServiceName());\n    }\n\n    if (request.spanName() != null) {\n      filters.addTerm(\"name\", request.spanName());\n    }\n\n    for (Map.Entry<String, String> kv : request.annotationQuery().entrySet()) {\n      if (kv.getValue().isEmpty()) {\n        filters.addTerm(\"_q\", kv.getKey());\n      } else {\n        filters.addTerm(\"_q\", kv.getKey() + \"=\" + kv.getValue());\n      }\n    }\n\n    if (request.minDuration() != null) {\n      filters.addRange(\"duration\", request.minDuration(), request.maxDuration());\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    Aggregation traceIdTimestamp =\n      Aggregation.terms(\"traceId\", request.limit())\n        .addSubAggregation(Aggregation.min(\"timestamp_millis\"))\n        .orderBy(\"timestamp_millis\", \"desc\");\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest esRequest =\n      SearchRequest.create(indices).filters(filters).addAggregation(traceIdTimestamp);\n\n    HttpCall<List<String>> traceIdsCall = search.newCall(esRequest, BodyConverters.KEYS);\n\n    Call<List<List<Span>>> result =\n      traceIdsCall.flatMap(new GetSpansByTraceId(search, indices)).map(groupByTraceId);\n    \r\n    \r\n    return strictTraceId ? result.map(StrictTraceId.filterTraces(request)) : result;\n  }\n","date":"2019-09-19 10:56:54","endLine":121,"groupId":"17","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getTraces","params":"(QueryRequestrequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/9b/c0beb16fa6471c93511b7c00cc2877226b8247.src","preCode":"  public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    long endMillis = request.endTs();\n    long beginMillis = Math.max(endMillis - request.lookback(), EARLIEST_MS);\n\n    SearchRequest.Filters filters = new SearchRequest.Filters();\n    filters.addRange(\"timestamp_millis\", beginMillis, endMillis);\n    if (request.serviceName() != null) {\n      filters.addTerm(\"localEndpoint.serviceName\", request.serviceName());\n    }\n\n    if (request.remoteServiceName() != null) {\n      filters.addTerm(\"remoteEndpoint.serviceName\", request.remoteServiceName());\n    }\n\n    if (request.spanName() != null) {\n      filters.addTerm(\"name\", request.spanName());\n    }\n\n    for (Map.Entry<String, String> kv : request.annotationQuery().entrySet()) {\n      if (kv.getValue().isEmpty()) {\n        filters.addTerm(\"_q\", kv.getKey());\n      } else {\n        filters.addTerm(\"_q\", kv.getKey() + \"=\" + kv.getValue());\n      }\n    }\n\n    if (request.minDuration() != null) {\n      filters.addRange(\"duration\", request.minDuration(), request.maxDuration());\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    Aggregation traceIdTimestamp =\n      Aggregation.terms(\"traceId\", request.limit())\n        .addSubAggregation(Aggregation.min(\"timestamp_millis\"))\n        .orderBy(\"timestamp_millis\", \"desc\");\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest esRequest =\n      SearchRequest.create(indices).filters(filters).addAggregation(traceIdTimestamp);\n\n    HttpCall<List<String>> traceIdsCall = search.newCall(esRequest, BodyConverters.KEYS);\n\n    Call<List<List<Span>>> result =\n      traceIdsCall.flatMap(new GetSpansByTraceId(search, indices)).map(groupByTraceId);\n    \r\n    \r\n    return strictTraceId ? result.map(StrictTraceId.filterTraces(request)) : result;\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"B"}],"commitId":"a2f49c6685ea31e8ac5d08b99e21b76272659c43","commitMessage":"@@@Adds getByTraceIds to elasticsearch\n","date":"2019-09-19 10:56:54","modifiedFileCount":"3","status":"M","submitter":"Raja Sundaram"},{"authorTime":"2019-10-01 19:13:42","codes":[{"authorDate":"2018-07-02 16:40:04","commitOrder":3,"curCode":"  @Override public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    Call<List<List<Span>>> result =\n      dataSourceCallFactory\n        .create(selectFromSpansAndAnnotationsFactory.create(request))\n        .map(groupByTraceId);\n\n    return strictTraceId ? result.map(StrictTraceId.filterTraces(request)) : result;\n  }\n","date":"2019-09-19 10:56:54","endLine":59,"groupId":"12333","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getTraces","params":"(QueryRequestrequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/9c/a938bb4a8a795fa5211f89288b30dcc3cba430.src","preCode":"  @Override public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    Call<List<List<Span>>> result =\n      dataSourceCallFactory\n        .create(selectFromSpansAndAnnotationsFactory.create(request))\n        .map(groupByTraceId);\n\n    return strictTraceId ? result.map(StrictTraceId.filterTraces(request)) : result;\n  }\n","realPath":"zipkin-storage/mysql-v1/src/main/java/zipkin2/storage/mysql/v1/MySQLSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"N"},{"authorDate":"2019-10-01 19:13:42","commitOrder":3,"curCode":"  public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    long endMillis = request.endTs();\n    long beginMillis = Math.max(endMillis - request.lookback(), EARLIEST_MS);\n\n    SearchRequest.Filters filters = new SearchRequest.Filters();\n    filters.addRange(\"timestamp_millis\", beginMillis, endMillis);\n    if (request.serviceName() != null) {\n      filters.addTerm(\"localEndpoint.serviceName\", request.serviceName());\n    }\n\n    if (request.remoteServiceName() != null) {\n      filters.addTerm(\"remoteEndpoint.serviceName\", request.remoteServiceName());\n    }\n\n    if (request.spanName() != null) {\n      filters.addTerm(\"name\", request.spanName());\n    }\n\n    for (Map.Entry<String, String> kv : request.annotationQuery().entrySet()) {\n      if (kv.getValue().isEmpty()) {\n        filters.addTerm(\"_q\", kv.getKey());\n      } else {\n        filters.addTerm(\"_q\", kv.getKey() + \"=\" + kv.getValue());\n      }\n    }\n\n    if (request.minDuration() != null) {\n      filters.addRange(\"duration\", request.minDuration(), request.maxDuration());\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    Aggregation traceIdTimestamp =\n      Aggregation.terms(\"traceId\", request.limit())\n        .addSubAggregation(Aggregation.min(\"timestamp_millis\"))\n        .orderBy(\"timestamp_millis\", \"desc\");\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(TYPE_SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest esRequest =\n      SearchRequest.create(indices).filters(filters).addAggregation(traceIdTimestamp);\n\n    HttpCall<List<String>> traceIdsCall = search.newCall(esRequest, BodyConverters.KEYS);\n\n    Call<List<List<Span>>> result =\n      traceIdsCall.flatMap(new GetSpansByTraceId(search, indices)).map(groupByTraceId);\n    \r\n    \r\n    return strictTraceId ? result.map(StrictTraceId.filterTraces(request)) : result;\n  }\n","date":"2019-10-01 19:13:42","endLine":120,"groupId":"12333","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"getTraces","params":"(QueryRequestrequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zipkin-10-0.7/blobInfo/CC_OUT/blobs/e5/47ee5233b1ee038b70960dee16ab373e7b4b9b.src","preCode":"  public Call<List<List<Span>>> getTraces(QueryRequest request) {\n    if (!searchEnabled) return Call.emptyList();\n\n    long endMillis = request.endTs();\n    long beginMillis = Math.max(endMillis - request.lookback(), EARLIEST_MS);\n\n    SearchRequest.Filters filters = new SearchRequest.Filters();\n    filters.addRange(\"timestamp_millis\", beginMillis, endMillis);\n    if (request.serviceName() != null) {\n      filters.addTerm(\"localEndpoint.serviceName\", request.serviceName());\n    }\n\n    if (request.remoteServiceName() != null) {\n      filters.addTerm(\"remoteEndpoint.serviceName\", request.remoteServiceName());\n    }\n\n    if (request.spanName() != null) {\n      filters.addTerm(\"name\", request.spanName());\n    }\n\n    for (Map.Entry<String, String> kv : request.annotationQuery().entrySet()) {\n      if (kv.getValue().isEmpty()) {\n        filters.addTerm(\"_q\", kv.getKey());\n      } else {\n        filters.addTerm(\"_q\", kv.getKey() + \"=\" + kv.getValue());\n      }\n    }\n\n    if (request.minDuration() != null) {\n      filters.addRange(\"duration\", request.minDuration(), request.maxDuration());\n    }\n\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    Aggregation traceIdTimestamp =\n      Aggregation.terms(\"traceId\", request.limit())\n        .addSubAggregation(Aggregation.min(\"timestamp_millis\"))\n        .orderBy(\"timestamp_millis\", \"desc\");\n\n    List<String> indices = indexNameFormatter.formatTypeAndRange(SPAN, beginMillis, endMillis);\n    if (indices.isEmpty()) return Call.emptyList();\n\n    SearchRequest esRequest =\n      SearchRequest.create(indices).filters(filters).addAggregation(traceIdTimestamp);\n\n    HttpCall<List<String>> traceIdsCall = search.newCall(esRequest, BodyConverters.KEYS);\n\n    Call<List<List<Span>>> result =\n      traceIdsCall.flatMap(new GetSpansByTraceId(search, indices)).map(groupByTraceId);\n    \r\n    \r\n    return strictTraceId ? result.map(StrictTraceId.filterTraces(request)) : result;\n  }\n","realPath":"zipkin-storage/elasticsearch/src/main/java/zipkin2/elasticsearch/ElasticsearchSpanStore.java","repoName":"zipkin","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"}],"commitId":"797f36d0ab169173d43de5de1cb7e7bd98dcd39a","commitMessage":"@@@Ensures index templates are verified before passing health. (#2827)\n\nCurrently.  we pass health checks which can hide errors provisioning\nindex templates.  and also worsen template provisioning race conditions.\n\nThis makes sure index templates are at least checked once per startup.\n\nThis also refactors the code so that someone can later do offline\ntemplate installation.\n\nFixes #2825","date":"2019-10-01 19:13:42","modifiedFileCount":"11","status":"M","submitter":"Adrian Cole"}]
