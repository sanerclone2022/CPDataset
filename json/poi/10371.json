[{"authorTime":"2021-04-08 05:40:33","codes":[{"authorDate":"2021-04-08 05:40:33","commitOrder":1,"curCode":"    public OldTextPieceTable(byte[] documentStream, byte[] tableStream,\n                             int offset, int size, int fcMin, Charset charset) {\n        \r\n        \r\n        PlexOfCps pieceTable = new PlexOfCps(tableStream, offset, size,\n                PieceDescriptor.getSizeInBytes());\n\n        int length = pieceTable.length();\n        PieceDescriptor[] pieces = new PieceDescriptor[length];\n\n        \r\n        \r\n        for (int x = 0; x < length; x++) {\n            GenericPropertyNode node = pieceTable.getProperty(x);\n            pieces[x] = new PieceDescriptor(node.getBytes(), 0, charset);\n        }\n\n        \r\n        \r\n        _cpMin = pieces[0].getFilePosition() - fcMin;\n        for (PieceDescriptor piece : pieces) {\n            int start = piece.getFilePosition() - fcMin;\n            if (start < _cpMin) {\n                _cpMin = start;\n            }\n        }\n\n        \r\n        for (int x = 0; x < pieces.length; x++) {\n            int start = pieces[x].getFilePosition();\n            GenericPropertyNode node = pieceTable.getProperty(x);\n\n            \r\n            int nodeStartChars = node.getStart();\n            int nodeEndChars = node.getEnd();\n\n            \r\n            boolean unicode = pieces[x].isUnicode();\n            int multiple = 1;\n            if (unicode ||\n                    (charset != null && DoubleByteUtil.DOUBLE_BYTE_CHARSETS.contains(charset))) {\n                multiple = 2;\n            }\n\n            \r\n            int textSizeChars = (nodeEndChars - nodeStartChars);\n            int textSizeBytes = textSizeChars * multiple;\n\n            \r\n            byte[] buf = IOUtils.safelyClone(documentStream, start, textSizeBytes, MAX_RECORD_LENGTH);\n\n            \r\n            final TextPiece newTextPiece = newTextPiece(nodeStartChars, nodeEndChars, buf, pieces[x]);\n\n            _textPieces.add(newTextPiece);\n        }\n\n        \r\n        \r\n        Collections.sort(_textPieces);\n        _textPiecesFCOrder = new ArrayList<>(_textPieces);\n        _textPiecesFCOrder.sort(new FCComparator());\n\n    }\n","date":"2021-04-08 05:40:33","endLine":99,"groupId":"20919","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"OldTextPieceTable","params":"(byte[]documentStream@byte[]tableStream@intoffset@intsize@intfcMin@Charsetcharset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-poi-10-0.7/blobInfo/CC_OUT/blobs/e6/a0887f328938f8e3c7d56a2085eed8dbb45d06.src","preCode":"    public OldTextPieceTable(byte[] documentStream, byte[] tableStream,\n                             int offset, int size, int fcMin, Charset charset) {\n        \r\n        \r\n        PlexOfCps pieceTable = new PlexOfCps(tableStream, offset, size,\n                PieceDescriptor.getSizeInBytes());\n\n        int length = pieceTable.length();\n        PieceDescriptor[] pieces = new PieceDescriptor[length];\n\n        \r\n        \r\n        for (int x = 0; x < length; x++) {\n            GenericPropertyNode node = pieceTable.getProperty(x);\n            pieces[x] = new PieceDescriptor(node.getBytes(), 0, charset);\n        }\n\n        \r\n        \r\n        _cpMin = pieces[0].getFilePosition() - fcMin;\n        for (PieceDescriptor piece : pieces) {\n            int start = piece.getFilePosition() - fcMin;\n            if (start < _cpMin) {\n                _cpMin = start;\n            }\n        }\n\n        \r\n        for (int x = 0; x < pieces.length; x++) {\n            int start = pieces[x].getFilePosition();\n            GenericPropertyNode node = pieceTable.getProperty(x);\n\n            \r\n            int nodeStartChars = node.getStart();\n            int nodeEndChars = node.getEnd();\n\n            \r\n            boolean unicode = pieces[x].isUnicode();\n            int multiple = 1;\n            if (unicode ||\n                    (charset != null && DoubleByteUtil.DOUBLE_BYTE_CHARSETS.contains(charset))) {\n                multiple = 2;\n            }\n\n            \r\n            int textSizeChars = (nodeEndChars - nodeStartChars);\n            int textSizeBytes = textSizeChars * multiple;\n\n            \r\n            byte[] buf = IOUtils.safelyClone(documentStream, start, textSizeBytes, MAX_RECORD_LENGTH);\n\n            \r\n            final TextPiece newTextPiece = newTextPiece(nodeStartChars, nodeEndChars, buf, pieces[x]);\n\n            _textPieces.add(newTextPiece);\n        }\n\n        \r\n        \r\n        Collections.sort(_textPieces);\n        _textPiecesFCOrder = new ArrayList<>(_textPieces);\n        _textPiecesFCOrder.sort(new FCComparator());\n\n    }\n","realPath":"poi-scratchpad/src/main/java/org/apache/poi/hwpf/model/OldTextPieceTable.java","repoName":"poi","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"B"},{"authorDate":"2021-04-08 05:40:33","commitOrder":1,"curCode":"    public TextPieceTable(byte[] documentStream, byte[] tableStream,\n                          int offset, int size, int fcMin) {\n        \r\n        PlexOfCps pieceTable = new PlexOfCps(tableStream, offset, size,\n                PieceDescriptor.getSizeInBytes());\n\n        int length = pieceTable.length();\n        PieceDescriptor[] pieces = new PieceDescriptor[length];\n\n        \r\n        \r\n        for (int x = 0; x < length; x++) {\n            GenericPropertyNode node = pieceTable.getProperty(x);\n            pieces[x] = new PieceDescriptor(node.getBytes(), 0);\n        }\n\n        \r\n        \r\n        _cpMin = pieces[0].getFilePosition() - fcMin;\n        for (PieceDescriptor piece : pieces) {\n            int start = piece.getFilePosition() - fcMin;\n            if (start < _cpMin) {\n                _cpMin = start;\n            }\n        }\n\n        \r\n        for (int x = 0; x < pieces.length; x++) {\n            int start = pieces[x].getFilePosition();\n            GenericPropertyNode node = pieceTable.getProperty(x);\n\n            \r\n            int nodeStartChars = node.getStart();\n            int nodeEndChars = node.getEnd();\n\n            \r\n            boolean unicode = pieces[x].isUnicode();\n            int multiple = 1;\n            if (unicode) {\n                multiple = 2;\n            }\n\n            \r\n            int textSizeChars = (nodeEndChars - nodeStartChars);\n            int textSizeBytes = textSizeChars * multiple;\n\n            \r\n            byte[] buf = IOUtils.safelyClone(documentStream, start, textSizeBytes, MAX_RECORD_LENGTH);\n\n            \r\n            final TextPiece newTextPiece = newTextPiece(nodeStartChars, nodeEndChars, buf,\n                    pieces[x]);\n\n            _textPieces.add(newTextPiece);\n        }\n\n        \r\n        \r\n        Collections.sort(_textPieces);\n        _textPiecesFCOrder = new ArrayList<>(_textPieces);\n        _textPiecesFCOrder.sort(new FCComparator());\n    }\n","date":"2021-04-08 05:40:33","endLine":120,"groupId":"18512","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"TextPieceTable","params":"(byte[]documentStream@byte[]tableStream@intoffset@intsize@intfcMin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-poi-10-0.7/blobInfo/CC_OUT/blobs/cd/885b955637bea6f85a6d8e8407809b3fce4689.src","preCode":"    public TextPieceTable(byte[] documentStream, byte[] tableStream,\n                          int offset, int size, int fcMin) {\n        \r\n        PlexOfCps pieceTable = new PlexOfCps(tableStream, offset, size,\n                PieceDescriptor.getSizeInBytes());\n\n        int length = pieceTable.length();\n        PieceDescriptor[] pieces = new PieceDescriptor[length];\n\n        \r\n        \r\n        for (int x = 0; x < length; x++) {\n            GenericPropertyNode node = pieceTable.getProperty(x);\n            pieces[x] = new PieceDescriptor(node.getBytes(), 0);\n        }\n\n        \r\n        \r\n        _cpMin = pieces[0].getFilePosition() - fcMin;\n        for (PieceDescriptor piece : pieces) {\n            int start = piece.getFilePosition() - fcMin;\n            if (start < _cpMin) {\n                _cpMin = start;\n            }\n        }\n\n        \r\n        for (int x = 0; x < pieces.length; x++) {\n            int start = pieces[x].getFilePosition();\n            GenericPropertyNode node = pieceTable.getProperty(x);\n\n            \r\n            int nodeStartChars = node.getStart();\n            int nodeEndChars = node.getEnd();\n\n            \r\n            boolean unicode = pieces[x].isUnicode();\n            int multiple = 1;\n            if (unicode) {\n                multiple = 2;\n            }\n\n            \r\n            int textSizeChars = (nodeEndChars - nodeStartChars);\n            int textSizeBytes = textSizeChars * multiple;\n\n            \r\n            byte[] buf = IOUtils.safelyClone(documentStream, start, textSizeBytes, MAX_RECORD_LENGTH);\n\n            \r\n            final TextPiece newTextPiece = newTextPiece(nodeStartChars, nodeEndChars, buf,\n                    pieces[x]);\n\n            _textPieces.add(newTextPiece);\n        }\n\n        \r\n        \r\n        Collections.sort(_textPieces);\n        _textPiecesFCOrder = new ArrayList<>(_textPieces);\n        _textPiecesFCOrder.sort(new FCComparator());\n    }\n","realPath":"poi-scratchpad/src/main/java/org/apache/poi/hwpf/model/TextPieceTable.java","repoName":"poi","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"B"}],"commitId":"b6aee1ef6d3e92a28ffd4b5c03e677b63b43747f","commitMessage":"@@@65206 - Migrate ant / maven to gradle build\ncompile / jar / test of mrJars\ndon't include ants build.xml anymore\nrename directories to match project and maven artifact names\nrefactor artifacts - so each project has one artifact\nreplace static references in hssf/dev tests with junit5 constructs.  which had problems in parallel tests\nincrease gradle heap to 4gb because of OOM - maybe less would also work\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1888488 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2021-04-08 05:40:33","modifiedFileCount":"0","status":"B","submitter":"Andreas Beeker"},{"authorTime":"2021-05-22 05:22:40","codes":[{"authorDate":"2021-05-22 05:22:40","commitOrder":2,"curCode":"    public OldTextPieceTable(byte[] documentStream, byte[] tableStream,\n                             int offset, int size, int fcMin, Charset charset) {\n        \r\n        \r\n        PlexOfCps pieceTable = new PlexOfCps(tableStream, offset, size,\n                PieceDescriptor.getSizeInBytes());\n\n        int length = pieceTable.length();\n        PieceDescriptor[] pieces = new PieceDescriptor[length];\n\n        \r\n        \r\n        for (int x = 0; x < length; x++) {\n            GenericPropertyNode node = pieceTable.getProperty(x);\n            pieces[x] = new PieceDescriptor(node.getBytes(), 0, charset);\n        }\n\n        \r\n        \r\n        _cpMin = pieces[0].getFilePosition() - fcMin;\n        for (PieceDescriptor piece : pieces) {\n            int start = piece.getFilePosition() - fcMin;\n            if (start < _cpMin) {\n                _cpMin = start;\n            }\n        }\n\n        \r\n        for (int x = 0; x < pieces.length; x++) {\n            int start = pieces[x].getFilePosition();\n            GenericPropertyNode node = pieceTable.getProperty(x);\n\n            \r\n            int nodeStartChars = node.getStart();\n            int nodeEndChars = node.getEnd();\n\n            \r\n            boolean unicode = pieces[x].isUnicode();\n            int multiple = 1;\n            if (unicode ||\n                    (charset != null && DoubleByteUtil.DOUBLE_BYTE_CHARSETS.contains(charset))) {\n                multiple = 2;\n            }\n\n            \r\n            int textSizeChars = (nodeEndChars - nodeStartChars);\n            int textSizeBytes = textSizeChars * multiple;\n\n            \r\n            byte[] buf = IOUtils.safelyClone(documentStream, start, textSizeBytes, MAX_RECORD_LENGTH);\n\n            \r\n            final TextPiece newTextPiece = newTextPiece(nodeStartChars, nodeEndChars, buf, pieces[x]);\n\n            _textPieces.add(newTextPiece);\n        }\n\n        \r\n        \r\n        Collections.sort(_textPieces);\n        _textPiecesFCOrder = new ArrayList<>(_textPieces);\n        _textPiecesFCOrder.sort(byFilePosition());\n\n    }\n","date":"2021-05-22 05:22:40","endLine":99,"groupId":"10371","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"OldTextPieceTable","params":"(byte[]documentStream@byte[]tableStream@intoffset@intsize@intfcMin@Charsetcharset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-poi-10-0.7/blobInfo/CC_OUT/blobs/47/8af6a272719cf9648a99b46d23f4992e401f33.src","preCode":"    public OldTextPieceTable(byte[] documentStream, byte[] tableStream,\n                             int offset, int size, int fcMin, Charset charset) {\n        \r\n        \r\n        PlexOfCps pieceTable = new PlexOfCps(tableStream, offset, size,\n                PieceDescriptor.getSizeInBytes());\n\n        int length = pieceTable.length();\n        PieceDescriptor[] pieces = new PieceDescriptor[length];\n\n        \r\n        \r\n        for (int x = 0; x < length; x++) {\n            GenericPropertyNode node = pieceTable.getProperty(x);\n            pieces[x] = new PieceDescriptor(node.getBytes(), 0, charset);\n        }\n\n        \r\n        \r\n        _cpMin = pieces[0].getFilePosition() - fcMin;\n        for (PieceDescriptor piece : pieces) {\n            int start = piece.getFilePosition() - fcMin;\n            if (start < _cpMin) {\n                _cpMin = start;\n            }\n        }\n\n        \r\n        for (int x = 0; x < pieces.length; x++) {\n            int start = pieces[x].getFilePosition();\n            GenericPropertyNode node = pieceTable.getProperty(x);\n\n            \r\n            int nodeStartChars = node.getStart();\n            int nodeEndChars = node.getEnd();\n\n            \r\n            boolean unicode = pieces[x].isUnicode();\n            int multiple = 1;\n            if (unicode ||\n                    (charset != null && DoubleByteUtil.DOUBLE_BYTE_CHARSETS.contains(charset))) {\n                multiple = 2;\n            }\n\n            \r\n            int textSizeChars = (nodeEndChars - nodeStartChars);\n            int textSizeBytes = textSizeChars * multiple;\n\n            \r\n            byte[] buf = IOUtils.safelyClone(documentStream, start, textSizeBytes, MAX_RECORD_LENGTH);\n\n            \r\n            final TextPiece newTextPiece = newTextPiece(nodeStartChars, nodeEndChars, buf, pieces[x]);\n\n            _textPieces.add(newTextPiece);\n        }\n\n        \r\n        \r\n        Collections.sort(_textPieces);\n        _textPiecesFCOrder = new ArrayList<>(_textPieces);\n        _textPiecesFCOrder.sort(new FCComparator());\n\n    }\n","realPath":"poi-scratchpad/src/main/java/org/apache/poi/hwpf/model/OldTextPieceTable.java","repoName":"poi","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2021-05-22 05:22:40","commitOrder":2,"curCode":"    public TextPieceTable(byte[] documentStream, byte[] tableStream,\n                          int offset, int size, int fcMin) {\n        \r\n        PlexOfCps pieceTable = new PlexOfCps(tableStream, offset, size,\n                PieceDescriptor.getSizeInBytes());\n\n        int length = pieceTable.length();\n        PieceDescriptor[] pieces = new PieceDescriptor[length];\n\n        \r\n        \r\n        for (int x = 0; x < length; x++) {\n            GenericPropertyNode node = pieceTable.getProperty(x);\n            pieces[x] = new PieceDescriptor(node.getBytes(), 0);\n        }\n\n        \r\n        \r\n        _cpMin = pieces[0].getFilePosition() - fcMin;\n        for (PieceDescriptor piece : pieces) {\n            int start = piece.getFilePosition() - fcMin;\n            if (start < _cpMin) {\n                _cpMin = start;\n            }\n        }\n\n        \r\n        for (int x = 0; x < pieces.length; x++) {\n            int start = pieces[x].getFilePosition();\n            GenericPropertyNode node = pieceTable.getProperty(x);\n\n            \r\n            int nodeStartChars = node.getStart();\n            int nodeEndChars = node.getEnd();\n\n            \r\n            boolean unicode = pieces[x].isUnicode();\n            int multiple = 1;\n            if (unicode) {\n                multiple = 2;\n            }\n\n            \r\n            int textSizeChars = (nodeEndChars - nodeStartChars);\n            int textSizeBytes = textSizeChars * multiple;\n\n            \r\n            byte[] buf = IOUtils.safelyClone(documentStream, start, textSizeBytes, MAX_RECORD_LENGTH);\n\n            \r\n            final TextPiece newTextPiece = newTextPiece(nodeStartChars, nodeEndChars, buf,\n                    pieces[x]);\n\n            _textPieces.add(newTextPiece);\n        }\n\n        \r\n        \r\n        Collections.sort(_textPieces);\n        _textPiecesFCOrder = new ArrayList<>(_textPieces);\n        _textPiecesFCOrder.sort(byFilePosition());\n    }\n","date":"2021-05-22 05:22:40","endLine":117,"groupId":"10371","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"TextPieceTable","params":"(byte[]documentStream@byte[]tableStream@intoffset@intsize@intfcMin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-poi-10-0.7/blobInfo/CC_OUT/blobs/5f/8c4da5ee415ea8c0419f8d620b736bbaf5df11.src","preCode":"    public TextPieceTable(byte[] documentStream, byte[] tableStream,\n                          int offset, int size, int fcMin) {\n        \r\n        PlexOfCps pieceTable = new PlexOfCps(tableStream, offset, size,\n                PieceDescriptor.getSizeInBytes());\n\n        int length = pieceTable.length();\n        PieceDescriptor[] pieces = new PieceDescriptor[length];\n\n        \r\n        \r\n        for (int x = 0; x < length; x++) {\n            GenericPropertyNode node = pieceTable.getProperty(x);\n            pieces[x] = new PieceDescriptor(node.getBytes(), 0);\n        }\n\n        \r\n        \r\n        _cpMin = pieces[0].getFilePosition() - fcMin;\n        for (PieceDescriptor piece : pieces) {\n            int start = piece.getFilePosition() - fcMin;\n            if (start < _cpMin) {\n                _cpMin = start;\n            }\n        }\n\n        \r\n        for (int x = 0; x < pieces.length; x++) {\n            int start = pieces[x].getFilePosition();\n            GenericPropertyNode node = pieceTable.getProperty(x);\n\n            \r\n            int nodeStartChars = node.getStart();\n            int nodeEndChars = node.getEnd();\n\n            \r\n            boolean unicode = pieces[x].isUnicode();\n            int multiple = 1;\n            if (unicode) {\n                multiple = 2;\n            }\n\n            \r\n            int textSizeChars = (nodeEndChars - nodeStartChars);\n            int textSizeBytes = textSizeChars * multiple;\n\n            \r\n            byte[] buf = IOUtils.safelyClone(documentStream, start, textSizeBytes, MAX_RECORD_LENGTH);\n\n            \r\n            final TextPiece newTextPiece = newTextPiece(nodeStartChars, nodeEndChars, buf,\n                    pieces[x]);\n\n            _textPieces.add(newTextPiece);\n        }\n\n        \r\n        \r\n        Collections.sort(_textPieces);\n        _textPiecesFCOrder = new ArrayList<>(_textPieces);\n        _textPiecesFCOrder.sort(new FCComparator());\n    }\n","realPath":"poi-scratchpad/src/main/java/org/apache/poi/hwpf/model/TextPieceTable.java","repoName":"poi","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"}],"commitId":"7eaca60a1a364ce6e232363d27823e971a992705","commitMessage":"@@@activate javadoc lint and fix errors\nadd signing and checksum generation\nadd slf4j-bridge for tests\nadd dependencies to ooxml-lite\nfix complex enum classes\nadd override annotations\nmove gradle logic to root build\ngenerate javadoc in its own dist directory.  because JPMS complains about duplicate modules otherwise\n\ngit-svn-id: https://svn.apache.org/repos/asf/poi/trunk@1890089 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2021-05-22 05:22:40","modifiedFileCount":"164","status":"M","submitter":"Andreas Beeker"}]
