[{"authorTime":"2019-10-05 10:49:53","codes":[{"authorDate":"2019-10-05 10:49:53","commitOrder":1,"curCode":"    public void shouldUpdateCachesWhenNotified() {\n        cacheByKey = new ConcurrentHashMap<>();\n        configItemKeyedByName = new ConcurrentHashMap<>();\n        Whitebox.setInternalState(register, \"cachesByKey\", cacheByKey);\n        Whitebox.setInternalState(register, \"configItemKeyedByName\", configItemKeyedByName);\n\n        KVCache cache1 = mock(KVCache.class);\n        KVCache cache2 = mock(KVCache.class);\n\n        ArgumentCaptor<ConsulCache.Listener> listener1 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n        ArgumentCaptor<ConsulCache.Listener> listener2 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n\n        PowerMockito.mockStatic(KVCache.class);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key1\"))).thenReturn(cache1);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key2\"))).thenReturn(cache2);\n\n        when(register.readConfig(any(Set.class))).thenCallRealMethod();\n\n        register.readConfig(Sets.newHashSet(\"key1\", \"key2\"));\n\n        verify(cache1).addListener(listener1.capture());\n        verify(cache2).addListener(listener2.capture());\n\n        listener1.getValue().notify(\n            ImmutableMap.of(\n                \"key1\",\n                ImmutableValue\n                    .builder()\n                    .createIndex(0)\n                    .modifyIndex(0)\n                    .lockIndex(0)\n                    .key(\"key1\")\n                    .flags(0)\n                    .value(BaseEncoding.base64().encode(\"val1\".getBytes()))\n                    .build())\n        );\n        listener2.getValue().notify(\n            ImmutableMap.of(\n                \"key2\",\n                ImmutableValue\n                    .builder()\n                    .createIndex(0)\n                    .modifyIndex(0)\n                    .lockIndex(0)\n                    .key(\"key2\")\n                    .flags(0)\n                    .value(BaseEncoding.base64().encode(\"val2\".getBytes()))\n                    .build())\n        );\n\n        assertEquals(2, configItemKeyedByName.size());\n        assertEquals(\"val1\", configItemKeyedByName.get(\"key1\").get());\n        assertEquals(\"val2\", configItemKeyedByName.get(\"key2\").get());\n    }\n","date":"2019-10-05 10:49:53","endLine":121,"groupId":"6490","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"shouldUpdateCachesWhenNotified","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/a4/1a2005d6f51cbf4944812f5287e5544ab91644.src","preCode":"    public void shouldUpdateCachesWhenNotified() {\n        cacheByKey = new ConcurrentHashMap<>();\n        configItemKeyedByName = new ConcurrentHashMap<>();\n        Whitebox.setInternalState(register, \"cachesByKey\", cacheByKey);\n        Whitebox.setInternalState(register, \"configItemKeyedByName\", configItemKeyedByName);\n\n        KVCache cache1 = mock(KVCache.class);\n        KVCache cache2 = mock(KVCache.class);\n\n        ArgumentCaptor<ConsulCache.Listener> listener1 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n        ArgumentCaptor<ConsulCache.Listener> listener2 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n\n        PowerMockito.mockStatic(KVCache.class);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key1\"))).thenReturn(cache1);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key2\"))).thenReturn(cache2);\n\n        when(register.readConfig(any(Set.class))).thenCallRealMethod();\n\n        register.readConfig(Sets.newHashSet(\"key1\", \"key2\"));\n\n        verify(cache1).addListener(listener1.capture());\n        verify(cache2).addListener(listener2.capture());\n\n        listener1.getValue().notify(\n            ImmutableMap.of(\n                \"key1\",\n                ImmutableValue\n                    .builder()\n                    .createIndex(0)\n                    .modifyIndex(0)\n                    .lockIndex(0)\n                    .key(\"key1\")\n                    .flags(0)\n                    .value(BaseEncoding.base64().encode(\"val1\".getBytes()))\n                    .build())\n        );\n        listener2.getValue().notify(\n            ImmutableMap.of(\n                \"key2\",\n                ImmutableValue\n                    .builder()\n                    .createIndex(0)\n                    .modifyIndex(0)\n                    .lockIndex(0)\n                    .key(\"key2\")\n                    .flags(0)\n                    .value(BaseEncoding.base64().encode(\"val2\".getBytes()))\n                    .build())\n        );\n\n        assertEquals(2, configItemKeyedByName.size());\n        assertEquals(\"val1\", configItemKeyedByName.get(\"key1\").get());\n        assertEquals(\"val2\", configItemKeyedByName.get(\"key2\").get());\n    }\n","realPath":"oap-server/server-configuration/configuration-consul/src/test/java/org/apache/skywalking/oap/server/configuration/consul/ConsulConfigurationWatcherRegisterTest.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"B"},{"authorDate":"2019-10-05 10:49:53","commitOrder":1,"curCode":"    public void shouldUnsubscribeWhenKeyRemoved() {\n        cacheByKey = new ConcurrentHashMap<>();\n        KVCache existedCache = mock(KVCache.class);\n        cacheByKey.put(\"existedKey\", existedCache);\n\n        configItemKeyedByName = new ConcurrentHashMap<>();\n        Whitebox.setInternalState(register, \"cachesByKey\", cacheByKey);\n        Whitebox.setInternalState(register, \"configItemKeyedByName\", configItemKeyedByName);\n\n        KVCache cache1 = mock(KVCache.class);\n        KVCache cache2 = mock(KVCache.class);\n\n        ArgumentCaptor<ConsulCache.Listener> listener1 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n        ArgumentCaptor<ConsulCache.Listener> listener2 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n\n        PowerMockito.mockStatic(KVCache.class);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key1\"))).thenReturn(cache1);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key2\"))).thenReturn(cache2);\n\n        when(register.readConfig(any(Set.class))).thenCallRealMethod();\n\n        register.readConfig(Sets.newHashSet(\"key1\", \"key2\"));\n\n        verify(cache1).addListener(listener1.capture());\n        verify(cache2).addListener(listener2.capture());\n        verify(existedCache).stop();\n    }\n","date":"2019-10-05 10:49:53","endLine":150,"groupId":"6490","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"shouldUnsubscribeWhenKeyRemoved","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/a4/1a2005d6f51cbf4944812f5287e5544ab91644.src","preCode":"    public void shouldUnsubscribeWhenKeyRemoved() {\n        cacheByKey = new ConcurrentHashMap<>();\n        KVCache existedCache = mock(KVCache.class);\n        cacheByKey.put(\"existedKey\", existedCache);\n\n        configItemKeyedByName = new ConcurrentHashMap<>();\n        Whitebox.setInternalState(register, \"cachesByKey\", cacheByKey);\n        Whitebox.setInternalState(register, \"configItemKeyedByName\", configItemKeyedByName);\n\n        KVCache cache1 = mock(KVCache.class);\n        KVCache cache2 = mock(KVCache.class);\n\n        ArgumentCaptor<ConsulCache.Listener> listener1 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n        ArgumentCaptor<ConsulCache.Listener> listener2 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n\n        PowerMockito.mockStatic(KVCache.class);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key1\"))).thenReturn(cache1);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key2\"))).thenReturn(cache2);\n\n        when(register.readConfig(any(Set.class))).thenCallRealMethod();\n\n        register.readConfig(Sets.newHashSet(\"key1\", \"key2\"));\n\n        verify(cache1).addListener(listener1.capture());\n        verify(cache2).addListener(listener2.capture());\n        verify(existedCache).stop();\n    }\n","realPath":"oap-server/server-configuration/configuration-consul/src/test/java/org/apache/skywalking/oap/server/configuration/consul/ConsulConfigurationWatcherRegisterTest.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"B"}],"commitId":"81f4c087b01bee72ddd79b2dfb9c995359b5708e","commitMessage":"@@@Provide Consul dynamic configuration center implementation (#3560)\n\n* Provide Consul dynamic configuration center implementation\n\n* Add more unit tests\n\n* Fix unit test\n\n* Add more unit tests and remove unused file\n\n* Remove redundant doc\n","date":"2019-10-05 10:49:53","modifiedFileCount":"1","status":"B","submitter":"kezhenxu94"},{"authorTime":"2020-09-29 10:34:21","codes":[{"authorDate":"2020-09-29 10:34:21","commitOrder":2,"curCode":"    public void shouldUpdateCachesWhenNotified() {\n        cacheByKey = new ConcurrentHashMap<>();\n        configItemKeyedByName = new ConcurrentHashMap<>();\n        Whitebox.setInternalState(register, \"cachesByKey\", cacheByKey);\n        Whitebox.setInternalState(register, \"configItemKeyedByName\", configItemKeyedByName);\n\n        KVCache cache1 = mock(KVCache.class);\n        KVCache cache2 = mock(KVCache.class);\n\n        ArgumentCaptor<ConsulCache.Listener> listener1 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n        ArgumentCaptor<ConsulCache.Listener> listener2 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n\n        PowerMockito.mockStatic(KVCache.class);\n        PowerMockito.when(KVCache.newCache(any(), eq(\"key1\"))).thenReturn(cache1);\n        PowerMockito.when(KVCache.newCache(any(), eq(\"key2\"))).thenReturn(cache2);\n\n        when(register.readConfig(any(Set.class))).thenCallRealMethod();\n\n        register.readConfig(Sets.newHashSet(\"key1\", \"key2\"));\n\n        verify(cache1).addListener(listener1.capture());\n        verify(cache2).addListener(listener2.capture());\n\n        listener1.getValue()\n                 .notify(ImmutableMap.of(\"key1\", ImmutableValue.builder()\n                                                               .createIndex(0)\n                                                               .modifyIndex(0)\n                                                               .lockIndex(0)\n                                                               .key(\"key1\")\n                                                               .flags(0)\n                                                               .value(BaseEncoding.base64().encode(\"val1\".getBytes()))\n                                                               .build()));\n        listener2.getValue()\n                 .notify(ImmutableMap.of(\"key2\", ImmutableValue.builder()\n                                                               .createIndex(0)\n                                                               .modifyIndex(0)\n                                                               .lockIndex(0)\n                                                               .key(\"key2\")\n                                                               .flags(0)\n                                                               .value(BaseEncoding.base64().encode(\"val2\".getBytes()))\n                                                               .build()));\n\n        assertEquals(2, configItemKeyedByName.size());\n        assertEquals(\"val1\", configItemKeyedByName.get(\"key1\").get());\n        assertEquals(\"val2\", configItemKeyedByName.get(\"key2\").get());\n    }\n","date":"2020-09-29 10:34:21","endLine":119,"groupId":"10610","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"shouldUpdateCachesWhenNotified","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/34/e6fc37fc2fd2876d9a9e69b71cac5e4e1df298.src","preCode":"    public void shouldUpdateCachesWhenNotified() {\n        cacheByKey = new ConcurrentHashMap<>();\n        configItemKeyedByName = new ConcurrentHashMap<>();\n        Whitebox.setInternalState(register, \"cachesByKey\", cacheByKey);\n        Whitebox.setInternalState(register, \"configItemKeyedByName\", configItemKeyedByName);\n\n        KVCache cache1 = mock(KVCache.class);\n        KVCache cache2 = mock(KVCache.class);\n\n        ArgumentCaptor<ConsulCache.Listener> listener1 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n        ArgumentCaptor<ConsulCache.Listener> listener2 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n\n        PowerMockito.mockStatic(KVCache.class);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key1\"))).thenReturn(cache1);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key2\"))).thenReturn(cache2);\n\n        when(register.readConfig(any(Set.class))).thenCallRealMethod();\n\n        register.readConfig(Sets.newHashSet(\"key1\", \"key2\"));\n\n        verify(cache1).addListener(listener1.capture());\n        verify(cache2).addListener(listener2.capture());\n\n        listener1.getValue()\n                 .notify(ImmutableMap.of(\"key1\", ImmutableValue.builder()\n                                                               .createIndex(0)\n                                                               .modifyIndex(0)\n                                                               .lockIndex(0)\n                                                               .key(\"key1\")\n                                                               .flags(0)\n                                                               .value(BaseEncoding.base64().encode(\"val1\".getBytes()))\n                                                               .build()));\n        listener2.getValue()\n                 .notify(ImmutableMap.of(\"key2\", ImmutableValue.builder()\n                                                               .createIndex(0)\n                                                               .modifyIndex(0)\n                                                               .lockIndex(0)\n                                                               .key(\"key2\")\n                                                               .flags(0)\n                                                               .value(BaseEncoding.base64().encode(\"val2\".getBytes()))\n                                                               .build()));\n\n        assertEquals(2, configItemKeyedByName.size());\n        assertEquals(\"val1\", configItemKeyedByName.get(\"key1\").get());\n        assertEquals(\"val2\", configItemKeyedByName.get(\"key2\").get());\n    }\n","realPath":"oap-server/server-configuration/configuration-consul/src/test/java/org/apache/skywalking/oap/server/configuration/consul/ConsulConfigurationWatcherRegisterTest.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"},{"authorDate":"2020-09-29 10:34:21","commitOrder":2,"curCode":"    public void shouldUnsubscribeWhenKeyRemoved() {\n        cacheByKey = new ConcurrentHashMap<>();\n        KVCache existedCache = mock(KVCache.class);\n        cacheByKey.put(\"existedKey\", existedCache);\n\n        configItemKeyedByName = new ConcurrentHashMap<>();\n        Whitebox.setInternalState(register, \"cachesByKey\", cacheByKey);\n        Whitebox.setInternalState(register, \"configItemKeyedByName\", configItemKeyedByName);\n\n        KVCache cache1 = mock(KVCache.class);\n        KVCache cache2 = mock(KVCache.class);\n\n        ArgumentCaptor<ConsulCache.Listener> listener1 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n        ArgumentCaptor<ConsulCache.Listener> listener2 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n\n        PowerMockito.mockStatic(KVCache.class);\n        PowerMockito.when(KVCache.newCache(any(), eq(\"key1\"))).thenReturn(cache1);\n        PowerMockito.when(KVCache.newCache(any(), eq(\"key2\"))).thenReturn(cache2);\n\n        when(register.readConfig(any(Set.class))).thenCallRealMethod();\n\n        register.readConfig(Sets.newHashSet(\"key1\", \"key2\"));\n\n        verify(cache1).addListener(listener1.capture());\n        verify(cache2).addListener(listener2.capture());\n        verify(existedCache).stop();\n    }\n","date":"2020-09-29 10:34:21","endLine":148,"groupId":"10610","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"shouldUnsubscribeWhenKeyRemoved","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/34/e6fc37fc2fd2876d9a9e69b71cac5e4e1df298.src","preCode":"    public void shouldUnsubscribeWhenKeyRemoved() {\n        cacheByKey = new ConcurrentHashMap<>();\n        KVCache existedCache = mock(KVCache.class);\n        cacheByKey.put(\"existedKey\", existedCache);\n\n        configItemKeyedByName = new ConcurrentHashMap<>();\n        Whitebox.setInternalState(register, \"cachesByKey\", cacheByKey);\n        Whitebox.setInternalState(register, \"configItemKeyedByName\", configItemKeyedByName);\n\n        KVCache cache1 = mock(KVCache.class);\n        KVCache cache2 = mock(KVCache.class);\n\n        ArgumentCaptor<ConsulCache.Listener> listener1 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n        ArgumentCaptor<ConsulCache.Listener> listener2 = ArgumentCaptor.forClass(ConsulCache.Listener.class);\n\n        PowerMockito.mockStatic(KVCache.class);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key1\"))).thenReturn(cache1);\n        PowerMockito.when(KVCache.newCache(any(KeyValueClient.class), eq(\"key2\"))).thenReturn(cache2);\n\n        when(register.readConfig(any(Set.class))).thenCallRealMethod();\n\n        register.readConfig(Sets.newHashSet(\"key1\", \"key2\"));\n\n        verify(cache1).addListener(listener1.capture());\n        verify(cache2).addListener(listener2.capture());\n        verify(existedCache).stop();\n    }\n","realPath":"oap-server/server-configuration/configuration-consul/src/test/java/org/apache/skywalking/oap/server/configuration/consul/ConsulConfigurationWatcherRegisterTest.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"M"}],"commitId":"103cf00672c4ed61b17626314ab2b6b31f1dc9c4","commitMessage":"@@@Support JDK 11 compiling and upgrade dependencies (#5579)\n\n* Upgrade dependencies and make the JDK11 compiling passed.\n\n* Update license and fix license check file.\n\n* Add CI for JDK11 compiling.\n\n* Update doc.\n","date":"2020-09-29 10:34:21","modifiedFileCount":"29","status":"M","submitter":"?? Wu Sheng"}]
