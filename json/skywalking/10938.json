[{"authorTime":"2021-05-07 07:50:03","codes":[{"authorDate":"2021-03-02 22:40:30","commitOrder":4,"curCode":"    public List<ServiceMeshMetric.Builder> analysis(\n        final List<ServiceMeshMetric.Builder> result,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final HTTPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(result)) {\n            return result;\n        }\n        if (!entry.hasCommonProperties()) {\n            return Collections.emptyList();\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Collections.emptyList();\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return Collections.emptyList();\n        }\n\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return result;\n    }\n","date":"2021-03-02 22:40:30","endLine":135,"groupId":"6983","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"analysis","params":"(finalList<ServiceMeshMetric.Builder>result@finalStreamAccessLogsMessage.Identifieridentifier@finalHTTPAccessLogEntryentry@finalRolerole)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/0c/b752e959033431b6270642e73bb2c3501c741e.src","preCode":"    public List<ServiceMeshMetric.Builder> analysis(\n        final List<ServiceMeshMetric.Builder> result,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final HTTPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(result)) {\n            return result;\n        }\n        if (!entry.hasCommonProperties()) {\n            return Collections.emptyList();\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Collections.emptyList();\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return Collections.emptyList();\n        }\n\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return result;\n    }\n","realPath":"oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/mx/MetaExchangeALSHTTPAnalyzer.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"NB"},{"authorDate":"2021-05-07 07:50:03","commitOrder":4,"curCode":"    public List<ServiceMeshMetric.Builder> analysis(\n        final List<ServiceMeshMetric.Builder> result,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final TCPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(result)) {\n            return result;\n        }\n        if (!entry.hasCommonProperties()) {\n            return Collections.emptyList();\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Collections.emptyList();\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return Collections.emptyList();\n        }\n\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return result;\n    }\n","date":"2021-05-07 07:50:03","endLine":134,"groupId":"6983","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"analysis","params":"(finalList<ServiceMeshMetric.Builder>result@finalStreamAccessLogsMessage.Identifieridentifier@finalTCPAccessLogEntryentry@finalRolerole)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/1f/4cdcc317f71591c04836f5c4211ce7b55909ae.src","preCode":"    public List<ServiceMeshMetric.Builder> analysis(\n        final List<ServiceMeshMetric.Builder> result,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final TCPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(result)) {\n            return result;\n        }\n        if (!entry.hasCommonProperties()) {\n            return Collections.emptyList();\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Collections.emptyList();\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return Collections.emptyList();\n        }\n\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return result;\n    }\n","realPath":"oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/tcp/mx/MetaExchangeTCPAccessLogAnalyzer.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"B"}],"commitId":"3b15f8d132284c6eec6bb670341910b640cbc65d","commitMessage":"@@@feature: Envoy access log receiver supports TCP logs (#6727)\n\n","date":"2021-05-07 07:50:03","modifiedFileCount":"17","status":"M","submitter":"Zhenxu Ke"},{"authorTime":"2021-05-07 23:25:20","codes":[{"authorDate":"2021-05-07 23:25:20","commitOrder":5,"curCode":"    public Result analysis(\n        final Result previousResult,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final HTTPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(previousResult.getMetrics())) {\n            return previousResult;\n        }\n        if (!entry.hasCommonProperties()) {\n            return previousResult;\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return previousResult;\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Result.builder().service(currSvc).build();\n        }\n\n        final List<ServiceMeshMetric.Builder> result = new ArrayList<>();\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return Result.builder().metrics(result).service(currSvc).build();\n    }\n","date":"2021-05-07 23:25:20","endLine":136,"groupId":"6983","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"analysis","params":"(finalResultpreviousResult@finalStreamAccessLogsMessage.Identifieridentifier@finalHTTPAccessLogEntryentry@finalRolerole)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/81/a3d106b8df3e2fba22ee2138ca7c83cfb4d542.src","preCode":"    public List<ServiceMeshMetric.Builder> analysis(\n        final List<ServiceMeshMetric.Builder> result,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final HTTPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(result)) {\n            return result;\n        }\n        if (!entry.hasCommonProperties()) {\n            return Collections.emptyList();\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Collections.emptyList();\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return Collections.emptyList();\n        }\n\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return result;\n    }\n","realPath":"oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/mx/MetaExchangeALSHTTPAnalyzer.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"},{"authorDate":"2021-05-07 23:25:20","commitOrder":5,"curCode":"    public Result analysis(\n        final Result previousResult,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final TCPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(previousResult.getMetrics())) {\n            return previousResult;\n        }\n        if (!entry.hasCommonProperties()) {\n            return previousResult;\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return previousResult;\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Result.builder().service(currSvc).build();\n        }\n\n        final List<ServiceMeshMetric.Builder> result = new ArrayList<>();\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return Result.builder().metrics(result).service(currSvc).build();\n    }\n","date":"2021-05-07 23:25:20","endLine":135,"groupId":"6983","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"analysis","params":"(finalResultpreviousResult@finalStreamAccessLogsMessage.Identifieridentifier@finalTCPAccessLogEntryentry@finalRolerole)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/0a/c1db68e591488b8665c583b5e28c0d6a89df06.src","preCode":"    public List<ServiceMeshMetric.Builder> analysis(\n        final List<ServiceMeshMetric.Builder> result,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final TCPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(result)) {\n            return result;\n        }\n        if (!entry.hasCommonProperties()) {\n            return Collections.emptyList();\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Collections.emptyList();\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return Collections.emptyList();\n        }\n\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return result;\n    }\n","realPath":"oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/tcp/mx/MetaExchangeTCPAccessLogAnalyzer.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"}],"commitId":"4103551092b51f733693daa1e7f3e9aba95141e5","commitMessage":"@@@bugfix: Envoy error logs are not persisted when no metrics are generated (#6911)\n\n","date":"2021-05-07 23:25:20","modifiedFileCount":"10","status":"M","submitter":"Zhenxu Ke"},{"authorTime":"2021-05-25 17:33:07","codes":[{"authorDate":"2021-05-25 17:33:07","commitOrder":6,"curCode":"    public Result analysis(\n        final Result previousResult,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final HTTPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(previousResult.getMetrics())) {\n            return previousResult;\n        }\n        if (!entry.hasCommonProperties()) {\n            return previousResult;\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return previousResult;\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Result.builder().service(currSvc).build();\n        }\n\n        final List<ServiceMeshMetric.Builder> result = new ArrayList<>();\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, config.serviceMetaInfoFactory().unknown(), currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return Result.builder().metrics(result).service(currSvc).build();\n    }\n","date":"2021-05-25 17:33:07","endLine":135,"groupId":"10938","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"analysis","params":"(finalResultpreviousResult@finalStreamAccessLogsMessage.Identifieridentifier@finalHTTPAccessLogEntryentry@finalRolerole)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/04/7b89ba528b6bc6a26d2cda7a609215fda7dd41.src","preCode":"    public Result analysis(\n        final Result previousResult,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final HTTPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(previousResult.getMetrics())) {\n            return previousResult;\n        }\n        if (!entry.hasCommonProperties()) {\n            return previousResult;\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return previousResult;\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Result.builder().service(currSvc).build();\n        }\n\n        final List<ServiceMeshMetric.Builder> result = new ArrayList<>();\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return Result.builder().metrics(result).service(currSvc).build();\n    }\n","realPath":"oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/mx/MetaExchangeALSHTTPAnalyzer.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":70,"status":"M"},{"authorDate":"2021-05-25 17:33:07","commitOrder":6,"curCode":"    public Result analysis(\n        final Result previousResult,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final TCPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(previousResult.getMetrics())) {\n            return previousResult;\n        }\n        if (!entry.hasCommonProperties()) {\n            return previousResult;\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return previousResult;\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Result.builder().service(currSvc).build();\n        }\n\n        final List<ServiceMeshMetric.Builder> result = new ArrayList<>();\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, config.serviceMetaInfoFactory().unknown(), currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return Result.builder().metrics(result).service(currSvc).build();\n    }\n","date":"2021-05-25 17:33:07","endLine":134,"groupId":"10938","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"analysis","params":"(finalResultpreviousResult@finalStreamAccessLogsMessage.Identifieridentifier@finalTCPAccessLogEntryentry@finalRolerole)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/20/772be90be4c658af6ed99a2b05c5eb99f08afd.src","preCode":"    public Result analysis(\n        final Result previousResult,\n        final StreamAccessLogsMessage.Identifier identifier,\n        final TCPAccessLogEntry entry,\n        final Role role\n    ) {\n        if (isNotEmpty(previousResult.getMetrics())) {\n            return previousResult;\n        }\n        if (!entry.hasCommonProperties()) {\n            return previousResult;\n        }\n        final ServiceMetaInfo currSvc;\n        try {\n            currSvc = adaptToServiceMetaInfo(identifier);\n        } catch (Exception e) {\n            log.error(\"Failed to inflate the ServiceMetaInfo from identifier.node.metadata. \", e);\n            return previousResult;\n        }\n        final AccessLogCommon properties = entry.getCommonProperties();\n        final Map<String, Any> stateMap = properties.getFilterStateObjectsMap();\n        if (stateMap.isEmpty()) {\n            return Result.builder().service(currSvc).build();\n        }\n\n        final List<ServiceMeshMetric.Builder> result = new ArrayList<>();\n        final AtomicBoolean downstreamExists = new AtomicBoolean();\n        stateMap.forEach((key, value) -> {\n            if (!key.equals(UPSTREAM_KEY) && !key.equals(DOWNSTREAM_KEY)) {\n                return;\n            }\n            final ServiceMetaInfo svc;\n            try {\n                svc = adaptToServiceMetaInfo(value);\n            } catch (Exception e) {\n                log.error(\"Fail to parse metadata {} to FlatNode\", Base64.getEncoder().encode(value.toByteArray()));\n                return;\n            }\n            final ServiceMeshMetric.Builder metrics;\n            switch (key) {\n                case UPSTREAM_KEY:\n                    metrics = newAdapter(entry, currSvc, svc).adaptToUpstreamMetrics().setTlsMode(NON_TLS);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} outbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    break;\n                case DOWNSTREAM_KEY:\n                    metrics = newAdapter(entry, svc, currSvc).adaptToDownstreamMetrics();\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Transformed a {} inbound mesh metrics {}\", role, TextFormat.shortDebugString(metrics));\n                    }\n                    result.add(metrics);\n                    downstreamExists.set(true);\n                    break;\n            }\n        });\n        if (role.equals(Role.PROXY) && !downstreamExists.get()) {\n            final ServiceMeshMetric.Builder metric = newAdapter(entry, UNKNOWN, currSvc).adaptToDownstreamMetrics();\n            if (log.isDebugEnabled()) {\n                log.debug(\"Transformed a {} inbound mesh metric {}\", role, TextFormat.shortDebugString(metric));\n            }\n            result.add(metric);\n        }\n        return Result.builder().metrics(result).service(currSvc).build();\n    }\n","realPath":"oap-server/server-receiver-plugin/envoy-metrics-receiver-plugin/src/main/java/org/apache/skywalking/oap/server/receiver/envoy/als/tcp/mx/MetaExchangeTCPAccessLogAnalyzer.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"}],"commitId":"379c4e1a46ef8c268b2d5c058dc9645b5b9baad3","commitMessage":"@@@Allow multiple definitions as fallback in `k8sServiceNameRule`. (#7006)\n\n","date":"2021-05-25 17:33:07","modifiedFileCount":"10","status":"M","submitter":"Zhenxu Ke"}]
