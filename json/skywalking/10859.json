[{"authorTime":"2020-02-25 10:12:16","codes":[{"authorDate":"2020-02-19 18:00:57","commitOrder":2,"curCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((int) values.get(3));\n            segmentRecord.setEndpointName((String) values.get(4));\n            segmentRecord.setStartTime((long) values.get(5));\n            segmentRecord.setEndTime((long) values.get(6));\n            segmentRecord.setLatency((int) values.get(7));\n            segmentRecord.setIsError((int) values.get(8));\n            segmentRecord.setVersion((int) values.get(10));\n\n            String base64 = (String) values.get(9);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","date":"2020-02-19 18:00:57","endLine":212,"groupId":"6089","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"queryByTraceId","params":"(StringtraceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/6a/d679edb0f18ad77021dce2153abc354a255996.src","preCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((int) values.get(3));\n            segmentRecord.setEndpointName((String) values.get(4));\n            segmentRecord.setStartTime((long) values.get(5));\n            segmentRecord.setEndTime((long) values.get(6));\n            segmentRecord.setLatency((int) values.get(7));\n            segmentRecord.setIsError((int) values.get(8));\n            segmentRecord.setVersion((int) values.get(10));\n\n            String base64 = (String) values.get(9);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/TraceQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":168,"status":"NB"},{"authorDate":"2020-02-25 10:12:16","commitOrder":2,"curCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (series == null || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((int) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","date":"2020-02-25 10:12:16","endLine":191,"groupId":"3474","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getProfiledSegment","params":"(StringsegmentId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/83/bd9a4faccc2ca1c273f12b86eb0693ba8844b8.src","preCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (series == null || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((int) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/ProfileThreadSnapshotQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"B"}],"commitId":"2ea341b890b3c89bc6420e1a59be2b4aa0c8ec75","commitMessage":"@@@Add missed profiled segment query (#4413)\n\n* add profiled segment query\n\n* fix query field error\n","date":"2020-02-25 10:12:16","modifiedFileCount":"9","status":"M","submitter":"mrproliu"},{"authorTime":"2020-04-10 11:03:24","codes":[{"authorDate":"2020-04-10 11:03:24","commitOrder":3,"curCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime((long) values.get(6));\n            segmentRecord.setEndTime((long) values.get(7));\n            segmentRecord.setLatency((int) values.get(8));\n            segmentRecord.setIsError((int) values.get(9));\n            segmentRecord.setVersion((int) values.get(10));\n\n            String base64 = (String) values.get(9);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","date":"2020-04-10 11:03:24","endLine":215,"groupId":"4023","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"queryByTraceId","params":"(StringtraceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/ea/c9706d5207ce402eeea4ab6a0972110552637c.src","preCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((int) values.get(3));\n            segmentRecord.setEndpointName((String) values.get(4));\n            segmentRecord.setStartTime((long) values.get(5));\n            segmentRecord.setEndTime((long) values.get(6));\n            segmentRecord.setLatency((int) values.get(7));\n            segmentRecord.setIsError((int) values.get(8));\n            segmentRecord.setVersion((int) values.get(10));\n\n            String base64 = (String) values.get(9);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/TraceQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"},{"authorDate":"2020-04-10 11:03:24","commitOrder":3,"curCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (series == null || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","date":"2020-04-10 11:03:24","endLine":191,"groupId":"3474","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getProfiledSegment","params":"(StringsegmentId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/36/a99371ce7071b721bc34cb082639c5b1bb1a42.src","preCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (series == null || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((int) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/ProfileThreadSnapshotQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":153,"status":"M"}],"commitId":"6fe2041b470113e626cb3f41e3789261d31f2548","commitMessage":"@@@Make 8.0.0 Core available. New protocol and register removed. (#4599)\n\nHere are the list of changes we made in this pull request. Top 3 are the principle changes.  others are following these principles.\n1. New agent and mesh report protocol. \n2. New agent header protocol. \n3. Service register.  instance register and network address register have been removed permanently.\n4. Service traffic.  instance traffic and network alias metrics are added to replace the service.  instance and network address inventory.\n5. Register process has been removed.\n6. Metrics stream process supports insert only mode.  especially for traffic entities.\n7. Metrics stream process supports no-downsampling mode for traffic entities and network alias.\n8. Remove all register mechanism and cache in the java agent.\n9. Remove MONTH step in GraphQL query.\n10. Update UI to remove MONTH step query.  the max query range is 60 days now.\n11. Simplify the TTL to metrics and record. And the unit has been formatted in Day unit. No specific TTL for ElasticSearch storage.\n12. Buffer mechanism of trace receiver and mesh receiver has been removed due to no register.\n13. New service id.  instance id and endpoint id rules.  including service relation.  instance relation and endpoint relation id rules.\n14. Java agent support `keep tracing` mode.  meaning.  agent generating tracing context even the backend is unconnected/unavailable.\n15. Plugin test tool up to date.  in order to support new protocol.\n16. Plugin tests expected data files updated.\n17. E2E tests updated.\n18. Telemetry of Grafana config has been merged into one.\n19. Documentation updates.\n20. [TBD] InfluxDB storage implementation is not available.  need @dmsolr to fix later.  in order to reduce the master change block by this PR.","date":"2020-04-10 11:03:24","modifiedFileCount":"342","status":"M","submitter":"?? Wu Sheng"},{"authorTime":"2020-04-19 20:10:59","codes":[{"authorDate":"2020-04-19 20:10:59","commitOrder":4,"curCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime((long) values.get(6));\n            segmentRecord.setEndTime((long) values.get(7));\n            segmentRecord.setLatency((int) values.get(8));\n            segmentRecord.setIsError((int) values.get(9));\n            segmentRecord.setVersion((int) values.get(11));\n\n            String base64 = (String) values.get(10);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","date":"2020-04-19 20:10:59","endLine":215,"groupId":"4023","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"queryByTraceId","params":"(StringtraceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/9e/577fa2ef5db5fbcbf9406aed4d0022486625da.src","preCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime((long) values.get(6));\n            segmentRecord.setEndTime((long) values.get(7));\n            segmentRecord.setLatency((int) values.get(8));\n            segmentRecord.setIsError((int) values.get(9));\n            segmentRecord.setVersion((int) values.get(10));\n\n            String base64 = (String) values.get(9);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/TraceQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"},{"authorDate":"2020-04-19 20:10:59","commitOrder":4,"curCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","date":"2020-04-19 20:10:59","endLine":205,"groupId":"4023","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getProfiledSegment","params":"(StringsegmentId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/25/dfc0e8d8fe96b560c3496aea1df702d1026a9d.src","preCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (series == null || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/ProfileThreadSnapshotQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"M"}],"commitId":"28530cd79d6d91443c0584fade1cbb79e137a8ed","commitMessage":"@@@Upgrade the InfluxDB storage-plugin to protocol V3 (#4641)\n\n\nCo-authored-by: ?? Wu Sheng <wu.sheng@foxmail.com>\nCo-authored-by: kezhenxu94 <kezhenxu94@163.com>\nCo-authored-by: kezhenxu94 <kezhenxu94@apache.org>","date":"2020-04-19 20:10:59","modifiedFileCount":"16","status":"M","submitter":"Daming"},{"authorTime":"2020-04-19 20:10:59","codes":[{"authorDate":"2020-05-14 21:13:22","commitOrder":5,"curCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime(((Number) values.get(6)).longValue());\n            segmentRecord.setEndTime(((Number) values.get(7)).longValue());\n            segmentRecord.setLatency(((Number) values.get(8)).intValue());\n            segmentRecord.setIsError(((Number) values.get(9)).intValue());\n            segmentRecord.setVersion(((Number) values.get(11)).intValue());\n\n            String base64 = (String) values.get(10);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","date":"2020-05-14 21:13:22","endLine":215,"groupId":"4023","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"queryByTraceId","params":"(StringtraceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/f3/15082946fa69b36310b8202028a1708027f882.src","preCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime((long) values.get(6));\n            segmentRecord.setEndTime((long) values.get(7));\n            segmentRecord.setLatency((int) values.get(8));\n            segmentRecord.setIsError((int) values.get(9));\n            segmentRecord.setVersion((int) values.get(11));\n\n            String base64 = (String) values.get(10);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/TraceQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"},{"authorDate":"2020-04-19 20:10:59","commitOrder":5,"curCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","date":"2020-04-19 20:10:59","endLine":205,"groupId":"4023","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getProfiledSegment","params":"(StringsegmentId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/25/dfc0e8d8fe96b560c3496aea1df702d1026a9d.src","preCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/ProfileThreadSnapshotQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"N"}],"commitId":"544d419fc08d188a342f4b0490b8746131006aef","commitMessage":"@@@the number type casts error (#4788)\n\nCo-authored-by: zhuanghaochao <zhuanghaochao@yy.com>","date":"2020-05-14 21:13:22","modifiedFileCount":"7","status":"M","submitter":"Daming"},{"authorTime":"2020-12-07 22:56:03","codes":[{"authorDate":"2020-05-14 21:13:22","commitOrder":6,"curCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime(((Number) values.get(6)).longValue());\n            segmentRecord.setEndTime(((Number) values.get(7)).longValue());\n            segmentRecord.setLatency(((Number) values.get(8)).intValue());\n            segmentRecord.setIsError(((Number) values.get(9)).intValue());\n            segmentRecord.setVersion(((Number) values.get(11)).intValue());\n\n            String base64 = (String) values.get(10);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","date":"2020-05-14 21:13:22","endLine":215,"groupId":"4023","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"queryByTraceId","params":"(StringtraceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/f3/15082946fa69b36310b8202028a1708027f882.src","preCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime(((Number) values.get(6)).longValue());\n            segmentRecord.setEndTime(((Number) values.get(7)).longValue());\n            segmentRecord.setLatency(((Number) values.get(8)).intValue());\n            segmentRecord.setIsError(((Number) values.get(9)).intValue());\n            segmentRecord.setVersion(((Number) values.get(11)).intValue());\n\n            String base64 = (String) values.get(10);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/TraceQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"N"},{"authorDate":"2020-12-07 22:56:03","commitOrder":6,"curCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime(((Number) values.get(5)).longValue());\n        segmentRecord.setEndTime(((Number) values.get(6)).longValue());\n        segmentRecord.setLatency(((Number) values.get(7)).intValue());\n        segmentRecord.setIsError(((Number) values.get(8)).intValue());\n        segmentRecord.setVersion(((Number) values.get(10)).intValue());\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","date":"2020-12-07 22:56:03","endLine":205,"groupId":"4023","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getProfiledSegment","params":"(StringsegmentId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/b5/d08be772d3d8abe99d0904233fa75f468869d8.src","preCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime((long) values.get(5));\n        segmentRecord.setEndTime((long) values.get(6));\n        segmentRecord.setLatency((int) values.get(7));\n        segmentRecord.setIsError((int) values.get(8));\n        segmentRecord.setVersion((int) values.get(10));\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/ProfileThreadSnapshotQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"M"}],"commitId":"e792da17821c0f2517273bd395c10f3684ee0604","commitMessage":"@@@fix influxdb bug while setting influxdb connection response format as InfluxDB.ResponseFormat.JSON (#5946)\n\n","date":"2020-12-07 22:56:03","modifiedFileCount":"4","status":"M","submitter":"cuiweiwei"},{"authorTime":"2020-12-17 22:54:36","codes":[{"authorDate":"2020-12-17 22:54:36","commitOrder":7,"curCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select().column(SegmentRecord.SEGMENT_ID)\n                                                             .column(SegmentRecord.TRACE_ID)\n                                                             .column(SegmentRecord.SERVICE_ID)\n                                                             .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                                             .column(SegmentRecord.ENDPOINT_NAME)\n                                                             .column(SegmentRecord.START_TIME)\n                                                             .column(SegmentRecord.END_TIME)\n                                                             .column(SegmentRecord.LATENCY)\n                                                             .column(SegmentRecord.IS_ERROR)\n                                                             .column(SegmentRecord.DATA_BINARY)\n                                                             .column(SegmentRecord.VERSION)\n                                                             .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                                             .where();\n\n        whereQuery.and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime(((Number) values.get(6)).longValue());\n            segmentRecord.setEndTime(((Number) values.get(7)).longValue());\n            segmentRecord.setLatency(((Number) values.get(8)).intValue());\n            segmentRecord.setIsError(((Number) values.get(9)).intValue());\n            segmentRecord.setVersion(((Number) values.get(11)).intValue());\n\n            String base64 = (String) values.get(10);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","date":"2020-12-17 22:54:36","endLine":227,"groupId":"4023","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"queryByTraceId","params":"(StringtraceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/ef/c28dc9deba6d97080e4f1621a6c001b32424d3.src","preCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                                       .column(SegmentRecord.TRACE_ID)\n                                       .column(SegmentRecord.SERVICE_ID)\n                                       .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                       .column(SegmentRecord.ENDPOINT_NAME)\n                                       .column(SegmentRecord.START_TIME)\n                                       .column(SegmentRecord.END_TIME)\n                                       .column(SegmentRecord.LATENCY)\n                                       .column(SegmentRecord.IS_ERROR)\n                                       .column(SegmentRecord.DATA_BINARY)\n                                       .column(SegmentRecord.VERSION)\n                                       .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                       .where()\n                                       .and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime(((Number) values.get(6)).longValue());\n            segmentRecord.setEndTime(((Number) values.get(7)).longValue());\n            segmentRecord.setLatency(((Number) values.get(8)).intValue());\n            segmentRecord.setIsError(((Number) values.get(9)).intValue());\n            segmentRecord.setVersion(((Number) values.get(11)).intValue());\n\n            String base64 = (String) values.get(10);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/TraceQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"M"},{"authorDate":"2020-12-17 22:54:36","commitOrder":7,"curCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select()\n            .column(SegmentRecord.SEGMENT_ID)\n            .column(SegmentRecord.TRACE_ID)\n            .column(SegmentRecord.SERVICE_ID)\n            .column(SegmentRecord.ENDPOINT_NAME)\n            .column(SegmentRecord.START_TIME)\n            .column(SegmentRecord.END_TIME)\n            .column(SegmentRecord.LATENCY)\n            .column(SegmentRecord.IS_ERROR)\n            .column(SegmentRecord.DATA_BINARY)\n            .column(SegmentRecord.VERSION)\n            .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n            .where();\n\n        whereQuery.and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        final List<Object> values = series.get(0).getValues().get(0);\n        final SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime(((Number) values.get(5)).longValue());\n        segmentRecord.setEndTime(((Number) values.get(6)).longValue());\n        segmentRecord.setLatency(((Number) values.get(7)).intValue());\n        segmentRecord.setIsError(((Number) values.get(8)).intValue());\n        segmentRecord.setVersion(((Number) values.get(10)).intValue());\n\n        final String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","date":"2020-12-17 22:54:36","endLine":208,"groupId":"4023","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getProfiledSegment","params":"(StringsegmentId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/04/0074f244c4e88bf58263abb94a34632720e132.src","preCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl query = select().column(SegmentRecord.SEGMENT_ID)\n                .column(SegmentRecord.TRACE_ID)\n                .column(SegmentRecord.SERVICE_ID)\n                .column(SegmentRecord.ENDPOINT_NAME)\n                .column(SegmentRecord.START_TIME)\n                .column(SegmentRecord.END_TIME)\n                .column(SegmentRecord.LATENCY)\n                .column(SegmentRecord.IS_ERROR)\n                .column(SegmentRecord.DATA_BINARY)\n                .column(SegmentRecord.VERSION)\n                .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                .where()\n                .and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(query);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", query.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        List<Object> values = series.get(0).getValues().get(0);\n        SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime(((Number) values.get(5)).longValue());\n        segmentRecord.setEndTime(((Number) values.get(6)).longValue());\n        segmentRecord.setLatency(((Number) values.get(7)).intValue());\n        segmentRecord.setIsError(((Number) values.get(8)).intValue());\n        segmentRecord.setVersion(((Number) values.get(10)).intValue());\n\n        String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/ProfileThreadSnapshotQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"}],"commitId":"8d33f0275ed958ddb4d45a1846a2ae1bb0900ddb","commitMessage":"@@@chore: code polish (#6025)\n\n","date":"2020-12-17 22:54:36","modifiedFileCount":"22","status":"M","submitter":"Daming"},{"authorTime":"2021-08-10 00:05:06","codes":[{"authorDate":"2021-08-10 00:05:06","commitOrder":8,"curCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select().column(SegmentRecord.SEGMENT_ID)\n                                                             .column(SegmentRecord.TRACE_ID)\n                                                             .column(SegmentRecord.SERVICE_ID)\n                                                             .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                                             .column(SegmentRecord.ENDPOINT_NAME)\n                                                             .column(SegmentRecord.START_TIME)\n                                                             .column(SegmentRecord.LATENCY)\n                                                             .column(SegmentRecord.IS_ERROR)\n                                                             .column(SegmentRecord.DATA_BINARY)\n                                                             .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                                             .where();\n\n        whereQuery.and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime(((Number) values.get(6)).longValue());\n            segmentRecord.setLatency(((Number) values.get(7)).intValue());\n            segmentRecord.setIsError(((Number) values.get(8)).intValue());\n\n            String base64 = (String) values.get(9);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","date":"2021-08-10 00:05:06","endLine":223,"groupId":"4023","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"queryByTraceId","params":"(StringtraceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/a5/23bd7e9fc41bb8a464b0834f7114c5b4cf10e7.src","preCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select().column(SegmentRecord.SEGMENT_ID)\n                                                             .column(SegmentRecord.TRACE_ID)\n                                                             .column(SegmentRecord.SERVICE_ID)\n                                                             .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                                             .column(SegmentRecord.ENDPOINT_NAME)\n                                                             .column(SegmentRecord.START_TIME)\n                                                             .column(SegmentRecord.END_TIME)\n                                                             .column(SegmentRecord.LATENCY)\n                                                             .column(SegmentRecord.IS_ERROR)\n                                                             .column(SegmentRecord.DATA_BINARY)\n                                                             .column(SegmentRecord.VERSION)\n                                                             .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                                             .where();\n\n        whereQuery.and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime(((Number) values.get(6)).longValue());\n            segmentRecord.setEndTime(((Number) values.get(7)).longValue());\n            segmentRecord.setLatency(((Number) values.get(8)).intValue());\n            segmentRecord.setIsError(((Number) values.get(9)).intValue());\n            segmentRecord.setVersion(((Number) values.get(11)).intValue());\n\n            String base64 = (String) values.get(10);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/TraceQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":180,"status":"M"},{"authorDate":"2021-08-10 00:05:06","commitOrder":8,"curCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select()\n            .column(SegmentRecord.SEGMENT_ID)\n            .column(SegmentRecord.TRACE_ID)\n            .column(SegmentRecord.SERVICE_ID)\n            .column(SegmentRecord.ENDPOINT_NAME)\n            .column(SegmentRecord.START_TIME)\n            .column(SegmentRecord.LATENCY)\n            .column(SegmentRecord.IS_ERROR)\n            .column(SegmentRecord.DATA_BINARY)\n            .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n            .where();\n\n        whereQuery.and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        final List<Object> values = series.get(0).getValues().get(0);\n        final SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime(((Number) values.get(5)).longValue());\n        segmentRecord.setLatency(((Number) values.get(6)).intValue());\n        segmentRecord.setIsError(((Number) values.get(7)).intValue());\n\n        final String base64 = (String) values.get(8);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","date":"2021-08-10 00:05:06","endLine":204,"groupId":"4023","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getProfiledSegment","params":"(StringsegmentId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/43/7af484941631074ee7edaa0adf6bc2acc7007c.src","preCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select()\n            .column(SegmentRecord.SEGMENT_ID)\n            .column(SegmentRecord.TRACE_ID)\n            .column(SegmentRecord.SERVICE_ID)\n            .column(SegmentRecord.ENDPOINT_NAME)\n            .column(SegmentRecord.START_TIME)\n            .column(SegmentRecord.END_TIME)\n            .column(SegmentRecord.LATENCY)\n            .column(SegmentRecord.IS_ERROR)\n            .column(SegmentRecord.DATA_BINARY)\n            .column(SegmentRecord.VERSION)\n            .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n            .where();\n\n        whereQuery.and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        final List<Object> values = series.get(0).getValues().get(0);\n        final SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime(((Number) values.get(5)).longValue());\n        segmentRecord.setEndTime(((Number) values.get(6)).longValue());\n        segmentRecord.setLatency(((Number) values.get(7)).intValue());\n        segmentRecord.setIsError(((Number) values.get(8)).intValue());\n        segmentRecord.setVersion(((Number) values.get(10)).intValue());\n\n        final String base64 = (String) values.get(9);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/ProfileThreadSnapshotQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":165,"status":"M"}],"commitId":"cc66254729f74d739ff2a85c72ded44fdaeb1cd4","commitMessage":"@@@Remove statement.  version.  and endtime from segment entity. (#7427)\n\n","date":"2021-08-10 00:05:06","modifiedFileCount":"11","status":"M","submitter":"?? Wu Sheng"},{"authorTime":"2021-08-11 16:27:10","codes":[{"authorDate":"2021-08-11 16:27:10","commitOrder":9,"curCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select().column(SegmentRecord.SEGMENT_ID)\n                                                             .column(SegmentRecord.TRACE_ID)\n                                                             .column(SegmentRecord.SERVICE_ID)\n                                                             .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                                             .column(SegmentRecord.START_TIME)\n                                                             .column(SegmentRecord.LATENCY)\n                                                             .column(SegmentRecord.IS_ERROR)\n                                                             .column(SegmentRecord.DATA_BINARY)\n                                                             .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                                             .where();\n\n        whereQuery.and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setStartTime(((Number) values.get(5)).longValue());\n            segmentRecord.setLatency(((Number) values.get(6)).intValue());\n            segmentRecord.setIsError(((Number) values.get(7)).intValue());\n\n            String base64 = (String) values.get(8);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","date":"2021-08-11 16:27:10","endLine":219,"groupId":"10859","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"queryByTraceId","params":"(StringtraceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/c2/87e204eec20301b1b5b5ea50f880e3777d6fe0.src","preCode":"    public List<SegmentRecord> queryByTraceId(String traceId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select().column(SegmentRecord.SEGMENT_ID)\n                                                             .column(SegmentRecord.TRACE_ID)\n                                                             .column(SegmentRecord.SERVICE_ID)\n                                                             .column(SegmentRecord.SERVICE_INSTANCE_ID)\n                                                             .column(SegmentRecord.ENDPOINT_NAME)\n                                                             .column(SegmentRecord.START_TIME)\n                                                             .column(SegmentRecord.LATENCY)\n                                                             .column(SegmentRecord.IS_ERROR)\n                                                             .column(SegmentRecord.DATA_BINARY)\n                                                             .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n                                                             .where();\n\n        whereQuery.and(eq(SegmentRecord.TRACE_ID, traceId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (series == null || series.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<SegmentRecord> segmentRecords = Lists.newArrayList();\n        series.get(0).getValues().forEach(values -> {\n            SegmentRecord segmentRecord = new SegmentRecord();\n\n            segmentRecord.setSegmentId((String) values.get(1));\n            segmentRecord.setTraceId((String) values.get(2));\n            segmentRecord.setServiceId((String) values.get(3));\n            segmentRecord.setServiceInstanceId((String) values.get(4));\n            segmentRecord.setEndpointName((String) values.get(5));\n            segmentRecord.setStartTime(((Number) values.get(6)).longValue());\n            segmentRecord.setLatency(((Number) values.get(7)).intValue());\n            segmentRecord.setIsError(((Number) values.get(8)).intValue());\n\n            String base64 = (String) values.get(9);\n            if (!Strings.isNullOrEmpty(base64)) {\n                segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n            }\n\n            segmentRecords.add(segmentRecord);\n        });\n\n        return segmentRecords;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/TraceQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":178,"status":"M"},{"authorDate":"2021-08-11 16:27:10","commitOrder":9,"curCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select()\n            .column(SegmentRecord.SEGMENT_ID)\n            .column(SegmentRecord.TRACE_ID)\n            .column(SegmentRecord.SERVICE_ID)\n            .column(SegmentRecord.START_TIME)\n            .column(SegmentRecord.LATENCY)\n            .column(SegmentRecord.IS_ERROR)\n            .column(SegmentRecord.DATA_BINARY)\n            .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n            .where();\n\n        whereQuery.and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        final List<Object> values = series.get(0).getValues().get(0);\n        final SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setStartTime(((Number) values.get(4)).longValue());\n        segmentRecord.setLatency(((Number) values.get(5)).intValue());\n        segmentRecord.setIsError(((Number) values.get(6)).intValue());\n\n        final String base64 = (String) values.get(7);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","date":"2021-08-11 16:27:10","endLine":204,"groupId":"10859","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getProfiledSegment","params":"(StringsegmentId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-skywalking-10-0.7/blobInfo/CC_OUT/blobs/b1/babc8e11bc056745f5b9462391e1b1efc10b6a.src","preCode":"    public SegmentRecord getProfiledSegment(String segmentId) throws IOException {\n        WhereQueryImpl<SelectQueryImpl> whereQuery = select()\n            .column(SegmentRecord.SEGMENT_ID)\n            .column(SegmentRecord.TRACE_ID)\n            .column(SegmentRecord.SERVICE_ID)\n            .column(SegmentRecord.ENDPOINT_NAME)\n            .column(SegmentRecord.START_TIME)\n            .column(SegmentRecord.LATENCY)\n            .column(SegmentRecord.IS_ERROR)\n            .column(SegmentRecord.DATA_BINARY)\n            .from(client.getDatabase(), SegmentRecord.INDEX_NAME)\n            .where();\n\n        whereQuery.and(eq(SegmentRecord.SEGMENT_ID, segmentId));\n        List<QueryResult.Series> series = client.queryForSeries(whereQuery);\n        if (log.isDebugEnabled()) {\n            log.debug(\"SQL: {} result set: {}\", whereQuery.getCommand(), series);\n        }\n        if (Objects.isNull(series) || series.isEmpty()) {\n            return null;\n        }\n\n        final List<Object> values = series.get(0).getValues().get(0);\n        final SegmentRecord segmentRecord = new SegmentRecord();\n\n        segmentRecord.setSegmentId((String) values.get(1));\n        segmentRecord.setTraceId((String) values.get(2));\n        segmentRecord.setServiceId((String) values.get(3));\n        segmentRecord.setEndpointName((String) values.get(4));\n        segmentRecord.setStartTime(((Number) values.get(5)).longValue());\n        segmentRecord.setLatency(((Number) values.get(6)).intValue());\n        segmentRecord.setIsError(((Number) values.get(7)).intValue());\n\n        final String base64 = (String) values.get(8);\n        if (!Strings.isNullOrEmpty(base64)) {\n            segmentRecord.setDataBinary(Base64.getDecoder().decode(base64));\n        }\n\n        return segmentRecord;\n    }\n","realPath":"oap-server/server-storage-plugin/storage-influxdb-plugin/src/main/java/org/apache/skywalking/oap/server/storage/plugin/influxdb/query/ProfileThreadSnapshotQuery.java","repoName":"skywalking","snippetEndLine":0,"snippetStartLine":0,"startLine":167,"status":"M"}],"commitId":"de6cae34295f1558a92430323accc617202c754d","commitMessage":"@@@[Break Change] Remove endpoint name in the trace query condition. (#7438)\n\n* [Break Change] Remove endpoint name in the trace query condition.\n\n* Fix a local UT error(MacOS only)","date":"2021-08-11 16:27:10","modifiedFileCount":"19","status":"M","submitter":"?? Wu Sheng"}]
