[{"authorTime":"2018-07-18 03:54:18","codes":[{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testUnionDuringIndexEvaluationForIN() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5) \",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5,101,102,103,104,105) AND p.createTime > 9l\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false, false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false, false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2018-07-18 03:54:18","endLine":233,"groupId":"45549","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnionDuringIndexEvaluationForIN","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/40/31085d84b8a831198ca195fcea9ff6ba0312fb.src","preCode":"  public void testUnionDuringIndexEvaluationForIN() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5) \",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5,101,102,103,104,105) AND p.createTime > 9l\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false, false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false, false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"B"},{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testBug39851() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  ( Select x.ID from /pos x where x.ID > 10) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n        new ObjectType[] {new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})\n\n    };\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2018-07-18 03:54:18","endLine":308,"groupId":"45549","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testBug39851","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/40/31085d84b8a831198ca195fcea9ff6ba0312fb.src","preCode":"  public void testBug39851() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  ( Select x.ID from /pos x where x.ID > 10) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n        new ObjectType[] {new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})\n\n    };\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":236,"status":"B"}],"commitId":"cb202f25b93e0a56f4776813da0bf6dcbba231cd","commitMessage":"@@@GEODE-5363: Moves all non-unit tests into specific isolated source sets. (#2126)\n\n* Creates integrationTest source set.\n* Creates distributedTest source set.\n* Creates acceptanceTest source set.\n* Creates uiTest source set.\n* Removes old categories.","date":"2018-07-18 03:54:18","modifiedFileCount":"697","status":"B","submitter":"Jacob Barrett"},{"authorTime":"2019-01-12 07:53:54","codes":[{"authorDate":"2019-01-12 07:53:54","commitOrder":2,"curCode":"  public void testUnionDuringIndexEvaluationForIN() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5) \",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5,101,102,103,104,105) AND p.createTime > 9l\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false, false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false, false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2019-01-12 07:53:54","endLine":242,"groupId":"45549","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUnionDuringIndexEvaluationForIN","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/65/0f871d11683b4bcdf26d574094790209e53a1a.src","preCode":"  public void testUnionDuringIndexEvaluationForIN() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5) \",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5,101,102,103,104,105) AND p.createTime > 9l\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false, false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false, false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":164,"status":"M"},{"authorDate":"2019-01-12 07:53:54","commitOrder":2,"curCode":"  public void testBug39851() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  ( Select x.ID from /pos x where x.ID > 10) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n        new ObjectType[] {new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})\n\n    };\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2019-01-12 07:53:54","endLine":322,"groupId":"45549","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testBug39851","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/65/0f871d11683b4bcdf26d574094790209e53a1a.src","preCode":"  public void testBug39851() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  ( Select x.ID from /pos x where x.ID > 10) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n        new ObjectType[] {new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})\n\n    };\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":245,"status":"M"}],"commitId":"9d737c9e95a77cb4db05a258f318908e7899bd6c","commitMessage":"@@@GEODE-4391: Add `@Override` where missing. (#3069)\n\n* GEODE-4391: Add `@Override` where missing.\n\n* Restart Concourse.  I think that was flaky.\n","date":"2019-01-12 07:53:54","modifiedFileCount":"1582","status":"M","submitter":"Galen O'Sullivan"},{"authorTime":"2020-05-29 00:37:39","codes":[{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testUnionDuringIndexEvaluationForIN() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(SEPARATOR + \"pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from \" + SEPARATOR\n            + \"pos p  where  p.ID IN  SET( 0,1,2,3,4,5) \",\n        \"select  p.status as sts, p as pos from \" + SEPARATOR\n            + \"pos p  where  p.ID IN  SET( 0,1,2,3,4,5,101,102,103,104,105) AND p.createTime > 9l\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", SEPARATOR + \"pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false, false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false, false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2020-05-29 00:37:39","endLine":250,"groupId":"104885","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testUnionDuringIndexEvaluationForIN","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7c/31e4770cae87e981fc4d9792943d99d9ac61a4.src","preCode":"  public void testUnionDuringIndexEvaluationForIN() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5) \",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3,4,5,101,102,103,104,105) AND p.createTime > 9l\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false, false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false, false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":170,"status":"M"},{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testBug39851() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(SEPARATOR + \"pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from \" + SEPARATOR\n            + \"pos p  where  p.ID IN  ( Select x.ID from \" + SEPARATOR + \"pos x where x.ID > 10) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", SEPARATOR + \"pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n        new ObjectType[] {new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})\n\n    };\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2020-05-29 00:37:39","endLine":331,"groupId":"104885","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testBug39851","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7c/31e4770cae87e981fc4d9792943d99d9ac61a4.src","preCode":"  public void testBug39851() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    Region rgn = CacheUtils.getRegion(\"/pos\");\n    for (int i = 100; i < 200; ++i) {\n      Portfolio pf = new Portfolio(i);\n      pf.setCreateTime(10l);\n      rgn.put(\"\" + i, pf);\n    }\n    String[] queries = new String[] {\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  ( Select x.ID from /pos x where x.ID > 10) \"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    final boolean[] expectedIndexUsed = new boolean[] {true, true};\n    final boolean[] actualIndexUsed = new boolean[] {false, false};\n\n    final boolean[] expectedProjectionCallabck = new boolean[] {false, false};\n    final boolean[] actualProjectionCallback = new boolean[] {false, false};\n\n    final boolean[] expectedUnionCallback = {false};\n    final boolean[] actualUnionCallback = new boolean[queries.length];\n\n\n    final boolean[] expectedIntersectionCallback = {false};\n    final boolean[] actualIntersectionCallback = new boolean[queries.length];\n\n    ObjectType[] expectedTypes = new ObjectType[] {new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n        new ObjectType[] {new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})\n\n    };\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void invokedQueryUtilsUnion(SelectResults r1, SelectResults r2) {\n        actualUnionCallback[i] = true;\n      }\n\n      @Override\n      public void invokedQueryUtilsIntersection(SelectResults r1, SelectResults r2) {\n        actualIntersectionCallback[i] = true;\n      }\n\n      @Override\n      public void beforeIndexLookup(Index index, int oper, Object key) {\n        actualIndexUsed[i] = true;\n      }\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualProjectionCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedUnionCallback[i], actualUnionCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n      assertEquals(expectedIndexUsed[i], actualIndexUsed[i]);\n      assertEquals(expectedProjectionCallabck[i], actualProjectionCallback[i]);\n      assertEquals(expectedIntersectionCallback[i], actualIntersectionCallback[i]);\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"}],"commitId":"0fd56e418752c14ed8ebebe5a370164034aafc39","commitMessage":"@@@GEODE-7846: Replace all uses of hardcoded / with Region.SEPARATOR (#5157)\n\nAuthored-by: Donal Evans <doevans@pivotal.io>","date":"2020-05-29 00:37:39","modifiedFileCount":"489","status":"M","submitter":"Donal Evans"}]
