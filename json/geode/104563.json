[{"authorTime":"2018-07-18 03:54:18","codes":[{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testCompactRangeIndexMemoryIndexStoreMaintenance() throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      final Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      r.put(\"0\", p0);\n\n      DefaultQuery.testHook = new MemoryIndexStoreREToIndexElemTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n\n      Thread t1 = new Thread(new Runnable() {\n        public void run() {\n          r.put(\"1\", p1);\n          threadsDone.countDown();\n        }\n      });\n      t1.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n\n        }\n      });\n      t0.start();\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(1, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(1, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 1, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","date":"2018-07-18 03:54:18","endLine":208,"groupId":"26535","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompactRangeIndexMemoryIndexStoreMaintenance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/35/50f97d20b7f9e5c458645246ae83ffb24c026e.src","preCode":"  public void testCompactRangeIndexMemoryIndexStoreMaintenance() throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      final Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      r.put(\"0\", p0);\n\n      DefaultQuery.testHook = new MemoryIndexStoreREToIndexElemTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n\n      Thread t1 = new Thread(new Runnable() {\n        public void run() {\n          r.put(\"1\", p1);\n          threadsDone.countDown();\n        }\n      });\n      t1.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n\n        }\n      });\n      t0.start();\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(1, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(1, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 1, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/CompactRangeIndexJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"B"},{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet()\n      throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      final Portfolio p2 = new Portfolio(2);\n      p2.status = \"active\";\n      Portfolio p3 = new Portfolio(3);\n      p3.status = \"active\";\n      r.put(\"0\", p0);\n      r.put(\"1\", p1);\n      r.put(\"3\", p3);\n\n      \r\n      DefaultQuery.testHook = new MemoryIndexStoreIndexElemToTokenToConcurrentHashSetTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n      Thread t2 = new Thread(new Runnable() {\n        public void run() {\n          r.put(\"2\", p2);\n          threadsDone.countDown();\n\n        }\n      });\n      t2.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n        }\n      });\n      t0.start();\n\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(3, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(3, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 3, count);\n    } finally {\n      DefaultQuery.testHook = null;\n      System.setProperty(\"index_elemarray_threshold\", \"100\");\n    }\n  }\n","date":"2018-07-18 03:54:18","endLine":277,"groupId":"26536","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/35/50f97d20b7f9e5c458645246ae83ffb24c026e.src","preCode":"  public void testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet()\n      throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      final Portfolio p2 = new Portfolio(2);\n      p2.status = \"active\";\n      Portfolio p3 = new Portfolio(3);\n      p3.status = \"active\";\n      r.put(\"0\", p0);\n      r.put(\"1\", p1);\n      r.put(\"3\", p3);\n\n      \r\n      DefaultQuery.testHook = new MemoryIndexStoreIndexElemToTokenToConcurrentHashSetTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n      Thread t2 = new Thread(new Runnable() {\n        public void run() {\n          r.put(\"2\", p2);\n          threadsDone.countDown();\n\n        }\n      });\n      t2.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n        }\n      });\n      t0.start();\n\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(3, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(3, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 3, count);\n    } finally {\n      DefaultQuery.testHook = null;\n      System.setProperty(\"index_elemarray_threshold\", \"100\");\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/CompactRangeIndexJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":216,"status":"B"}],"commitId":"cb202f25b93e0a56f4776813da0bf6dcbba231cd","commitMessage":"@@@GEODE-5363: Moves all non-unit tests into specific isolated source sets. (#2126)\n\n* Creates integrationTest source set.\n* Creates distributedTest source set.\n* Creates acceptanceTest source set.\n* Creates uiTest source set.\n* Removes old categories.","date":"2018-07-18 03:54:18","modifiedFileCount":"697","status":"B","submitter":"Jacob Barrett"},{"authorTime":"2019-01-12 07:53:54","codes":[{"authorDate":"2019-01-12 07:53:54","commitOrder":2,"curCode":"  public void testCompactRangeIndexMemoryIndexStoreMaintenance() throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      final Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      r.put(\"0\", p0);\n\n      DefaultQuery.testHook = new MemoryIndexStoreREToIndexElemTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n\n      Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"1\", p1);\n          threadsDone.countDown();\n        }\n      });\n      t1.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n\n        }\n      });\n      t0.start();\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(1, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(1, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 1, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","date":"2019-01-12 07:53:54","endLine":210,"groupId":"26535","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompactRangeIndexMemoryIndexStoreMaintenance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/ad/96bae87592a0a6d470f6b6ebaba2fe5695605b.src","preCode":"  public void testCompactRangeIndexMemoryIndexStoreMaintenance() throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      final Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      r.put(\"0\", p0);\n\n      DefaultQuery.testHook = new MemoryIndexStoreREToIndexElemTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n\n      Thread t1 = new Thread(new Runnable() {\n        public void run() {\n          r.put(\"1\", p1);\n          threadsDone.countDown();\n        }\n      });\n      t1.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n\n        }\n      });\n      t0.start();\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(1, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(1, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 1, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/CompactRangeIndexJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"},{"authorDate":"2019-01-12 07:53:54","commitOrder":2,"curCode":"  public void testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet()\n      throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      final Portfolio p2 = new Portfolio(2);\n      p2.status = \"active\";\n      Portfolio p3 = new Portfolio(3);\n      p3.status = \"active\";\n      r.put(\"0\", p0);\n      r.put(\"1\", p1);\n      r.put(\"3\", p3);\n\n      \r\n      DefaultQuery.testHook = new MemoryIndexStoreIndexElemToTokenToConcurrentHashSetTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n      Thread t2 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"2\", p2);\n          threadsDone.countDown();\n\n        }\n      });\n      t2.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n        }\n      });\n      t0.start();\n\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(3, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(3, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 3, count);\n    } finally {\n      DefaultQuery.testHook = null;\n      System.setProperty(\"index_elemarray_threshold\", \"100\");\n    }\n  }\n","date":"2019-01-12 07:53:54","endLine":281,"groupId":"16116","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/ad/96bae87592a0a6d470f6b6ebaba2fe5695605b.src","preCode":"  public void testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet()\n      throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      final Portfolio p2 = new Portfolio(2);\n      p2.status = \"active\";\n      Portfolio p3 = new Portfolio(3);\n      p3.status = \"active\";\n      r.put(\"0\", p0);\n      r.put(\"1\", p1);\n      r.put(\"3\", p3);\n\n      \r\n      DefaultQuery.testHook = new MemoryIndexStoreIndexElemToTokenToConcurrentHashSetTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n      Thread t2 = new Thread(new Runnable() {\n        public void run() {\n          r.put(\"2\", p2);\n          threadsDone.countDown();\n\n        }\n      });\n      t2.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n        }\n      });\n      t0.start();\n\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(3, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(3, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 3, count);\n    } finally {\n      DefaultQuery.testHook = null;\n      System.setProperty(\"index_elemarray_threshold\", \"100\");\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/CompactRangeIndexJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":218,"status":"M"}],"commitId":"9d737c9e95a77cb4db05a258f318908e7899bd6c","commitMessage":"@@@GEODE-4391: Add `@Override` where missing. (#3069)\n\n* GEODE-4391: Add `@Override` where missing.\n\n* Restart Concourse.  I think that was flaky.\n","date":"2019-01-12 07:53:54","modifiedFileCount":"1582","status":"M","submitter":"Galen O'Sullivan"},{"authorTime":"2020-05-29 00:37:39","codes":[{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testCompactRangeIndexMemoryIndexStoreMaintenance() throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", SEPARATOR + \"exampleRegion p\");\n      final Region r = utils.getCache().getRegion(SEPARATOR + \"exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      final Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      r.put(\"0\", p0);\n\n      DefaultQuery.testHook = new MemoryIndexStoreREToIndexElemTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n\n      Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"1\", p1);\n          threadsDone.countDown();\n        }\n      });\n      t1.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n\n        }\n      });\n      t0.start();\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status='active'\")\n          .execute();\n      \r\n      assertEquals(1, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status!='inactive'\")\n          .execute();\n      assertEquals(1, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 1, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","date":"2020-05-29 00:37:39","endLine":218,"groupId":"12243","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompactRangeIndexMemoryIndexStoreMaintenance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/9e/2a97c1b1464ce95599caac0de1ccac6532f7cf.src","preCode":"  public void testCompactRangeIndexMemoryIndexStoreMaintenance() throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      final Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      r.put(\"0\", p0);\n\n      DefaultQuery.testHook = new MemoryIndexStoreREToIndexElemTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n\n      Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"1\", p1);\n          threadsDone.countDown();\n        }\n      });\n      t1.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n\n        }\n      });\n      t0.start();\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(1, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(1, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 1, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/CompactRangeIndexJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"M"},{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet()\n      throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", SEPARATOR + \"exampleRegion p\");\n      final Region r = utils.getCache().getRegion(SEPARATOR + \"exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      final Portfolio p2 = new Portfolio(2);\n      p2.status = \"active\";\n      Portfolio p3 = new Portfolio(3);\n      p3.status = \"active\";\n      r.put(\"0\", p0);\n      r.put(\"1\", p1);\n      r.put(\"3\", p3);\n\n      \r\n      DefaultQuery.testHook = new MemoryIndexStoreIndexElemToTokenToConcurrentHashSetTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n      Thread t2 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"2\", p2);\n          threadsDone.countDown();\n\n        }\n      });\n      t2.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n        }\n      });\n      t0.start();\n\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status='active'\")\n          .execute();\n      \r\n      assertEquals(3, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status!='inactive'\")\n          .execute();\n      assertEquals(3, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 3, count);\n    } finally {\n      DefaultQuery.testHook = null;\n      System.setProperty(\"index_elemarray_threshold\", \"100\");\n    }\n  }\n","date":"2020-05-29 00:37:39","endLine":291,"groupId":"12243","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/9e/2a97c1b1464ce95599caac0de1ccac6532f7cf.src","preCode":"  public void testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet()\n      throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", \"/exampleRegion p\");\n      final Region r = utils.getCache().getRegion(\"/exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      final Portfolio p2 = new Portfolio(2);\n      p2.status = \"active\";\n      Portfolio p3 = new Portfolio(3);\n      p3.status = \"active\";\n      r.put(\"0\", p0);\n      r.put(\"1\", p1);\n      r.put(\"3\", p3);\n\n      \r\n      DefaultQuery.testHook = new MemoryIndexStoreIndexElemToTokenToConcurrentHashSetTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n      Thread t2 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"2\", p2);\n          threadsDone.countDown();\n\n        }\n      });\n      t2.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n        }\n      });\n      t0.start();\n\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status='active'\").execute();\n      \r\n      assertEquals(3, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from /exampleRegion r where r.status!='inactive'\").execute();\n      assertEquals(3, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 3, count);\n    } finally {\n      DefaultQuery.testHook = null;\n      System.setProperty(\"index_elemarray_threshold\", \"100\");\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/CompactRangeIndexJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":226,"status":"M"}],"commitId":"0fd56e418752c14ed8ebebe5a370164034aafc39","commitMessage":"@@@GEODE-7846: Replace all uses of hardcoded / with Region.SEPARATOR (#5157)\n\nAuthored-by: Donal Evans <doevans@pivotal.io>","date":"2020-05-29 00:37:39","modifiedFileCount":"489","status":"M","submitter":"Donal Evans"},{"authorTime":"2021-05-07 15:06:45","codes":[{"authorDate":"2020-05-29 00:37:39","commitOrder":4,"curCode":"  public void testCompactRangeIndexMemoryIndexStoreMaintenance() throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", SEPARATOR + \"exampleRegion p\");\n      final Region r = utils.getCache().getRegion(SEPARATOR + \"exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      final Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      r.put(\"0\", p0);\n\n      DefaultQuery.testHook = new MemoryIndexStoreREToIndexElemTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n\n      Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"1\", p1);\n          threadsDone.countDown();\n        }\n      });\n      t1.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n\n        }\n      });\n      t0.start();\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status='active'\")\n          .execute();\n      \r\n      assertEquals(1, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status!='inactive'\")\n          .execute();\n      assertEquals(1, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 1, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","date":"2020-05-29 00:37:39","endLine":218,"groupId":"104563","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testCompactRangeIndexMemoryIndexStoreMaintenance","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/9e/2a97c1b1464ce95599caac0de1ccac6532f7cf.src","preCode":"  public void testCompactRangeIndexMemoryIndexStoreMaintenance() throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", SEPARATOR + \"exampleRegion p\");\n      final Region r = utils.getCache().getRegion(SEPARATOR + \"exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      final Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      r.put(\"0\", p0);\n\n      DefaultQuery.testHook = new MemoryIndexStoreREToIndexElemTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n\n      Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"1\", p1);\n          threadsDone.countDown();\n        }\n      });\n      t1.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n\n        }\n      });\n      t0.start();\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status='active'\")\n          .execute();\n      \r\n      assertEquals(1, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status!='inactive'\")\n          .execute();\n      assertEquals(1, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 1, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/CompactRangeIndexJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":162,"status":"N"},{"authorDate":"2021-05-07 15:06:45","commitOrder":4,"curCode":"  public void testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet()\n      throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", SEPARATOR + \"exampleRegion p\");\n      final Region r = utils.getCache().getRegion(SEPARATOR + \"exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      final Portfolio p2 = new Portfolio(2);\n      p2.status = \"active\";\n      Portfolio p3 = new Portfolio(3);\n      p3.status = \"active\";\n      r.put(\"0\", p0);\n      r.put(\"1\", p1);\n      r.put(\"3\", p3);\n\n      \r\n      DefaultQuery.testHook = new MemoryIndexStoreIndexElemToTokenToConcurrentHashSetTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n      Thread t2 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"2\", p2);\n          threadsDone.countDown();\n\n        }\n      });\n      t2.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n        }\n      });\n      t0.start();\n\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status='active'\")\n          .execute();\n      \r\n      assertEquals(3, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status!='inactive'\")\n          .execute();\n      assertEquals(3, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 3, count);\n    } finally {\n      DefaultQuery.testHook = null;\n    }\n  }\n","date":"2021-05-07 15:06:45","endLine":292,"groupId":"104563","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7a/17c8b0c4ee358734fad0165c5c4548a2e4df32.src","preCode":"  public void testMemoryIndexStoreMaintenanceTransitionFromElemArrayToTokenToConcurrentHashSet()\n      throws Exception {\n    try {\n      index = utils.createIndex(\"compact range index\", \"p.status\", SEPARATOR + \"exampleRegion p\");\n      final Region r = utils.getCache().getRegion(SEPARATOR + \"exampleRegion\");\n      Portfolio p0 = new Portfolio(0);\n      p0.status = \"active\";\n      Portfolio p1 = new Portfolio(1);\n      p1.status = \"active\";\n      final Portfolio p2 = new Portfolio(2);\n      p2.status = \"active\";\n      Portfolio p3 = new Portfolio(3);\n      p3.status = \"active\";\n      r.put(\"0\", p0);\n      r.put(\"1\", p1);\n      r.put(\"3\", p3);\n\n      \r\n      DefaultQuery.testHook = new MemoryIndexStoreIndexElemToTokenToConcurrentHashSetTestHook();\n      final CountDownLatch threadsDone = new CountDownLatch(2);\n      Thread t2 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.put(\"2\", p2);\n          threadsDone.countDown();\n\n        }\n      });\n      t2.start();\n\n      Thread t0 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n          r.remove(\"0\");\n          threadsDone.countDown();\n        }\n      });\n      t0.start();\n\n      threadsDone.await(90, TimeUnit.SECONDS);\n      QueryService qs = utils.getCache().getQueryService();\n      SelectResults results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status='active'\")\n          .execute();\n      \r\n      assertEquals(3, results.size());\n\n      results = (SelectResults) qs\n          .newQuery(\"Select * from \" + SEPARATOR + \"exampleRegion r where r.status!='inactive'\")\n          .execute();\n      assertEquals(3, results.size());\n\n      CompactRangeIndex cindex = (CompactRangeIndex) index;\n      MemoryIndexStore indexStore = (MemoryIndexStore) cindex.getIndexStorage();\n      CloseableIterator iterator = indexStore.get(\"active\");\n      int count = 0;\n      while (iterator.hasNext()) {\n        count++;\n        iterator.next();\n      }\n      assertEquals(\"incorrect number of entries in collection\", 3, count);\n    } finally {\n      DefaultQuery.testHook = null;\n      System.setProperty(\"index_elemarray_threshold\", \"100\");\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/CompactRangeIndexJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":228,"status":"M"}],"commitId":"884d399d58912864d36161e06a47c8d8af93a641","commitMessage":"@@@GEODE-9004: Align results of queries with and without map indexes (#6279)\n\n* GEODE-9004: Align results of queries with and without map indexes\n\nQueries in which map fields are involved\nin the condition.  sometimes do not return the same entries\nif map indexes are used.  compared to when map indexes\nare not used.\n\nDifferences were found when the condition on the\nmap field was of type '!=' and also when the condition\non the map field was comparing the value with null.\n\nExample1:\nRunning a query with the following condition:\npositions['SUN'] = null\n\nin a region with the following entries:\nentry1.positions=null\nentry2.positions={'a'=>'b'}\nentry3.positions={'SUN'=>null}\n\n- will return entry1 and entry3 if there are no\n  indexes defined.\n- will return no entries if the following index is defined:\n  positions['SUN'. 'c']\n- will return entry3 if the following index is defined:\n  positions[*]\n\nExample2:\nRunning a query with the following condition:\npositions['SUN'] != '3'\n\nin a region with the following entries:\nentry1.positions=null\nentry2.positions={'a'=>'b'}\nentry3.positions={'SUN'=>'4'}\nentry4.positions={'SUN'=>'3'}\nentry5.positions={'SUN'=>null}\n\n- will return all entries except for entry4 if:\n  there are no indexes defined.\n- will return entry3 if the following index is defined:\n  positions['SUN'. 'c']\n- will return entry3 and entry5 if the following index is defined:\n  positions[*]\n\nIn order to have the same results for these\nqueries no matter if indexes are used. \nthe following changes have been made:\n\n- When using compact map indexes or map indexes\nan index entry will be created for every entry\nadded to the region even if the entry does not\ncontain the indexed map (the map is null) or\nit does not contain any of the indexed keys.\nThe above will not apply to indexes of type\n\"allkeys\" (e.g. positions[*]).\n\n- As a consequence of the statement above\nabout indexes of type \"allkeys\".  when the index\nconfigured is of \"allkeys\" type and the query\nis of type \"!=\" (e.g. positions['SUN'] != \"3\"\nor the query is comparing against a null value\n(e.g. positions['SUN'] = null) the index will\nnot be used.\nThis is a limitation of this solution\nas allowing the index to be used in this case\nwould require bigger and more complex changes that\nhave not been considered in this solution.\n\n* GEODE-9004: Fix stats for number of keys in compact map indexes\n\n* GEODE-9004: Fix failing test cases polluted by other test cases changing a System Property\n\n* GEODE-9004: Changes after review and some refactorings\n\n* GEODE-9004: Add documentation changes\n\n* GEODE-9004: Small change in doc. after review","date":"2021-05-07 15:06:45","modifiedFileCount":"12","status":"M","submitter":"Alberto Gomez"}]
