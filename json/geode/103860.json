[{"authorTime":"2018-07-18 03:54:18","codes":[{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testEarlyTerminationOfCompactorByDefault() throws Exception {\n    try {\n      \r\n      DiskRegionProperties props = new DiskRegionProperties();\n      props.setRegionName(\"testEarlyTerminationOfCompactorByDefault\");\n      props.setRolling(true);\n      props.setCompactionThreshold(100);\n      props.setDiskDirs(dirs);\n      props.setMaxOplogSize(100);\n      props.setPersistBackup(true);\n      region = DiskRegionHelperFactory.getSyncPersistOnlyRegion(cache, props, Scope.LOCAL);\n      final boolean[] foundException = new boolean[] {false, false};\n      final boolean[] closeThreadStarted = new boolean[] {false};\n      final boolean[] allowCompactorThread = new boolean[] {false};\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n\n      final Thread th = new Thread(new Runnable() {\n        public void run() {\n          DiskStoreImpl dsi = ((LocalRegion) region).getDiskStore();\n          region.close();\n          dsi.close();\n        }\n      });\n      final Object anotherLock = new Object();\n      \r\n      CacheObserver old = CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n        int sizeBeforeRoll;\n        Map monitor;\n        final AtomicBoolean compactorSignalled = new AtomicBoolean();\n        final AtomicBoolean compactorCompleted = new AtomicBoolean();\n\n        public void beforeGoingToCompact() {\n          logWriter.info(\"beforeGoingToCompact\");\n          DiskRegion cdr = ((LocalRegion) region).getDiskRegion();\n          monitor = cdr.getOplogIdToOplog();\n          \r\n          synchronized (anotherLock) {\n            try {\n              if (!allowCompactorThread[0]) {\n                anotherLock.wait(15000);\n                assertTrue(allowCompactorThread[0]);\n              }\n            } catch (Exception e) {\n              foundException[0] = true;\n              e.printStackTrace();\n            }\n          }\n          synchronized (monitor) {\n            sizeBeforeRoll = monitor.size();\n            assertTrue(sizeBeforeRoll > 0);\n          }\n          logWriter.info(\"beforeGoingToCompact sizeBeforeCompact=\" + sizeBeforeRoll);\n          this.compactorSignalled.set(false);\n          this.compactorCompleted.set(false);\n          th.start();\n          synchronized (region) {\n            closeThreadStarted[0] = true;\n            region.notifyAll();\n          }\n          \r\n          synchronized (this.compactorSignalled) {\n            int waits = 0;\n            while (!this.compactorSignalled.get()) {\n              try {\n                this.compactorSignalled.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterSignallingCompactor\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterSignallingCompactor() {\n          logWriter.info(\"afterSignallingCompactor\");\n          synchronized (this.compactorSignalled) {\n            this.compactorSignalled.set(true);\n            this.compactorSignalled.notifyAll();\n          }\n        }\n\n        public void afterStoppingCompactor() {\n          \r\n          logWriter.info(\"afterStoppingCompactor\");\n          \r\n          synchronized (this.compactorCompleted) {\n            int waits = 0;\n            while (!this.compactorCompleted.get()) {\n              try {\n                this.compactorCompleted.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterHavingCompacted\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterHavingCompacted() {\n          logWriter.info(\"afterHavingCompacted\");\n          synchronized (this.compactorCompleted) {\n            this.compactorCompleted.set(true);\n            this.compactorCompleted.notifyAll();\n          }\n          synchronized (monitor) {\n            if (monitor.size() != sizeBeforeRoll) {\n              foundException[1] = true;\n              \r\n              assertEquals(sizeBeforeRoll, monitor.size());\n            }\n          }\n        }\n      });\n      \r\n      for (int i = 0; i < 100; ++i) {\n        region.put(\"\" + i, \"\" + i);\n      }\n      synchronized (anotherLock) {\n        anotherLock.notifyAll();\n        allowCompactorThread[0] = true;\n      }\n      synchronized (region) {\n        if (!closeThreadStarted[0]) {\n          region.wait(9000);\n          assertTrue(closeThreadStarted[0]);\n        }\n      }\n      th.join();\n      assertFalse(foundException[0]);\n      assertFalse(foundException[1]);\n\n    } finally {\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = false;\n      CacheObserverHolder.setInstance(new CacheObserverAdapter());\n    }\n  }\n","date":"2018-07-18 03:54:18","endLine":2316,"groupId":"37090","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testEarlyTerminationOfCompactorByDefault","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/6f/ec15b27cf96b28e5f7bf1a1027c42781a868ef.src","preCode":"  public void testEarlyTerminationOfCompactorByDefault() throws Exception {\n    try {\n      \r\n      DiskRegionProperties props = new DiskRegionProperties();\n      props.setRegionName(\"testEarlyTerminationOfCompactorByDefault\");\n      props.setRolling(true);\n      props.setCompactionThreshold(100);\n      props.setDiskDirs(dirs);\n      props.setMaxOplogSize(100);\n      props.setPersistBackup(true);\n      region = DiskRegionHelperFactory.getSyncPersistOnlyRegion(cache, props, Scope.LOCAL);\n      final boolean[] foundException = new boolean[] {false, false};\n      final boolean[] closeThreadStarted = new boolean[] {false};\n      final boolean[] allowCompactorThread = new boolean[] {false};\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n\n      final Thread th = new Thread(new Runnable() {\n        public void run() {\n          DiskStoreImpl dsi = ((LocalRegion) region).getDiskStore();\n          region.close();\n          dsi.close();\n        }\n      });\n      final Object anotherLock = new Object();\n      \r\n      CacheObserver old = CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n        int sizeBeforeRoll;\n        Map monitor;\n        final AtomicBoolean compactorSignalled = new AtomicBoolean();\n        final AtomicBoolean compactorCompleted = new AtomicBoolean();\n\n        public void beforeGoingToCompact() {\n          logWriter.info(\"beforeGoingToCompact\");\n          DiskRegion cdr = ((LocalRegion) region).getDiskRegion();\n          monitor = cdr.getOplogIdToOplog();\n          \r\n          synchronized (anotherLock) {\n            try {\n              if (!allowCompactorThread[0]) {\n                anotherLock.wait(15000);\n                assertTrue(allowCompactorThread[0]);\n              }\n            } catch (Exception e) {\n              foundException[0] = true;\n              e.printStackTrace();\n            }\n          }\n          synchronized (monitor) {\n            sizeBeforeRoll = monitor.size();\n            assertTrue(sizeBeforeRoll > 0);\n          }\n          logWriter.info(\"beforeGoingToCompact sizeBeforeCompact=\" + sizeBeforeRoll);\n          this.compactorSignalled.set(false);\n          this.compactorCompleted.set(false);\n          th.start();\n          synchronized (region) {\n            closeThreadStarted[0] = true;\n            region.notifyAll();\n          }\n          \r\n          synchronized (this.compactorSignalled) {\n            int waits = 0;\n            while (!this.compactorSignalled.get()) {\n              try {\n                this.compactorSignalled.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterSignallingCompactor\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterSignallingCompactor() {\n          logWriter.info(\"afterSignallingCompactor\");\n          synchronized (this.compactorSignalled) {\n            this.compactorSignalled.set(true);\n            this.compactorSignalled.notifyAll();\n          }\n        }\n\n        public void afterStoppingCompactor() {\n          \r\n          logWriter.info(\"afterStoppingCompactor\");\n          \r\n          synchronized (this.compactorCompleted) {\n            int waits = 0;\n            while (!this.compactorCompleted.get()) {\n              try {\n                this.compactorCompleted.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterHavingCompacted\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterHavingCompacted() {\n          logWriter.info(\"afterHavingCompacted\");\n          synchronized (this.compactorCompleted) {\n            this.compactorCompleted.set(true);\n            this.compactorCompleted.notifyAll();\n          }\n          synchronized (monitor) {\n            if (monitor.size() != sizeBeforeRoll) {\n              foundException[1] = true;\n              \r\n              assertEquals(sizeBeforeRoll, monitor.size());\n            }\n          }\n        }\n      });\n      \r\n      for (int i = 0; i < 100; ++i) {\n        region.put(\"\" + i, \"\" + i);\n      }\n      synchronized (anotherLock) {\n        anotherLock.notifyAll();\n        allowCompactorThread[0] = true;\n      }\n      synchronized (region) {\n        if (!closeThreadStarted[0]) {\n          region.wait(9000);\n          assertTrue(closeThreadStarted[0]);\n        }\n      }\n      th.join();\n      assertFalse(foundException[0]);\n      assertFalse(foundException[1]);\n\n    } finally {\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = false;\n      CacheObserverHolder.setInstance(new CacheObserverAdapter());\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":2169,"status":"B"},{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testNoTerminationOfCompactorTillRollingCompleted() throws Exception {\n    try {\n      \r\n      System.getProperties()\n          .setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"true\");\n      DiskRegionProperties props = new DiskRegionProperties();\n      props.setRegionName(\"testNoTerminationOfCompactorTillRollingCompleted\");\n      props.setRolling(true);\n      props.setCompactionThreshold(100);\n      props.setDiskDirs(dirs);\n      props.setMaxOplogSize(100);\n      props.setPersistBackup(true);\n      region = DiskRegionHelperFactory.getSyncPersistOnlyRegion(cache, props, Scope.LOCAL);\n      final boolean[] foundException = new boolean[] {false, false};\n      final boolean[] closeThreadStarted = new boolean[] {false};\n      final boolean[] allowCompactorThread = new boolean[] {false};\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n\n      final Thread th = new Thread(new Runnable() {\n        public void run() {\n          DiskStoreImpl dsi = ((LocalRegion) region).getDiskStore();\n          region.close();\n          dsi.close();\n        }\n      });\n      final Object anotherLock = new Object();\n      \r\n      CacheObserver old = CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n        int sizeBeforeRoll;\n        Map monitor;\n        final AtomicBoolean compactorSignalled = new AtomicBoolean();\n\n        public void beforeGoingToCompact() {\n\n          DiskRegion cdr = ((LocalRegion) region).getDiskRegion();\n          monitor = cdr.getOplogIdToOplog();\n          \r\n          synchronized (anotherLock) {\n            try {\n              if (!allowCompactorThread[0]) {\n                anotherLock.wait(9000);\n                assertTrue(allowCompactorThread[0]);\n              }\n            } catch (Exception e) {\n              foundException[0] = true;\n              e.printStackTrace();\n            }\n          }\n          synchronized (monitor) {\n            sizeBeforeRoll = monitor.size();\n            assertTrue(sizeBeforeRoll > 0);\n          }\n          logWriter.info(\"beforeGoingToCompact sizeBeforeCompact=\" + sizeBeforeRoll);\n          this.compactorSignalled.set(false);\n          th.start();\n          synchronized (region) {\n            closeThreadStarted[0] = true;\n            region.notifyAll();\n          }\n          \r\n          synchronized (this.compactorSignalled) {\n            int waits = 0;\n            while (!this.compactorSignalled.get()) {\n              try {\n                this.compactorSignalled.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterSignallingCompactor\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterSignallingCompactor() {\n          synchronized (this.compactorSignalled) {\n            this.compactorSignalled.set(true);\n            this.compactorSignalled.notifyAll();\n          }\n        }\n\n        public void afterHavingCompacted() {\n          synchronized (monitor) {\n            if (sizeBeforeRoll != monitor.size()) {\n              \r\n              foundException[1] = true;\n              \r\n              fail(\"expected sizeBeforeRoll \" + sizeBeforeRoll + \" to be equal to \"\n                  + monitor.size());\n            }\n          }\n        }\n      });\n      \r\n      for (int i = 0; i < 100; ++i) {\n        region.put(\"\" + i, \"\" + i);\n      }\n      synchronized (anotherLock) {\n        anotherLock.notifyAll();\n        allowCompactorThread[0] = true;\n      }\n      synchronized (region) {\n        if (!closeThreadStarted[0]) {\n          region.wait(9000);\n          assertTrue(closeThreadStarted[0]);\n        }\n      }\n      th.join();\n      assertFalse(foundException[0]);\n      assertFalse(foundException[1]);\n\n    } finally {\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = false;\n      CacheObserverHolder.setInstance(new CacheObserverAdapter());\n      System.getProperties()\n          .setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"\");\n    }\n  }\n","date":"2018-07-18 03:54:18","endLine":2502,"groupId":"22414","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoTerminationOfCompactorTillRollingCompleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/6f/ec15b27cf96b28e5f7bf1a1027c42781a868ef.src","preCode":"  public void testNoTerminationOfCompactorTillRollingCompleted() throws Exception {\n    try {\n      \r\n      System.getProperties()\n          .setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"true\");\n      DiskRegionProperties props = new DiskRegionProperties();\n      props.setRegionName(\"testNoTerminationOfCompactorTillRollingCompleted\");\n      props.setRolling(true);\n      props.setCompactionThreshold(100);\n      props.setDiskDirs(dirs);\n      props.setMaxOplogSize(100);\n      props.setPersistBackup(true);\n      region = DiskRegionHelperFactory.getSyncPersistOnlyRegion(cache, props, Scope.LOCAL);\n      final boolean[] foundException = new boolean[] {false, false};\n      final boolean[] closeThreadStarted = new boolean[] {false};\n      final boolean[] allowCompactorThread = new boolean[] {false};\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n\n      final Thread th = new Thread(new Runnable() {\n        public void run() {\n          DiskStoreImpl dsi = ((LocalRegion) region).getDiskStore();\n          region.close();\n          dsi.close();\n        }\n      });\n      final Object anotherLock = new Object();\n      \r\n      CacheObserver old = CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n        int sizeBeforeRoll;\n        Map monitor;\n        final AtomicBoolean compactorSignalled = new AtomicBoolean();\n\n        public void beforeGoingToCompact() {\n\n          DiskRegion cdr = ((LocalRegion) region).getDiskRegion();\n          monitor = cdr.getOplogIdToOplog();\n          \r\n          synchronized (anotherLock) {\n            try {\n              if (!allowCompactorThread[0]) {\n                anotherLock.wait(9000);\n                assertTrue(allowCompactorThread[0]);\n              }\n            } catch (Exception e) {\n              foundException[0] = true;\n              e.printStackTrace();\n            }\n          }\n          synchronized (monitor) {\n            sizeBeforeRoll = monitor.size();\n            assertTrue(sizeBeforeRoll > 0);\n          }\n          logWriter.info(\"beforeGoingToCompact sizeBeforeCompact=\" + sizeBeforeRoll);\n          this.compactorSignalled.set(false);\n          th.start();\n          synchronized (region) {\n            closeThreadStarted[0] = true;\n            region.notifyAll();\n          }\n          \r\n          synchronized (this.compactorSignalled) {\n            int waits = 0;\n            while (!this.compactorSignalled.get()) {\n              try {\n                this.compactorSignalled.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterSignallingCompactor\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterSignallingCompactor() {\n          synchronized (this.compactorSignalled) {\n            this.compactorSignalled.set(true);\n            this.compactorSignalled.notifyAll();\n          }\n        }\n\n        public void afterHavingCompacted() {\n          synchronized (monitor) {\n            if (sizeBeforeRoll != monitor.size()) {\n              \r\n              foundException[1] = true;\n              \r\n              fail(\"expected sizeBeforeRoll \" + sizeBeforeRoll + \" to be equal to \"\n                  + monitor.size());\n            }\n          }\n        }\n      });\n      \r\n      for (int i = 0; i < 100; ++i) {\n        region.put(\"\" + i, \"\" + i);\n      }\n      synchronized (anotherLock) {\n        anotherLock.notifyAll();\n        allowCompactorThread[0] = true;\n      }\n      synchronized (region) {\n        if (!closeThreadStarted[0]) {\n          region.wait(9000);\n          assertTrue(closeThreadStarted[0]);\n        }\n      }\n      th.join();\n      assertFalse(foundException[0]);\n      assertFalse(foundException[1]);\n\n    } finally {\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = false;\n      CacheObserverHolder.setInstance(new CacheObserverAdapter());\n      System.getProperties()\n          .setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"\");\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":2380,"status":"B"}],"commitId":"cb202f25b93e0a56f4776813da0bf6dcbba231cd","commitMessage":"@@@GEODE-5363: Moves all non-unit tests into specific isolated source sets. (#2126)\n\n* Creates integrationTest source set.\n* Creates distributedTest source set.\n* Creates acceptanceTest source set.\n* Creates uiTest source set.\n* Removes old categories.","date":"2018-07-18 03:54:18","modifiedFileCount":"697","status":"B","submitter":"Jacob Barrett"},{"authorTime":"2018-09-13 05:13:28","codes":[{"authorDate":"2018-09-13 05:13:28","commitOrder":2,"curCode":"  public void testEarlyTerminationOfCompactorByDefault() throws Exception {\n    DiskRegionProperties diskRegionProperties = new DiskRegionProperties();\n    diskRegionProperties.setRegionName(regionName);\n    diskRegionProperties.setRolling(true);\n    diskRegionProperties.setCompactionThreshold(100);\n    diskRegionProperties.setDiskDirs(diskDirs);\n    diskRegionProperties.setMaxOplogSize(100);\n    diskRegionProperties.setPersistBackup(true);\n\n    DiskStoreFactory diskStoreFactory = toDiskStoreFactory(diskRegionProperties);\n\n    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, 100);\n\n    Region<String, String> region =\n        createRegion(regionName, diskStoreName, true, true, false, false, 0);\n\n    AtomicReference<Future<Void>> closeRegionFuture = new AtomicReference<>();\n    CountDownLatch closingRegionLatch = new CountDownLatch(1);\n    CountDownLatch allowCompactorLatch = new CountDownLatch(1);\n\n    LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n    CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n      private final CountDownLatch compactorSignalledLatch = new CountDownLatch(1);\n      private final CountDownLatch compactorCompletedLatch = new CountDownLatch(1);\n      private volatile int oplogSizeBeforeRolling;\n\n      @Override\n      public void beforeGoingToCompact() {\n        try {\n          \r\n          awaitLatch(allowCompactorLatch);\n\n          DiskRegion diskRegion = getDiskRegion(region);\n          oplogSizeBeforeRolling = diskRegion.getOplogIdToOplog().size();\n          assertThat(oplogSizeBeforeRolling).isGreaterThan(0);\n\n          closeRegionFuture.set(executorServiceRule.runAsync(() -> {\n            closingRegionLatch.countDown();\n            DiskStoreImpl diskStoreImpl = getDiskStore(region);\n            region.close();\n            diskStoreImpl.close();\n          }));\n\n          \r\n          awaitLatch(compactorSignalledLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterSignallingCompactor() {\n        try {\n          compactorSignalledLatch.countDown();\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterStoppingCompactor() {\n        try {\n          awaitLatch(compactorCompletedLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterHavingCompacted() {\n        try {\n          compactorCompletedLatch.countDown();\n          DiskRegion diskRegion = getDiskRegion(region);\n          assertThat(diskRegion.getOplogIdToOplog()).hasSize(oplogSizeBeforeRolling);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n    });\n\n    \r\n    for (int i = 0; i < 100; ++i) {\n      region.put(String.valueOf(i), String.valueOf(i));\n    }\n\n    allowCompactorLatch.countDown();\n    awaitLatch(closingRegionLatch);\n    awaitFuture(closeRegionFuture);\n  }\n","date":"2018-09-13 05:13:28","endLine":1923,"groupId":"39061","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testEarlyTerminationOfCompactorByDefault","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/af/60aca498efb0c3f81d3920a2383310bdff6ec0.src","preCode":"  public void testEarlyTerminationOfCompactorByDefault() throws Exception {\n    try {\n      \r\n      DiskRegionProperties props = new DiskRegionProperties();\n      props.setRegionName(\"testEarlyTerminationOfCompactorByDefault\");\n      props.setRolling(true);\n      props.setCompactionThreshold(100);\n      props.setDiskDirs(dirs);\n      props.setMaxOplogSize(100);\n      props.setPersistBackup(true);\n      region = DiskRegionHelperFactory.getSyncPersistOnlyRegion(cache, props, Scope.LOCAL);\n      final boolean[] foundException = new boolean[] {false, false};\n      final boolean[] closeThreadStarted = new boolean[] {false};\n      final boolean[] allowCompactorThread = new boolean[] {false};\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n\n      final Thread th = new Thread(new Runnable() {\n        public void run() {\n          DiskStoreImpl dsi = ((LocalRegion) region).getDiskStore();\n          region.close();\n          dsi.close();\n        }\n      });\n      final Object anotherLock = new Object();\n      \r\n      CacheObserver old = CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n        int sizeBeforeRoll;\n        Map monitor;\n        final AtomicBoolean compactorSignalled = new AtomicBoolean();\n        final AtomicBoolean compactorCompleted = new AtomicBoolean();\n\n        public void beforeGoingToCompact() {\n          logWriter.info(\"beforeGoingToCompact\");\n          DiskRegion cdr = ((LocalRegion) region).getDiskRegion();\n          monitor = cdr.getOplogIdToOplog();\n          \r\n          synchronized (anotherLock) {\n            try {\n              if (!allowCompactorThread[0]) {\n                anotherLock.wait(15000);\n                assertTrue(allowCompactorThread[0]);\n              }\n            } catch (Exception e) {\n              foundException[0] = true;\n              e.printStackTrace();\n            }\n          }\n          synchronized (monitor) {\n            sizeBeforeRoll = monitor.size();\n            assertTrue(sizeBeforeRoll > 0);\n          }\n          logWriter.info(\"beforeGoingToCompact sizeBeforeCompact=\" + sizeBeforeRoll);\n          this.compactorSignalled.set(false);\n          this.compactorCompleted.set(false);\n          th.start();\n          synchronized (region) {\n            closeThreadStarted[0] = true;\n            region.notifyAll();\n          }\n          \r\n          synchronized (this.compactorSignalled) {\n            int waits = 0;\n            while (!this.compactorSignalled.get()) {\n              try {\n                this.compactorSignalled.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterSignallingCompactor\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterSignallingCompactor() {\n          logWriter.info(\"afterSignallingCompactor\");\n          synchronized (this.compactorSignalled) {\n            this.compactorSignalled.set(true);\n            this.compactorSignalled.notifyAll();\n          }\n        }\n\n        public void afterStoppingCompactor() {\n          \r\n          logWriter.info(\"afterStoppingCompactor\");\n          \r\n          synchronized (this.compactorCompleted) {\n            int waits = 0;\n            while (!this.compactorCompleted.get()) {\n              try {\n                this.compactorCompleted.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterHavingCompacted\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterHavingCompacted() {\n          logWriter.info(\"afterHavingCompacted\");\n          synchronized (this.compactorCompleted) {\n            this.compactorCompleted.set(true);\n            this.compactorCompleted.notifyAll();\n          }\n          synchronized (monitor) {\n            if (monitor.size() != sizeBeforeRoll) {\n              foundException[1] = true;\n              \r\n              assertEquals(sizeBeforeRoll, monitor.size());\n            }\n          }\n        }\n      });\n      \r\n      for (int i = 0; i < 100; ++i) {\n        region.put(\"\" + i, \"\" + i);\n      }\n      synchronized (anotherLock) {\n        anotherLock.notifyAll();\n        allowCompactorThread[0] = true;\n      }\n      synchronized (region) {\n        if (!closeThreadStarted[0]) {\n          region.wait(9000);\n          assertTrue(closeThreadStarted[0]);\n        }\n      }\n      th.join();\n      assertFalse(foundException[0]);\n      assertFalse(foundException[1]);\n\n    } finally {\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = false;\n      CacheObserverHolder.setInstance(new CacheObserverAdapter());\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":1835,"status":"M"},{"authorDate":"2018-09-13 05:13:28","commitOrder":2,"curCode":"  public void testNoTerminationOfCompactorTillRollingCompleted() throws Exception {\n    System.setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"true\");\n\n    DiskRegionProperties diskRegionProperties = new DiskRegionProperties();\n    diskRegionProperties.setRegionName(regionName);\n    diskRegionProperties.setRolling(true);\n    diskRegionProperties.setCompactionThreshold(100);\n    diskRegionProperties.setDiskDirs(diskDirs);\n    diskRegionProperties.setMaxOplogSize(100);\n    diskRegionProperties.setPersistBackup(true);\n\n    DiskStoreFactory diskStoreFactory = toDiskStoreFactory(diskRegionProperties);\n\n    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, 100);\n\n    Region<Object, Object> region =\n        createRegion(regionName, diskStoreName, true, true, false, false, 0);\n\n    AtomicReference<Future<Void>> closeRegionFuture = new AtomicReference<>();\n    CountDownLatch closeThreadStartedLatch = new CountDownLatch(1);\n    CountDownLatch allowCompactorLatch = new CountDownLatch(1);\n\n    LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n    CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n      private final CountDownLatch compactorSignalledLatch = new CountDownLatch(1);\n      private volatile int oplogSizeBeforeRolling;\n\n      @Override\n      public void beforeGoingToCompact() {\n        try {\n          \r\n          awaitLatch(allowCompactorLatch);\n\n          DiskRegion diskRegion = getDiskRegion(region);\n          oplogSizeBeforeRolling = diskRegion.getOplogIdToOplog().size();\n          assertThat(oplogSizeBeforeRolling).isGreaterThan(0);\n\n          closeRegionFuture.set(executorServiceRule.runAsync(() -> {\n            DiskStoreImpl diskStore = getDiskStore(region);\n            region.close();\n            diskStore.close();\n          }));\n\n          closeThreadStartedLatch.countDown();\n\n          \r\n          awaitLatch(compactorSignalledLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterSignallingCompactor() {\n        try {\n          compactorSignalledLatch.countDown();\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterHavingCompacted() {\n        try {\n          DiskRegion diskRegion = getDiskRegion(region);\n          assertThat(diskRegion.getOplogIdToOplog()).hasSize(oplogSizeBeforeRolling);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n    });\n\n    \r\n    for (int i = 0; i < 100; ++i) {\n      region.put(String.valueOf(i), String.valueOf(i));\n    }\n\n    allowCompactorLatch.countDown();\n    awaitLatch(closeThreadStartedLatch);\n    awaitFuture(closeRegionFuture);\n  }\n","date":"2018-09-13 05:13:28","endLine":2068,"groupId":"20980","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoTerminationOfCompactorTillRollingCompleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/af/60aca498efb0c3f81d3920a2383310bdff6ec0.src","preCode":"  public void testNoTerminationOfCompactorTillRollingCompleted() throws Exception {\n    try {\n      \r\n      System.getProperties()\n          .setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"true\");\n      DiskRegionProperties props = new DiskRegionProperties();\n      props.setRegionName(\"testNoTerminationOfCompactorTillRollingCompleted\");\n      props.setRolling(true);\n      props.setCompactionThreshold(100);\n      props.setDiskDirs(dirs);\n      props.setMaxOplogSize(100);\n      props.setPersistBackup(true);\n      region = DiskRegionHelperFactory.getSyncPersistOnlyRegion(cache, props, Scope.LOCAL);\n      final boolean[] foundException = new boolean[] {false, false};\n      final boolean[] closeThreadStarted = new boolean[] {false};\n      final boolean[] allowCompactorThread = new boolean[] {false};\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n\n      final Thread th = new Thread(new Runnable() {\n        public void run() {\n          DiskStoreImpl dsi = ((LocalRegion) region).getDiskStore();\n          region.close();\n          dsi.close();\n        }\n      });\n      final Object anotherLock = new Object();\n      \r\n      CacheObserver old = CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n        int sizeBeforeRoll;\n        Map monitor;\n        final AtomicBoolean compactorSignalled = new AtomicBoolean();\n\n        public void beforeGoingToCompact() {\n\n          DiskRegion cdr = ((LocalRegion) region).getDiskRegion();\n          monitor = cdr.getOplogIdToOplog();\n          \r\n          synchronized (anotherLock) {\n            try {\n              if (!allowCompactorThread[0]) {\n                anotherLock.wait(9000);\n                assertTrue(allowCompactorThread[0]);\n              }\n            } catch (Exception e) {\n              foundException[0] = true;\n              e.printStackTrace();\n            }\n          }\n          synchronized (monitor) {\n            sizeBeforeRoll = monitor.size();\n            assertTrue(sizeBeforeRoll > 0);\n          }\n          logWriter.info(\"beforeGoingToCompact sizeBeforeCompact=\" + sizeBeforeRoll);\n          this.compactorSignalled.set(false);\n          th.start();\n          synchronized (region) {\n            closeThreadStarted[0] = true;\n            region.notifyAll();\n          }\n          \r\n          synchronized (this.compactorSignalled) {\n            int waits = 0;\n            while (!this.compactorSignalled.get()) {\n              try {\n                this.compactorSignalled.wait(100);\n                waits++;\n                if (waits > 100) {\n                  foundException[0] = true;\n                  fail(\"took too long to call afterSignallingCompactor\");\n                }\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n                foundException[0] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        public void afterSignallingCompactor() {\n          synchronized (this.compactorSignalled) {\n            this.compactorSignalled.set(true);\n            this.compactorSignalled.notifyAll();\n          }\n        }\n\n        public void afterHavingCompacted() {\n          synchronized (monitor) {\n            if (sizeBeforeRoll != monitor.size()) {\n              \r\n              foundException[1] = true;\n              \r\n              fail(\"expected sizeBeforeRoll \" + sizeBeforeRoll + \" to be equal to \"\n                  + monitor.size());\n            }\n          }\n        }\n      });\n      \r\n      for (int i = 0; i < 100; ++i) {\n        region.put(\"\" + i, \"\" + i);\n      }\n      synchronized (anotherLock) {\n        anotherLock.notifyAll();\n        allowCompactorThread[0] = true;\n      }\n      synchronized (region) {\n        if (!closeThreadStarted[0]) {\n          region.wait(9000);\n          assertTrue(closeThreadStarted[0]);\n        }\n      }\n      th.join();\n      assertFalse(foundException[0]);\n      assertFalse(foundException[1]);\n\n    } finally {\n      LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = false;\n      CacheObserverHolder.setInstance(new CacheObserverAdapter());\n      System.getProperties()\n          .setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"\");\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":1988,"status":"M"}],"commitId":"4290946d9dab98450964bbf498beea2bee650a3f","commitMessage":"@@@GEODE-4273: overhaul DiskRegionJUnitTest (#2449)\n\n* Remove use of base class\n* Extract testCompactorClose to DiskRegionCompactorCloseIntegrationTest\n* Extract testDiskRegDWAttrbts to DiskRegionAttributesIntegrationTest\n* GEODE-3900: Use TemporaryFolder for all disk dirs and files\n* Ensure Cache and DS have proper tearDown\n* Use Rules.  Awaitility.  and AssertJ\n* Use CountDownLatch instead of verbose synchronization tricks\n* Minimize usage of non-User APIs\n* Fix usage of deprecated APIs\n* Use proper variable names\n* Use MAX_OPLOG_SIZE_IN_BYTES instead of literal value\n* Protect AtomicReferences with Awaitility to prevent NPEs\n","date":"2018-09-13 05:13:28","modifiedFileCount":"4","status":"M","submitter":"Kirk Lund"},{"authorTime":"2019-05-24 19:34:00","codes":[{"authorDate":"2019-05-24 19:34:00","commitOrder":3,"curCode":"  public void testEarlyTerminationOfCompactorByDefault() throws Exception {\n    DiskRegionProperties diskRegionProperties = new DiskRegionProperties();\n    diskRegionProperties.setRegionName(regionName);\n    diskRegionProperties.setRolling(true);\n    diskRegionProperties.setCompactionThreshold(100);\n    diskRegionProperties.setDiskDirs(diskDirs);\n    diskRegionProperties.setMaxOplogSize(100);\n    diskRegionProperties.setPersistBackup(true);\n\n    DiskStoreFactory diskStoreFactory = toDiskStoreFactory(diskRegionProperties);\n\n    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, 100);\n\n    Region<String, String> region =\n        createRegion(regionName, diskStoreName, true, true, false, false, 0);\n\n    AtomicReference<Future<Void>> closeRegionFuture = new AtomicReference<>();\n    CountDownLatch closingRegionLatch = new CountDownLatch(1);\n    CountDownLatch allowCompactorLatch = new CountDownLatch(1);\n\n    LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n    CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n      private final CountDownLatch compactorSignalledLatch = new CountDownLatch(1);\n      private final CountDownLatch compactorCompletedLatch = new CountDownLatch(1);\n      private volatile int oplogSizeBeforeRolling;\n\n      @Override\n      public void beforeGoingToCompact() {\n        try {\n          \r\n          awaitLatch(allowCompactorLatch);\n\n          DiskRegion diskRegion = getDiskRegion(region);\n          oplogSizeBeforeRolling = diskRegion.getOplogIdToOplog().size();\n          assertThat(oplogSizeBeforeRolling).isGreaterThan(0);\n\n          closeRegionFuture.set(executorServiceRule.runAsync(() -> {\n            closingRegionLatch.countDown();\n            DiskStoreImpl diskStoreImpl = getDiskStore(region);\n            region.close();\n            diskStoreImpl.close();\n          }));\n\n          \r\n          awaitLatch(compactorSignalledLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterSignallingCompactor() {\n        try {\n          compactorSignalledLatch.countDown();\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterStoppingCompactor() {\n        try {\n          awaitLatch(compactorCompletedLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterHavingCompacted() {\n        try {\n          DiskRegion diskRegion = getDiskRegion(region);\n          assertThat(diskRegion.getOplogIdToOplog()).hasSize(oplogSizeBeforeRolling);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        } finally {\n          compactorCompletedLatch.countDown();\n        }\n      }\n    });\n\n    \r\n    for (int i = 0; i < 100; ++i) {\n      region.put(String.valueOf(i), String.valueOf(i));\n    }\n\n    allowCompactorLatch.countDown();\n    awaitLatch(closingRegionLatch);\n    awaitFuture(closeRegionFuture);\n  }\n","date":"2019-06-27 00:28:12","endLine":1924,"groupId":"103860","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testEarlyTerminationOfCompactorByDefault","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/e5/aba9cbb8795648f267d5c6780bb57e603ee370.src","preCode":"  public void testEarlyTerminationOfCompactorByDefault() throws Exception {\n    DiskRegionProperties diskRegionProperties = new DiskRegionProperties();\n    diskRegionProperties.setRegionName(regionName);\n    diskRegionProperties.setRolling(true);\n    diskRegionProperties.setCompactionThreshold(100);\n    diskRegionProperties.setDiskDirs(diskDirs);\n    diskRegionProperties.setMaxOplogSize(100);\n    diskRegionProperties.setPersistBackup(true);\n\n    DiskStoreFactory diskStoreFactory = toDiskStoreFactory(diskRegionProperties);\n\n    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, 100);\n\n    Region<String, String> region =\n        createRegion(regionName, diskStoreName, true, true, false, false, 0);\n\n    AtomicReference<Future<Void>> closeRegionFuture = new AtomicReference<>();\n    CountDownLatch closingRegionLatch = new CountDownLatch(1);\n    CountDownLatch allowCompactorLatch = new CountDownLatch(1);\n\n    LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n    CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n      private final CountDownLatch compactorSignalledLatch = new CountDownLatch(1);\n      private final CountDownLatch compactorCompletedLatch = new CountDownLatch(1);\n      private volatile int oplogSizeBeforeRolling;\n\n      @Override\n      public void beforeGoingToCompact() {\n        try {\n          \r\n          awaitLatch(allowCompactorLatch);\n\n          DiskRegion diskRegion = getDiskRegion(region);\n          oplogSizeBeforeRolling = diskRegion.getOplogIdToOplog().size();\n          assertThat(oplogSizeBeforeRolling).isGreaterThan(0);\n\n          closeRegionFuture.set(executorServiceRule.runAsync(() -> {\n            closingRegionLatch.countDown();\n            DiskStoreImpl diskStoreImpl = getDiskStore(region);\n            region.close();\n            diskStoreImpl.close();\n          }));\n\n          \r\n          awaitLatch(compactorSignalledLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterSignallingCompactor() {\n        try {\n          compactorSignalledLatch.countDown();\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterStoppingCompactor() {\n        try {\n          awaitLatch(compactorCompletedLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterHavingCompacted() {\n        try {\n          compactorCompletedLatch.countDown();\n          DiskRegion diskRegion = getDiskRegion(region);\n          assertThat(diskRegion.getOplogIdToOplog()).hasSize(oplogSizeBeforeRolling);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n    });\n\n    \r\n    for (int i = 0; i < 100; ++i) {\n      region.put(String.valueOf(i), String.valueOf(i));\n    }\n\n    allowCompactorLatch.countDown();\n    awaitLatch(closingRegionLatch);\n    awaitFuture(closeRegionFuture);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":1835,"status":"M"},{"authorDate":"2019-05-24 19:34:00","commitOrder":3,"curCode":"  public void testNoTerminationOfCompactorTillRollingCompleted() throws Exception {\n    System.setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"true\");\n\n    DiskRegionProperties diskRegionProperties = new DiskRegionProperties();\n    diskRegionProperties.setRegionName(regionName);\n    diskRegionProperties.setRolling(true);\n    diskRegionProperties.setCompactionThreshold(100);\n    diskRegionProperties.setDiskDirs(diskDirs);\n    diskRegionProperties.setMaxOplogSize(100);\n    diskRegionProperties.setPersistBackup(true);\n\n    DiskStoreFactory diskStoreFactory = toDiskStoreFactory(diskRegionProperties);\n\n    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, 100);\n\n    Region<Object, Object> region =\n        createRegion(regionName, diskStoreName, true, true, false, false, 0);\n\n    AtomicReference<Future<Void>> closeRegionFuture = new AtomicReference<>();\n    CountDownLatch closeThreadStartedLatch = new CountDownLatch(1);\n    CountDownLatch allowCompactorLatch = new CountDownLatch(1);\n\n    LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n    CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n      private final CountDownLatch compactorSignalledLatch = new CountDownLatch(1);\n      private final CountDownLatch compactorCompletedLatch = new CountDownLatch(1);\n      private volatile int oplogSizeBeforeRolling;\n\n      @Override\n      public void beforeGoingToCompact() {\n        try {\n          \r\n          awaitLatch(allowCompactorLatch);\n\n          DiskRegion diskRegion = getDiskRegion(region);\n          oplogSizeBeforeRolling = diskRegion.getOplogIdToOplog().size();\n          assertThat(oplogSizeBeforeRolling).isGreaterThan(0);\n\n          closeRegionFuture.set(executorServiceRule.runAsync(() -> {\n            closeThreadStartedLatch.countDown();\n            DiskStoreImpl diskStore = getDiskStore(region);\n            region.close();\n            diskStore.close();\n          }));\n\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterSignallingCompactor() {\n        try {\n          compactorSignalledLatch.countDown();\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterStoppingCompactor() {\n        try {\n          awaitLatch(compactorCompletedLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterHavingCompacted() {\n        try {\n          awaitLatch(compactorSignalledLatch);\n          DiskRegion diskRegion = getDiskRegion(region);\n          assertThat(diskRegion.getOplogIdToOplog()).hasSize(oplogSizeBeforeRolling);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        } finally {\n          compactorCompletedLatch.countDown();\n        }\n      }\n    });\n\n    \r\n    for (int i = 0; i < 100; ++i) {\n      region.put(String.valueOf(i), String.valueOf(i));\n    }\n\n    allowCompactorLatch.countDown();\n    awaitLatch(closeThreadStartedLatch);\n    awaitFuture(closeRegionFuture);\n  }\n","date":"2019-06-27 00:28:12","endLine":2079,"groupId":"103860","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoTerminationOfCompactorTillRollingCompleted","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/e5/aba9cbb8795648f267d5c6780bb57e603ee370.src","preCode":"  public void testNoTerminationOfCompactorTillRollingCompleted() throws Exception {\n    System.setProperty(DiskStoreImpl.COMPLETE_COMPACTION_BEFORE_TERMINATION_PROPERTY_NAME, \"true\");\n\n    DiskRegionProperties diskRegionProperties = new DiskRegionProperties();\n    diskRegionProperties.setRegionName(regionName);\n    diskRegionProperties.setRolling(true);\n    diskRegionProperties.setCompactionThreshold(100);\n    diskRegionProperties.setDiskDirs(diskDirs);\n    diskRegionProperties.setMaxOplogSize(100);\n    diskRegionProperties.setPersistBackup(true);\n\n    DiskStoreFactory diskStoreFactory = toDiskStoreFactory(diskRegionProperties);\n\n    createDiskStoreWithSizeInBytes(diskStoreName, diskStoreFactory, 100);\n\n    Region<Object, Object> region =\n        createRegion(regionName, diskStoreName, true, true, false, false, 0);\n\n    AtomicReference<Future<Void>> closeRegionFuture = new AtomicReference<>();\n    CountDownLatch closeThreadStartedLatch = new CountDownLatch(1);\n    CountDownLatch allowCompactorLatch = new CountDownLatch(1);\n\n    LocalRegion.ISSUE_CALLBACKS_TO_CACHE_OBSERVER = true;\n    CacheObserverHolder.setInstance(new CacheObserverAdapter() {\n      private final CountDownLatch compactorSignalledLatch = new CountDownLatch(1);\n      private volatile int oplogSizeBeforeRolling;\n\n      @Override\n      public void beforeGoingToCompact() {\n        try {\n          \r\n          awaitLatch(allowCompactorLatch);\n\n          DiskRegion diskRegion = getDiskRegion(region);\n          oplogSizeBeforeRolling = diskRegion.getOplogIdToOplog().size();\n          assertThat(oplogSizeBeforeRolling).isGreaterThan(0);\n\n          closeRegionFuture.set(executorServiceRule.runAsync(() -> {\n            DiskStoreImpl diskStore = getDiskStore(region);\n            region.close();\n            diskStore.close();\n          }));\n\n          closeThreadStartedLatch.countDown();\n\n          \r\n          awaitLatch(compactorSignalledLatch);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterSignallingCompactor() {\n        try {\n          compactorSignalledLatch.countDown();\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n\n      @Override\n      public void afterHavingCompacted() {\n        try {\n          DiskRegion diskRegion = getDiskRegion(region);\n          assertThat(diskRegion.getOplogIdToOplog()).hasSize(oplogSizeBeforeRolling);\n        } catch (AssertionError | Exception e) {\n          errorCollector.addError(e);\n        }\n      }\n    });\n\n    \r\n    for (int i = 0; i < 100; ++i) {\n      region.put(String.valueOf(i), String.valueOf(i));\n    }\n\n    allowCompactorLatch.countDown();\n    awaitLatch(closeThreadStartedLatch);\n    awaitFuture(closeRegionFuture);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/DiskRegionJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":1989,"status":"M"}],"commitId":"cb24b9fad3207328dcbcf2332574522f57244b91","commitMessage":"@@@GEODE-2863: Discard all new tasks.  after close request received\n","date":"2019-06-27 00:28:12","modifiedFileCount":"2","status":"M","submitter":"Mario Ivanac"}]
