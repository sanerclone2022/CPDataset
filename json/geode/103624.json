[{"authorTime":"2018-07-18 03:54:18","codes":[{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testThreadIdToSequenceIdMapExpiryPositive() {\n    int port3 = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setMaximumTimeBetweenPings(10000);\n        server.setPort(port3);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port3);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(-1);\n        pf.setSubscriptionMessageTrackingTimeout(4000);\n        pf.setSubscriptionAckInterval(2000);\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        verifyExpiry(60 * 1000);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as the previous entry should have expired \");\n        }\n\n      } catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Failed to initialize client\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","date":"2018-07-18 03:54:18","endLine":398,"groupId":"30611","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testThreadIdToSequenceIdMapExpiryPositive","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/26/c87c915d23802dee6f2ef1f120c6d1b9960e4a.src","preCode":"  public void testThreadIdToSequenceIdMapExpiryPositive() {\n    int port3 = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setMaximumTimeBetweenPings(10000);\n        server.setPort(port3);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port3);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(-1);\n        pf.setSubscriptionMessageTrackingTimeout(4000);\n        pf.setSubscriptionAckInterval(2000);\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        verifyExpiry(60 * 1000);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as the previous entry should have expired \");\n        }\n\n      } catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Failed to initialize client\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/tier/sockets/ConnectionProxyJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":356,"status":"B"},{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testNoAckSendByClient() {\n    int port = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setPort(port);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(1);\n        pf.setReadTimeout(20000);\n        pf.setSubscriptionMessageTrackingTimeout(8000);\n        pf.setSubscriptionAckInterval(2000);\n\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        assertFalse(seo.getAckSend());\n\n        \r\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        verifyAckSend(30 * 1000, false);\n\n        \r\n        verifyExpiry(90 * 1000);\n      }\n\n      catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Test testPeriodicAckSendByClient Failed\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","date":"2018-07-18 03:54:18","endLine":777,"groupId":"28282","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoAckSendByClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/26/c87c915d23802dee6f2ef1f120c6d1b9960e4a.src","preCode":"  public void testNoAckSendByClient() {\n    int port = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setPort(port);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(1);\n        pf.setReadTimeout(20000);\n        pf.setSubscriptionMessageTrackingTimeout(8000);\n        pf.setSubscriptionAckInterval(2000);\n\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        assertFalse(seo.getAckSend());\n\n        \r\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        verifyAckSend(30 * 1000, false);\n\n        \r\n        verifyExpiry(90 * 1000);\n      }\n\n      catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Test testPeriodicAckSendByClient Failed\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/tier/sockets/ConnectionProxyJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":726,"status":"B"}],"commitId":"cb202f25b93e0a56f4776813da0bf6dcbba231cd","commitMessage":"@@@GEODE-5363: Moves all non-unit tests into specific isolated source sets. (#2126)\n\n* Creates integrationTest source set.\n* Creates distributedTest source set.\n* Creates acceptanceTest source set.\n* Creates uiTest source set.\n* Removes old categories.","date":"2018-07-18 03:54:18","modifiedFileCount":"697","status":"B","submitter":"Jacob Barrett"},{"authorTime":"2020-04-07 00:29:03","codes":[{"authorDate":"2020-04-07 00:29:03","commitOrder":2,"curCode":"  public void testThreadIdToSequenceIdMapExpiryPositive() {\n    int port3 = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setMaximumTimeBetweenPings(10000);\n        server.setPort(port3);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port3);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(-1);\n        pf.setSubscriptionMessageTrackingTimeout(4000);\n        pf.setSubscriptionAckInterval(2000);\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        verifyExpiry();\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as the previous entry should have expired \");\n        }\n\n      } catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Failed to initialize client\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","date":"2020-04-07 00:29:03","endLine":387,"groupId":"30611","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testThreadIdToSequenceIdMapExpiryPositive","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/ec/f87c49bc28d7c47a9109e0711dae00d6c4d3be.src","preCode":"  public void testThreadIdToSequenceIdMapExpiryPositive() {\n    int port3 = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setMaximumTimeBetweenPings(10000);\n        server.setPort(port3);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port3);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(-1);\n        pf.setSubscriptionMessageTrackingTimeout(4000);\n        pf.setSubscriptionAckInterval(2000);\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        verifyExpiry(60 * 1000);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as the previous entry should have expired \");\n        }\n\n      } catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Failed to initialize client\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/tier/sockets/ConnectionProxyJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"M"},{"authorDate":"2020-04-07 00:29:03","commitOrder":2,"curCode":"  public void testNoAckSendByClient() {\n    int port = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setPort(port);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(1);\n        pf.setReadTimeout(20000);\n        pf.setSubscriptionMessageTrackingTimeout(8000);\n        pf.setSubscriptionAckInterval(2000);\n\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        assertFalse(seo.getAckSend());\n\n        \r\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        verifyAckSend(false);\n\n        \r\n        verifyExpiry();\n      }\n\n      catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Test testPeriodicAckSendByClient Failed\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","date":"2020-04-07 00:29:03","endLine":757,"groupId":"28282","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoAckSendByClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/ec/f87c49bc28d7c47a9109e0711dae00d6c4d3be.src","preCode":"  public void testNoAckSendByClient() {\n    int port = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setPort(port);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(1);\n        pf.setReadTimeout(20000);\n        pf.setSubscriptionMessageTrackingTimeout(8000);\n        pf.setSubscriptionAckInterval(2000);\n\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        assertFalse(seo.getAckSend());\n\n        \r\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        verifyAckSend(30 * 1000, false);\n\n        \r\n        verifyExpiry(90 * 1000);\n      }\n\n      catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Test testPeriodicAckSendByClient Failed\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/tier/sockets/ConnectionProxyJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":706,"status":"M"}],"commitId":"087e47a33f51523c07fa15221be16f069e13b1c4","commitMessage":"@@@Merge pull request #4827 from Nordix/feature/GEODE-7892\n\nGEODE-7892: Code improvements in ConnectionProxyJUnitTest","date":"2020-04-07 00:29:03","modifiedFileCount":"1","status":"M","submitter":"Bruce Schuchardt"},{"authorTime":"2020-12-18 03:10:55","codes":[{"authorDate":"2020-12-18 03:10:55","commitOrder":3,"curCode":"  public void testThreadIdToSequenceIdMapExpiryPositive() {\n    int port3 = getRandomAvailableTCPPort();\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setMaximumTimeBetweenPings(10000);\n        server.setPort(port3);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port3);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(-1);\n        pf.setSubscriptionMessageTrackingTimeout(4000);\n        pf.setSubscriptionAckInterval(2000);\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        verifyExpiry();\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as the previous entry should have expired \");\n        }\n\n      } catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Failed to initialize client\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","date":"2020-12-18 03:10:55","endLine":386,"groupId":"103624","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testThreadIdToSequenceIdMapExpiryPositive","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7b/6be7e3847a3a00b81630ea890eb92304f7baa1.src","preCode":"  public void testThreadIdToSequenceIdMapExpiryPositive() {\n    int port3 = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setMaximumTimeBetweenPings(10000);\n        server.setPort(port3);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port3);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(-1);\n        pf.setSubscriptionMessageTrackingTimeout(4000);\n        pf.setSubscriptionAckInterval(2000);\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        verifyExpiry();\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as the previous entry should have expired \");\n        }\n\n      } catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Failed to initialize client\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/tier/sockets/ConnectionProxyJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"M"},{"authorDate":"2020-12-18 03:10:55","commitOrder":3,"curCode":"  public void testNoAckSendByClient() {\n    int port = getRandomAvailableTCPPort();\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setPort(port);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(1);\n        pf.setReadTimeout(20000);\n        pf.setSubscriptionMessageTrackingTimeout(8000);\n        pf.setSubscriptionAckInterval(2000);\n\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        assertFalse(seo.getAckSend());\n\n        \r\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        verifyAckSend(false);\n\n        \r\n        verifyExpiry();\n      }\n\n      catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Test testPeriodicAckSendByClient Failed\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","date":"2020-12-18 03:10:55","endLine":756,"groupId":"103624","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testNoAckSendByClient","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7b/6be7e3847a3a00b81630ea890eb92304f7baa1.src","preCode":"  public void testNoAckSendByClient() {\n    int port = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);\n    CacheServer server = null;\n    try {\n      try {\n        server = this.cache.addCacheServer();\n        server.setPort(port);\n        server.start();\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Failed to create server\");\n      }\n      try {\n        PoolFactory pf = PoolManager.createFactory();\n        pf.addServer(\"localhost\", port);\n        pf.setSubscriptionEnabled(true);\n        pf.setSubscriptionRedundancy(1);\n        pf.setReadTimeout(20000);\n        pf.setSubscriptionMessageTrackingTimeout(8000);\n        pf.setSubscriptionAckInterval(2000);\n\n        proxy = (PoolImpl) pf.create(\"clientPool\");\n\n        EventID eid = new EventID(new byte[0], 1, 1);\n\n        if (proxy.verifyIfDuplicate(eid)) {\n          fail(\" eid should not be duplicate as it is a new entry\");\n        }\n\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        assertFalse(seo.getAckSend());\n\n        \r\n        seo = (SequenceIdAndExpirationObject) proxy.getThreadIdToSequenceIdMap()\n            .get(new ThreadIdentifier(new byte[0], 1));\n        verifyAckSend(false);\n\n        \r\n        verifyExpiry();\n      }\n\n      catch (Exception ex) {\n        ex.printStackTrace();\n        fail(\"Test testPeriodicAckSendByClient Failed\");\n      }\n    } finally {\n      if (server != null) {\n        server.stop();\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/internal/cache/tier/sockets/ConnectionProxyJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":705,"status":"M"}],"commitId":"b3867a8a466db8d7812c62bbafc4c668b14ea9fe","commitMessage":"@@@Make tests use AvailablePortHelper.  not AvailablePort (#5861)\n\nMake nearly all tests use AvailablePortHelper instead of AvailablePort\nto obtain ports. See the rationale below.\n\nAlso: Remove unused methods from AvailablePort.\n\nRationale:\n\nAvailablePort is inherently risky as a source of ports for tests.\nEach \"get available port\" method obtains candidate port numbers from the\ndesired range by randomly sampling with replacement. This means that\nmultiple calls can return the same port number if the port is not put\ninto use between calls.\n\nSome tests failed intermittently because they made multiple calls to\nAvailablePort.  received the same port on multiple calls.  and unknowingly\nattempted bind multiple sockets to the same port number.  resulting in a\nBindException. See GEODE-6622 for examples.\n\nAvailablePortHelper does not have this problem. It obtains candidate\nport numbers round robin. After returning an available port. \nAvailablePortHelper will not return that port again in that JVM until it\nhas tested every other port in the range for availability.\n\nTo reduce the chance of different JVMs selecting each other's ports. \nAvailablePortHelper selects a random starting point for its round robin\nsearch in each JVM.\n\nFor distributed tests.  DUnit further arranges for the\nAvailablePortHelper in each JVM to start its round robin search in a\ndistinct place.  maximally distant from the starting points of all other\nJVMs. Because AvailablePort selects randomly from the full port range. \nit cannot benefit from this techique.\n\nThe problems caused by AvailablePort are rare.  but inevitable.  with a\nfrequency determined by the total size of the port range. An upcoming\nchange will make the available port range much smaller (~400 ports\ninstead of the current ~10000 ports).  which will greatly increase the\nfrequency of this problem. But the problem exists now.  and results in\nintermittent BindExceptions.","date":"2020-12-18 03:10:55","modifiedFileCount":"98","status":"M","submitter":"Dale Emery"}]
