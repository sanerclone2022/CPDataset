[{"authorTime":"2019-01-30 08:05:48","codes":[{"authorDate":"2019-01-30 08:05:48","commitOrder":1,"curCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer, mockStats);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","date":"2019-01-30 08:05:48","endLine":414,"groupId":"1083","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeast","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/68/d79361070624666d1f40f774257b6d57a155b7.src","preCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer, mockStats);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"B"},{"authorDate":"2019-01-30 08:05:48","commitOrder":1,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(100);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer, mockStats);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","date":"2019-01-30 08:05:48","endLine":458,"groupId":"22674","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/68/d79361070624666d1f40f774257b6d57a155b7.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(100);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer, mockStats);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":424,"status":"B"}],"commitId":"33077b3dab41260c70cece5b4f7ff1c42501b01c","commitMessage":"@@@GEODE-2113 Implement SSL over NIO\n\nThis fixes several bugs in the original implementation of SSL over NIO.\nNotably there were buffer handling problems in MsgReader and the\nNioFilters.  This new commit includes code coverage for these classes\nin new tests.\n\nOriginal commit message:\n\nThis removes old-I/O use in TCPConduit peer-to-peer communications.\nThis was used for SSL/TLS secure commuications but Java has had an\nSSLEngine implementation that allows you to implement secure communications\non new-I/O SocketChannels or any other transport mechanism.\n\nA new NioSSLEngine class wraps the JDK's SSLEngine and provides the\nSSL handshake as well as encryption/decryption of messages. SocketCreator\nperforms the SSL handshake and returns a NioSslEngine that TCPConduit\nthen uses for messaging.\n\nThe SSL handshake needs to be done in Connection.java now because the\nByteBuffer used to do the handshake is also used for reading messages\nin Receivers. Because of this the Handshake pool in TCPConduit became\nobsolete and I deleted it.\n\nI've also done a lot of cleanup of compilation warnings in Connection.java\nand removed references to \"NIO\". The primary SSL/TLS changes in that class\nare in writeFully (renamed from nioWriteFully) and processBuffer (renamed\nfrom processNIOBuffer).\n\nWhile testing I noticed some places where we're creating non-daemon\nthreads that were keeping DUnit ChildVM processes from exiting.  I've\nchanged these places to use daemon threads.  Very few threads in Geode\nshould be non-daemon.\n\nPorting client/server to use NioSSLEngine will be done under a separate\nticket and a different version of NioEngine may be created to secure\nUDP messaging.\n","date":"2019-01-30 08:05:48","modifiedFileCount":"33","status":"B","submitter":"Bruce Schuchardt"},{"authorTime":"2019-05-21 23:42:21","codes":[{"authorDate":"2019-05-21 23:42:21","commitOrder":2,"curCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","date":"2019-05-21 23:42:21","endLine":422,"groupId":"1083","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeast","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/72/36895946daa05b531c6aa58acbd18bacbc2766.src","preCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer, mockStats);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":392,"status":"M"},{"authorDate":"2019-05-21 23:42:21","commitOrder":2,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(100);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","date":"2019-05-21 23:42:21","endLine":466,"groupId":"22674","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/72/36895946daa05b531c6aa58acbd18bacbc2766.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(100);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer, mockStats);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":432,"status":"M"}],"commitId":"3ec8459e9254b7b5a553965c40b75668f9e8b673","commitMessage":"@@@GEODE-6733 Remove mutable static org.apache.geode.internal.net.Buffers.buffersQueue\n\nConverted static Buffers class to be a non-static buffer pool.\n","date":"2019-05-21 23:42:21","modifiedFileCount":"18","status":"M","submitter":"Bruce Schuchardt"},{"authorTime":"2019-11-16 02:39:37","codes":[{"authorDate":"2019-05-21 23:42:21","commitOrder":3,"curCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","date":"2019-05-21 23:42:21","endLine":422,"groupId":"1083","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeast","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/72/36895946daa05b531c6aa58acbd18bacbc2766.src","preCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":392,"status":"N"},{"authorDate":"2019-11-16 02:39:37","commitOrder":3,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","date":"2019-11-16 02:39:37","endLine":477,"groupId":"7172","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/46/551b74a6e58380edbbefac9d9507c8b8815237.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(100);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":438,"status":"M"}],"commitId":"05df143224ab07547522e960334007b521babc09","commitMessage":"@@@GEODE-7450 SSL peerAppDataBuffer expansion needs work (#4330)\n\nThe expansion logic for the decrypted buffer in NioSslEngine was\nexpanding the buffer to twice its old capacity and wouldn't go\nbeyond that.  Some ciphers will compress data a lot more than that.  so\nwe need to continually increase available space in the decryption buffer\nif the SslEngine reports a BUFFER_OVERFLOW status.  The changes in\nthis commit do that by always doubling the available space in the\ndecryption buffer in response to a BUFFER_OVERFLOW.\n\nAlong with that I found it unnecessary to take preemptive action to\nincrease the size of the buffer and deleted that code.","date":"2019-11-16 02:39:37","modifiedFileCount":"3","status":"M","submitter":"Bruce Schuchardt"},{"authorTime":"2020-10-30 07:38:25","codes":[{"authorDate":"2020-10-30 07:38:25","commitOrder":4,"curCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      \r\n      ByteBuffer unwrappedBuffer = inputSharing.getBuffer();\n      unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n      unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n      \r\n      when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n        @Override\n        public Integer answer(InvocationOnMock invocation) throws Throwable {\n          ByteBuffer buffer = invocation.getArgument(0);\n          buffer.position(buffer.position() + individualRead);\n          return individualRead;\n        }\n      });\n\n      TestSSLEngine testSSLEngine = new TestSSLEngine();\n      testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n      nioSslEngine.engine = testSSLEngine;\n\n      try (final ByteBufferSharing sharedBuffer =\n          nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n        ByteBuffer data = sharedBuffer.getBuffer();\n        verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n        assertThat(data.position()).isEqualTo(0);\n        assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      }\n    }\n  }\n","date":"2020-10-30 07:38:25","endLine":443,"groupId":"2759","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeast","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/e9/b01cfd0ea5c86b2b7a2ad8e53f1928429cda44.src","preCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":408,"status":"M"},{"authorDate":"2020-10-30 07:38:25","commitOrder":4,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","date":"2020-10-30 07:38:25","endLine":501,"groupId":"7172","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/e9/b01cfd0ea5c86b2b7a2ad8e53f1928429cda44.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":453,"status":"M"}],"commitId":"08e9e9673d0ed05555a3d74c6d16e706817cab09","commitMessage":"@@@GEODE-8652: NioSslEngine.close() Bypasses Locks (#5666)\n\n- NioSslEngine.close() proceeds even if readers (or writers) are\n  operating on its ByteBuffers.  allowing Connection.close() to close \n  its socket and proceed.\n\n- NioSslEngine.close() needed a lock only on the output buffer.  so \n  we split what was a single lock into two. Also instead of using \n  synchronized we use a ReentrantLock so we can \n  call tryLock() and time out if needed in NioSslEngine.close().\n\n- Since readers/writers may hold locks on these input/output buffers\n  when NioSslEngine.close() is called a reference count is maintained\n  and the buffers are returned to the pool only when the last user\n  is done.\n\n- To manage the locking and reference counting a new AutoCloseable\n  ByteBufferSharing interface is introduced with a trivial \n  implementation: ByteBufferSharingNoOp and a real implementation:\n  ByteBufferSharingImpl.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>","date":"2020-10-30 07:38:25","modifiedFileCount":"9","status":"M","submitter":"Bill Burcham"},{"authorTime":"2020-11-06 04:52:02","codes":[{"authorDate":"2020-11-06 04:52:02","commitOrder":5,"curCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","date":"2020-11-06 05:45:26","endLine":450,"groupId":"1083","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeast","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/88/e4f31a6fdf460bda4a1562a2f06ec9701417ea.src","preCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      \r\n      ByteBuffer unwrappedBuffer = inputSharing.getBuffer();\n      unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n      unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n      \r\n      when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n        @Override\n        public Integer answer(InvocationOnMock invocation) throws Throwable {\n          ByteBuffer buffer = invocation.getArgument(0);\n          buffer.position(buffer.position() + individualRead);\n          return individualRead;\n        }\n      });\n\n      TestSSLEngine testSSLEngine = new TestSSLEngine();\n      testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n      nioSslEngine.engine = testSSLEngine;\n\n      try (final ByteBufferSharing sharedBuffer =\n          nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n        ByteBuffer data = sharedBuffer.getBuffer();\n        verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n        assertThat(data.position()).isEqualTo(0);\n        assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":420,"status":"M"},{"authorDate":"2020-11-06 04:52:02","commitOrder":5,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","date":"2020-11-06 05:45:26","endLine":499,"groupId":"7172","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/88/e4f31a6fdf460bda4a1562a2f06ec9701417ea.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":460,"status":"M"}],"commitId":"9653a0b6e490272fa77d375049f0e9f1cb6c8929","commitMessage":"@@@Revert \"GEODE-8652: NioSslEngine.close() Bypasses Locks (#5666)\"\n\nThis reverts commit 08e9e9673d0ed05555a3d74c6d16e706817cab09.\n","date":"2020-11-06 05:45:26","modifiedFileCount":"9","status":"M","submitter":"Bill Burcham"},{"authorTime":"2020-11-06 09:30:29","codes":[{"authorDate":"2020-11-06 09:30:29","commitOrder":6,"curCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      \r\n      ByteBuffer unwrappedBuffer = inputSharing.getBuffer();\n      unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n      unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n      \r\n      when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n        @Override\n        public Integer answer(InvocationOnMock invocation) throws Throwable {\n          ByteBuffer buffer = invocation.getArgument(0);\n          buffer.position(buffer.position() + individualRead);\n          return individualRead;\n        }\n      });\n\n      TestSSLEngine testSSLEngine = new TestSSLEngine();\n      testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n      nioSslEngine.engine = testSSLEngine;\n\n      try (final ByteBufferSharing sharedBuffer =\n          nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n        ByteBuffer data = sharedBuffer.getBuffer();\n        verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n        assertThat(data.position()).isEqualTo(0);\n        assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      }\n    }\n  }\n","date":"2020-11-06 09:30:29","endLine":468,"groupId":"2759","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeast","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/df/d7b9012b1bcff84ad56505519a39503aa3b1fb.src","preCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = nioSslEngine.peerAppData;\n    unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n    unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"M"},{"authorDate":"2020-11-06 09:30:29","commitOrder":6,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","date":"2020-11-06 09:30:29","endLine":526,"groupId":"7172","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/df/d7b9012b1bcff84ad56505519a39503aa3b1fb.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"}],"commitId":"af267c005a63317cbb8528cdb38eccf6a8747818","commitMessage":"@@@* GEODE-8652: NioSslEngine.close() Bypasses Locks (#5712)\n\n- NioSslEngine.close() proceeds even if readers (or writers) are\n  operating on its ByteBuffers.  allowing Connection.close() to close\n  its socket and proceed.\n\n- NioSslEngine.close() needed a lock only on the output buffer.  so\n  we split what was a single lock into two. Also instead of using\n  synchronized we use a ReentrantLock so we can\n  call tryLock() and time out if needed in NioSslEngine.close().\n\n- Since readers/writers may hold locks on these input/output buffers\n  when NioSslEngine.close() is called a reference count is maintained\n  and the buffers are returned to the pool only when the last user\n  is done.\n\n- To manage the locking and reference counting a new AutoCloseable\n  ByteBufferSharing interface is introduced with a trivial\n  implementation: ByteBufferSharingNoOp and a real implementation:\n  ByteBufferSharingImpl.\n\n- Added a new unit test.  and a new concurrency test for\n  ByteBufferSharingImpl: both ensure that ByteBuffers are returned\n  to the pool exactly once. Added a new DUnit test for the interaction\n  between ByteBufferSharingImpl and NioSslEngine and Connection.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>\nCo-authored-by: Dan Smith <upthewaterspout@apache.org>","date":"2020-11-06 09:30:29","modifiedFileCount":"9","status":"M","submitter":"Bill Burcham"},{"authorTime":"2021-04-18 04:15:53","codes":[{"authorDate":"2020-11-06 09:30:29","commitOrder":7,"curCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      \r\n      ByteBuffer unwrappedBuffer = inputSharing.getBuffer();\n      unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n      unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n      \r\n      when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n        @Override\n        public Integer answer(InvocationOnMock invocation) throws Throwable {\n          ByteBuffer buffer = invocation.getArgument(0);\n          buffer.position(buffer.position() + individualRead);\n          return individualRead;\n        }\n      });\n\n      TestSSLEngine testSSLEngine = new TestSSLEngine();\n      testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n      nioSslEngine.engine = testSSLEngine;\n\n      try (final ByteBufferSharing sharedBuffer =\n          nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n        ByteBuffer data = sharedBuffer.getBuffer();\n        verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n        assertThat(data.position()).isEqualTo(0);\n        assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      }\n    }\n  }\n","date":"2020-11-06 09:30:29","endLine":468,"groupId":"2759","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeast","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/df/d7b9012b1bcff84ad56505519a39503aa3b1fb.src","preCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      \r\n      ByteBuffer unwrappedBuffer = inputSharing.getBuffer();\n      unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n      unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n      \r\n      when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n        @Override\n        public Integer answer(InvocationOnMock invocation) throws Throwable {\n          ByteBuffer buffer = invocation.getArgument(0);\n          buffer.position(buffer.position() + individualRead);\n          return individualRead;\n        }\n      });\n\n      TestSSLEngine testSSLEngine = new TestSSLEngine();\n      testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n      nioSslEngine.engine = testSSLEngine;\n\n      try (final ByteBufferSharing sharedBuffer =\n          nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n        ByteBuffer data = sharedBuffer.getBuffer();\n        verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n        assertThat(data.position()).isEqualTo(0);\n        assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":433,"status":"N"},{"authorDate":"2021-04-18 04:15:53","commitOrder":7,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferVendor inputSharingImpl = (ByteBufferVendor) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","date":"2021-04-29 01:25:35","endLine":526,"groupId":"7172","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/62/a858c9832508665d2326f9a6eb0f4f6643add8.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"}],"commitId":"38a3540583a1d0a402b026ee0d33ae4b0a2907d3","commitMessage":"@@@GEODE-9141: (1 of 2) rename ByteBufferSharingImpl to ByteBuferVendor\n","date":"2021-04-29 01:25:35","modifiedFileCount":"4","status":"M","submitter":"Bill Burcham"},{"authorTime":"2021-04-18 00:12:13","codes":[{"authorDate":"2021-04-18 00:12:13","commitOrder":8,"curCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    try (final ByteBufferSharing inputSharing =\n        nioSslEngine.getInputBufferVendorForTestingOnly().open()) {\n      \r\n      ByteBuffer unwrappedBuffer = inputSharing.getBuffer();\n      unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n      unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n      \r\n      when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n        @Override\n        public Integer answer(InvocationOnMock invocation) throws Throwable {\n          ByteBuffer buffer = invocation.getArgument(0);\n          buffer.position(buffer.position() + individualRead);\n          return individualRead;\n        }\n      });\n\n      TestSSLEngine testSSLEngine = new TestSSLEngine();\n      testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n      nioSslEngine.engine = testSSLEngine;\n\n      try (final ByteBufferSharing sharedBuffer =\n          nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n        ByteBuffer data = sharedBuffer.getBuffer();\n        verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n        assertThat(data.position()).isEqualTo(0);\n        assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      }\n    }\n  }\n","date":"2021-04-29 01:25:35","endLine":476,"groupId":"102563","id":15,"instanceNumber":1,"isCurCommit":1,"methodName":"readAtLeast","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/d6/b9aa64850c9bae417a4ecf837e567ba5e51df9.src","preCode":"  public void readAtLeast() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      \r\n      ByteBuffer unwrappedBuffer = inputSharing.getBuffer();\n      unwrappedBuffer.position(unwrappedBuffer.capacity() - individualRead);\n      unwrappedBuffer.limit(unwrappedBuffer.position() + preexistingBytes);\n\n      \r\n      when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n        @Override\n        public Integer answer(InvocationOnMock invocation) throws Throwable {\n          ByteBuffer buffer = invocation.getArgument(0);\n          buffer.position(buffer.position() + individualRead);\n          return individualRead;\n        }\n      });\n\n      TestSSLEngine testSSLEngine = new TestSSLEngine();\n      testSSLEngine.addReturnResult(new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n      nioSslEngine.engine = testSSLEngine;\n\n      try (final ByteBufferSharing sharedBuffer =\n          nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n        ByteBuffer data = sharedBuffer.getBuffer();\n        verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n        assertThat(data.position()).isEqualTo(0);\n        assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":440,"status":"M"},{"authorDate":"2021-04-18 00:12:13","commitOrder":8,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    nioSslEngine.getInputBufferVendorForTestingOnly().setBufferForTestingOnly(unwrappedBuffer);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing =\n          nioSslEngine.getInputBufferVendorForTestingOnly().open()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","date":"2021-04-29 01:25:35","endLine":532,"groupId":"102563","id":16,"instanceNumber":2,"isCurCommit":1,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/d6/b9aa64850c9bae417a4ecf837e567ba5e51df9.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferVendor inputSharingImpl = (ByteBufferVendor) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":486,"status":"M"}],"commitId":"9d0d4d1d33794d0f6a21c3bcae71e965cbbd7fbd","commitMessage":"@@@GEODE-9141: (2 of 2) Handle in-buffer concurrency\n* Connection uses a ByteBufferVendor to mediate access to inputBuffer\n* Prevent return to pool before socket closer is finished\n","date":"2021-04-29 01:25:35","modifiedFileCount":"12","status":"M","submitter":"Bill Burcham"}]
