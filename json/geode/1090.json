[{"authorTime":"2018-07-28 02:28:34","codes":[{"authorDate":"2018-07-28 02:28:34","commitOrder":1,"curCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","date":"2018-07-28 02:28:34","endLine":75,"groupId":"11348","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRollLocatorsWithOldServer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/db/ed9c0796df95b2b9b7b47278d4a249ea647df8.src","preCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeRollLocatorsWithOldServer.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":38,"status":"B"},{"authorDate":"2018-07-28 02:28:34","commitOrder":1,"curCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","date":"2018-07-28 02:28:34","endLine":113,"groupId":"38713","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/a4/25ee1ed53cc2034b2abcfe39f499315519c9bf.src","preCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","realPath":"geode-lucene/src/upgradeTest/java/org/apache/geode/cache/lucene/RollingUpgradeQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":37,"status":"B"}],"commitId":"6712acaadfb7ce894f797e442de09abddb8ea390","commitMessage":"@@@GEODE-5471 Split RollingUpgrade tests to parallelize (#2183)\n\nFor all UpgradeTest test classes.  split each method into its own class\nto allow gradle-docker-plugin to run them concurrently fast.\n\n- RollingUpgradeDUnit split to 3 test classes\n- Using 'parameterize' instead of native constructors\n- Tightened visibility of helper methods\n- rollingupgrade2dunit refactored into 16 test classes\n- Extract LuceneRollingUpgrade tests to individual test child classes.\n- split WAN rolling upgrade\n\nCo-authored-by: Robert Houghton <rhoughton@pivotal.io>\nCo-authored-by: Patrick Rhomberg <prhomberg@pivotal.io>\nCo-authored-by: Finn Southerland <fsoutherland@pivotal.io>\n","date":"2018-07-28 02:28:34","modifiedFileCount":"3","status":"B","submitter":"Robert Houghton"},{"authorTime":"2018-08-17 08:13:57","codes":[{"authorDate":"2018-08-17 08:13:57","commitOrder":2,"curCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","date":"2018-08-18 01:08:42","endLine":75,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRollLocatorsWithOldServer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/42/750b773513639982a0cd170e60538d203e2a38.src","preCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeRollLocatorsWithOldServer.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":38,"status":"M"},{"authorDate":"2018-08-17 08:13:57","commitOrder":2,"curCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","date":"2018-08-18 01:08:42","endLine":113,"groupId":"22565","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/78/e4e6dadca6145bd72ad8cbf656365b0d768307.src","preCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .until(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","realPath":"geode-lucene/src/upgradeTest/java/org/apache/geode/cache/lucene/RollingUpgradeQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":37,"status":"M"}],"commitId":"f3f255a234eac78b63dc4932e1d725c20fe75706","commitMessage":"@@@GEODE-5593 Update test dependencies\n\nUpdated the following dependencies:\n\nassertj \t3.8.0 => 3.10.0\nawaitility \t2.0.0 => 3.1.1\nbcel\t\t6.0 => 6.2\ncglib\t\t3.2.4 => 3.2.7\nderby\t\t10.13.1.1 => 10.14.2.0\nhttpclient\t4.5.3 => 4.5.6\nbcel\t\t6.0 => 6.2\ncglib\t\t3.2.4 => 3.2.7\nderby\t\t10.13.1.1 => 10.14.2.0\nhttpclient\t4.5.3 => 4.5.6\nhttpcore\t4.4.6 => 4.4.10\njavax.mail\t1.4.6 => 1.6.1\njavax.persistence 2.1.1 => 2.2.0\njmock\t\t2.8.2 => 2.8.4\njson-path\t2.2.0 => 2.4.0\njunit-quickcheck 0.7 => 0.8.1\nmockito\t\t2.8.9 => 2.19.1\npowermock\t1.7.1 => 2.0.0-beta.5\nselenimum\t3.9.1 => 3.13.0\nsystem-rules\t1.17.1 => 1.18.0\nxerces\t\t2.11.0 => 2.12.0\n\nUpdated some tests due to API changes. Typically this meant\nconverting from until() to untilAsserted().  In other cases\nyou aren't allowed to throw undeclared check exceptions.\n\nUpdated and corrected powermock usage in a few places.\n\nDid not update junit-params since too many places in our\ntests use the test method name for region name (and the\ntest method name would not have been a legal region\nname).  This is an opportunity for future refactoring.\n","date":"2018-08-18 01:08:42","modifiedFileCount":"182","status":"M","submitter":"Anthony Baker"},{"authorTime":"2018-10-05 06:38:58","codes":[{"authorDate":"2018-10-05 06:38:58","commitOrder":3,"curCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","date":"2018-10-19 08:01:02","endLine":73,"groupId":"11615","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRollLocatorsWithOldServer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/b0/e90ff8d0fd97fdac45e76ad881b9e40458a39f.src","preCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeRollLocatorsWithOldServer.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2018-10-05 06:38:58","commitOrder":3,"curCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","date":"2018-10-19 08:01:02","endLine":111,"groupId":"22565","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/21/c5bcf5fc786c11306204c4687fdfba43ea10d4.src","preCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> Awaitility.await().atMost(65, TimeUnit.SECONDS).pollInterval(1, TimeUnit.SECONDS)\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","realPath":"geode-lucene/src/upgradeTest/java/org/apache/geode/cache/lucene/RollingUpgradeQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":35,"status":"M"}],"commitId":"239c532f8338c9d8e9bb8062fab9fadd3376ec73","commitMessage":"@@@GEODE-5424: Changing all awaitility calls to use consistent timings\n\nWe have a lot of Awaitility calls in our tests. Each test was picking\nits own timeout. That lead to some tests picking too small of a timeout\nand failing spuriously.\n\nWith this change.  all tests will use a new factory. \nGeodeAwaility.await().  rather than Awaitility.await(). This new factory\nsets a default timeout of 5 minutes. It also sets a sensible pollDelay\nand pollInterval.\n\nThe custom timeouts used in all tests have been removed.  in favor of\nthis new factory.  except for a couple of tests that had waits greater\nthan 5 minutes.\n","date":"2018-10-19 08:01:02","modifiedFileCount":"334","status":"M","submitter":"Dan Smith"},{"authorTime":"2019-08-16 01:19:19","codes":[{"authorDate":"2019-08-16 01:19:19","commitOrder":4,"curCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","date":"2019-08-16 01:19:19","endLine":74,"groupId":"11615","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"testRollLocatorsWithOldServer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/30/c54ccb42e540eb3ec6a8769aef6c5f9295dee6.src","preCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeRollLocatorsWithOldServer.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"},{"authorDate":"2019-08-16 01:19:19","commitOrder":4,"curCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","date":"2019-08-16 01:19:19","endLine":112,"groupId":"22565","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/cb/680559ee62a505ae1e7ee40af7e9e460d49dd7.src","preCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    DistributedTestUtils.deleteLocatorStateFile(locatorPorts);\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","realPath":"geode-lucene/src/upgradeTest/java/org/apache/geode/cache/lucene/RollingUpgradeQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":35,"status":"M"}],"commitId":"86fd74db98b5dff0e92ea4985651f3955c1a3420","commitMessage":"@@@GEODE-7072 CI Failure: WANRollingUpgradeEventProcessingMixedSiteOneCurrentSiteTwo (#3908)\n\n* GEODE-7072 CI Failure: WANRollingUpgradeEventProcessingMixedSiteOneCurrentSiteTwo\n\nA number of tests were attempting to delete old locator state files\ncontaining membership views in order to ensure that artifacts from\npreviously run tests were not around to infect the current test.\n\nUnfortunately the calls to DistributedTestUtils.deleteLocatorStateFile()\nwere being made from the wrong working directory.  Instead of looking\nfor the file(s) in the directory that the test's locator would use they\nwere looking in the unit test VMs working directory.\n\n* adding another test\n","date":"2019-08-16 01:19:19","modifiedFileCount":"26","status":"M","submitter":"Bruce Schuchardt"},{"authorTime":"2019-11-01 13:03:14","codes":[{"authorDate":"2019-08-16 01:19:19","commitOrder":5,"curCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","date":"2019-08-16 01:19:19","endLine":74,"groupId":"11615","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"testRollLocatorsWithOldServer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/30/c54ccb42e540eb3ec6a8769aef6c5f9295dee6.src","preCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeRollLocatorsWithOldServer.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2019-11-01 13:03:14","commitOrder":5,"curCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","date":"2019-11-01 13:03:14","endLine":112,"groupId":"22565","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/81/78ea6e0e1f799f9cf935dd965c41b89990bc5f.src","preCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","realPath":"geode-lucene/src/upgradeTest/java/org/apache/geode/cache/lucene/RollingUpgradeQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":35,"status":"M"}],"commitId":"3ae83cf4eb4ef22b61cf51dc27fa5c6b5b46e735","commitMessage":"@@@Feature/geode 7258 2 (#4250)\n\nGEODE-7258: The function retry logic is modified to handle exception\nthrown.  while trying to connect to a server thats shutdown/closed.\n\n    Co-authored-by: Anil <agingade@pivotal.io>\n    Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>\n","date":"2019-11-01 13:03:14","modifiedFileCount":"16","status":"M","submitter":"Xiaojian Zhou"},{"authorTime":"2021-09-23 13:52:26","codes":[{"authorDate":"2019-08-16 01:19:19","commitOrder":6,"curCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","date":"2019-08-16 01:19:19","endLine":74,"groupId":"11615","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"testRollLocatorsWithOldServer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/30/c54ccb42e540eb3ec6a8769aef6c5f9295dee6.src","preCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeRollLocatorsWithOldServer.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2021-09-23 13:52:26","commitOrder":6,"curCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObject(server1, regionName, 0, 10);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","date":"2021-09-23 13:52:26","endLine":123,"groupId":"22565","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/e1/ce48bc28a1253f4edb0e4e16baa9d29bb6a99e.src","preCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","realPath":"geode-lucene/src/upgradeTest/java/org/apache/geode/cache/lucene/RollingUpgradeQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":35,"status":"M"}],"commitId":"68629356f561a932f5dfbace70b01d9971a42473","commitMessage":"@@@GEODE-7309: uplift lucene to 7.1.0 (#6351)\n\n* GEODE-7309: uplift lucene to 7.1.0","date":"2021-09-23 13:52:26","modifiedFileCount":"17","status":"M","submitter":"Mario Kevo"},{"authorTime":"2021-09-25 14:47:02","codes":[{"authorDate":"2019-08-16 01:19:19","commitOrder":7,"curCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","date":"2019-08-16 01:19:19","endLine":74,"groupId":"1090","id":13,"instanceNumber":1,"isCurCommit":1,"methodName":"testRollLocatorsWithOldServer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/30/c54ccb42e540eb3ec6a8769aef6c5f9295dee6.src","preCode":"  public void testRollLocatorsWithOldServer() {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server4 = host.getVM(oldVersion, 3);\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(3);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName();\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(invokeStartLocator(hostName, locatorPorts[0], getTestMethodName(),\n          getLocatorProperties(locatorString), true));\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      locator2.invoke(invokeStartLocator(hostName, locatorPorts[1], getTestMethodName(),\n          getLocatorProperties(locatorString), false));\n\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server4);\n\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server4);\n    }\n  }\n","realPath":"geode-core/src/upgradeTest/java/org/apache/geode/internal/cache/rollingupgrade/RollingUpgradeRollLocatorsWithOldServer.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"N"},{"authorDate":"2021-09-25 14:47:02","commitOrder":7,"curCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 0,\n          10, server1, server2);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName, expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName, expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","date":"2021-09-25 14:47:02","endLine":112,"groupId":"1090","id":14,"instanceNumber":2,"isCurCommit":1,"methodName":"luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/81/78ea6e0e1f799f9cf935dd965c41b89990bc5f.src","preCode":"  public void luceneQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled()\n      throws Exception {\n    final Host host = Host.getHost(0);\n    VM locator1 = host.getVM(oldVersion, 0);\n    VM locator2 = host.getVM(oldVersion, 1);\n    VM server1 = host.getVM(oldVersion, 2);\n    VM server2 = host.getVM(oldVersion, 3);\n\n    final String regionName = \"aRegion\";\n    RegionShortcut shortcut = RegionShortcut.PARTITION_REDUNDANT;\n    String regionType = \"partitionedRedundant\";\n\n    int[] locatorPorts = AvailablePortHelper.getRandomAvailableTCPPorts(2);\n    locator1.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n    locator2.invoke(() -> DistributedTestUtils.deleteLocatorStateFile(locatorPorts));\n\n    String hostName = NetworkUtils.getServerHostName(host);\n    String locatorString = getLocatorString(locatorPorts);\n    try {\n      locator1.invoke(\n          invokeStartLocator(hostName, locatorPorts[0], getLocatorPropertiesPre91(locatorString)));\n      locator2.invoke(\n          invokeStartLocator(hostName, locatorPorts[1], getLocatorPropertiesPre91(locatorString)));\n      invokeRunnableInVMs(invokeCreateCache(getSystemProperties(locatorPorts)), server1, server2);\n\n      \r\n      \r\n      locator1.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n      locator2.invoke(\n          () -> await()\n              .untilAsserted(() -> assertTrue(\n                  !InternalLocator.getLocator().getConfig().getEnableClusterConfiguration()\n                      || InternalLocator.getLocator().isSharedConfigurationRunning())));\n\n      server1.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n      server2.invoke(() -> createLuceneIndex(cache, regionName, INDEX_NAME));\n\n      invokeRunnableInVMs(invokeCreateRegion(regionName, shortcut.name()), server1, server2);\n      int expectedRegionSize = 10;\n      putSerializableObject(server1, regionName, 0, 10);\n      locator1 = rollLocatorToCurrent(locator1, hostName, locatorPorts[0], getTestMethodName(),\n          locatorString);\n\n      locator2 = rollLocatorToCurrent(locator2, hostName, locatorPorts[1], getTestMethodName(),\n          locatorString);\n\n      server1 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server1, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 10;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 15,\n          25, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 15,\n          25, server1);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 20,\n          30, server2);\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 20,\n          30, server1);\n\n      server2 = rollServerToCurrentCreateLuceneIndexAndCreateRegion(server2, regionType, null,\n          shortcut.name(), regionName, locatorPorts, reindex);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server2, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 25,\n          35, server1, server2);\n      expectedRegionSize += 5;\n      putSerializableObjectAndVerifyLuceneQueryResult(server1, regionName,\n          hasLuceneVersionMismatch(host),\n          expectedRegionSize, 30,\n          40, server1, server2);\n\n    } finally {\n      invokeRunnableInVMs(true, invokeStopLocator(), locator1, locator2);\n      invokeRunnableInVMs(true, invokeCloseCache(), server1, server2);\n    }\n  }\n","realPath":"geode-lucene/src/upgradeTest/java/org/apache/geode/cache/lucene/RollingUpgradeQueryReturnsCorrectResultAfterTwoLocatorsWithTwoServersAreRolled.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":35,"status":"M"}],"commitId":"08ecbe70b64a72113aa4eddbd31ec732e77eb1f9","commitMessage":"@@@Revert \"GEODE-7309: uplift lucene to 7.1.0 (#6351)\" (#6903)\n\nThis reverts commit 68629356f561a932f5dfbace70b01d9971a42473.","date":"2021-09-25 14:47:02","modifiedFileCount":"17","status":"M","submitter":"Kamilla Aslami"}]
