[{"authorTime":"2019-11-19 00:03:09","codes":[{"authorDate":"2019-11-16 02:39:37","commitOrder":4,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","date":"2019-11-16 02:39:37","endLine":477,"groupId":"7172","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/46/551b74a6e58380edbbefac9d9507c8b8815237.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":438,"status":"NB"},{"authorDate":"2019-11-19 00:03:09","commitOrder":4,"curCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit())\n        .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n  }\n","date":"2019-11-19 00:03:09","endLine":524,"groupId":"7172","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBufferAtWriteLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/1d/5e4a67e20fa72efd761a310fc83449b49416b3.src","preCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit())\n        .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":487,"status":"B"}],"commitId":"f46b492cf09ed2626646b2da06a6f76e4a23794e","commitMessage":"@@@GEODE-7450 SSL peerAppDataBuffer expansion needs work (#4336)\n\nensure that the buffer capacity always increases after an overflow\nstatus is returned.","date":"2019-11-19 00:03:09","modifiedFileCount":"2","status":"M","submitter":"Bruce Schuchardt"},{"authorTime":"2020-10-30 07:38:25","codes":[{"authorDate":"2020-10-30 07:38:25","commitOrder":5,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","date":"2020-10-30 07:38:25","endLine":501,"groupId":"7172","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/e9/b01cfd0ea5c86b2b7a2ad8e53f1928429cda44.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":453,"status":"M"},{"authorDate":"2020-10-30 07:38:25","commitOrder":5,"curCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit())\n          .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n    }\n  }\n","date":"2020-10-30 07:38:25","endLine":553,"groupId":"7172","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBufferAtWriteLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/e9/b01cfd0ea5c86b2b7a2ad8e53f1928429cda44.src","preCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit())\n        .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":510,"status":"M"}],"commitId":"08e9e9673d0ed05555a3d74c6d16e706817cab09","commitMessage":"@@@GEODE-8652: NioSslEngine.close() Bypasses Locks (#5666)\n\n- NioSslEngine.close() proceeds even if readers (or writers) are\n  operating on its ByteBuffers.  allowing Connection.close() to close \n  its socket and proceed.\n\n- NioSslEngine.close() needed a lock only on the output buffer.  so \n  we split what was a single lock into two. Also instead of using \n  synchronized we use a ReentrantLock so we can \n  call tryLock() and time out if needed in NioSslEngine.close().\n\n- Since readers/writers may hold locks on these input/output buffers\n  when NioSslEngine.close() is called a reference count is maintained\n  and the buffers are returned to the pool only when the last user\n  is done.\n\n- To manage the locking and reference counting a new AutoCloseable\n  ByteBufferSharing interface is introduced with a trivial \n  implementation: ByteBufferSharingNoOp and a real implementation:\n  ByteBufferSharingImpl.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>","date":"2020-10-30 07:38:25","modifiedFileCount":"9","status":"M","submitter":"Bill Burcham"},{"authorTime":"2020-11-06 04:52:02","codes":[{"authorDate":"2020-11-06 04:52:02","commitOrder":6,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","date":"2020-11-06 05:45:26","endLine":499,"groupId":"7172","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/88/e4f31a6fdf460bda4a1562a2f06ec9701417ea.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":460,"status":"M"},{"authorDate":"2020-11-06 04:52:02","commitOrder":6,"curCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit())\n        .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n  }\n","date":"2020-11-06 05:45:26","endLine":546,"groupId":"7172","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBufferAtWriteLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/88/e4f31a6fdf460bda4a1562a2f06ec9701417ea.src","preCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit())\n          .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"M"}],"commitId":"9653a0b6e490272fa77d375049f0e9f1cb6c8929","commitMessage":"@@@Revert \"GEODE-8652: NioSslEngine.close() Bypasses Locks (#5666)\"\n\nThis reverts commit 08e9e9673d0ed05555a3d74c6d16e706817cab09.\n","date":"2020-11-06 05:45:26","modifiedFileCount":"9","status":"M","submitter":"Bill Burcham"},{"authorTime":"2020-11-06 09:30:29","codes":[{"authorDate":"2020-11-06 09:30:29","commitOrder":7,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","date":"2020-11-06 09:30:29","endLine":526,"groupId":"7172","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/df/d7b9012b1bcff84ad56505519a39503aa3b1fb.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n    \r\n    int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n    assertThat(nioSslEngine.peerAppData.capacity())\n        .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"},{"authorDate":"2020-11-06 09:30:29","commitOrder":7,"curCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit())\n          .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n    }\n  }\n","date":"2020-11-06 09:30:29","endLine":578,"groupId":"7172","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBufferAtWriteLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/df/d7b9012b1bcff84ad56505519a39503aa3b1fb.src","preCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.peerAppData = unwrappedBuffer;\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    ByteBuffer data = nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer);\n    verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n    assertThat(data.position()).isEqualTo(0);\n    assertThat(data.limit())\n        .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":535,"status":"M"}],"commitId":"af267c005a63317cbb8528cdb38eccf6a8747818","commitMessage":"@@@* GEODE-8652: NioSslEngine.close() Bypasses Locks (#5712)\n\n- NioSslEngine.close() proceeds even if readers (or writers) are\n  operating on its ByteBuffers.  allowing Connection.close() to close\n  its socket and proceed.\n\n- NioSslEngine.close() needed a lock only on the output buffer.  so\n  we split what was a single lock into two. Also instead of using\n  synchronized we use a ReentrantLock so we can\n  call tryLock() and time out if needed in NioSslEngine.close().\n\n- Since readers/writers may hold locks on these input/output buffers\n  when NioSslEngine.close() is called a reference count is maintained\n  and the buffers are returned to the pool only when the last user\n  is done.\n\n- To manage the locking and reference counting a new AutoCloseable\n  ByteBufferSharing interface is introduced with a trivial\n  implementation: ByteBufferSharingNoOp and a real implementation:\n  ByteBufferSharingImpl.\n\n- Added a new unit test.  and a new concurrency test for\n  ByteBufferSharingImpl: both ensure that ByteBuffers are returned\n  to the pool exactly once. Added a new DUnit test for the interaction\n  between ByteBufferSharingImpl and NioSslEngine and Connection.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>\nCo-authored-by: Dan Smith <upthewaterspout@apache.org>","date":"2020-11-06 09:30:29","modifiedFileCount":"9","status":"M","submitter":"Bill Burcham"},{"authorTime":"2021-04-18 04:15:53","codes":[{"authorDate":"2021-04-18 04:15:53","commitOrder":8,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferVendor inputSharingImpl = (ByteBufferVendor) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","date":"2021-04-29 01:25:35","endLine":526,"groupId":"7172","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/62/a858c9832508665d2326f9a6eb0f4f6643add8.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"M"},{"authorDate":"2021-04-18 04:15:53","commitOrder":8,"curCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferVendor inputSharingImpl = (ByteBufferVendor) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit())\n          .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n    }\n  }\n","date":"2021-04-29 01:25:35","endLine":578,"groupId":"7172","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"readAtLeastUsingSmallAppBufferAtWriteLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/62/a858c9832508665d2326f9a6eb0f4f6643add8.src","preCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferSharingImpl inputSharingImpl = (ByteBufferSharingImpl) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit())\n          .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":535,"status":"M"}],"commitId":"38a3540583a1d0a402b026ee0d33ae4b0a2907d3","commitMessage":"@@@GEODE-9141: (1 of 2) rename ByteBufferSharingImpl to ByteBuferVendor\n","date":"2021-04-29 01:25:35","modifiedFileCount":"4","status":"M","submitter":"Bill Burcham"},{"authorTime":"2021-04-18 00:12:13","codes":[{"authorDate":"2021-04-18 00:12:13","commitOrder":9,"curCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    nioSslEngine.getInputBufferVendorForTestingOnly().setBufferForTestingOnly(unwrappedBuffer);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing =\n          nioSslEngine.getInputBufferVendorForTestingOnly().open()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","date":"2021-04-29 01:25:35","endLine":532,"groupId":"102565","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"readAtLeastUsingSmallAppBuffer","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/d6/b9aa64850c9bae417a4ecf837e567ba5e51df9.src","preCode":"  public void readAtLeastUsingSmallAppBuffer() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 60;\n    final int preexistingBytes = 10;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    int initialUnwrappedBufferSize = 100;\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferVendor inputSharingImpl = (ByteBufferVendor) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0), \r\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0)); \r\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(3)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit()).isEqualTo(individualRead * 3 + preexistingBytes);\n      \r\n      int initialFreeSpace = initialUnwrappedBufferSize - preexistingBytes;\n      try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n        assertThat(inputSharing.getBuffer().capacity())\n            .isEqualTo(2 * initialFreeSpace + preexistingBytes);\n      }\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":486,"status":"M"},{"authorDate":"2021-04-18 00:12:13","commitOrder":9,"curCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    nioSslEngine.getInputBufferVendorForTestingOnly().setBufferForTestingOnly(unwrappedBuffer);\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit())\n          .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n    }\n  }\n","date":"2021-04-29 01:25:35","endLine":581,"groupId":"102565","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"readAtLeastUsingSmallAppBufferAtWriteLimit","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/d6/b9aa64850c9bae417a4ecf837e567ba5e51df9.src","preCode":"  public void readAtLeastUsingSmallAppBufferAtWriteLimit() throws Exception {\n    final int amountToRead = 150;\n    final int individualRead = 150;\n\n    int initialUnwrappedBufferSize = 100;\n    final int preexistingBytes = initialUnwrappedBufferSize - 7;\n    ByteBuffer wrappedBuffer = ByteBuffer.allocate(1000);\n    SocketChannel mockChannel = mock(SocketChannel.class);\n\n    \r\n    ByteBuffer unwrappedBuffer = ByteBuffer.allocate(initialUnwrappedBufferSize);\n    unwrappedBuffer.position(7).limit(preexistingBytes + 7); \r\n    try (final ByteBufferSharing inputSharing = nioSslEngine.shareInputBuffer()) {\n      final ByteBufferVendor inputSharingImpl = (ByteBufferVendor) inputSharing;\n      inputSharingImpl.setBufferForTestingOnly(unwrappedBuffer);\n    }\n\n    \r\n    when(mockChannel.read(any(ByteBuffer.class))).thenAnswer(new Answer<Integer>() {\n      @Override\n      public Integer answer(InvocationOnMock invocation) throws Throwable {\n        ByteBuffer buffer = invocation.getArgument(0);\n        buffer.position(buffer.position() + individualRead);\n        return individualRead;\n      }\n    });\n\n    TestSSLEngine testSSLEngine = new TestSSLEngine();\n    testSSLEngine.addReturnResult(\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(BUFFER_OVERFLOW, NEED_UNWRAP, 0, 0),\n        new SSLEngineResult(OK, NEED_UNWRAP, 0, 0));\n    nioSslEngine.engine = testSSLEngine;\n\n    try (final ByteBufferSharing sharedBuffer =\n        nioSslEngine.readAtLeast(mockChannel, amountToRead, wrappedBuffer)) {\n      ByteBuffer data = sharedBuffer.getBuffer();\n      verify(mockChannel, times(1)).read(isA(ByteBuffer.class));\n      assertThat(data.position()).isEqualTo(0);\n      assertThat(data.limit())\n          .isEqualTo(individualRead * testSSLEngine.getNumberOfUnwraps() + preexistingBytes);\n    }\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/NioSslEngineTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":541,"status":"M"}],"commitId":"9d0d4d1d33794d0f6a21c3bcae71e965cbbd7fbd","commitMessage":"@@@GEODE-9141: (2 of 2) Handle in-buffer concurrency\n* Connection uses a ByteBufferVendor to mediate access to inputBuffer\n* Prevent return to pool before socket closer is finished\n","date":"2021-04-29 01:25:35","modifiedFileCount":"12","status":"M","submitter":"Bill Burcham"}]
