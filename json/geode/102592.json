[{"authorTime":"2020-11-06 09:30:29","codes":[{"authorDate":"2020-11-06 09:30:29","commitOrder":1,"curCode":"  public void concurrentAccessToSharingShouldBeExclusive(ParallelExecutor executor)\n      throws Exception {\n    poolMock = mock(BufferPool.class);\n    ByteBuffer someBuffer = ByteBuffer.allocate(1);\n    ByteBufferSharingImpl sharing =\n        new ByteBufferSharingImpl(someBuffer, BufferPool.BufferType.TRACKED_SENDER,\n            poolMock);\n\n    final AtomicBoolean inUse = new AtomicBoolean(false);\n    final RunnableWithException useBufferAndCheckAccess = () -> {\n      try (ByteBufferSharing localSharing = sharing.open()) {\n        assertFalse(inUse.getAndSet(true));\n        localSharing.getBuffer();\n        assertTrue(inUse.getAndSet(false));\n      }\n    };\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.execute();\n    verify(poolMock, times(0)).releaseBuffer(any(), any());\n    sharing.destruct();\n    verify(poolMock, times(1)).releaseBuffer(any(), any());\n  }\n","date":"2020-11-06 09:30:29","endLine":130,"groupId":"23324","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"concurrentAccessToSharingShouldBeExclusive","params":"(ParallelExecutorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7c/1f38352c56ad703649a3e6bd7e35a009e7cb71.src","preCode":"  public void concurrentAccessToSharingShouldBeExclusive(ParallelExecutor executor)\n      throws Exception {\n    poolMock = mock(BufferPool.class);\n    ByteBuffer someBuffer = ByteBuffer.allocate(1);\n    ByteBufferSharingImpl sharing =\n        new ByteBufferSharingImpl(someBuffer, BufferPool.BufferType.TRACKED_SENDER,\n            poolMock);\n\n    final AtomicBoolean inUse = new AtomicBoolean(false);\n    final RunnableWithException useBufferAndCheckAccess = () -> {\n      try (ByteBufferSharing localSharing = sharing.open()) {\n        assertFalse(inUse.getAndSet(true));\n        localSharing.getBuffer();\n        assertTrue(inUse.getAndSet(false));\n      }\n    };\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.execute();\n    verify(poolMock, times(0)).releaseBuffer(any(), any());\n    sharing.destruct();\n    verify(poolMock, times(1)).releaseBuffer(any(), any());\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/ByteBufferConcurrencyTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"B"},{"authorDate":"2020-11-06 09:30:29","commitOrder":1,"curCode":"  public void concurrentAccessToSharingShouldBeExclusiveWithExtraCloses(ParallelExecutor executor)\n      throws Exception {\n    poolMock = mock(BufferPool.class);\n    ByteBuffer someBuffer = ByteBuffer.allocate(1);\n    ByteBufferSharingImpl sharing =\n        new ByteBufferSharingImpl(someBuffer, BufferPool.BufferType.TRACKED_SENDER,\n            poolMock);\n\n    final AtomicBoolean inUse = new AtomicBoolean(false);\n    final RunnableWithException useBufferAndCheckAccess = () -> {\n      Assertions.assertThatThrownBy(() -> {\n        try (ByteBufferSharing localSharing = sharing.open()) {\n          assertFalse(inUse.getAndSet(true));\n          localSharing.getBuffer();\n          assertTrue(inUse.getAndSet(false));\n          localSharing.close();\n        }\n      }).isInstanceOf(IllegalMonitorStateException.class);\n    };\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.execute();\n\n\n    verify(poolMock, times(0)).releaseBuffer(any(), any());\n    sharing.destruct();\n    verify(poolMock, times(1)).releaseBuffer(any(), any());\n  }\n","date":"2020-11-06 09:30:29","endLine":161,"groupId":"23324","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"concurrentAccessToSharingShouldBeExclusiveWithExtraCloses","params":"(ParallelExecutorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7c/1f38352c56ad703649a3e6bd7e35a009e7cb71.src","preCode":"  public void concurrentAccessToSharingShouldBeExclusiveWithExtraCloses(ParallelExecutor executor)\n      throws Exception {\n    poolMock = mock(BufferPool.class);\n    ByteBuffer someBuffer = ByteBuffer.allocate(1);\n    ByteBufferSharingImpl sharing =\n        new ByteBufferSharingImpl(someBuffer, BufferPool.BufferType.TRACKED_SENDER,\n            poolMock);\n\n    final AtomicBoolean inUse = new AtomicBoolean(false);\n    final RunnableWithException useBufferAndCheckAccess = () -> {\n      Assertions.assertThatThrownBy(() -> {\n        try (ByteBufferSharing localSharing = sharing.open()) {\n          assertFalse(inUse.getAndSet(true));\n          localSharing.getBuffer();\n          assertTrue(inUse.getAndSet(false));\n          localSharing.close();\n        }\n      }).isInstanceOf(IllegalMonitorStateException.class);\n    };\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.execute();\n\n\n    verify(poolMock, times(0)).releaseBuffer(any(), any());\n    sharing.destruct();\n    verify(poolMock, times(1)).releaseBuffer(any(), any());\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/ByteBufferConcurrencyTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"B"}],"commitId":"af267c005a63317cbb8528cdb38eccf6a8747818","commitMessage":"@@@* GEODE-8652: NioSslEngine.close() Bypasses Locks (#5712)\n\n- NioSslEngine.close() proceeds even if readers (or writers) are\n  operating on its ByteBuffers.  allowing Connection.close() to close\n  its socket and proceed.\n\n- NioSslEngine.close() needed a lock only on the output buffer.  so\n  we split what was a single lock into two. Also instead of using\n  synchronized we use a ReentrantLock so we can\n  call tryLock() and time out if needed in NioSslEngine.close().\n\n- Since readers/writers may hold locks on these input/output buffers\n  when NioSslEngine.close() is called a reference count is maintained\n  and the buffers are returned to the pool only when the last user\n  is done.\n\n- To manage the locking and reference counting a new AutoCloseable\n  ByteBufferSharing interface is introduced with a trivial\n  implementation: ByteBufferSharingNoOp and a real implementation:\n  ByteBufferSharingImpl.\n\n- Added a new unit test.  and a new concurrency test for\n  ByteBufferSharingImpl: both ensure that ByteBuffers are returned\n  to the pool exactly once. Added a new DUnit test for the interaction\n  between ByteBufferSharingImpl and NioSslEngine and Connection.\n\nCo-authored-by: Bill Burcham <bill.burcham@gmail.com>\nCo-authored-by: Darrel Schneider <dschneider@pivotal.io>\nCo-authored-by: Ernie Burghardt <burghardte@vmware.com>\nCo-authored-by: Dan Smith <upthewaterspout@apache.org>","date":"2020-11-06 09:30:29","modifiedFileCount":"9","status":"B","submitter":"Bill Burcham"},{"authorTime":"2021-04-18 04:15:53","codes":[{"authorDate":"2021-04-18 04:15:53","commitOrder":2,"curCode":"  public void concurrentAccessToSharingShouldBeExclusive(ParallelExecutor executor)\n      throws Exception {\n    poolMock = mock(BufferPool.class);\n    ByteBuffer someBuffer = ByteBuffer.allocate(1);\n    ByteBufferVendor sharing =\n        new ByteBufferVendor(someBuffer, BufferPool.BufferType.TRACKED_SENDER,\n            poolMock);\n\n    final AtomicBoolean inUse = new AtomicBoolean(false);\n    final RunnableWithException useBufferAndCheckAccess = () -> {\n      try (ByteBufferSharing localSharing = sharing.open()) {\n        assertFalse(inUse.getAndSet(true));\n        localSharing.getBuffer();\n        assertTrue(inUse.getAndSet(false));\n      }\n    };\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.execute();\n    verify(poolMock, times(0)).releaseBuffer(any(), any());\n    sharing.destruct();\n    verify(poolMock, times(1)).releaseBuffer(any(), any());\n  }\n","date":"2021-04-29 01:25:35","endLine":130,"groupId":"102592","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"concurrentAccessToSharingShouldBeExclusive","params":"(ParallelExecutorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/bf/9596377ee709320137a2a7c702a8cd55bdc903.src","preCode":"  public void concurrentAccessToSharingShouldBeExclusive(ParallelExecutor executor)\n      throws Exception {\n    poolMock = mock(BufferPool.class);\n    ByteBuffer someBuffer = ByteBuffer.allocate(1);\n    ByteBufferSharingImpl sharing =\n        new ByteBufferSharingImpl(someBuffer, BufferPool.BufferType.TRACKED_SENDER,\n            poolMock);\n\n    final AtomicBoolean inUse = new AtomicBoolean(false);\n    final RunnableWithException useBufferAndCheckAccess = () -> {\n      try (ByteBufferSharing localSharing = sharing.open()) {\n        assertFalse(inUse.getAndSet(true));\n        localSharing.getBuffer();\n        assertTrue(inUse.getAndSet(false));\n      }\n    };\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.execute();\n    verify(poolMock, times(0)).releaseBuffer(any(), any());\n    sharing.destruct();\n    verify(poolMock, times(1)).releaseBuffer(any(), any());\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/ByteBufferConcurrencyTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"},{"authorDate":"2021-04-18 04:15:53","commitOrder":2,"curCode":"  public void concurrentAccessToSharingShouldBeExclusiveWithExtraCloses(ParallelExecutor executor)\n      throws Exception {\n    poolMock = mock(BufferPool.class);\n    ByteBuffer someBuffer = ByteBuffer.allocate(1);\n    ByteBufferVendor sharing =\n        new ByteBufferVendor(someBuffer, BufferPool.BufferType.TRACKED_SENDER,\n            poolMock);\n\n    final AtomicBoolean inUse = new AtomicBoolean(false);\n    final RunnableWithException useBufferAndCheckAccess = () -> {\n      Assertions.assertThatThrownBy(() -> {\n        try (ByteBufferSharing localSharing = sharing.open()) {\n          assertFalse(inUse.getAndSet(true));\n          localSharing.getBuffer();\n          assertTrue(inUse.getAndSet(false));\n          localSharing.close();\n        }\n      }).isInstanceOf(IllegalMonitorStateException.class);\n    };\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.execute();\n\n\n    verify(poolMock, times(0)).releaseBuffer(any(), any());\n    sharing.destruct();\n    verify(poolMock, times(1)).releaseBuffer(any(), any());\n  }\n","date":"2021-04-29 01:25:35","endLine":161,"groupId":"102592","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"concurrentAccessToSharingShouldBeExclusiveWithExtraCloses","params":"(ParallelExecutorexecutor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/bf/9596377ee709320137a2a7c702a8cd55bdc903.src","preCode":"  public void concurrentAccessToSharingShouldBeExclusiveWithExtraCloses(ParallelExecutor executor)\n      throws Exception {\n    poolMock = mock(BufferPool.class);\n    ByteBuffer someBuffer = ByteBuffer.allocate(1);\n    ByteBufferSharingImpl sharing =\n        new ByteBufferSharingImpl(someBuffer, BufferPool.BufferType.TRACKED_SENDER,\n            poolMock);\n\n    final AtomicBoolean inUse = new AtomicBoolean(false);\n    final RunnableWithException useBufferAndCheckAccess = () -> {\n      Assertions.assertThatThrownBy(() -> {\n        try (ByteBufferSharing localSharing = sharing.open()) {\n          assertFalse(inUse.getAndSet(true));\n          localSharing.getBuffer();\n          assertTrue(inUse.getAndSet(false));\n          localSharing.close();\n        }\n      }).isInstanceOf(IllegalMonitorStateException.class);\n    };\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.inParallel(useBufferAndCheckAccess);\n    executor.execute();\n\n\n    verify(poolMock, times(0)).releaseBuffer(any(), any());\n    sharing.destruct();\n    verify(poolMock, times(1)).releaseBuffer(any(), any());\n  }\n","realPath":"geode-core/src/test/java/org/apache/geode/internal/net/ByteBufferConcurrencyTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"M"}],"commitId":"38a3540583a1d0a402b026ee0d33ae4b0a2907d3","commitMessage":"@@@GEODE-9141: (1 of 2) rename ByteBufferSharingImpl to ByteBuferVendor\n","date":"2021-04-29 01:25:35","modifiedFileCount":"4","status":"M","submitter":"Bill Burcham"}]
