[{"authorTime":"2018-07-18 03:54:18","codes":[{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex() throws Exception {\n    IndexManager.TEST_RANGEINDEX_ONLY = true;\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    LocalRegion testRgn = (LocalRegion) CacheUtils.createRegion(\"testRgn\", null);\n    int ID = 1;\n    \r\n    \r\n    \r\n    for (; ID <= 5; ++ID) {\n      MapKeyIndexData mkid = new MapKeyIndexData(ID);\n      for (int j = 1; j <= ID; ++j) {\n        mkid.maap.put(\"key\" + j, \"val\" + j);\n      }\n      testRgn.put(ID, mkid);\n    }\n    --ID;\r\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL,\n        \"objs.maap['key1','key2','key3','key7']\", \"/testRgn objs\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.maap['key1','key2','key3','key7']\");\n    assertTrue(i1 instanceof MapRangeIndex);\n    MapRangeIndex mri = (MapRangeIndex) i1;\n    \r\n    \r\n    Map<Object, AbstractIndex> indxMap = mri.getRangeIndexHolderForTesting();\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    ++ID; \r\n    MapKeyIndexData mkid = new MapKeyIndexData(ID);\n    for (int j = 1; j <= ID; ++j) {\n      mkid.maap.put(\"key\" + j, \"val\" + j);\n    }\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    mkid.maap.put(\"key7\", \"val7\");\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 4);\n\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    assertTrue(indxMap.containsKey(\"key7\"));\n    RangeIndex rng = (RangeIndex) indxMap.get(\"key7\");\n    Iterator itr = rng.valueToEntriesMap.values().iterator();\n    assertEquals(rng.valueToEntriesMap.size(), 1);\n    assertTrue(rng.valueToEntriesMap.containsKey(\"val7\"));\n    RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n    assertEquals(1, entryMap.getNumEntries());\n    RegionEntry re = testRgn.basicGetEntry(6);\n    entryMap.containsEntry(re);\n\n    \r\n    mkid.maap.remove(\"key7\");\n    testRgn.put(ID, mkid);\n    \r\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      rng = (RangeIndex) indxMap.get(\"key\" + j);\n      itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    \r\n    mkid = (MapKeyIndexData) testRgn.get(1);\n    mkid.maap.put(\"key1\", \"val2\");\n    testRgn.put(1, mkid);\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(5, entryMap.getNumEntries());\n        expectedElements.remove(1);\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID + 1 - j, entryMap.getNumEntries());\n          for (Integer elem : expectedElements) {\n            re = testRgn.basicGetEntry(elem);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n      }\n    }\n    \r\n    testRgn.remove(3);\n\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(4, entryMap.getNumEntries());\n\n        for (int k = 2; k <= 6; ++k) {\n          if (k == 3) {\n            continue;\n          } else {\n            re = testRgn.basicGetEntry(k);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID - j, entryMap.getNumEntries());\n          for (int p = j; p <= ID; ++p) {\n            re = testRgn.basicGetEntry(p);\n            if (p == 3) {\n              assertNull(re);\n            } else {\n              assertTrue(entryMap.containsEntry(re));\n            }\n          }\n        }\n      }\n    }\n  }\n","date":"2018-07-18 03:54:18","endLine":887,"groupId":"7422","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/88/c3c7d94beb50946047aab031afabcd66d50524.src","preCode":"  public void testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex() throws Exception {\n    IndexManager.TEST_RANGEINDEX_ONLY = true;\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    LocalRegion testRgn = (LocalRegion) CacheUtils.createRegion(\"testRgn\", null);\n    int ID = 1;\n    \r\n    \r\n    \r\n    for (; ID <= 5; ++ID) {\n      MapKeyIndexData mkid = new MapKeyIndexData(ID);\n      for (int j = 1; j <= ID; ++j) {\n        mkid.maap.put(\"key\" + j, \"val\" + j);\n      }\n      testRgn.put(ID, mkid);\n    }\n    --ID;\r\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL,\n        \"objs.maap['key1','key2','key3','key7']\", \"/testRgn objs\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.maap['key1','key2','key3','key7']\");\n    assertTrue(i1 instanceof MapRangeIndex);\n    MapRangeIndex mri = (MapRangeIndex) i1;\n    \r\n    \r\n    Map<Object, AbstractIndex> indxMap = mri.getRangeIndexHolderForTesting();\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    ++ID; \r\n    MapKeyIndexData mkid = new MapKeyIndexData(ID);\n    for (int j = 1; j <= ID; ++j) {\n      mkid.maap.put(\"key\" + j, \"val\" + j);\n    }\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    mkid.maap.put(\"key7\", \"val7\");\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 4);\n\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    assertTrue(indxMap.containsKey(\"key7\"));\n    RangeIndex rng = (RangeIndex) indxMap.get(\"key7\");\n    Iterator itr = rng.valueToEntriesMap.values().iterator();\n    assertEquals(rng.valueToEntriesMap.size(), 1);\n    assertTrue(rng.valueToEntriesMap.containsKey(\"val7\"));\n    RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n    assertEquals(1, entryMap.getNumEntries());\n    RegionEntry re = testRgn.basicGetEntry(6);\n    entryMap.containsEntry(re);\n\n    \r\n    mkid.maap.remove(\"key7\");\n    testRgn.put(ID, mkid);\n    \r\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      rng = (RangeIndex) indxMap.get(\"key\" + j);\n      itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    \r\n    mkid = (MapKeyIndexData) testRgn.get(1);\n    mkid.maap.put(\"key1\", \"val2\");\n    testRgn.put(1, mkid);\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(5, entryMap.getNumEntries());\n        expectedElements.remove(1);\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID + 1 - j, entryMap.getNumEntries());\n          for (Integer elem : expectedElements) {\n            re = testRgn.basicGetEntry(elem);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n      }\n    }\n    \r\n    testRgn.remove(3);\n\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(4, entryMap.getNumEntries());\n\n        for (int k = 2; k <= 6; ++k) {\n          if (k == 3) {\n            continue;\n          } else {\n            re = testRgn.basicGetEntry(k);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID - j, entryMap.getNumEntries());\n          for (int p = j; p <= ID; ++p) {\n            re = testRgn.basicGetEntry(p);\n            if (p == 3) {\n              assertNull(re);\n            } else {\n              assertTrue(entryMap.containsEntry(re));\n            }\n          }\n        }\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexMaintenanceJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":649,"status":"B"},{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testMapKeyIndexCreation_2_NonCompactType() throws Exception {\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL, \"pf.positions['key1','key2','key3']\",\n        \"/portfolios pf\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.positions['key1','key2','key3']\");\n    assertTrue(i1 instanceof CompactMapRangeIndex);\n    CompactMapRangeIndex mri = (CompactMapRangeIndex) i1;\n    Object mapKeys[] = mri.getMapKeysForTesting();\n    assertEquals(mapKeys.length, 3);\n    Set<String> keys = new HashSet<String>();\n    keys.add(\"key1\");\n    keys.add(\"key2\");\n    keys.add(\"key3\");\n    for (Object key : mapKeys) {\n      keys.remove(key);\n    }\n    assertTrue(keys.isEmpty());\n    String[] patterns = mri.getPatternsForTesting();\n    assertEquals(patterns.length, 3);\n    Set<String> patternsSet = new HashSet<String>();\n    patternsSet.add(\"index_iter1.positions['key1']\");\n    patternsSet.add(\"index_iter1.positions['key2']\");\n    patternsSet.add(\"index_iter1.positions['key3']\");\n    for (String ptrn : patterns) {\n      patternsSet.remove(ptrn);\n    }\n    assertTrue(patternsSet.isEmpty());\n    assertEquals(mri.getIndexedExpression(), \"pf.positions['key1','key2','key3']\");\n  }\n","date":"2018-07-18 03:54:18","endLine":765,"groupId":"24019","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testMapKeyIndexCreation_2_NonCompactType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/26/c115c3e3e786cedc40703e52e37f8ef4d52e77.src","preCode":"  public void testMapKeyIndexCreation_2_NonCompactType() throws Exception {\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL, \"pf.positions['key1','key2','key3']\",\n        \"/portfolios pf\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.positions['key1','key2','key3']\");\n    assertTrue(i1 instanceof CompactMapRangeIndex);\n    CompactMapRangeIndex mri = (CompactMapRangeIndex) i1;\n    Object mapKeys[] = mri.getMapKeysForTesting();\n    assertEquals(mapKeys.length, 3);\n    Set<String> keys = new HashSet<String>();\n    keys.add(\"key1\");\n    keys.add(\"key2\");\n    keys.add(\"key3\");\n    for (Object key : mapKeys) {\n      keys.remove(key);\n    }\n    assertTrue(keys.isEmpty());\n    String[] patterns = mri.getPatternsForTesting();\n    assertEquals(patterns.length, 3);\n    Set<String> patternsSet = new HashSet<String>();\n    patternsSet.add(\"index_iter1.positions['key1']\");\n    patternsSet.add(\"index_iter1.positions['key2']\");\n    patternsSet.add(\"index_iter1.positions['key3']\");\n    for (String ptrn : patterns) {\n      patternsSet.remove(ptrn);\n    }\n    assertTrue(patternsSet.isEmpty());\n    assertEquals(mri.getIndexedExpression(), \"pf.positions['key1','key2','key3']\");\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/IndexCreationJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":735,"status":"B"}],"commitId":"cb202f25b93e0a56f4776813da0bf6dcbba231cd","commitMessage":"@@@GEODE-5363: Moves all non-unit tests into specific isolated source sets. (#2126)\n\n* Creates integrationTest source set.\n* Creates distributedTest source set.\n* Creates acceptanceTest source set.\n* Creates uiTest source set.\n* Removes old categories.","date":"2018-07-18 03:54:18","modifiedFileCount":"697","status":"B","submitter":"Jacob Barrett"},{"authorTime":"2020-05-29 00:37:39","codes":[{"authorDate":"2020-05-29 00:37:39","commitOrder":2,"curCode":"  public void testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex() throws Exception {\n    IndexManager.TEST_RANGEINDEX_ONLY = true;\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    LocalRegion testRgn = (LocalRegion) CacheUtils.createRegion(\"testRgn\", null);\n    int ID = 1;\n    \r\n    \r\n    \r\n    for (; ID <= 5; ++ID) {\n      MapKeyIndexData mkid = new MapKeyIndexData(ID);\n      for (int j = 1; j <= ID; ++j) {\n        mkid.maap.put(\"key\" + j, \"val\" + j);\n      }\n      testRgn.put(ID, mkid);\n    }\n    --ID;\r\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL,\n        \"objs.maap['key1','key2','key3','key7']\", SEPARATOR + \"testRgn objs\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.maap['key1','key2','key3','key7']\");\n    assertTrue(i1 instanceof MapRangeIndex);\n    MapRangeIndex mri = (MapRangeIndex) i1;\n    \r\n    \r\n    Map<Object, AbstractIndex> indxMap = mri.getRangeIndexHolderForTesting();\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    ++ID; \r\n    MapKeyIndexData mkid = new MapKeyIndexData(ID);\n    for (int j = 1; j <= ID; ++j) {\n      mkid.maap.put(\"key\" + j, \"val\" + j);\n    }\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    mkid.maap.put(\"key7\", \"val7\");\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 4);\n\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    assertTrue(indxMap.containsKey(\"key7\"));\n    RangeIndex rng = (RangeIndex) indxMap.get(\"key7\");\n    Iterator itr = rng.valueToEntriesMap.values().iterator();\n    assertEquals(rng.valueToEntriesMap.size(), 1);\n    assertTrue(rng.valueToEntriesMap.containsKey(\"val7\"));\n    RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n    assertEquals(1, entryMap.getNumEntries());\n    RegionEntry re = testRgn.basicGetEntry(6);\n    entryMap.containsEntry(re);\n\n    \r\n    mkid.maap.remove(\"key7\");\n    testRgn.put(ID, mkid);\n    \r\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      rng = (RangeIndex) indxMap.get(\"key\" + j);\n      itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    \r\n    mkid = (MapKeyIndexData) testRgn.get(1);\n    mkid.maap.put(\"key1\", \"val2\");\n    testRgn.put(1, mkid);\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(5, entryMap.getNumEntries());\n        expectedElements.remove(1);\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID + 1 - j, entryMap.getNumEntries());\n          for (Integer elem : expectedElements) {\n            re = testRgn.basicGetEntry(elem);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n      }\n    }\n    \r\n    testRgn.remove(3);\n\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(4, entryMap.getNumEntries());\n\n        for (int k = 2; k <= 6; ++k) {\n          if (k == 3) {\n            continue;\n          } else {\n            re = testRgn.basicGetEntry(k);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID - j, entryMap.getNumEntries());\n          for (int p = j; p <= ID; ++p) {\n            re = testRgn.basicGetEntry(p);\n            if (p == 3) {\n              assertNull(re);\n            } else {\n              assertTrue(entryMap.containsEntry(re));\n            }\n          }\n        }\n      }\n    }\n  }\n","date":"2020-05-29 00:37:39","endLine":901,"groupId":"7422","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/45/e8cac1342d658454c69504a7b5b1a0f6f9f51c.src","preCode":"  public void testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex() throws Exception {\n    IndexManager.TEST_RANGEINDEX_ONLY = true;\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    LocalRegion testRgn = (LocalRegion) CacheUtils.createRegion(\"testRgn\", null);\n    int ID = 1;\n    \r\n    \r\n    \r\n    for (; ID <= 5; ++ID) {\n      MapKeyIndexData mkid = new MapKeyIndexData(ID);\n      for (int j = 1; j <= ID; ++j) {\n        mkid.maap.put(\"key\" + j, \"val\" + j);\n      }\n      testRgn.put(ID, mkid);\n    }\n    --ID;\r\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL,\n        \"objs.maap['key1','key2','key3','key7']\", \"/testRgn objs\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.maap['key1','key2','key3','key7']\");\n    assertTrue(i1 instanceof MapRangeIndex);\n    MapRangeIndex mri = (MapRangeIndex) i1;\n    \r\n    \r\n    Map<Object, AbstractIndex> indxMap = mri.getRangeIndexHolderForTesting();\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    ++ID; \r\n    MapKeyIndexData mkid = new MapKeyIndexData(ID);\n    for (int j = 1; j <= ID; ++j) {\n      mkid.maap.put(\"key\" + j, \"val\" + j);\n    }\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    mkid.maap.put(\"key7\", \"val7\");\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 4);\n\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    assertTrue(indxMap.containsKey(\"key7\"));\n    RangeIndex rng = (RangeIndex) indxMap.get(\"key7\");\n    Iterator itr = rng.valueToEntriesMap.values().iterator();\n    assertEquals(rng.valueToEntriesMap.size(), 1);\n    assertTrue(rng.valueToEntriesMap.containsKey(\"val7\"));\n    RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n    assertEquals(1, entryMap.getNumEntries());\n    RegionEntry re = testRgn.basicGetEntry(6);\n    entryMap.containsEntry(re);\n\n    \r\n    mkid.maap.remove(\"key7\");\n    testRgn.put(ID, mkid);\n    \r\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      rng = (RangeIndex) indxMap.get(\"key\" + j);\n      itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    \r\n    mkid = (MapKeyIndexData) testRgn.get(1);\n    mkid.maap.put(\"key1\", \"val2\");\n    testRgn.put(1, mkid);\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(5, entryMap.getNumEntries());\n        expectedElements.remove(1);\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID + 1 - j, entryMap.getNumEntries());\n          for (Integer elem : expectedElements) {\n            re = testRgn.basicGetEntry(elem);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n      }\n    }\n    \r\n    testRgn.remove(3);\n\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(4, entryMap.getNumEntries());\n\n        for (int k = 2; k <= 6; ++k) {\n          if (k == 3) {\n            continue;\n          } else {\n            re = testRgn.basicGetEntry(k);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID - j, entryMap.getNumEntries());\n          for (int p = j; p <= ID; ++p) {\n            re = testRgn.basicGetEntry(p);\n            if (p == 3) {\n              assertNull(re);\n            } else {\n              assertTrue(entryMap.containsEntry(re));\n            }\n          }\n        }\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexMaintenanceJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":663,"status":"M"},{"authorDate":"2020-05-29 00:37:39","commitOrder":2,"curCode":"  public void testMapKeyIndexCreation_2_NonCompactType() throws Exception {\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL, \"pf.positions['key1','key2','key3']\",\n        SEPARATOR + \"portfolios pf\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.positions['key1','key2','key3']\");\n    assertTrue(i1 instanceof CompactMapRangeIndex);\n    CompactMapRangeIndex mri = (CompactMapRangeIndex) i1;\n    Object mapKeys[] = mri.getMapKeysForTesting();\n    assertEquals(mapKeys.length, 3);\n    Set<String> keys = new HashSet<String>();\n    keys.add(\"key1\");\n    keys.add(\"key2\");\n    keys.add(\"key3\");\n    for (Object key : mapKeys) {\n      keys.remove(key);\n    }\n    assertTrue(keys.isEmpty());\n    String[] patterns = mri.getPatternsForTesting();\n    assertEquals(patterns.length, 3);\n    Set<String> patternsSet = new HashSet<String>();\n    patternsSet.add(\"index_iter1.positions['key1']\");\n    patternsSet.add(\"index_iter1.positions['key2']\");\n    patternsSet.add(\"index_iter1.positions['key3']\");\n    for (String ptrn : patterns) {\n      patternsSet.remove(ptrn);\n    }\n    assertTrue(patternsSet.isEmpty());\n    assertEquals(mri.getIndexedExpression(), \"pf.positions['key1','key2','key3']\");\n  }\n","date":"2020-05-29 00:37:39","endLine":801,"groupId":"24019","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testMapKeyIndexCreation_2_NonCompactType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/84/ff970e40c8dfd81312bc2e6262d71a3672de70.src","preCode":"  public void testMapKeyIndexCreation_2_NonCompactType() throws Exception {\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL, \"pf.positions['key1','key2','key3']\",\n        \"/portfolios pf\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.positions['key1','key2','key3']\");\n    assertTrue(i1 instanceof CompactMapRangeIndex);\n    CompactMapRangeIndex mri = (CompactMapRangeIndex) i1;\n    Object mapKeys[] = mri.getMapKeysForTesting();\n    assertEquals(mapKeys.length, 3);\n    Set<String> keys = new HashSet<String>();\n    keys.add(\"key1\");\n    keys.add(\"key2\");\n    keys.add(\"key3\");\n    for (Object key : mapKeys) {\n      keys.remove(key);\n    }\n    assertTrue(keys.isEmpty());\n    String[] patterns = mri.getPatternsForTesting();\n    assertEquals(patterns.length, 3);\n    Set<String> patternsSet = new HashSet<String>();\n    patternsSet.add(\"index_iter1.positions['key1']\");\n    patternsSet.add(\"index_iter1.positions['key2']\");\n    patternsSet.add(\"index_iter1.positions['key3']\");\n    for (String ptrn : patterns) {\n      patternsSet.remove(ptrn);\n    }\n    assertTrue(patternsSet.isEmpty());\n    assertEquals(mri.getIndexedExpression(), \"pf.positions['key1','key2','key3']\");\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/IndexCreationJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":771,"status":"M"}],"commitId":"0fd56e418752c14ed8ebebe5a370164034aafc39","commitMessage":"@@@GEODE-7846: Replace all uses of hardcoded / with Region.SEPARATOR (#5157)\n\nAuthored-by: Donal Evans <doevans@pivotal.io>","date":"2020-05-29 00:37:39","modifiedFileCount":"489","status":"M","submitter":"Donal Evans"},{"authorTime":"2020-05-29 00:37:39","codes":[{"authorDate":"2021-05-07 15:06:45","commitOrder":3,"curCode":"  public void testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex() throws Exception {\n    IndexManager.TEST_RANGEINDEX_ONLY = true;\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    LocalRegion testRgn = (LocalRegion) CacheUtils.createRegion(\"testRgn\", null);\n    int ID = 1;\n    \r\n    \r\n    \r\n    for (; ID <= 5; ++ID) {\n      MapKeyIndexData mkid = new MapKeyIndexData(ID);\n      for (int j = 1; j <= ID; ++j) {\n        mkid.maap.put(\"key\" + j, \"val\" + j);\n      }\n      testRgn.put(ID, mkid);\n    }\n    --ID;\r\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL,\n        \"objs.maap['key1','key2','key3','key7']\", SEPARATOR + \"testRgn objs\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.maap['key1','key2','key3','key7']\");\n    assertTrue(i1 instanceof MapRangeIndex);\n    MapRangeIndex mri = (MapRangeIndex) i1;\n    \r\n    \r\n    Map<Object, AbstractIndex> indxMap = mri.getRangeIndexHolderForTesting();\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    ++ID; \r\n    MapKeyIndexData mkid = new MapKeyIndexData(ID);\n    for (int j = 1; j <= ID; ++j) {\n      mkid.maap.put(\"key\" + j, \"val\" + j);\n    }\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    mkid.maap.put(\"key7\", \"val7\");\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 4);\n\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    assertTrue(indxMap.containsKey(\"key7\"));\n    RangeIndex rng = (RangeIndex) indxMap.get(\"key7\");\n    Iterator itr = rng.valueToEntriesMap.values().iterator();\n    assertEquals(rng.valueToEntriesMap.size(), 1);\n    assertTrue(rng.valueToEntriesMap.containsKey(\"val7\"));\n    RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n    assertEquals(1, entryMap.getNumEntries());\n    RegionEntry re = testRgn.basicGetEntry(6);\n    entryMap.containsEntry(re);\n\n    \r\n    mkid.maap.remove(\"key7\");\n    testRgn.put(ID, mkid);\n    \r\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      rng = (RangeIndex) indxMap.get(\"key\" + j);\n      itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    \r\n    mkid = (MapKeyIndexData) testRgn.get(1);\n    mkid.maap.put(\"key1\", \"val2\");\n    testRgn.put(1, mkid);\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(5, entryMap.getNumEntries());\n        expectedElements.remove(1);\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID + 1 - j, entryMap.getNumEntries());\n          for (Integer elem : expectedElements) {\n            re = testRgn.basicGetEntry(elem);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n      }\n    }\n    \r\n    testRgn.remove(3);\n\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(4, entryMap.getNumEntries());\n\n        for (int k = 2; k <= 6; ++k) {\n          if (k == 3) {\n            continue;\n          } else {\n            re = testRgn.basicGetEntry(k);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID - j, entryMap.getNumEntries());\n          for (int p = j; p <= ID; ++p) {\n            re = testRgn.basicGetEntry(p);\n            if (p == 3) {\n              assertNull(re);\n            } else {\n              assertTrue(entryMap.containsEntry(re));\n            }\n          }\n        }\n      }\n    }\n  }\n","date":"2021-05-07 15:06:45","endLine":901,"groupId":"104733","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/36/8111265bf5f87c46c98b02a4ce18b1e3c8189b.src","preCode":"  public void testMapKeyIndexMaintenanceForNonCompactTypeSpecificKeysIndex() throws Exception {\n    IndexManager.TEST_RANGEINDEX_ONLY = true;\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    LocalRegion testRgn = (LocalRegion) CacheUtils.createRegion(\"testRgn\", null);\n    int ID = 1;\n    \r\n    \r\n    \r\n    for (; ID <= 5; ++ID) {\n      MapKeyIndexData mkid = new MapKeyIndexData(ID);\n      for (int j = 1; j <= ID; ++j) {\n        mkid.maap.put(\"key\" + j, \"val\" + j);\n      }\n      testRgn.put(ID, mkid);\n    }\n    --ID;\r\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL,\n        \"objs.maap['key1','key2','key3','key7']\", SEPARATOR + \"testRgn objs\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.maap['key1','key2','key3','key7']\");\n    assertTrue(i1 instanceof MapRangeIndex);\n    MapRangeIndex mri = (MapRangeIndex) i1;\n    \r\n    \r\n    Map<Object, AbstractIndex> indxMap = mri.getRangeIndexHolderForTesting();\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    ++ID; \r\n    MapKeyIndexData mkid = new MapKeyIndexData(ID);\n    for (int j = 1; j <= ID; ++j) {\n      mkid.maap.put(\"key\" + j, \"val\" + j);\n    }\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 3);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    for (int j = 4; j <= ID; ++j) {\n      assertFalse(indxMap.containsKey(\"key\" + j));\n    }\n    \r\n    mkid.maap.put(\"key7\", \"val7\");\n    testRgn.put(ID, mkid);\n    assertEquals(indxMap.size(), 4);\n\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      RangeIndex rng = (RangeIndex) indxMap.get(\"key\" + j);\n      Iterator itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          RegionEntry re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    assertTrue(indxMap.containsKey(\"key7\"));\n    RangeIndex rng = (RangeIndex) indxMap.get(\"key7\");\n    Iterator itr = rng.valueToEntriesMap.values().iterator();\n    assertEquals(rng.valueToEntriesMap.size(), 1);\n    assertTrue(rng.valueToEntriesMap.containsKey(\"val7\"));\n    RegionEntryToValuesMap entryMap = (RegionEntryToValuesMap) itr.next();\n    assertEquals(1, entryMap.getNumEntries());\n    RegionEntry re = testRgn.basicGetEntry(6);\n    entryMap.containsEntry(re);\n\n    \r\n    mkid.maap.remove(\"key7\");\n    testRgn.put(ID, mkid);\n    \r\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      assertTrue(indxMap.containsKey(\"key\" + j));\n      rng = (RangeIndex) indxMap.get(\"key\" + j);\n      itr = rng.valueToEntriesMap.values().iterator();\n      assertEquals(rng.valueToEntriesMap.size(), 1);\n      assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      while (itr.hasNext()) {\n        entryMap = (RegionEntryToValuesMap) itr.next();\n        assertEquals(ID + 1 - j, entryMap.getNumEntries());\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n\n          assertTrue(entryMap.containsEntry(re));\n        }\n      }\n    }\n    \r\n    mkid = (MapKeyIndexData) testRgn.get(1);\n    mkid.maap.put(\"key1\", \"val2\");\n    testRgn.put(1, mkid);\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n\n      Set<Integer> expectedElements = new HashSet<Integer>();\n      for (int k = j; k <= ID; ++k) {\n        expectedElements.add(k);\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(5, entryMap.getNumEntries());\n        expectedElements.remove(1);\n        for (Integer elem : expectedElements) {\n          re = testRgn.basicGetEntry(elem);\n          assertTrue(entryMap.containsEntry(re));\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID + 1 - j, entryMap.getNumEntries());\n          for (Integer elem : expectedElements) {\n            re = testRgn.basicGetEntry(elem);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n      }\n    }\n    \r\n    testRgn.remove(3);\n\n    assertEquals(indxMap.size(), 4);\n    for (int j = 1; j <= 3; ++j) {\n      String keey = \"key\" + j;\n      assertTrue(indxMap.containsKey(keey));\n      rng = (RangeIndex) indxMap.get(keey);\n      itr = rng.valueToEntriesMap.values().iterator();\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val1\"));\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val2\"));\n      } else {\n        assertEquals(rng.valueToEntriesMap.size(), 1);\n        assertTrue(rng.valueToEntriesMap.containsKey(\"val\" + j));\n      }\n      if (keey.equals(\"key1\")) {\n        assertEquals(rng.valueToEntriesMap.size(), 2);\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val1\");\n        assertEquals(4, entryMap.getNumEntries());\n\n        for (int k = 2; k <= 6; ++k) {\n          if (k == 3) {\n            continue;\n          } else {\n            re = testRgn.basicGetEntry(k);\n            assertTrue(entryMap.containsEntry(re));\n          }\n        }\n        entryMap = (RegionEntryToValuesMap) rng.valueToEntriesMap.get(\"val2\");\n        assertEquals(1, entryMap.getNumEntries());\n        re = testRgn.basicGetEntry(1);\n        assertTrue(entryMap.containsEntry(re));\n\n      } else {\n        while (itr.hasNext()) {\n          entryMap = (RegionEntryToValuesMap) itr.next();\n          assertEquals(ID - j, entryMap.getNumEntries());\n          for (int p = j; p <= ID; ++p) {\n            re = testRgn.basicGetEntry(p);\n            if (p == 3) {\n              assertNull(re);\n            } else {\n              assertTrue(entryMap.containsEntry(re));\n            }\n          }\n        }\n      }\n    }\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/internal/index/IndexMaintenanceJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":663,"status":"M"},{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testMapKeyIndexCreation_2_NonCompactType() throws Exception {\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL, \"pf.positions['key1','key2','key3']\",\n        SEPARATOR + \"portfolios pf\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.positions['key1','key2','key3']\");\n    assertTrue(i1 instanceof CompactMapRangeIndex);\n    CompactMapRangeIndex mri = (CompactMapRangeIndex) i1;\n    Object mapKeys[] = mri.getMapKeysForTesting();\n    assertEquals(mapKeys.length, 3);\n    Set<String> keys = new HashSet<String>();\n    keys.add(\"key1\");\n    keys.add(\"key2\");\n    keys.add(\"key3\");\n    for (Object key : mapKeys) {\n      keys.remove(key);\n    }\n    assertTrue(keys.isEmpty());\n    String[] patterns = mri.getPatternsForTesting();\n    assertEquals(patterns.length, 3);\n    Set<String> patternsSet = new HashSet<String>();\n    patternsSet.add(\"index_iter1.positions['key1']\");\n    patternsSet.add(\"index_iter1.positions['key2']\");\n    patternsSet.add(\"index_iter1.positions['key3']\");\n    for (String ptrn : patterns) {\n      patternsSet.remove(ptrn);\n    }\n    assertTrue(patternsSet.isEmpty());\n    assertEquals(mri.getIndexedExpression(), \"pf.positions['key1','key2','key3']\");\n  }\n","date":"2020-05-29 00:37:39","endLine":801,"groupId":"104733","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testMapKeyIndexCreation_2_NonCompactType","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/84/ff970e40c8dfd81312bc2e6262d71a3672de70.src","preCode":"  public void testMapKeyIndexCreation_2_NonCompactType() throws Exception {\n    QueryService qs;\n    qs = CacheUtils.getQueryService();\n    Index i1 = qs.createIndex(\"Index1\", IndexType.FUNCTIONAL, \"pf.positions['key1','key2','key3']\",\n        SEPARATOR + \"portfolios pf\");\n    assertEquals(i1.getCanonicalizedIndexedExpression(),\n        \"index_iter1.positions['key1','key2','key3']\");\n    assertTrue(i1 instanceof CompactMapRangeIndex);\n    CompactMapRangeIndex mri = (CompactMapRangeIndex) i1;\n    Object mapKeys[] = mri.getMapKeysForTesting();\n    assertEquals(mapKeys.length, 3);\n    Set<String> keys = new HashSet<String>();\n    keys.add(\"key1\");\n    keys.add(\"key2\");\n    keys.add(\"key3\");\n    for (Object key : mapKeys) {\n      keys.remove(key);\n    }\n    assertTrue(keys.isEmpty());\n    String[] patterns = mri.getPatternsForTesting();\n    assertEquals(patterns.length, 3);\n    Set<String> patternsSet = new HashSet<String>();\n    patternsSet.add(\"index_iter1.positions['key1']\");\n    patternsSet.add(\"index_iter1.positions['key2']\");\n    patternsSet.add(\"index_iter1.positions['key3']\");\n    for (String ptrn : patterns) {\n      patternsSet.remove(ptrn);\n    }\n    assertTrue(patternsSet.isEmpty());\n    assertEquals(mri.getIndexedExpression(), \"pf.positions['key1','key2','key3']\");\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/IndexCreationJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":771,"status":"N"}],"commitId":"884d399d58912864d36161e06a47c8d8af93a641","commitMessage":"@@@GEODE-9004: Align results of queries with and without map indexes (#6279)\n\n* GEODE-9004: Align results of queries with and without map indexes\n\nQueries in which map fields are involved\nin the condition.  sometimes do not return the same entries\nif map indexes are used.  compared to when map indexes\nare not used.\n\nDifferences were found when the condition on the\nmap field was of type '!=' and also when the condition\non the map field was comparing the value with null.\n\nExample1:\nRunning a query with the following condition:\npositions['SUN'] = null\n\nin a region with the following entries:\nentry1.positions=null\nentry2.positions={'a'=>'b'}\nentry3.positions={'SUN'=>null}\n\n- will return entry1 and entry3 if there are no\n  indexes defined.\n- will return no entries if the following index is defined:\n  positions['SUN'. 'c']\n- will return entry3 if the following index is defined:\n  positions[*]\n\nExample2:\nRunning a query with the following condition:\npositions['SUN'] != '3'\n\nin a region with the following entries:\nentry1.positions=null\nentry2.positions={'a'=>'b'}\nentry3.positions={'SUN'=>'4'}\nentry4.positions={'SUN'=>'3'}\nentry5.positions={'SUN'=>null}\n\n- will return all entries except for entry4 if:\n  there are no indexes defined.\n- will return entry3 if the following index is defined:\n  positions['SUN'. 'c']\n- will return entry3 and entry5 if the following index is defined:\n  positions[*]\n\nIn order to have the same results for these\nqueries no matter if indexes are used. \nthe following changes have been made:\n\n- When using compact map indexes or map indexes\nan index entry will be created for every entry\nadded to the region even if the entry does not\ncontain the indexed map (the map is null) or\nit does not contain any of the indexed keys.\nThe above will not apply to indexes of type\n\"allkeys\" (e.g. positions[*]).\n\n- As a consequence of the statement above\nabout indexes of type \"allkeys\".  when the index\nconfigured is of \"allkeys\" type and the query\nis of type \"!=\" (e.g. positions['SUN'] != \"3\"\nor the query is comparing against a null value\n(e.g. positions['SUN'] = null) the index will\nnot be used.\nThis is a limitation of this solution\nas allowing the index to be used in this case\nwould require bigger and more complex changes that\nhave not been considered in this solution.\n\n* GEODE-9004: Fix stats for number of keys in compact map indexes\n\n* GEODE-9004: Fix failing test cases polluted by other test cases changing a System Property\n\n* GEODE-9004: Changes after review and some refactorings\n\n* GEODE-9004: Add documentation changes\n\n* GEODE-9004: Small change in doc. after review","date":"2021-05-07 15:06:45","modifiedFileCount":"12","status":"M","submitter":"Alberto Gomez"}]
