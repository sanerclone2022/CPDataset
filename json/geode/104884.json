[{"authorTime":"2018-07-18 03:54:18","codes":[{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testProjectionEvaluationDuringIndexResults() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\"select  p.status from /pos p where p.ID > 0 \",\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID IN  SET( 0,1,2,3) and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new ObjectTypeImpl(String.class), new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, true, false, false, false, true};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2018-07-18 03:54:18","endLine":107,"groupId":"5093","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testProjectionEvaluationDuringIndexResults","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/40/31085d84b8a831198ca195fcea9ff6ba0312fb.src","preCode":"  public void testProjectionEvaluationDuringIndexResults() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\"select  p.status from /pos p where p.ID > 0 \",\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID IN  SET( 0,1,2,3) and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new ObjectTypeImpl(String.class), new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, true, false, false, false, true};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"B"},{"authorDate":"2018-07-18 03:54:18","commitOrder":1,"curCode":"  public void testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3) and p.createTime > 0L\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, false, false};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2018-07-18 03:54:18","endLine":157,"groupId":"5094","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/40/31085d84b8a831198ca195fcea9ff6ba0312fb.src","preCode":"  public void testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3) and p.createTime > 0L\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, false, false};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":111,"status":"B"}],"commitId":"cb202f25b93e0a56f4776813da0bf6dcbba231cd","commitMessage":"@@@GEODE-5363: Moves all non-unit tests into specific isolated source sets. (#2126)\n\n* Creates integrationTest source set.\n* Creates distributedTest source set.\n* Creates acceptanceTest source set.\n* Creates uiTest source set.\n* Removes old categories.","date":"2018-07-18 03:54:18","modifiedFileCount":"697","status":"B","submitter":"Jacob Barrett"},{"authorTime":"2019-01-12 07:53:54","codes":[{"authorDate":"2019-01-12 07:53:54","commitOrder":2,"curCode":"  public void testProjectionEvaluationDuringIndexResults() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\"select  p.status from /pos p where p.ID > 0 \",\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID IN  SET( 0,1,2,3) and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new ObjectTypeImpl(String.class), new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, true, false, false, false, true};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2019-01-12 07:53:54","endLine":109,"groupId":"5093","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testProjectionEvaluationDuringIndexResults","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/65/0f871d11683b4bcdf26d574094790209e53a1a.src","preCode":"  public void testProjectionEvaluationDuringIndexResults() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\"select  p.status from /pos p where p.ID > 0 \",\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID IN  SET( 0,1,2,3) and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new ObjectTypeImpl(String.class), new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, true, false, false, false, true};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"},{"authorDate":"2019-01-12 07:53:54","commitOrder":2,"curCode":"  public void testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3) and p.createTime > 0L\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, false, false};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2019-01-12 07:53:54","endLine":161,"groupId":"0","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/65/0f871d11683b4bcdf26d574094790209e53a1a.src","preCode":"  public void testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3) and p.createTime > 0L\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, false, false};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"M"}],"commitId":"9d737c9e95a77cb4db05a258f318908e7899bd6c","commitMessage":"@@@GEODE-4391: Add `@Override` where missing. (#3069)\n\n* GEODE-4391: Add `@Override` where missing.\n\n* Restart Concourse.  I think that was flaky.\n","date":"2019-01-12 07:53:54","modifiedFileCount":"1582","status":"M","submitter":"Galen O'Sullivan"},{"authorTime":"2020-05-29 00:37:39","codes":[{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testProjectionEvaluationDuringIndexResults() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\"select  p.status from \" + SEPARATOR + \"pos p where p.ID > 0 \",\n        \"select  p.status from \" + SEPARATOR + \"pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status from \" + SEPARATOR + \"pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from \" + SEPARATOR\n            + \"pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from \" + SEPARATOR\n            + \"pos p  where p.ID IN  SET( 0,1,2,3) and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from \" + SEPARATOR\n            + \"pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", SEPARATOR + \"pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new ObjectTypeImpl(String.class), new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, true, false, false, false, true};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2020-05-29 00:37:39","endLine":113,"groupId":"104884","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testProjectionEvaluationDuringIndexResults","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7c/31e4770cae87e981fc4d9792943d99d9ac61a4.src","preCode":"  public void testProjectionEvaluationDuringIndexResults() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\"select  p.status from /pos p where p.ID > 0 \",\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID > 0 and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where p.ID IN  SET( 0,1,2,3) and p.createTime > 0\",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\"\n\n    };\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new ObjectTypeImpl(String.class), new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, true, false, false, false, true};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"},{"authorDate":"2020-05-29 00:37:39","commitOrder":3,"curCode":"  public void testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\n        \"select  p.status from \" + SEPARATOR + \"pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status as sts, p as pos from \" + SEPARATOR\n            + \"pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\",\n        \"select  p.status as sts, p as pos from \" + SEPARATOR\n            + \"pos p  where  p.ID IN  SET( 0,1,2,3) and p.createTime > 0L\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", SEPARATOR + \"pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", SEPARATOR + \"pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, false, false};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","date":"2020-05-29 00:37:39","endLine":167,"groupId":"104884","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-geode-10-0.7/blobInfo/CC_OUT/blobs/7c/31e4770cae87e981fc4d9792943d99d9ac61a4.src","preCode":"  public void testProjectionEvaluationDuringIndexResults_UNIMPLEMENTED() throws QueryException {\n    QueryService qs = CacheUtils.getQueryService();\n    String[] queries = new String[] {\n        \"select  p.status from /pos p, p.positions pos where p.ID > 0 \",\n        \"select  p.status as sts, p as pos from /pos p  where ( p.ID IN  SET( 0,1,2,3) and p.createTime > 0L) OR (p.ID IN  SET( 2,3) and p.createTime > 5L)\",\n        \"select  p.status as sts, p as pos from /pos p  where  p.ID IN  SET( 0,1,2,3) and p.createTime > 0L\"};\n    SelectResults[][] sr = new SelectResults[queries.length][2];\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][0] = (SelectResults) q.execute();\n    }\n\n    qs.createIndex(\"PortFolioID\", IndexType.FUNCTIONAL, \"ID\", \"/pos\");\n    qs.createIndex(\"CreateTime\", IndexType.FUNCTIONAL, \"createTime\", \"/pos\");\n\n\n    ObjectType[] expectedTypes = new ObjectType[] {new ObjectTypeImpl(String.class),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"},\n            new ObjectType[] {new ObjectTypeImpl(String.class),\n                new ObjectTypeImpl(Portfolio.class)}),\n        new StructTypeImpl(new String[] {\"sts\", \"pos\"}, new ObjectType[] {\n            new ObjectTypeImpl(String.class), new ObjectTypeImpl(Portfolio.class)})};\n\n    final boolean[] expectedCallback = {false, false, false};\n    final boolean[] actualCallback = new boolean[queries.length];\n    QueryObserverHolder.setInstance(new QueryObserverAdapter() {\n      private int i = 0;\n\n      @Override\n      public void beforeApplyingProjectionOnFilterEvaluatedResults(Object preProjectionApplied) {\n        actualCallback[i] = true;\n      }\n\n      @Override\n      public void afterQueryEvaluation(Object result) {\n        ++i;\n      }\n    });\n\n    for (int i = 0; i < queries.length; ++i) {\n      Query q = qs.newQuery(queries[i]);\n      sr[i][1] = (SelectResults) q.execute();\n      assertEquals(expectedCallback[i], actualCallback[i]);\n      assertEquals(expectedTypes[i], sr[i][1].getCollectionType().getElementType());\n    }\n\n    CacheUtils.compareResultsOfWithAndWithoutIndex(sr, this);\n  }\n","realPath":"geode-core/src/integrationTest/java/org/apache/geode/cache/query/functional/CustomerOptimizationsJUnitTest.java","repoName":"geode","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"}],"commitId":"0fd56e418752c14ed8ebebe5a370164034aafc39","commitMessage":"@@@GEODE-7846: Replace all uses of hardcoded / with Region.SEPARATOR (#5157)\n\nAuthored-by: Donal Evans <doevans@pivotal.io>","date":"2020-05-29 00:37:39","modifiedFileCount":"489","status":"M","submitter":"Donal Evans"}]
