[{"authorTime":"2018-08-26 22:43:11","codes":[{"authorDate":"2018-08-26 22:43:11","commitOrder":1,"curCode":"    public void fillRemoteBranches (final Map<String, String> branches) {\n        new GitProgressSupport.NoOutputLogging() {\n            @Override\n            protected void perform () {\n                final Map<String, GitBranch> localBranches = new HashMap<String, GitBranch>();\n                RepositoryInfo info = RepositoryInfo.getInstance(repository);\n                info.refresh();\n                localBranches.putAll(info.getBranches());\n                EventQueue.invokeLater(new Runnable () {\n                    @Override\n                    public void run () {\n                        fillRemoteBranches(branches, localBranches);\n                    }\n                });\n            }\n        }.start(Git.getInstance().getRequestProcessor(repository), repository, NbBundle.getMessage(UpdateBranchReferencesStep.class, \"MSG_PushBranchesPanel.loadingLocalBranches\")); \r\n    }\n","date":"2018-08-26 22:43:11","endLine":115,"groupId":"55191","id":1,"instanceNumber":1,"isCurCommit":1,"methodName":"fillRemoteBranches","params":"(finalMap<String@String>branches)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-netbeans-10-0.7/blobInfo/CC_OUT/blobs/84/61ca436d7358055305848e5c146f25b71716b1.src","preCode":"    public void fillRemoteBranches (final Map<String, String> branches) {\n        new GitProgressSupport.NoOutputLogging() {\n            @Override\n            protected void perform () {\n                final Map<String, GitBranch> localBranches = new HashMap<String, GitBranch>();\n                RepositoryInfo info = RepositoryInfo.getInstance(repository);\n                info.refresh();\n                localBranches.putAll(info.getBranches());\n                EventQueue.invokeLater(new Runnable () {\n                    @Override\n                    public void run () {\n                        fillRemoteBranches(branches, localBranches);\n                    }\n                });\n            }\n        }.start(Git.getInstance().getRequestProcessor(repository), repository, NbBundle.getMessage(UpdateBranchReferencesStep.class, \"MSG_PushBranchesPanel.loadingLocalBranches\")); \r\n    }\n","realPath":"ide/git/src/org/netbeans/modules/git/ui/push/UpdateBranchReferencesStep.java","repoName":"netbeans","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"B"},{"authorDate":"2018-08-26 22:43:11","commitOrder":1,"curCode":"    public void fillRemoteBranches (final GitRemoteConfig cfg, final Map<String, GitBranch> branches,\n            final Map<String, String> tags) {\n        fillLocalObjects(Collections.<PushMapping>emptyList());\n        new GitProgressSupport.NoOutputLogging() {\n            @Override\n            protected void perform () {\n                final Map<String, GitBranch> localBranches = new HashMap<String, GitBranch>();\n                final Map<String, GitTag> localTags = new HashMap<String, GitTag>();\n                RepositoryInfo info = RepositoryInfo.getInstance(repository);\n                info.refresh();\n                localBranches.putAll(info.getBranches());\n                localTags.putAll(info.getTags());\n                \n                final List<PushMapping> l = new ArrayList<PushMapping>(branches.size());\n                GitClient client;\n                try {\n                    client = getClient();\n                } catch (GitException ex) {\n                    client = null;\n                }\n                for (GitBranch branch : localBranches.values()) {\n                    if (branch.getName() == GitBranch.NO_BRANCH) {\n                        \r\n                        continue;\n                    }\n                    if (!branch.isRemote()) {\n                        GitBranch remoteBranch = branches.get(branch.getName());\n                        boolean conflicted = false;\n                        boolean updateNeeded = remoteBranch != null && !remoteBranch.getId().equals(branch.getId());\n                        if (client != null && remoteBranch != null) {\n                            String idLocal = branch.getId();\n                            String idRemote = remoteBranch.getId();\n                            if (!idLocal.equals(idRemote)) {\n                                try {\n                                    GitRevisionInfo rev = client.getCommonAncestor(new String[] { idLocal, idRemote } , getProgressMonitor());\n                                    \r\n                                    \r\n                                    \r\n                                    \r\n                                    conflicted = rev == null || (!idRemote.equals(rev.getRevision()) && !idLocal.equals(rev.getRevision()));\n                                    if (!conflicted && idLocal.equals(rev.getRevision())) {\n                                        \r\n                                        updateNeeded = false;\n                                    }\n                                } catch (GitException.MissingObjectException ex) {\n                                    if (idRemote.equals(ex.getObjectName())) {\n                                        conflicted = true;\n                                    } else {\n                                        Logger.getLogger(PushBranchesStep.class.getName()).log(Level.INFO, idLocal + \", \" + idRemote, ex); \r\n                                    }\n                                } catch (GitException ex) {\n                                    Logger.getLogger(PushBranchesStep.class.getName()).log(Level.INFO, idLocal + \", \" + idRemote, ex); \r\n                                }\n                            }\n                        }\n                        boolean preselected = !conflicted && updateNeeded;\n                        l.add(new PushMapping.PushBranchMapping(remoteBranch == null ? null : remoteBranch.getName(),\n                                remoteBranch == null ? null : remoteBranch.getId(),\n                                branch, conflicted, preselected, updateNeeded));\n                    }\n                }\n                if (cfg != null) {\n                    \r\n                    for (GitBranch branch : branches.values()) {\n                        String branchName = cfg.getRemoteName() + \"/\" + branch.getName();\n                        GitBranch local = localBranches.get(branchName);\n                        if (local == null || !local.isRemote()) {\n                            \r\n                            l.add(new PushMapping.PushBranchMapping(branch.getName(), branch.getId(), false));\n                        }\n                    }\n                }\n                \n                for (GitTag tag : localTags.values()) {\n                    String repoTagId = tags.get(tag.getTagName());\n                    if (!tag.getTagId().equals(repoTagId)) {\n                        l.add(new PushMapping.PushTagMapping(tag, repoTagId == null ? null : tag.getTagName()));\n                    }\n                }\n                EventQueue.invokeLater(new Runnable () {\n                    @Override\n                    public void run () {\n                        fillLocalObjects(l);\n                    }\n                });\n            }\n        }.start(Git.getInstance().getRequestProcessor(repository), repository, NbBundle.getMessage(PushBranchesStep.class, \"MSG_PushBranchesPanel.loadingLocalBranches\")); \r\n    }\n","date":"2018-08-26 22:43:11","endLine":188,"groupId":"16009","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"fillRemoteBranches","params":"(finalGitRemoteConfigcfg@finalMap<String@GitBranch>branches@finalMap<String@String>tags)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-netbeans-10-0.7/blobInfo/CC_OUT/blobs/63/722b6127ea5a69c54fd918cdd6375071f36c6a.src","preCode":"    public void fillRemoteBranches (final GitRemoteConfig cfg, final Map<String, GitBranch> branches,\n            final Map<String, String> tags) {\n        fillLocalObjects(Collections.<PushMapping>emptyList());\n        new GitProgressSupport.NoOutputLogging() {\n            @Override\n            protected void perform () {\n                final Map<String, GitBranch> localBranches = new HashMap<String, GitBranch>();\n                final Map<String, GitTag> localTags = new HashMap<String, GitTag>();\n                RepositoryInfo info = RepositoryInfo.getInstance(repository);\n                info.refresh();\n                localBranches.putAll(info.getBranches());\n                localTags.putAll(info.getTags());\n                \n                final List<PushMapping> l = new ArrayList<PushMapping>(branches.size());\n                GitClient client;\n                try {\n                    client = getClient();\n                } catch (GitException ex) {\n                    client = null;\n                }\n                for (GitBranch branch : localBranches.values()) {\n                    if (branch.getName() == GitBranch.NO_BRANCH) {\n                        \r\n                        continue;\n                    }\n                    if (!branch.isRemote()) {\n                        GitBranch remoteBranch = branches.get(branch.getName());\n                        boolean conflicted = false;\n                        boolean updateNeeded = remoteBranch != null && !remoteBranch.getId().equals(branch.getId());\n                        if (client != null && remoteBranch != null) {\n                            String idLocal = branch.getId();\n                            String idRemote = remoteBranch.getId();\n                            if (!idLocal.equals(idRemote)) {\n                                try {\n                                    GitRevisionInfo rev = client.getCommonAncestor(new String[] { idLocal, idRemote } , getProgressMonitor());\n                                    \r\n                                    \r\n                                    \r\n                                    \r\n                                    conflicted = rev == null || (!idRemote.equals(rev.getRevision()) && !idLocal.equals(rev.getRevision()));\n                                    if (!conflicted && idLocal.equals(rev.getRevision())) {\n                                        \r\n                                        updateNeeded = false;\n                                    }\n                                } catch (GitException.MissingObjectException ex) {\n                                    if (idRemote.equals(ex.getObjectName())) {\n                                        conflicted = true;\n                                    } else {\n                                        Logger.getLogger(PushBranchesStep.class.getName()).log(Level.INFO, idLocal + \", \" + idRemote, ex); \r\n                                    }\n                                } catch (GitException ex) {\n                                    Logger.getLogger(PushBranchesStep.class.getName()).log(Level.INFO, idLocal + \", \" + idRemote, ex); \r\n                                }\n                            }\n                        }\n                        boolean preselected = !conflicted && updateNeeded;\n                        l.add(new PushMapping.PushBranchMapping(remoteBranch == null ? null : remoteBranch.getName(),\n                                remoteBranch == null ? null : remoteBranch.getId(),\n                                branch, conflicted, preselected, updateNeeded));\n                    }\n                }\n                if (cfg != null) {\n                    \r\n                    for (GitBranch branch : branches.values()) {\n                        String branchName = cfg.getRemoteName() + \"/\" + branch.getName();\n                        GitBranch local = localBranches.get(branchName);\n                        if (local == null || !local.isRemote()) {\n                            \r\n                            l.add(new PushMapping.PushBranchMapping(branch.getName(), branch.getId(), false));\n                        }\n                    }\n                }\n                \n                for (GitTag tag : localTags.values()) {\n                    String repoTagId = tags.get(tag.getTagName());\n                    if (!tag.getTagId().equals(repoTagId)) {\n                        l.add(new PushMapping.PushTagMapping(tag, repoTagId == null ? null : tag.getTagName()));\n                    }\n                }\n                EventQueue.invokeLater(new Runnable () {\n                    @Override\n                    public void run () {\n                        fillLocalObjects(l);\n                    }\n                });\n            }\n        }.start(Git.getInstance().getRequestProcessor(repository), repository, NbBundle.getMessage(PushBranchesStep.class, \"MSG_PushBranchesPanel.loadingLocalBranches\")); \r\n    }\n","realPath":"ide/git/src/org/netbeans/modules/git/ui/push/PushBranchesStep.java","repoName":"netbeans","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"B"}],"commitId":"0f2e98d513deaedccef831ee9cfc08d09f3650b6","commitMessage":"@@@Merge pull request #791 from ralphbenjamin/NETBEANS-1172_move_ide_modules_to_ide_subdirectory\n\n[NETBEANS-1172] move ide modules to ide subdirectory","date":"2018-08-26 22:43:11","modifiedFileCount":"0","status":"B","submitter":"Geertjan Wielenga"},{"authorTime":"2020-03-02 00:27:49","codes":[{"authorDate":"2018-08-26 22:43:11","commitOrder":2,"curCode":"    public void fillRemoteBranches (final Map<String, String> branches) {\n        new GitProgressSupport.NoOutputLogging() {\n            @Override\n            protected void perform () {\n                final Map<String, GitBranch> localBranches = new HashMap<String, GitBranch>();\n                RepositoryInfo info = RepositoryInfo.getInstance(repository);\n                info.refresh();\n                localBranches.putAll(info.getBranches());\n                EventQueue.invokeLater(new Runnable () {\n                    @Override\n                    public void run () {\n                        fillRemoteBranches(branches, localBranches);\n                    }\n                });\n            }\n        }.start(Git.getInstance().getRequestProcessor(repository), repository, NbBundle.getMessage(UpdateBranchReferencesStep.class, \"MSG_PushBranchesPanel.loadingLocalBranches\")); \r\n    }\n","date":"2018-08-26 22:43:11","endLine":115,"groupId":"126426","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"fillRemoteBranches","params":"(finalMap<String@String>branches)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-netbeans-10-0.7/blobInfo/CC_OUT/blobs/84/61ca436d7358055305848e5c146f25b71716b1.src","preCode":"    public void fillRemoteBranches (final Map<String, String> branches) {\n        new GitProgressSupport.NoOutputLogging() {\n            @Override\n            protected void perform () {\n                final Map<String, GitBranch> localBranches = new HashMap<String, GitBranch>();\n                RepositoryInfo info = RepositoryInfo.getInstance(repository);\n                info.refresh();\n                localBranches.putAll(info.getBranches());\n                EventQueue.invokeLater(new Runnable () {\n                    @Override\n                    public void run () {\n                        fillRemoteBranches(branches, localBranches);\n                    }\n                });\n            }\n        }.start(Git.getInstance().getRequestProcessor(repository), repository, NbBundle.getMessage(UpdateBranchReferencesStep.class, \"MSG_PushBranchesPanel.loadingLocalBranches\")); \r\n    }\n","realPath":"ide/git/src/org/netbeans/modules/git/ui/push/UpdateBranchReferencesStep.java","repoName":"netbeans","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"N"},{"authorDate":"2020-03-02 00:27:49","commitOrder":2,"curCode":"    public void fillRemoteBranches (final GitRemoteConfig cfg, final Map<String, GitBranch> branches,\n            final Map<String, String> tags) {\n        fillLocalObjects(Collections.<PushMapping>emptyList());\n        new GitProgressSupport.NoOutputLogging() {\n            @Override\n            protected void perform () {\n                final Map<String, GitBranch> localBranches = new HashMap<String, GitBranch>();\n                final Map<String, GitTag> localTags = new HashMap<String, GitTag>();\n                RepositoryInfo info = RepositoryInfo.getInstance(repository);\n                info.refresh();\n                localBranches.putAll(info.getBranches());\n                localTags.putAll(info.getTags());\n                \n                final List<PushMapping> l = new ArrayList<PushMapping>(branches.size());\n                GitClient client;\n                try {\n                    client = getClient();\n                } catch (GitException ex) {\n                    client = null;\n                }\n                for (GitBranch branch : localBranches.values()) {\n                    if (branch.getName() == GitBranch.NO_BRANCH) {\n                        \r\n                        continue;\n                    }\n                    if (!branch.isRemote()) {\n                        \r\n                        GitBranch remoteBranch = branches.get(branch.getName());\n                        boolean conflicted = false;\n                        boolean updateNeeded = remoteBranch != null && !remoteBranch.getId().equals(branch.getId());\n                        if (client != null && remoteBranch != null) {\n                            String idLocal = branch.getId();\n                            String idRemote = remoteBranch.getId();\n                            if (!idLocal.equals(idRemote)) {\n                                try {\n                                    GitRevisionInfo rev = client.getCommonAncestor(new String[] { idLocal, idRemote } , getProgressMonitor());\n                                    \r\n                                    \r\n                                    \r\n                                    \r\n                                    conflicted = rev == null || (!idRemote.equals(rev.getRevision()) && !idLocal.equals(rev.getRevision()));\n                                    if (!conflicted && idLocal.equals(rev.getRevision())) {\n                                        \r\n                                        updateNeeded = false;\n                                    }\n                                } catch (GitException.MissingObjectException ex) {\n                                    if (idRemote.equals(ex.getObjectName())) {\n                                        conflicted = true;\n                                    } else {\n                                        Logger.getLogger(PushBranchesStep.class.getName()).log(Level.INFO, idLocal + \", \" + idRemote, ex); \r\n                                    }\n                                } catch (GitException ex) {\n                                    Logger.getLogger(PushBranchesStep.class.getName()).log(Level.INFO, idLocal + \", \" + idRemote, ex); \r\n                                }\n                            }\n                        }\n                        boolean preselected = !conflicted && updateNeeded;\n\n                        \r\n                        l.add(new PushMapping.PushBranchMapping(remoteBranch == null ? null : remoteBranch.getName(),\n                                remoteBranch == null ? null : remoteBranch.getId(),\n                                branch, conflicted, preselected, updateNeeded));\n                    }\n                }\n                if (cfg != null) {\n                    \r\n                    for (GitBranch branch : branches.values()) {\n                        String branchName = cfg.getRemoteName() + \"/\" + branch.getName();\n                        GitBranch local = localBranches.get(branchName);\n                        if (local == null || !local.isRemote()) {\n                            \r\n                            l.add(new PushMapping.PushBranchMapping(branch.getName(), branch.getId(), false));\n                        }\n                    }\n                }\n\n                \r\n                for (GitTag tag : localTags.values()) {\n                    String repoTagId = tags.get(tag.getTagName());\n                    if (!tag.getTagId().equals(repoTagId)) {\n                        \r\n                        l.add(new PushMapping.PushTagMapping(tag, repoTagId == null ? null : tag.getTagName()));\n                    }\n                }\n\n                \r\n                for (String tag : tags.keySet()) {\n                    \r\n                    GitTag localTag = localTags.get(tag);\n                    if (localTag == null) {\n                        \r\n                        l.add(new PushMapping.PushTagMapping(tag));\n                    }\n                }\n\n                EventQueue.invokeLater(new Runnable () {\n                    @Override\n                    public void run () {\n                        fillLocalObjects(l);\n                    }\n                });\n            }\n        }.start(Git.getInstance().getRequestProcessor(repository), repository, NbBundle.getMessage(PushBranchesStep.class, \"MSG_PushBranchesPanel.loadingLocalBranches\")); \r\n    }\n","date":"2020-03-07 00:37:18","endLine":210,"groupId":"126426","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"fillRemoteBranches","params":"(finalGitRemoteConfigcfg@finalMap<String@GitBranch>branches@finalMap<String@String>tags)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-netbeans-10-0.7/blobInfo/CC_OUT/blobs/42/c0320763edc5e9ec9ff062a2ac0e500cfa0cee.src","preCode":"    public void fillRemoteBranches (final GitRemoteConfig cfg, final Map<String, GitBranch> branches,\n            final Map<String, String> tags) {\n        fillLocalObjects(Collections.<PushMapping>emptyList());\n        new GitProgressSupport.NoOutputLogging() {\n            @Override\n            protected void perform () {\n                final Map<String, GitBranch> localBranches = new HashMap<String, GitBranch>();\n                final Map<String, GitTag> localTags = new HashMap<String, GitTag>();\n                RepositoryInfo info = RepositoryInfo.getInstance(repository);\n                info.refresh();\n                localBranches.putAll(info.getBranches());\n                localTags.putAll(info.getTags());\n                \n                final List<PushMapping> l = new ArrayList<PushMapping>(branches.size());\n                GitClient client;\n                try {\n                    client = getClient();\n                } catch (GitException ex) {\n                    client = null;\n                }\n                for (GitBranch branch : localBranches.values()) {\n                    if (branch.getName() == GitBranch.NO_BRANCH) {\n                        \r\n                        continue;\n                    }\n                    if (!branch.isRemote()) {\n                        GitBranch remoteBranch = branches.get(branch.getName());\n                        boolean conflicted = false;\n                        boolean updateNeeded = remoteBranch != null && !remoteBranch.getId().equals(branch.getId());\n                        if (client != null && remoteBranch != null) {\n                            String idLocal = branch.getId();\n                            String idRemote = remoteBranch.getId();\n                            if (!idLocal.equals(idRemote)) {\n                                try {\n                                    GitRevisionInfo rev = client.getCommonAncestor(new String[] { idLocal, idRemote } , getProgressMonitor());\n                                    \r\n                                    \r\n                                    \r\n                                    \r\n                                    conflicted = rev == null || (!idRemote.equals(rev.getRevision()) && !idLocal.equals(rev.getRevision()));\n                                    if (!conflicted && idLocal.equals(rev.getRevision())) {\n                                        \r\n                                        updateNeeded = false;\n                                    }\n                                } catch (GitException.MissingObjectException ex) {\n                                    if (idRemote.equals(ex.getObjectName())) {\n                                        conflicted = true;\n                                    } else {\n                                        Logger.getLogger(PushBranchesStep.class.getName()).log(Level.INFO, idLocal + \", \" + idRemote, ex); \r\n                                    }\n                                } catch (GitException ex) {\n                                    Logger.getLogger(PushBranchesStep.class.getName()).log(Level.INFO, idLocal + \", \" + idRemote, ex); \r\n                                }\n                            }\n                        }\n                        boolean preselected = !conflicted && updateNeeded;\n                        l.add(new PushMapping.PushBranchMapping(remoteBranch == null ? null : remoteBranch.getName(),\n                                remoteBranch == null ? null : remoteBranch.getId(),\n                                branch, conflicted, preselected, updateNeeded));\n                    }\n                }\n                if (cfg != null) {\n                    \r\n                    for (GitBranch branch : branches.values()) {\n                        String branchName = cfg.getRemoteName() + \"/\" + branch.getName();\n                        GitBranch local = localBranches.get(branchName);\n                        if (local == null || !local.isRemote()) {\n                            \r\n                            l.add(new PushMapping.PushBranchMapping(branch.getName(), branch.getId(), false));\n                        }\n                    }\n                }\n                \n                for (GitTag tag : localTags.values()) {\n                    String repoTagId = tags.get(tag.getTagName());\n                    if (!tag.getTagId().equals(repoTagId)) {\n                        l.add(new PushMapping.PushTagMapping(tag, repoTagId == null ? null : tag.getTagName()));\n                    }\n                }\n                EventQueue.invokeLater(new Runnable () {\n                    @Override\n                    public void run () {\n                        fillLocalObjects(l);\n                    }\n                });\n            }\n        }.start(Git.getInstance().getRequestProcessor(repository), repository, NbBundle.getMessage(PushBranchesStep.class, \"MSG_PushBranchesPanel.loadingLocalBranches\")); \r\n    }\n","realPath":"ide/git/src/org/netbeans/modules/git/ui/push/PushBranchesStep.java","repoName":"netbeans","snippetEndLine":0,"snippetStartLine":0,"startLine":107,"status":"M"}],"commitId":"7d17072e22ca45228e57ef2399ecfd7ac37c53e2","commitMessage":"@@@[NETBEANS-3929] Add option to gitclient to push tag deletes\n\nAdding the ability to delete a tag from a remote repository using\nintegrated GitClient. Before a user could delete a branch but could not\ndelete a tag. Now.  when performing git push... a user can select locally\ndeleted tag and GitClient will perform git push :refs/tags/{tag_name_to_delete}\n","date":"2020-03-07 00:37:18","modifiedFileCount":"8","status":"M","submitter":"Dmitry Mochalov"}]
