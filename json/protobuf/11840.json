[{"authorTime":"2017-09-18 23:34:54","codes":[{"authorDate":"2017-08-22 01:39:27","commitOrder":3,"curCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          final ByteBuffer result = slice(pos, pos + size);\n          pos += size;\n          return ByteString.wrap(result);\n        } else {\n          \r\n          byte[] bytes = new byte[size];\n          UnsafeUtil.copyMemory(pos, bytes, 0, size);\n          pos += size;\n          return ByteString.wrap(bytes);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","date":"2017-08-22 01:39:27","endLine":1630,"groupId":"1757","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"readBytes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/d6/a941b1c03d901f7fe2155fc334d7150f886801.src","preCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          final ByteBuffer result = slice(pos, pos + size);\n          pos += size;\n          return ByteString.wrap(result);\n        } else {\n          \r\n          byte[] bytes = new byte[size];\n          UnsafeUtil.copyMemory(pos, bytes, 0, size);\n          pos += size;\n          return ByteString.wrap(bytes);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/CodedInputStream.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1607,"status":"NB"},{"authorDate":"2017-09-18 23:34:54","commitOrder":3,"curCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= currentByteBufferLimit - currentByteBufferPos) {\n        if (immutable && enableAliasing) {\n          final int idx = (int) (currentByteBufferPos - currentAddress);\n          final ByteString result = ByteString.wrap(slice(idx, idx + size));\n          currentByteBufferPos += size;\n          return result;\n        } else {\n          byte[] bytes;\n          bytes = new byte[size];\n          UnsafeUtil.copyMemory(currentByteBufferPos, bytes, 0, size);\n          currentByteBufferPos += size;\n          return ByteString.wrap(bytes);\n        }\n      } else if (size > 0 && size <= remaining()) {\n        byte[] temp = new byte[size];\n        readRawBytesTo(temp, 0, size);\n        return ByteString.wrap(temp);\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","date":"2017-09-18 23:34:54","endLine":3481,"groupId":"1767","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"readBytes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/51/1501d4e9d64eddaca83e3d62e17010db5e1301.src","preCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= currentByteBufferLimit - currentByteBufferPos) {\n        if (immutable && enableAliasing) {\n          final int idx = (int) (currentByteBufferPos - currentAddress);\n          final ByteString result = ByteString.wrap(slice(idx, idx + size));\n          currentByteBufferPos += size;\n          return result;\n        } else {\n          byte[] bytes;\n          bytes = new byte[size];\n          UnsafeUtil.copyMemory(currentByteBufferPos, bytes, 0, size);\n          currentByteBufferPos += size;\n          return ByteString.wrap(bytes);\n        }\n      } else if (size > 0 && size <= remaining()) {\n        byte[] temp = new byte[size];\n        readRawBytesTo(temp, 0, size);\n        return ByteString.wrap(temp);\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/CodedInputStream.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":3453,"status":"B"}],"commitId":"fa5a69e73b0dd667ff15062adbc170310d440ee9","commitMessage":"@@@Merge pull request #3624 from acozzette/down-integrate\n\nIntegrated internal changes from Google","date":"2017-09-18 23:34:54","modifiedFileCount":"16","status":"M","submitter":"Adam Cozzette"},{"authorTime":"2021-03-31 04:41:33","codes":[{"authorDate":"2017-08-22 01:39:27","commitOrder":4,"curCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          final ByteBuffer result = slice(pos, pos + size);\n          pos += size;\n          return ByteString.wrap(result);\n        } else {\n          \r\n          byte[] bytes = new byte[size];\n          UnsafeUtil.copyMemory(pos, bytes, 0, size);\n          pos += size;\n          return ByteString.wrap(bytes);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","date":"2017-08-22 01:39:27","endLine":1630,"groupId":"1757","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"readBytes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/d6/a941b1c03d901f7fe2155fc334d7150f886801.src","preCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          final ByteBuffer result = slice(pos, pos + size);\n          pos += size;\n          return ByteString.wrap(result);\n        } else {\n          \r\n          byte[] bytes = new byte[size];\n          UnsafeUtil.copyMemory(pos, bytes, 0, size);\n          pos += size;\n          return ByteString.wrap(bytes);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/CodedInputStream.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1607,"status":"N"},{"authorDate":"2021-03-31 04:41:33","commitOrder":4,"curCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= currentByteBufferLimit - currentByteBufferPos) {\n        if (immutable && enableAliasing) {\n          final int idx = (int) (currentByteBufferPos - currentAddress);\n          final ByteString result = ByteString.wrap(slice(idx, idx + size));\n          currentByteBufferPos += size;\n          return result;\n        } else {\n          byte[] bytes;\n          bytes = new byte[size];\n          UnsafeUtil.copyMemory(currentByteBufferPos, bytes, 0, size);\n          currentByteBufferPos += size;\n          return ByteString.wrap(bytes);\n        }\n      } else if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          ArrayList<ByteString> byteStrings = new ArrayList<>();\n          int l = size;\n          while (l > 0) {\n            if (currentRemaining() == 0) {\n              getNextByteBuffer();\n            }\n            int bytesToCopy = Math.min(l, (int) currentRemaining());\n            int idx = (int) (currentByteBufferPos - currentAddress);\n            byteStrings.add(ByteString.wrap(slice(idx, idx + bytesToCopy)));\n            l -= bytesToCopy;\n            currentByteBufferPos += bytesToCopy;\n          }\n          return ByteString.copyFrom(byteStrings);\n        } else {\n          byte[] temp = new byte[size];\n          readRawBytesTo(temp, 0, size);\n          return ByteString.wrap(temp);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","date":"2021-03-31 04:41:33","endLine":3554,"groupId":"1757","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"readBytes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/60/98a9ad8e79c408bc3468444f6090b360edaf00.src","preCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= currentByteBufferLimit - currentByteBufferPos) {\n        if (immutable && enableAliasing) {\n          final int idx = (int) (currentByteBufferPos - currentAddress);\n          final ByteString result = ByteString.wrap(slice(idx, idx + size));\n          currentByteBufferPos += size;\n          return result;\n        } else {\n          byte[] bytes;\n          bytes = new byte[size];\n          UnsafeUtil.copyMemory(currentByteBufferPos, bytes, 0, size);\n          currentByteBufferPos += size;\n          return ByteString.wrap(bytes);\n        }\n      } else if (size > 0 && size <= remaining()) {\n        byte[] temp = new byte[size];\n        readRawBytesTo(temp, 0, size);\n        return ByteString.wrap(temp);\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/CodedInputStream.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":3510,"status":"M"}],"commitId":"e9360dfa53f151e64c996823785e0eb6c8118620","commitMessage":"@@@Merge pull request #8437 from haberman/sync-stage\n\nIntegrate from Piper for C++.  Java.  and Python","date":"2021-03-31 04:41:33","modifiedFileCount":"3","status":"M","submitter":"Joshua Haberman"},{"authorTime":"2021-08-26 22:38:09","codes":[{"authorDate":"2017-08-22 01:39:27","commitOrder":5,"curCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          final ByteBuffer result = slice(pos, pos + size);\n          pos += size;\n          return ByteString.wrap(result);\n        } else {\n          \r\n          byte[] bytes = new byte[size];\n          UnsafeUtil.copyMemory(pos, bytes, 0, size);\n          pos += size;\n          return ByteString.wrap(bytes);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","date":"2017-08-22 01:39:27","endLine":1630,"groupId":"11840","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"readBytes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/d6/a941b1c03d901f7fe2155fc334d7150f886801.src","preCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          final ByteBuffer result = slice(pos, pos + size);\n          pos += size;\n          return ByteString.wrap(result);\n        } else {\n          \r\n          byte[] bytes = new byte[size];\n          UnsafeUtil.copyMemory(pos, bytes, 0, size);\n          pos += size;\n          return ByteString.wrap(bytes);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/CodedInputStream.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1607,"status":"N"},{"authorDate":"2021-08-26 22:38:09","commitOrder":5,"curCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= currentByteBufferLimit - currentByteBufferPos) {\n        if (immutable && enableAliasing) {\n          final int idx = (int) (currentByteBufferPos - currentAddress);\n          final ByteString result = ByteString.wrap(slice(idx, idx + size));\n          currentByteBufferPos += size;\n          return result;\n        } else {\n          byte[] bytes = new byte[size];\n          UnsafeUtil.copyMemory(currentByteBufferPos, bytes, 0, size);\n          currentByteBufferPos += size;\n          return ByteString.wrap(bytes);\n        }\n      } else if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          ArrayList<ByteString> byteStrings = new ArrayList<>();\n          int l = size;\n          while (l > 0) {\n            if (currentRemaining() == 0) {\n              getNextByteBuffer();\n            }\n            int bytesToCopy = Math.min(l, (int) currentRemaining());\n            int idx = (int) (currentByteBufferPos - currentAddress);\n            byteStrings.add(ByteString.wrap(slice(idx, idx + bytesToCopy)));\n            l -= bytesToCopy;\n            currentByteBufferPos += bytesToCopy;\n          }\n          return ByteString.copyFrom(byteStrings);\n        } else {\n          byte[] temp = new byte[size];\n          readRawBytesTo(temp, 0, size);\n          return ByteString.wrap(temp);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","date":"2021-08-26 22:38:09","endLine":3558,"groupId":"11840","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"readBytes","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/2e/1cc6bdcbe94c68c6c366180551b8033a091103.src","preCode":"    public ByteString readBytes() throws IOException {\n      final int size = readRawVarint32();\n      if (size > 0 && size <= currentByteBufferLimit - currentByteBufferPos) {\n        if (immutable && enableAliasing) {\n          final int idx = (int) (currentByteBufferPos - currentAddress);\n          final ByteString result = ByteString.wrap(slice(idx, idx + size));\n          currentByteBufferPos += size;\n          return result;\n        } else {\n          byte[] bytes;\n          bytes = new byte[size];\n          UnsafeUtil.copyMemory(currentByteBufferPos, bytes, 0, size);\n          currentByteBufferPos += size;\n          return ByteString.wrap(bytes);\n        }\n      } else if (size > 0 && size <= remaining()) {\n        if (immutable && enableAliasing) {\n          ArrayList<ByteString> byteStrings = new ArrayList<>();\n          int l = size;\n          while (l > 0) {\n            if (currentRemaining() == 0) {\n              getNextByteBuffer();\n            }\n            int bytesToCopy = Math.min(l, (int) currentRemaining());\n            int idx = (int) (currentByteBufferPos - currentAddress);\n            byteStrings.add(ByteString.wrap(slice(idx, idx + bytesToCopy)));\n            l -= bytesToCopy;\n            currentByteBufferPos += bytesToCopy;\n          }\n          return ByteString.copyFrom(byteStrings);\n        } else {\n          byte[] temp = new byte[size];\n          readRawBytesTo(temp, 0, size);\n          return ByteString.wrap(temp);\n        }\n      }\n\n      if (size == 0) {\n        return ByteString.EMPTY;\n      }\n      if (size < 0) {\n        throw InvalidProtocolBufferException.negativeSize();\n      }\n      throw InvalidProtocolBufferException.truncatedMessage();\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/CodedInputStream.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":3515,"status":"M"}],"commitId":"66b7b71a455bbb295d0d407e32c07b9fcdbf85c0","commitMessage":"@@@Merge pull request #8902 from acozzette/sync-stage\n\nIntegrate from Piper for C++.  Java.  and Python","date":"2021-08-26 22:38:09","modifiedFileCount":"5","status":"M","submitter":"Adam Cozzette"}]
