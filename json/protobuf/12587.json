[{"authorTime":"2016-04-12 14:37:42","codes":[{"authorDate":"2016-04-12 14:37:42","commitOrder":1,"curCode":"    int partialIsValidUtf8(int state, byte[] bytes, final int index, final int limit) {\n      if ((index | limit | bytes.length - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit));\n      }\n      long offset = ARRAY_BASE_OFFSET + index;\n      final long offsetLimit = ARRAY_BASE_OFFSET + limit;\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (offset >= offsetLimit) {  \r\n          return state;\n        }\n        int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(bytes, offset, (int) (offsetLimit - offset));\n    }\n","date":"2016-04-12 14:37:42","endLine":1105,"groupId":"1110","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"partialIsValidUtf8","params":"(intstate@byte[]bytes@finalintindex@finalintlimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/30/8c69e95897fd7d56aed7a5dbed00cf78effbb8.src","preCode":"    int partialIsValidUtf8(int state, byte[] bytes, final int index, final int limit) {\n      if ((index | limit | bytes.length - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit));\n      }\n      long offset = ARRAY_BASE_OFFSET + index;\n      final long offsetLimit = ARRAY_BASE_OFFSET + limit;\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (offset >= offsetLimit) {  \r\n          return state;\n        }\n        int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(bytes, offset, (int) (offsetLimit - offset));\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/Utf8.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1014,"status":"B"},{"authorDate":"2016-04-12 14:37:42","commitOrder":1,"curCode":"    int partialIsValidUtf8Direct(\n        final int state, ByteBuffer buffer, final int index, final int limit) {\n      if ((index | limit | buffer.limit() - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"buffer limit=%d, index=%d, limit=%d\", buffer.limit(), index, limit));\n      }\n      long address = addressOffset(buffer) + index;\n      final long addressLimit = address + (limit - index);\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (address >= addressLimit) { \r\n          return state;\n        }\n\n        final int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(address, (int) (addressLimit - address));\n    }\n","date":"2016-04-12 14:37:42","endLine":1201,"groupId":"1110","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"partialIsValidUtf8Direct","params":"(finalintstate@ByteBufferbuffer@finalintindex@finalintlimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/30/8c69e95897fd7d56aed7a5dbed00cf78effbb8.src","preCode":"    int partialIsValidUtf8Direct(\n        final int state, ByteBuffer buffer, final int index, final int limit) {\n      if ((index | limit | buffer.limit() - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"buffer limit=%d, index=%d, limit=%d\", buffer.limit(), index, limit));\n      }\n      long address = addressOffset(buffer) + index;\n      final long addressLimit = address + (limit - index);\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (address >= addressLimit) { \r\n          return state;\n        }\n\n        final int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(address, (int) (addressLimit - address));\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/Utf8.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1108,"status":"B"}],"commitId":"814685ca2cd9280ca401e1842fd6311440921a0a","commitMessage":"@@@Merge pull request #1397 from google/internal-merge\n\nInternal merge","date":"2016-04-12 14:37:42","modifiedFileCount":"57","status":"B","submitter":"Joshua Haberman"},{"authorTime":"2016-06-30 06:23:27","codes":[{"authorDate":"2016-06-30 06:23:27","commitOrder":2,"curCode":"    int partialIsValidUtf8(int state, byte[] bytes, final int index, final int limit) {\n      if ((index | limit | bytes.length - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit));\n      }\n      long offset = getArrayBaseOffset() + index;\n      final long offsetLimit = getArrayBaseOffset() + limit;\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (offset >= offsetLimit) {  \r\n          return state;\n        }\n        int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(bytes, offset, (int) (offsetLimit - offset));\n    }\n","date":"2016-06-30 06:38:03","endLine":1090,"groupId":"1110","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"partialIsValidUtf8","params":"(intstate@byte[]bytes@finalintindex@finalintlimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/5b/80d405ebda7c11b8fc524b62b2d67cd4900d9d.src","preCode":"    int partialIsValidUtf8(int state, byte[] bytes, final int index, final int limit) {\n      if ((index | limit | bytes.length - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit));\n      }\n      long offset = ARRAY_BASE_OFFSET + index;\n      final long offsetLimit = ARRAY_BASE_OFFSET + limit;\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (offset >= offsetLimit) {  \r\n          return state;\n        }\n        int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UNSAFE.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(bytes, offset, (int) (offsetLimit - offset));\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/Utf8.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":999,"status":"M"},{"authorDate":"2016-06-30 06:23:27","commitOrder":2,"curCode":"    int partialIsValidUtf8Direct(\n        final int state, ByteBuffer buffer, final int index, final int limit) {\n      if ((index | limit | buffer.limit() - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"buffer limit=%d, index=%d, limit=%d\", buffer.limit(), index, limit));\n      }\n      long address = addressOffset(buffer) + index;\n      final long addressLimit = address + (limit - index);\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (address >= addressLimit) { \r\n          return state;\n        }\n\n        final int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(address, (int) (addressLimit - address));\n    }\n","date":"2016-06-30 06:38:03","endLine":1186,"groupId":"1110","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"partialIsValidUtf8Direct","params":"(finalintstate@ByteBufferbuffer@finalintindex@finalintlimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/5b/80d405ebda7c11b8fc524b62b2d67cd4900d9d.src","preCode":"    int partialIsValidUtf8Direct(\n        final int state, ByteBuffer buffer, final int index, final int limit) {\n      if ((index | limit | buffer.limit() - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"buffer limit=%d, index=%d, limit=%d\", buffer.limit(), index, limit));\n      }\n      long address = addressOffset(buffer) + index;\n      final long addressLimit = address + (limit - index);\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (address >= addressLimit) { \r\n          return state;\n        }\n\n        final int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UNSAFE.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UNSAFE.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(address, (int) (addressLimit - address));\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/Utf8.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1093,"status":"M"}],"commitId":"d64a2d9941c36a7bc2a7959ea10ab8363192ac14","commitMessage":"@@@Integrated internal changes from Google\n\nThis includes all internal changes from around May 20 to now.\n","date":"2016-06-30 06:38:03","modifiedFileCount":"44","status":"M","submitter":"Adam Cozzette"},{"authorTime":"2016-06-30 06:23:27","codes":[{"authorDate":"2017-08-22 01:39:27","commitOrder":3,"curCode":"    int partialIsValidUtf8(int state, byte[] bytes, final int index, final int limit) {\n      if ((index | limit | bytes.length - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit));\n      }\n      long offset = index;\n      final long offsetLimit = limit;\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (offset >= offsetLimit) {  \r\n          return state;\n        }\n        int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(bytes, offset, (int) (offsetLimit - offset));\n    }\n","date":"2017-08-22 01:39:27","endLine":1089,"groupId":"12587","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"partialIsValidUtf8","params":"(intstate@byte[]bytes@finalintindex@finalintlimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/1b/1361445b030280579777b3770a25497432137e.src","preCode":"    int partialIsValidUtf8(int state, byte[] bytes, final int index, final int limit) {\n      if ((index | limit | bytes.length - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit));\n      }\n      long offset = getArrayBaseOffset() + index;\n      final long offsetLimit = getArrayBaseOffset() + limit;\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (offset >= offsetLimit) {  \r\n          return state;\n        }\n        int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UnsafeUtil.getByte(bytes, offset++);\n            if (offset >= offsetLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(bytes, offset, (int) (offsetLimit - offset));\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/Utf8.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":998,"status":"M"},{"authorDate":"2016-06-30 06:23:27","commitOrder":3,"curCode":"    int partialIsValidUtf8Direct(\n        final int state, ByteBuffer buffer, final int index, final int limit) {\n      if ((index | limit | buffer.limit() - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"buffer limit=%d, index=%d, limit=%d\", buffer.limit(), index, limit));\n      }\n      long address = addressOffset(buffer) + index;\n      final long addressLimit = address + (limit - index);\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (address >= addressLimit) { \r\n          return state;\n        }\n\n        final int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(address, (int) (addressLimit - address));\n    }\n","date":"2016-06-30 06:38:03","endLine":1186,"groupId":"12587","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"partialIsValidUtf8Direct","params":"(finalintstate@ByteBufferbuffer@finalintindex@finalintlimit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/5b/80d405ebda7c11b8fc524b62b2d67cd4900d9d.src","preCode":"    int partialIsValidUtf8Direct(\n        final int state, ByteBuffer buffer, final int index, final int limit) {\n      if ((index | limit | buffer.limit() - limit) < 0) {\n        throw new ArrayIndexOutOfBoundsException(\n            String.format(\"buffer limit=%d, index=%d, limit=%d\", buffer.limit(), index, limit));\n      }\n      long address = addressOffset(buffer) + index;\n      final long addressLimit = address + (limit - index);\n      if (state != COMPLETE) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (address >= addressLimit) { \r\n          return state;\n        }\n\n        final int byte1 = (byte) state;\n        \r\n        if (byte1 < (byte) 0xE0) {\n          \r\n\n          \r\n          \r\n          if (byte1 < (byte) 0xC2\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else if (byte1 < (byte) 0xF0) {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          }\n          if (byte2 > (byte) 0xBF\n              \r\n              || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n              \r\n              || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        } else {\n          \r\n\n          \r\n          int byte2 = (byte) ~(state >> 8);\n          int byte3 = 0;\n          if (byte2 == 0) {\n            byte2 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2);\n            }\n          } else {\n            byte3 = (byte) (state >> 16);\n          }\n          if (byte3 == 0) {\n            byte3 = UnsafeUtil.getByte(address++);\n            if (address >= addressLimit) {\n              return incompleteStateFor(byte1, byte2, byte3);\n            }\n          }\n\n          \r\n          \r\n          \r\n\n          if (byte2 > (byte) 0xBF\n              \r\n              \r\n              \r\n              \r\n              || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n              \r\n              || byte3 > (byte) 0xBF\n              \r\n              || UnsafeUtil.getByte(address++) > (byte) 0xBF) {\n            return MALFORMED;\n          }\n        }\n      }\n\n      return partialIsValidUtf8(address, (int) (addressLimit - address));\n    }\n","realPath":"java/core/src/main/java/com/google/protobuf/Utf8.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1093,"status":"N"}],"commitId":"ba4e54724d2e6a1881c4fe88664d81fbacaf8c08","commitMessage":"@@@Merge pull request #3529 from pherl/merge3.4.x\n\nMerge 3.4.x into master","date":"2017-08-22 01:39:27","modifiedFileCount":"32","status":"M","submitter":"Jisi Liu"}]
