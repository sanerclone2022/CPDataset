[{"authorTime":"2021-03-04 06:59:34","codes":[{"authorDate":"2021-03-04 06:59:34","commitOrder":1,"curCode":"  public void testParseFromArray_manyNestedMessagesError() throws Exception {\n    RecursiveMessage.Builder recursiveMessage =\n        RecursiveMessage.newBuilder().setPayload(ByteString.copyFrom(new byte[1]));\n    for (int i = 0; i < 20; i++) {\n      recursiveMessage = RecursiveMessage.newBuilder().setRecurse(recursiveMessage.build());\n    }\n    byte[] result = recursiveMessage.build().toByteArray();\n    result[\n            result.length\n                - CodedOutputStream.computeTagSize(RecursiveMessage.PAYLOAD_FIELD_NUMBER)\n                - CodedOutputStream.computeLengthDelimitedFieldSize(1)] =\n        0; \r\n    try {\n      RecursiveMessage.parseFrom(result);\n      fail(\"Result was: \" + Arrays.toString(result));\n    } catch (InvalidProtocolBufferException expected) {\n      boolean found = false;\n      int exceptionCount = 0;\n      for (Throwable exception = expected; exception != null; exception = exception.getCause()) {\n        if (exception instanceof InvalidProtocolBufferException) {\n          exceptionCount++;\n        }\n        for (StackTraceElement element : exception.getStackTrace()) {\n          if (InvalidProtocolBufferException.class.getName().equals(element.getClassName())\n              && \"invalidTag\".equals(element.getMethodName())) {\n            found = true;\n          } else if (Android.isOnAndroidDevice()\n              && \"decodeUnknownField\".equals(element.getMethodName())) {\n            \r\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        throw new AssertionError(\"Lost cause of parsing error\", expected);\n      }\n      if (exceptionCount > 1) {\n        throw new AssertionError(exceptionCount + \" nested parsing exceptions\", expected);\n      }\n    }\n  }\n","date":"2021-03-04 06:59:34","endLine":1734,"groupId":"2085","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testParseFromArray_manyNestedMessagesError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/06/d244a643670f068c5192290ce5d3654b35c8f8.src","preCode":"  public void testParseFromArray_manyNestedMessagesError() throws Exception {\n    RecursiveMessage.Builder recursiveMessage =\n        RecursiveMessage.newBuilder().setPayload(ByteString.copyFrom(new byte[1]));\n    for (int i = 0; i < 20; i++) {\n      recursiveMessage = RecursiveMessage.newBuilder().setRecurse(recursiveMessage.build());\n    }\n    byte[] result = recursiveMessage.build().toByteArray();\n    result[\n            result.length\n                - CodedOutputStream.computeTagSize(RecursiveMessage.PAYLOAD_FIELD_NUMBER)\n                - CodedOutputStream.computeLengthDelimitedFieldSize(1)] =\n        0; \r\n    try {\n      RecursiveMessage.parseFrom(result);\n      fail(\"Result was: \" + Arrays.toString(result));\n    } catch (InvalidProtocolBufferException expected) {\n      boolean found = false;\n      int exceptionCount = 0;\n      for (Throwable exception = expected; exception != null; exception = exception.getCause()) {\n        if (exception instanceof InvalidProtocolBufferException) {\n          exceptionCount++;\n        }\n        for (StackTraceElement element : exception.getStackTrace()) {\n          if (InvalidProtocolBufferException.class.getName().equals(element.getClassName())\n              && \"invalidTag\".equals(element.getMethodName())) {\n            found = true;\n          } else if (Android.isOnAndroidDevice()\n              && \"decodeUnknownField\".equals(element.getMethodName())) {\n            \r\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        throw new AssertionError(\"Lost cause of parsing error\", expected);\n      }\n      if (exceptionCount > 1) {\n        throw new AssertionError(exceptionCount + \" nested parsing exceptions\", expected);\n      }\n    }\n  }\n","realPath":"java/lite/src/test/java/com/google/protobuf/LiteTest.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1694,"status":"B"},{"authorDate":"2021-03-04 06:59:34","commitOrder":1,"curCode":"  public void testParseFromStream_manyNestedMessagesError() throws Exception {\n    RecursiveMessage.Builder recursiveMessage =\n        RecursiveMessage.newBuilder().setPayload(ByteString.copyFrom(new byte[1]));\n    for (int i = 0; i < 20; i++) {\n      recursiveMessage = RecursiveMessage.newBuilder().setRecurse(recursiveMessage.build());\n    }\n    byte[] result = recursiveMessage.build().toByteArray();\n    result[\n            result.length\n                - CodedOutputStream.computeTagSize(RecursiveMessage.PAYLOAD_FIELD_NUMBER)\n                - CodedOutputStream.computeLengthDelimitedFieldSize(1)] =\n        0; \r\n    try {\n      RecursiveMessage.parseFrom(CodedInputStream.newInstance(new ByteArrayInputStream(result)));\n      fail(\"Result was: \" + Arrays.toString(result));\n    } catch (InvalidProtocolBufferException expected) {\n      boolean found = false;\n      int exceptionCount = 0;\n      for (Throwable exception = expected; exception != null; exception = exception.getCause()) {\n        if (exception instanceof InvalidProtocolBufferException) {\n          exceptionCount++;\n        }\n        for (StackTraceElement element : exception.getStackTrace()) {\n          if (InvalidProtocolBufferException.class.getName().equals(element.getClassName())\n              && \"invalidTag\".equals(element.getMethodName())) {\n            found = true;\n          } else if (Android.isOnAndroidDevice() && \"readTag\".equals(element.getMethodName())) {\n            \r\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        throw new AssertionError(\"Lost cause of parsing error\", expected);\n      }\n      if (exceptionCount > 1) {\n        throw new AssertionError(exceptionCount + \" nested parsing exceptions\", expected);\n      }\n    }\n  }\n","date":"2021-03-04 06:59:34","endLine":1775,"groupId":"2085","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testParseFromStream_manyNestedMessagesError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/06/d244a643670f068c5192290ce5d3654b35c8f8.src","preCode":"  public void testParseFromStream_manyNestedMessagesError() throws Exception {\n    RecursiveMessage.Builder recursiveMessage =\n        RecursiveMessage.newBuilder().setPayload(ByteString.copyFrom(new byte[1]));\n    for (int i = 0; i < 20; i++) {\n      recursiveMessage = RecursiveMessage.newBuilder().setRecurse(recursiveMessage.build());\n    }\n    byte[] result = recursiveMessage.build().toByteArray();\n    result[\n            result.length\n                - CodedOutputStream.computeTagSize(RecursiveMessage.PAYLOAD_FIELD_NUMBER)\n                - CodedOutputStream.computeLengthDelimitedFieldSize(1)] =\n        0; \r\n    try {\n      RecursiveMessage.parseFrom(CodedInputStream.newInstance(new ByteArrayInputStream(result)));\n      fail(\"Result was: \" + Arrays.toString(result));\n    } catch (InvalidProtocolBufferException expected) {\n      boolean found = false;\n      int exceptionCount = 0;\n      for (Throwable exception = expected; exception != null; exception = exception.getCause()) {\n        if (exception instanceof InvalidProtocolBufferException) {\n          exceptionCount++;\n        }\n        for (StackTraceElement element : exception.getStackTrace()) {\n          if (InvalidProtocolBufferException.class.getName().equals(element.getClassName())\n              && \"invalidTag\".equals(element.getMethodName())) {\n            found = true;\n          } else if (Android.isOnAndroidDevice() && \"readTag\".equals(element.getMethodName())) {\n            \r\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        throw new AssertionError(\"Lost cause of parsing error\", expected);\n      }\n      if (exceptionCount > 1) {\n        throw new AssertionError(exceptionCount + \" nested parsing exceptions\", expected);\n      }\n    }\n  }\n","realPath":"java/lite/src/test/java/com/google/protobuf/LiteTest.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1736,"status":"B"}],"commitId":"27f4e8b5d93cc5ded69f3a9e7c11b04b68b284d4","commitMessage":"@@@Merge pull request #8350 from haberman/sync-stage\n\nIntegrate from Piper for C++.  Java.  and Python","date":"2021-03-04 06:59:34","modifiedFileCount":"6","status":"B","submitter":"Joshua Haberman"},{"authorTime":"2021-08-10 06:55:00","codes":[{"authorDate":"2021-08-10 06:55:00","commitOrder":2,"curCode":"  public void testParseFromArray_manyNestedMessagesError() throws Exception {\n    RecursiveMessage.Builder recursiveMessage =\n        RecursiveMessage.newBuilder().setPayload(ByteString.copyFrom(new byte[1]));\n    for (int i = 0; i < 20; i++) {\n      recursiveMessage = RecursiveMessage.newBuilder().setRecurse(recursiveMessage.build());\n    }\n    byte[] result = recursiveMessage.build().toByteArray();\n    result[\n            result.length\n                - CodedOutputStream.computeTagSize(RecursiveMessage.PAYLOAD_FIELD_NUMBER)\n                - CodedOutputStream.computeLengthDelimitedFieldSize(1)] =\n        0; \r\n    try {\n      RecursiveMessage.parseFrom(result);\n      assertWithMessage(\"Result was: \" + Arrays.toString(result)).fail();\n    } catch (InvalidProtocolBufferException expected) {\n      boolean found = false;\n      int exceptionCount = 0;\n      for (Throwable exception = expected; exception != null; exception = exception.getCause()) {\n        if (exception instanceof InvalidProtocolBufferException) {\n          exceptionCount++;\n        }\n        for (StackTraceElement element : exception.getStackTrace()) {\n          if (InvalidProtocolBufferException.class.getName().equals(element.getClassName())\n              && \"invalidTag\".equals(element.getMethodName())) {\n            found = true;\n          } else if (Android.isOnAndroidDevice()\n              && \"decodeUnknownField\".equals(element.getMethodName())) {\n            \r\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        throw new AssertionError(\"Lost cause of parsing error\", expected);\n      }\n      if (exceptionCount > 1) {\n        throw new AssertionError(exceptionCount + \" nested parsing exceptions\", expected);\n      }\n    }\n  }\n","date":"2021-08-10 06:55:00","endLine":1787,"groupId":"1023","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testParseFromArray_manyNestedMessagesError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/7c/bc764fb7aef6ea7d25ee4b2281113abd2dd612.src","preCode":"  public void testParseFromArray_manyNestedMessagesError() throws Exception {\n    RecursiveMessage.Builder recursiveMessage =\n        RecursiveMessage.newBuilder().setPayload(ByteString.copyFrom(new byte[1]));\n    for (int i = 0; i < 20; i++) {\n      recursiveMessage = RecursiveMessage.newBuilder().setRecurse(recursiveMessage.build());\n    }\n    byte[] result = recursiveMessage.build().toByteArray();\n    result[\n            result.length\n                - CodedOutputStream.computeTagSize(RecursiveMessage.PAYLOAD_FIELD_NUMBER)\n                - CodedOutputStream.computeLengthDelimitedFieldSize(1)] =\n        0; \r\n    try {\n      RecursiveMessage.parseFrom(result);\n      fail(\"Result was: \" + Arrays.toString(result));\n    } catch (InvalidProtocolBufferException expected) {\n      boolean found = false;\n      int exceptionCount = 0;\n      for (Throwable exception = expected; exception != null; exception = exception.getCause()) {\n        if (exception instanceof InvalidProtocolBufferException) {\n          exceptionCount++;\n        }\n        for (StackTraceElement element : exception.getStackTrace()) {\n          if (InvalidProtocolBufferException.class.getName().equals(element.getClassName())\n              && \"invalidTag\".equals(element.getMethodName())) {\n            found = true;\n          } else if (Android.isOnAndroidDevice()\n              && \"decodeUnknownField\".equals(element.getMethodName())) {\n            \r\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        throw new AssertionError(\"Lost cause of parsing error\", expected);\n      }\n      if (exceptionCount > 1) {\n        throw new AssertionError(exceptionCount + \" nested parsing exceptions\", expected);\n      }\n    }\n  }\n","realPath":"java/lite/src/test/java/com/google/protobuf/LiteTest.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1747,"status":"M"},{"authorDate":"2021-08-10 06:55:00","commitOrder":2,"curCode":"  public void testParseFromStream_manyNestedMessagesError() throws Exception {\n    RecursiveMessage.Builder recursiveMessage =\n        RecursiveMessage.newBuilder().setPayload(ByteString.copyFrom(new byte[1]));\n    for (int i = 0; i < 20; i++) {\n      recursiveMessage = RecursiveMessage.newBuilder().setRecurse(recursiveMessage.build());\n    }\n    byte[] result = recursiveMessage.build().toByteArray();\n    result[\n            result.length\n                - CodedOutputStream.computeTagSize(RecursiveMessage.PAYLOAD_FIELD_NUMBER)\n                - CodedOutputStream.computeLengthDelimitedFieldSize(1)] =\n        0; \r\n    try {\n      RecursiveMessage.parseFrom(CodedInputStream.newInstance(new ByteArrayInputStream(result)));\n      assertWithMessage(\"Result was: \" + Arrays.toString(result)).fail();\n    } catch (InvalidProtocolBufferException expected) {\n      boolean found = false;\n      int exceptionCount = 0;\n      for (Throwable exception = expected; exception != null; exception = exception.getCause()) {\n        if (exception instanceof InvalidProtocolBufferException) {\n          exceptionCount++;\n        }\n        for (StackTraceElement element : exception.getStackTrace()) {\n          if (InvalidProtocolBufferException.class.getName().equals(element.getClassName())\n              && \"invalidTag\".equals(element.getMethodName())) {\n            found = true;\n          } else if (Android.isOnAndroidDevice() && \"readTag\".equals(element.getMethodName())) {\n            \r\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        throw new AssertionError(\"Lost cause of parsing error\", expected);\n      }\n      if (exceptionCount > 1) {\n        throw new AssertionError(exceptionCount + \" nested parsing exceptions\", expected);\n      }\n    }\n  }\n","date":"2021-08-10 06:55:00","endLine":1829,"groupId":"1023","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testParseFromStream_manyNestedMessagesError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-protobuf-10-0.7/blobInfo/CC_OUT/blobs/7c/bc764fb7aef6ea7d25ee4b2281113abd2dd612.src","preCode":"  public void testParseFromStream_manyNestedMessagesError() throws Exception {\n    RecursiveMessage.Builder recursiveMessage =\n        RecursiveMessage.newBuilder().setPayload(ByteString.copyFrom(new byte[1]));\n    for (int i = 0; i < 20; i++) {\n      recursiveMessage = RecursiveMessage.newBuilder().setRecurse(recursiveMessage.build());\n    }\n    byte[] result = recursiveMessage.build().toByteArray();\n    result[\n            result.length\n                - CodedOutputStream.computeTagSize(RecursiveMessage.PAYLOAD_FIELD_NUMBER)\n                - CodedOutputStream.computeLengthDelimitedFieldSize(1)] =\n        0; \r\n    try {\n      RecursiveMessage.parseFrom(CodedInputStream.newInstance(new ByteArrayInputStream(result)));\n      fail(\"Result was: \" + Arrays.toString(result));\n    } catch (InvalidProtocolBufferException expected) {\n      boolean found = false;\n      int exceptionCount = 0;\n      for (Throwable exception = expected; exception != null; exception = exception.getCause()) {\n        if (exception instanceof InvalidProtocolBufferException) {\n          exceptionCount++;\n        }\n        for (StackTraceElement element : exception.getStackTrace()) {\n          if (InvalidProtocolBufferException.class.getName().equals(element.getClassName())\n              && \"invalidTag\".equals(element.getMethodName())) {\n            found = true;\n          } else if (Android.isOnAndroidDevice() && \"readTag\".equals(element.getMethodName())) {\n            \r\n            found = true;\n          }\n        }\n      }\n      if (!found) {\n        throw new AssertionError(\"Lost cause of parsing error\", expected);\n      }\n      if (exceptionCount > 1) {\n        throw new AssertionError(exceptionCount + \" nested parsing exceptions\", expected);\n      }\n    }\n  }\n","realPath":"java/lite/src/test/java/com/google/protobuf/LiteTest.java","repoName":"protobuf","snippetEndLine":0,"snippetStartLine":0,"startLine":1790,"status":"M"}],"commitId":"8a3c4948a49d3b38effea499fd9dee66f28cb0c4","commitMessage":"@@@Merge pull request #8858 from acozzette/sync-stage\n\nIntegrate from Piper for C++.  Java.  and Python","date":"2021-08-10 06:55:00","modifiedFileCount":"84","status":"M","submitter":"Adam Cozzette"}]
