[{"authorTime":"2011-08-30 06:55:45","codes":[{"authorDate":"2017-04-21 05:33:38","commitOrder":3,"curCode":"  public void testSupplierThreadSafe(Function<Supplier<Boolean>, Supplier<Boolean>> memoizer)\n      throws Throwable {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicReference<Throwable> thrown =\n        new AtomicReference<Throwable>(null);\n    final int numThreads = 3;\n    final Thread[] threads = new Thread[numThreads];\n    final long timeout = TimeUnit.SECONDS.toNanos(60);\n\n    final Supplier<Boolean> supplier = new Supplier<Boolean>() {\n      boolean isWaiting(Thread thread) {\n        switch (thread.getState()) {\n          case BLOCKED:\n          case WAITING:\n          case TIMED_WAITING:\n          return true;\n          default:\n          return false;\n        }\n      }\n\n      int waitingThreads() {\n        int waitingThreads = 0;\n        for (Thread thread : threads) {\n          if (isWaiting(thread)) {\n            waitingThreads++;\n          }\n        }\n        return waitingThreads;\n      }\n\n      @Override\n      public Boolean get() {\n        \r\n        \r\n        long t0 = System.nanoTime();\n        while (waitingThreads() != numThreads - 1) {\n          if (System.nanoTime() - t0 > timeout) {\n            thrown.set(new TimeoutException(\n                \"timed out waiting for other threads to block\" +\n                \" synchronizing on supplier\"));\n            break;\n          }\n          Thread.yield();\n        }\n        count.getAndIncrement();\n        return Boolean.TRUE;\n      }\n    };\n\n    final Supplier<Boolean> memoizedSupplier = memoizer.apply(supplier);\n\n    for (int i = 0; i < numThreads; i++) {\n      threads[i] = new Thread() {\n        @Override public void run() {\n          assertSame(Boolean.TRUE, memoizedSupplier.get());\n        }\n      };\n    }\n    for (Thread t : threads) {\n      t.start();\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n\n    if (thrown.get() != null) {\n      throw thrown.get();\n    }\n    assertEquals(1, count.get());\n  }\n","date":"2017-04-21 10:27:51","endLine":365,"groupId":"9489","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testSupplierThreadSafe","params":"(Function<Supplier<Boolean>@Supplier<Boolean>>memoizer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/05/7385d11731a2f0e3e43094ff25da269dc51115.src","preCode":"  public void testSupplierThreadSafe(Function<Supplier<Boolean>, Supplier<Boolean>> memoizer)\n      throws Throwable {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicReference<Throwable> thrown =\n        new AtomicReference<Throwable>(null);\n    final int numThreads = 3;\n    final Thread[] threads = new Thread[numThreads];\n    final long timeout = TimeUnit.SECONDS.toNanos(60);\n\n    final Supplier<Boolean> supplier = new Supplier<Boolean>() {\n      boolean isWaiting(Thread thread) {\n        switch (thread.getState()) {\n          case BLOCKED:\n          case WAITING:\n          case TIMED_WAITING:\n          return true;\n          default:\n          return false;\n        }\n      }\n\n      int waitingThreads() {\n        int waitingThreads = 0;\n        for (Thread thread : threads) {\n          if (isWaiting(thread)) {\n            waitingThreads++;\n          }\n        }\n        return waitingThreads;\n      }\n\n      @Override\n      public Boolean get() {\n        \r\n        \r\n        long t0 = System.nanoTime();\n        while (waitingThreads() != numThreads - 1) {\n          if (System.nanoTime() - t0 > timeout) {\n            thrown.set(new TimeoutException(\n                \"timed out waiting for other threads to block\" +\n                \" synchronizing on supplier\"));\n            break;\n          }\n          Thread.yield();\n        }\n        count.getAndIncrement();\n        return Boolean.TRUE;\n      }\n    };\n\n    final Supplier<Boolean> memoizedSupplier = memoizer.apply(supplier);\n\n    for (int i = 0; i < numThreads; i++) {\n      threads[i] = new Thread() {\n        @Override public void run() {\n          assertSame(Boolean.TRUE, memoizedSupplier.get());\n        }\n      };\n    }\n    for (Thread t : threads) {\n      t.start();\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n\n    if (thrown.get() != null) {\n      throw thrown.get();\n    }\n    assertEquals(1, count.get());\n  }\n","realPath":"android/guava-tests/test/com/google/common/base/SuppliersTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"B"},{"authorDate":"2011-08-30 06:55:45","commitOrder":3,"curCode":"  public void testSupplierThreadSafe(\n      Function<Supplier<Boolean>, Supplier<Boolean>> memoizer)\n      throws Throwable {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicReference<Throwable> thrown =\n        new AtomicReference<Throwable>(null);\n    final int numThreads = 3;\n    final Thread[] threads = new Thread[numThreads];\n    final long timeout = TimeUnit.SECONDS.toNanos(60);\n\n    final Supplier<Boolean> supplier = new Supplier<Boolean>() {\n      boolean isWaiting(Thread thread) {\n        switch (thread.getState()) {\n          case BLOCKED:\n          case WAITING:\n          case TIMED_WAITING:\n          return true;\n          default:\n          return false;\n        }\n      }\n\n      int waitingThreads() {\n        int waitingThreads = 0;\n        for (Thread thread : threads) {\n          if (isWaiting(thread)) {\n            waitingThreads++;\n          }\n        }\n        return waitingThreads;\n      }\n\n      @Override\n      public Boolean get() {\n        \r\n        \r\n        long t0 = System.nanoTime();\n        while (waitingThreads() != numThreads - 1) {\n          if (System.nanoTime() - t0 > timeout) {\n            thrown.set(new TimeoutException(\n                \"timed out waiting for other threads to block\" +\n                \" synchronizing on supplier\"));\n            break;\n          }\n          Thread.yield();\n        }\n        count.getAndIncrement();\n        return Boolean.TRUE;\n      }\n    };\n\n    final Supplier<Boolean> memoizedSupplier = memoizer.apply(supplier);\n\n    for (int i = 0; i < numThreads; i++) {\n      threads[i] = new Thread() {\n        @Override public void run() {\n          assertSame(Boolean.TRUE, memoizedSupplier.get());\n        }\n      };\n    }\n    for (Thread t : threads) {\n      t.start();\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n\n    if (thrown.get() != null) {\n      throw thrown.get();\n    }\n    assertEquals(1, count.get());\n  }\n","date":"2011-08-30 06:55:45","endLine":330,"groupId":"9489","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testSupplierThreadSafe","params":"(Function<Supplier<Boolean>@Supplier<Boolean>>memoizer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/a2/573e2f415c155ee0817173f02823f1253cf825.src","preCode":"  public void testSupplierThreadSafe(\n      Function<Supplier<Boolean>, Supplier<Boolean>> memoizer)\n      throws Throwable {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicReference<Throwable> thrown =\n        new AtomicReference<Throwable>(null);\n    final int numThreads = 3;\n    final Thread[] threads = new Thread[numThreads];\n    final long timeout = TimeUnit.SECONDS.toNanos(60);\n\n    final Supplier<Boolean> supplier = new Supplier<Boolean>() {\n      boolean isWaiting(Thread thread) {\n        switch (thread.getState()) {\n          case BLOCKED:\n          case WAITING:\n          case TIMED_WAITING:\n          return true;\n          default:\n          return false;\n        }\n      }\n\n      int waitingThreads() {\n        int waitingThreads = 0;\n        for (Thread thread : threads) {\n          if (isWaiting(thread)) {\n            waitingThreads++;\n          }\n        }\n        return waitingThreads;\n      }\n\n      @Override\n      public Boolean get() {\n        \r\n        \r\n        long t0 = System.nanoTime();\n        while (waitingThreads() != numThreads - 1) {\n          if (System.nanoTime() - t0 > timeout) {\n            thrown.set(new TimeoutException(\n                \"timed out waiting for other threads to block\" +\n                \" synchronizing on supplier\"));\n            break;\n          }\n          Thread.yield();\n        }\n        count.getAndIncrement();\n        return Boolean.TRUE;\n      }\n    };\n\n    final Supplier<Boolean> memoizedSupplier = memoizer.apply(supplier);\n\n    for (int i = 0; i < numThreads; i++) {\n      threads[i] = new Thread() {\n        @Override public void run() {\n          assertSame(Boolean.TRUE, memoizedSupplier.get());\n        }\n      };\n    }\n    for (Thread t : threads) {\n      t.start();\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n\n    if (thrown.get() != null) {\n      throw thrown.get();\n    }\n    assertEquals(1, count.get());\n  }\n","realPath":"guava-tests/test/com/google/common/base/SuppliersTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":259,"status":"NB"}],"commitId":"9b94fb3965c6869b0ac47420958a4bbae0b2d54c","commitMessage":"@@@Begin exporting sources of Guava for Android.\n\npom.xml files to come.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=153757913\n","date":"2017-04-21 10:27:51","modifiedFileCount":"0","status":"M","submitter":"zhenghua"},{"authorTime":"2017-07-26 22:37:38","codes":[{"authorDate":"2017-07-26 22:37:38","commitOrder":4,"curCode":"  public void testSupplierThreadSafe(Function<Supplier<Boolean>, Supplier<Boolean>> memoizer)\n      throws Throwable {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicReference<Throwable> thrown = new AtomicReference<>(null);\n    final int numThreads = 3;\n    final Thread[] threads = new Thread[numThreads];\n    final long timeout = TimeUnit.SECONDS.toNanos(60);\n\n    final Supplier<Boolean> supplier = new Supplier<Boolean>() {\n      boolean isWaiting(Thread thread) {\n        switch (thread.getState()) {\n          case BLOCKED:\n          case WAITING:\n          case TIMED_WAITING:\n          return true;\n          default:\n          return false;\n        }\n      }\n\n      int waitingThreads() {\n        int waitingThreads = 0;\n        for (Thread thread : threads) {\n          if (isWaiting(thread)) {\n            waitingThreads++;\n          }\n        }\n        return waitingThreads;\n      }\n\n      @Override\n      public Boolean get() {\n        \r\n        \r\n        long t0 = System.nanoTime();\n        while (waitingThreads() != numThreads - 1) {\n          if (System.nanoTime() - t0 > timeout) {\n            thrown.set(new TimeoutException(\n                \"timed out waiting for other threads to block\" +\n                \" synchronizing on supplier\"));\n            break;\n          }\n          Thread.yield();\n        }\n        count.getAndIncrement();\n        return Boolean.TRUE;\n      }\n    };\n\n    final Supplier<Boolean> memoizedSupplier = memoizer.apply(supplier);\n\n    for (int i = 0; i < numThreads; i++) {\n      threads[i] = new Thread() {\n        @Override public void run() {\n          assertSame(Boolean.TRUE, memoizedSupplier.get());\n        }\n      };\n    }\n    for (Thread t : threads) {\n      t.start();\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n\n    if (thrown.get() != null) {\n      throw thrown.get();\n    }\n    assertEquals(1, count.get());\n  }\n","date":"2017-07-26 22:45:36","endLine":364,"groupId":"101252","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testSupplierThreadSafe","params":"(Function<Supplier<Boolean>@Supplier<Boolean>>memoizer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/d8/ba3236dec4e4bf72fb09c14137df68220c38a9.src","preCode":"  public void testSupplierThreadSafe(Function<Supplier<Boolean>, Supplier<Boolean>> memoizer)\n      throws Throwable {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicReference<Throwable> thrown =\n        new AtomicReference<Throwable>(null);\n    final int numThreads = 3;\n    final Thread[] threads = new Thread[numThreads];\n    final long timeout = TimeUnit.SECONDS.toNanos(60);\n\n    final Supplier<Boolean> supplier = new Supplier<Boolean>() {\n      boolean isWaiting(Thread thread) {\n        switch (thread.getState()) {\n          case BLOCKED:\n          case WAITING:\n          case TIMED_WAITING:\n          return true;\n          default:\n          return false;\n        }\n      }\n\n      int waitingThreads() {\n        int waitingThreads = 0;\n        for (Thread thread : threads) {\n          if (isWaiting(thread)) {\n            waitingThreads++;\n          }\n        }\n        return waitingThreads;\n      }\n\n      @Override\n      public Boolean get() {\n        \r\n        \r\n        long t0 = System.nanoTime();\n        while (waitingThreads() != numThreads - 1) {\n          if (System.nanoTime() - t0 > timeout) {\n            thrown.set(new TimeoutException(\n                \"timed out waiting for other threads to block\" +\n                \" synchronizing on supplier\"));\n            break;\n          }\n          Thread.yield();\n        }\n        count.getAndIncrement();\n        return Boolean.TRUE;\n      }\n    };\n\n    final Supplier<Boolean> memoizedSupplier = memoizer.apply(supplier);\n\n    for (int i = 0; i < numThreads; i++) {\n      threads[i] = new Thread() {\n        @Override public void run() {\n          assertSame(Boolean.TRUE, memoizedSupplier.get());\n        }\n      };\n    }\n    for (Thread t : threads) {\n      t.start();\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n\n    if (thrown.get() != null) {\n      throw thrown.get();\n    }\n    assertEquals(1, count.get());\n  }\n","realPath":"android/guava-tests/test/com/google/common/base/SuppliersTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"M"},{"authorDate":"2017-07-26 22:37:38","commitOrder":4,"curCode":"  public void testSupplierThreadSafe(Function<Supplier<Boolean>, Supplier<Boolean>> memoizer)\n      throws Throwable {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicReference<Throwable> thrown = new AtomicReference<>(null);\n    final int numThreads = 3;\n    final Thread[] threads = new Thread[numThreads];\n    final long timeout = TimeUnit.SECONDS.toNanos(60);\n\n    final Supplier<Boolean> supplier = new Supplier<Boolean>() {\n      boolean isWaiting(Thread thread) {\n        switch (thread.getState()) {\n          case BLOCKED:\n          case WAITING:\n          case TIMED_WAITING:\n          return true;\n          default:\n          return false;\n        }\n      }\n\n      int waitingThreads() {\n        int waitingThreads = 0;\n        for (Thread thread : threads) {\n          if (isWaiting(thread)) {\n            waitingThreads++;\n          }\n        }\n        return waitingThreads;\n      }\n\n      @Override\n      public Boolean get() {\n        \r\n        \r\n        long t0 = System.nanoTime();\n        while (waitingThreads() != numThreads - 1) {\n          if (System.nanoTime() - t0 > timeout) {\n            thrown.set(new TimeoutException(\n                \"timed out waiting for other threads to block\" +\n                \" synchronizing on supplier\"));\n            break;\n          }\n          Thread.yield();\n        }\n        count.getAndIncrement();\n        return Boolean.TRUE;\n      }\n    };\n\n    final Supplier<Boolean> memoizedSupplier = memoizer.apply(supplier);\n\n    for (int i = 0; i < numThreads; i++) {\n      threads[i] = new Thread() {\n        @Override public void run() {\n          assertSame(Boolean.TRUE, memoizedSupplier.get());\n        }\n      };\n    }\n    for (Thread t : threads) {\n      t.start();\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n\n    if (thrown.get() != null) {\n      throw thrown.get();\n    }\n    assertEquals(1, count.get());\n  }\n","date":"2017-07-26 22:45:36","endLine":364,"groupId":"101252","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testSupplierThreadSafe","params":"(Function<Supplier<Boolean>@Supplier<Boolean>>memoizer)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/d8/ba3236dec4e4bf72fb09c14137df68220c38a9.src","preCode":"  public void testSupplierThreadSafe(Function<Supplier<Boolean>, Supplier<Boolean>> memoizer)\n      throws Throwable {\n    final AtomicInteger count = new AtomicInteger(0);\n    final AtomicReference<Throwable> thrown =\n        new AtomicReference<Throwable>(null);\n    final int numThreads = 3;\n    final Thread[] threads = new Thread[numThreads];\n    final long timeout = TimeUnit.SECONDS.toNanos(60);\n\n    final Supplier<Boolean> supplier = new Supplier<Boolean>() {\n      boolean isWaiting(Thread thread) {\n        switch (thread.getState()) {\n          case BLOCKED:\n          case WAITING:\n          case TIMED_WAITING:\n          return true;\n          default:\n          return false;\n        }\n      }\n\n      int waitingThreads() {\n        int waitingThreads = 0;\n        for (Thread thread : threads) {\n          if (isWaiting(thread)) {\n            waitingThreads++;\n          }\n        }\n        return waitingThreads;\n      }\n\n      @Override\n      public Boolean get() {\n        \r\n        \r\n        long t0 = System.nanoTime();\n        while (waitingThreads() != numThreads - 1) {\n          if (System.nanoTime() - t0 > timeout) {\n            thrown.set(new TimeoutException(\n                \"timed out waiting for other threads to block\" +\n                \" synchronizing on supplier\"));\n            break;\n          }\n          Thread.yield();\n        }\n        count.getAndIncrement();\n        return Boolean.TRUE;\n      }\n    };\n\n    final Supplier<Boolean> memoizedSupplier = memoizer.apply(supplier);\n\n    for (int i = 0; i < numThreads; i++) {\n      threads[i] = new Thread() {\n        @Override public void run() {\n          assertSame(Boolean.TRUE, memoizedSupplier.get());\n        }\n      };\n    }\n    for (Thread t : threads) {\n      t.start();\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n\n    if (thrown.get() != null) {\n      throw thrown.get();\n    }\n    assertEquals(1, count.get());\n  }\n","realPath":"guava-tests/test/com/google/common/base/SuppliersTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"M"}],"commitId":"934e3840945d3b866f80c28135a0369cb32d7163","commitMessage":"@@@Use diamond operator.\n\nFixes #2875\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=163205176\n","date":"2017-07-26 22:45:36","modifiedFileCount":"175","status":"M","submitter":"cpovirk"}]
