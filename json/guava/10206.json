[{"authorTime":"2018-03-03 05:09:40","codes":[{"authorDate":"2018-03-03 05:09:40","commitOrder":1,"curCode":"  public void forGraph_depthFirstPreOrderIterable_iterableIsLazy() {\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\"));\n\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n\n    \r\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n  }\n","date":"2018-03-06 12:59:08","endLine":540,"groupId":"6257","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"forGraph_depthFirstPreOrderIterable_iterableIsLazy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/f1/db94300a9c092849c1b872883950cc86fd3623.src","preCode":"  public void forGraph_depthFirstPreOrderIterable_iterableIsLazy() {\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\"));\n\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n\n    \r\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n  }\n","realPath":"guava-tests/test/com/google/common/graph/TraverserTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":530,"status":"B"},{"authorDate":"2018-03-03 05:09:40","commitOrder":1,"curCode":"  public void forGraph_depthFirstPostOrderIterable_iterableIsLazy() {\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(\"ac\"));\n\n    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n\n    \r\n    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n  }\n","date":"2018-03-06 12:59:08","endLine":722,"groupId":"6257","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"forGraph_depthFirstPostOrderIterable_iterableIsLazy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/f1/db94300a9c092849c1b872883950cc86fd3623.src","preCode":"  public void forGraph_depthFirstPostOrderIterable_iterableIsLazy() {\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(\"ac\"));\n\n    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n\n    \r\n    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n  }\n","realPath":"guava-tests/test/com/google/common/graph/TraverserTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":712,"status":"B"}],"commitId":"cbc53084465d3a95cdb8cbd79da21624e3086d5d","commitMessage":"@@@Traverser.java: add support for multiple start nodes.\n\nUpdate documentation (in this file and in graphs_explained.md) relating to behavior and definitions of equals() and hashCode().\n\nRELNOTES=`common.graph.Traverser`: add support for traversing from multiple start nodes.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=187659103\n","date":"2018-03-06 12:59:08","modifiedFileCount":"4","status":"B","submitter":"jrtom"},{"authorTime":"2018-03-03 05:09:40","codes":[{"authorDate":"2020-07-11 06:32:35","commitOrder":2,"curCode":"  public void forGraph_depthFirstPreOrderIterable_iterableIsLazy() {\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\"));\n\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c');\n\n    \r\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c');\n  }\n","date":"2020-07-13 23:39:57","endLine":540,"groupId":"10206","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"forGraph_depthFirstPreOrderIterable_iterableIsLazy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/49/7c43bf33b7383701d9878cab36c5fd1bbb46b3.src","preCode":"  public void forGraph_depthFirstPreOrderIterable_iterableIsLazy() {\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\"));\n\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n\n    \r\n    assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n  }\n","realPath":"guava-tests/test/com/google/common/graph/TraverserTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":530,"status":"M"},{"authorDate":"2018-03-03 05:09:40","commitOrder":2,"curCode":"  public void forGraph_depthFirstPostOrderIterable_iterableIsLazy() {\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(\"ac\"));\n\n    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n\n    \r\n    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n  }\n","date":"2018-03-06 12:59:08","endLine":722,"groupId":"10206","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"forGraph_depthFirstPostOrderIterable_iterableIsLazy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/f1/db94300a9c092849c1b872883950cc86fd3623.src","preCode":"  public void forGraph_depthFirstPostOrderIterable_iterableIsLazy() {\n    RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n    Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder(charactersOf(\"ac\"));\n\n    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');\n\n    \r\n    assertEqualCharNodes(Iterables.limit(result, 2), \"db\");\n    assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');\n  }\n","realPath":"guava-tests/test/com/google/common/graph/TraverserTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":712,"status":"N"}],"commitId":"b5210ca95c4303bd91fdb9cb1d063f5680183f0b","commitMessage":"@@@Speed up Traverser and cut about 30 lines of code.\n\nWhen stacked against the unsubmitted Walker.  before the change:\n   breadthFirst was roughly on par;\n   preOrder/postOrder were about 70% slower (1359 vs. 2358);\n\nAfter adopting the Walker impl.  the tree traversal preorder/postorder are improved close to Walker impl.\n\nThere is still about 10% slowness (2405 vs. 2268) remaining.  which I suspect is due to Iterator being slower than Spliterator.  because with Spliterator.  we can tryAdvance() once for each element.  while with Iterator.  we have to call both hasNext() and next().\n\nThe graph traversal adoption is similar.  with about 15% remaining slowness compared to Walker (1583 vs. 1338).  which is likely result of Spliterator.tryAdvance() vs. Iterator.hasNext() + next().\n\nDid not adopt the Walker's breadth-first impl for the following reasons:\n\n1. Adopting the Walker's breadth-first impl contributed about 10% slowdown compared to the current impl. I think this is likely due to the eager foreach loop of the successors in the current breadth-first iterator. In the full traversal benchmark.  it's likely faster than consuming the successor iterator lazily.\n\nOn the other hand.  the breadth-first iterator is inconsistent with the depth-first iterators that consume the successor iterators lazily.\n\nFor follow-up: It might be better to go complete lazy for breadth-first.  even at the cost of 10% slowdown in the full-traversal benchmark. Plus we can reuse code and delete the two existing BreadthFirstIterator classes.\n\nI'm going to add the benchmark class in the the labs directory to compare between Iteration and Traverser.\n\nRELNOTES=Optimize Traverser\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=320688457\n","date":"2020-07-13 23:39:57","modifiedFileCount":"4","status":"M","submitter":"benyu"}]
