[{"authorTime":"2017-03-30 00:01:35","codes":[{"authorDate":"2017-04-21 05:33:38","commitOrder":13,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdge(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdge(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2017-04-21 10:27:51","endLine":173,"groupId":"5740","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/78/375146993591b9e1bacfe12ba731f36107d8dd.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdge(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdge(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"B"},{"authorDate":"2017-03-30 00:01:35","commitOrder":13,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdge(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdge(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2017-03-30 01:14:54","endLine":173,"groupId":"5740","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/78/375146993591b9e1bacfe12ba731f36107d8dd.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdge(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdge(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"NB"}],"commitId":"9b94fb3965c6869b0ac47420958a4bbae0b2d54c","commitMessage":"@@@Begin exporting sources of Guava for Android.\n\npom.xml files to come.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=153757913\n","date":"2017-04-21 10:27:51","modifiedFileCount":"0","status":"M","submitter":"zhenghua"},{"authorTime":"2017-05-23 00:56:43","codes":[{"authorDate":"2017-05-23 00:56:43","commitOrder":14,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2017-05-23 01:39:27","endLine":171,"groupId":"5740","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/04/15897e60fe6f43db3d2a5b6915ca2491b2b955.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdge(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdge(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"},{"authorDate":"2017-05-23 00:56:43","commitOrder":14,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2017-05-23 01:39:27","endLine":171,"groupId":"5740","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/04/15897e60fe6f43db3d2a5b6915ca2491b2b955.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdge(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdge(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":118,"status":"M"}],"commitId":"bc996973fe6ce1ecb67803aa1ff5bdf5df59d182","commitMessage":"@@@common.graph classes: mark types and methods as @GoogleInternal that are not yet ready for release in Guava 22.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=156749408\n","date":"2017-05-23 01:39:27","modifiedFileCount":"24","status":"M","submitter":"jrtom"},{"authorTime":"2017-06-29 06:00:12","codes":[{"authorDate":"2017-06-29 06:00:12","commitOrder":15,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2017-06-29 11:36:54","endLine":171,"groupId":"5740","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/f8/9af64219a047ceb21c0e58c31f2cb4218343f2.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2017-06-29 06:00:12","commitOrder":15,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2017-06-29 11:36:54","endLine":171,"groupId":"5740","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/f8/9af64219a047ceb21c0e58c31f2cb4218343f2.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"}],"commitId":"49e145257d6dfb36ca1dd17a144d81c635504b9e","commitMessage":"@@@hasEdge(): rename to hasEdgeConnecting().  remove @GoogleInternal annotation.  and add to Network as well.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=160455853\n","date":"2017-06-29 11:36:54","modifiedFileCount":"22","status":"M","submitter":"jrtom"},{"authorTime":"2017-07-26 22:37:38","codes":[{"authorDate":"2017-07-26 22:37:38","commitOrder":16,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2017-07-26 22:45:36","endLine":171,"groupId":"5740","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/f0/781c432dac2b409c3ccf0cdd9f60e9cd18877d.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2017-07-26 22:37:38","commitOrder":16,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2017-07-26 22:45:36","endLine":171,"groupId":"5740","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/f0/781c432dac2b409c3ccf0cdd9f60e9cd18877d.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"}],"commitId":"934e3840945d3b866f80c28135a0369cb32d7163","commitMessage":"@@@Use diamond operator.\n\nFixes #2875\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=163205176\n","date":"2017-07-26 22:45:36","modifiedFileCount":"175","status":"M","submitter":"cpovirk"},{"authorTime":"2018-01-11 07:51:10","codes":[{"authorDate":"2018-01-11 07:51:10","commitOrder":17,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n        assertThat(graph.incidentEdges(node)).contains(EndpointPair.of(graph, predecessor, node));\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n        assertThat(graph.incidentEdges(node)).contains(EndpointPair.of(graph, node, successor));\n      }\n\n      for (EndpointPair<N> endpoints : sanityCheckSet(graph.incidentEdges(node))) {\n        if (graph.isDirected()) {\n          assertThat(graph.hasEdgeConnecting(endpoints.source(), endpoints.target())).isTrue();\n        } else {\n          assertThat(graph.hasEdgeConnecting(endpoints.nodeU(), endpoints.nodeV())).isTrue();\n        }\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2018-01-11 23:04:59","endLine":181,"groupId":"10495","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/1e/4267457f4a342a030574edc8f6a53187dafb2d.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2018-01-11 07:51:10","commitOrder":17,"curCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n        assertThat(graph.incidentEdges(node)).contains(EndpointPair.of(graph, predecessor, node));\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n        assertThat(graph.incidentEdges(node)).contains(EndpointPair.of(graph, node, successor));\n      }\n\n      for (EndpointPair<N> endpoints : sanityCheckSet(graph.incidentEdges(node))) {\n        if (graph.isDirected()) {\n          assertThat(graph.hasEdgeConnecting(endpoints.source(), endpoints.target())).isTrue();\n        } else {\n          assertThat(graph.hasEdgeConnecting(endpoints.nodeU(), endpoints.nodeV())).isTrue();\n        }\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","date":"2018-01-11 23:04:59","endLine":181,"groupId":"10495","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"validateGraph","params":"(Graph<N>graph)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/1e/4267457f4a342a030574edc8f6a53187dafb2d.src","preCode":"  static <N> void validateGraph(Graph<N> graph) {\n    assertStronglyEquivalent(graph, Graphs.copyOf(graph));\n    assertStronglyEquivalent(graph, ImmutableGraph.copyOf(graph));\n\n    String graphString = graph.toString();\n    assertThat(graphString).contains(\"isDirected: \" + graph.isDirected());\n    assertThat(graphString).contains(\"allowsSelfLoops: \" + graph.allowsSelfLoops());\n\n    int nodeStart = graphString.indexOf(\"nodes:\");\n    int edgeStart = graphString.indexOf(\"edges:\");\n    String nodeString = graphString.substring(nodeStart, edgeStart);\n\n    Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n\n    for (N node : sanityCheckSet(graph.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      if (graph.isDirected()) {\n        assertThat(graph.degree(node)).isEqualTo(graph.inDegree(node) + graph.outDegree(node));\n        assertThat(graph.predecessors(node)).hasSize(graph.inDegree(node));\n        assertThat(graph.successors(node)).hasSize(graph.outDegree(node));\n      } else {\n        int selfLoopCount = graph.adjacentNodes(node).contains(node) ? 1 : 0;\n        assertThat(graph.degree(node)).isEqualTo(graph.adjacentNodes(node).size() + selfLoopCount);\n        assertThat(graph.predecessors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.successors(node)).isEqualTo(graph.adjacentNodes(node));\n        assertThat(graph.inDegree(node)).isEqualTo(graph.degree(node));\n        assertThat(graph.outDegree(node)).isEqualTo(graph.degree(node));\n      }\n\n      for (N adjacentNode : sanityCheckSet(graph.adjacentNodes(node))) {\n        if (!graph.allowsSelfLoops()) {\n          assertThat(node).isNotEqualTo(adjacentNode);\n        }\n        assertThat(\n                graph.predecessors(node).contains(adjacentNode)\n                    || graph.successors(node).contains(adjacentNode))\n            .isTrue();\n      }\n\n      for (N predecessor : sanityCheckSet(graph.predecessors(node))) {\n        assertThat(graph.successors(predecessor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(predecessor, node)).isTrue();\n      }\n\n      for (N successor : sanityCheckSet(graph.successors(node))) {\n        allEndpointPairs.add(EndpointPair.of(graph, node, successor));\n        assertThat(graph.predecessors(successor)).contains(node);\n        assertThat(graph.hasEdgeConnecting(node, successor)).isTrue();\n      }\n    }\n\n    sanityCheckSet(graph.edges());\n    assertThat(graph.edges()).doesNotContain(EndpointPair.of(graph, new Object(), new Object()));\n    assertThat(graph.edges()).isEqualTo(allEndpointPairs);\n  }\n","realPath":"guava-tests/test/com/google/common/graph/AbstractGraphTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"}],"commitId":"d788bc15f0721b94f6f79f0a9063247083745a27","commitMessage":"@@@common.graph: add incidentEdges() method to Graph/ValueGraph.\n\nAlso added an override of remove() to the Set returned by the edges() method.  to ensure that it wouldn't allow removal of elements from the set.\n\nJava []\n\nRELNOTES=Graph.  ValueGraph: added incidentEdges() method.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=181529878\n","date":"2018-01-11 23:04:59","modifiedFileCount":"22","status":"M","submitter":"jrtom"}]
