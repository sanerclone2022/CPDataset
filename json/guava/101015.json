[{"authorTime":"2016-09-01 12:04:06","codes":[{"authorDate":"2017-04-21 05:33:38","commitOrder":2,"curCode":"  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n    Random gen = new Random(42); \r\n\n    for (int trial = 0; trial < NUM_TRIALS; ++trial) {\n      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty();\n      AbstractGraphTest.validateGraph(graph);\n\n      while (graph.nodes().size() < NUM_NODES) {\n        graph.addNode(gen.nextInt(NODE_POOL_SIZE));\n      }\n      ArrayList<Integer> nodeList = new ArrayList<Integer>(graph.nodes());\n      while (graph.edges().size() < NUM_EDGES) {\n        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));\n      }\n      ArrayList<EndpointPair<Integer>> edgeList =\n          new ArrayList<EndpointPair<Integer>>(graph.edges());\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(edgeList, gen);\n      int numEdgesToRemove = gen.nextInt(NUM_EDGES);\n      for (int i = 0; i < numEdgesToRemove; ++i) {\n        EndpointPair<Integer> edge = edgeList.get(i);\n        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      int numNodesToRemove = gen.nextInt(NUM_NODES);\n      for (int i = 0; i < numNodesToRemove; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);\n      \r\n      AbstractGraphTest.validateGraph(graph);\n\n      for (int i = numNodesToRemove; i < NUM_NODES; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty(); \r\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      for (Integer node : nodeList) {\n        assertThat(graph.addNode(node)).isTrue();\n      }\n      Collections.shuffle(edgeList, gen);\n      for (EndpointPair<Integer> edge : edgeList) {\n        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n    }\n  }\n","date":"2017-04-21 10:27:51","endLine":115,"groupId":"766","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testGraphMutation","params":"(GraphBuilder<?superInteger>graphBuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/13/3d3a8c3800d1785aa7a5cfb4e31029284f95e3.src","preCode":"  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n    Random gen = new Random(42); \r\n\n    for (int trial = 0; trial < NUM_TRIALS; ++trial) {\n      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty();\n      AbstractGraphTest.validateGraph(graph);\n\n      while (graph.nodes().size() < NUM_NODES) {\n        graph.addNode(gen.nextInt(NODE_POOL_SIZE));\n      }\n      ArrayList<Integer> nodeList = new ArrayList<Integer>(graph.nodes());\n      while (graph.edges().size() < NUM_EDGES) {\n        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));\n      }\n      ArrayList<EndpointPair<Integer>> edgeList =\n          new ArrayList<EndpointPair<Integer>>(graph.edges());\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(edgeList, gen);\n      int numEdgesToRemove = gen.nextInt(NUM_EDGES);\n      for (int i = 0; i < numEdgesToRemove; ++i) {\n        EndpointPair<Integer> edge = edgeList.get(i);\n        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      int numNodesToRemove = gen.nextInt(NUM_NODES);\n      for (int i = 0; i < numNodesToRemove; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);\n      \r\n      AbstractGraphTest.validateGraph(graph);\n\n      for (int i = numNodesToRemove; i < NUM_NODES; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty(); \r\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      for (Integer node : nodeList) {\n        assertThat(graph.addNode(node)).isTrue();\n      }\n      Collections.shuffle(edgeList, gen);\n      for (EndpointPair<Integer> edge : edgeList) {\n        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n    }\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/GraphMutationTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"B"},{"authorDate":"2016-09-01 12:04:06","commitOrder":2,"curCode":"  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n    Random gen = new Random(42); \r\n\n    for (int trial = 0; trial < NUM_TRIALS; ++trial) {\n      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty();\n      AbstractGraphTest.validateGraph(graph);\n\n      while (graph.nodes().size() < NUM_NODES) {\n        graph.addNode(gen.nextInt(NODE_POOL_SIZE));\n      }\n      ArrayList<Integer> nodeList = new ArrayList<Integer>(graph.nodes());\n      while (graph.edges().size() < NUM_EDGES) {\n        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));\n      }\n      ArrayList<EndpointPair<Integer>> edgeList =\n          new ArrayList<EndpointPair<Integer>>(graph.edges());\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(edgeList, gen);\n      int numEdgesToRemove = gen.nextInt(NUM_EDGES);\n      for (int i = 0; i < numEdgesToRemove; ++i) {\n        EndpointPair<Integer> edge = edgeList.get(i);\n        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      int numNodesToRemove = gen.nextInt(NUM_NODES);\n      for (int i = 0; i < numNodesToRemove; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);\n      \r\n      AbstractGraphTest.validateGraph(graph);\n\n      for (int i = numNodesToRemove; i < NUM_NODES; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty(); \r\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      for (Integer node : nodeList) {\n        assertThat(graph.addNode(node)).isTrue();\n      }\n      Collections.shuffle(edgeList, gen);\n      for (EndpointPair<Integer> edge : edgeList) {\n        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n    }\n  }\n","date":"2016-09-01 22:30:43","endLine":117,"groupId":"766","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testGraphMutation","params":"(GraphBuilder<?superInteger>graphBuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/86/8ec94098b37170133863a0c408e11ebe0464af.src","preCode":"  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n    Random gen = new Random(42); \r\n\n    for (int trial = 0; trial < NUM_TRIALS; ++trial) {\n      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty();\n      AbstractGraphTest.validateGraph(graph);\n\n      while (graph.nodes().size() < NUM_NODES) {\n        graph.addNode(gen.nextInt(NODE_POOL_SIZE));\n      }\n      ArrayList<Integer> nodeList = new ArrayList<Integer>(graph.nodes());\n      while (graph.edges().size() < NUM_EDGES) {\n        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));\n      }\n      ArrayList<EndpointPair<Integer>> edgeList =\n          new ArrayList<EndpointPair<Integer>>(graph.edges());\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(edgeList, gen);\n      int numEdgesToRemove = gen.nextInt(NUM_EDGES);\n      for (int i = 0; i < numEdgesToRemove; ++i) {\n        EndpointPair<Integer> edge = edgeList.get(i);\n        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      int numNodesToRemove = gen.nextInt(NUM_NODES);\n      for (int i = 0; i < numNodesToRemove; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);\n      \r\n      AbstractGraphTest.validateGraph(graph);\n\n      for (int i = numNodesToRemove; i < NUM_NODES; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty(); \r\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      for (Integer node : nodeList) {\n        assertThat(graph.addNode(node)).isTrue();\n      }\n      Collections.shuffle(edgeList, gen);\n      for (EndpointPair<Integer> edge : edgeList) {\n        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n    }\n  }\n","realPath":"guava-tests/test/com/google/common/graph/GraphMutationTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"NB"}],"commitId":"9b94fb3965c6869b0ac47420958a4bbae0b2d54c","commitMessage":"@@@Begin exporting sources of Guava for Android.\n\npom.xml files to come.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=153757913\n","date":"2017-04-21 10:27:51","modifiedFileCount":"0","status":"M","submitter":"zhenghua"},{"authorTime":"2017-08-18 23:57:56","codes":[{"authorDate":"2017-08-18 23:57:56","commitOrder":3,"curCode":"  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n    Random gen = new Random(42); \r\n\n    for (int trial = 0; trial < NUM_TRIALS; ++trial) {\n      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty();\n      AbstractGraphTest.validateGraph(graph);\n\n      while (graph.nodes().size() < NUM_NODES) {\n        graph.addNode(gen.nextInt(NODE_POOL_SIZE));\n      }\n      ArrayList<Integer> nodeList = new ArrayList<>(graph.nodes());\n      while (graph.edges().size() < NUM_EDGES) {\n        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));\n      }\n      ArrayList<EndpointPair<Integer>> edgeList = new ArrayList<>(graph.edges());\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(edgeList, gen);\n      int numEdgesToRemove = gen.nextInt(NUM_EDGES);\n      for (int i = 0; i < numEdgesToRemove; ++i) {\n        EndpointPair<Integer> edge = edgeList.get(i);\n        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      int numNodesToRemove = gen.nextInt(NUM_NODES);\n      for (int i = 0; i < numNodesToRemove; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);\n      \r\n      AbstractGraphTest.validateGraph(graph);\n\n      for (int i = numNodesToRemove; i < NUM_NODES; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty(); \r\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      for (Integer node : nodeList) {\n        assertThat(graph.addNode(node)).isTrue();\n      }\n      Collections.shuffle(edgeList, gen);\n      for (EndpointPair<Integer> edge : edgeList) {\n        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n    }\n  }\n","date":"2017-08-19 00:17:46","endLine":114,"groupId":"101015","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"testGraphMutation","params":"(GraphBuilder<?superInteger>graphBuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/82/ff96756723b6595e73c9574565877c2fd75270.src","preCode":"  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n    Random gen = new Random(42); \r\n\n    for (int trial = 0; trial < NUM_TRIALS; ++trial) {\n      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty();\n      AbstractGraphTest.validateGraph(graph);\n\n      while (graph.nodes().size() < NUM_NODES) {\n        graph.addNode(gen.nextInt(NODE_POOL_SIZE));\n      }\n      ArrayList<Integer> nodeList = new ArrayList<Integer>(graph.nodes());\n      while (graph.edges().size() < NUM_EDGES) {\n        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));\n      }\n      ArrayList<EndpointPair<Integer>> edgeList =\n          new ArrayList<EndpointPair<Integer>>(graph.edges());\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(edgeList, gen);\n      int numEdgesToRemove = gen.nextInt(NUM_EDGES);\n      for (int i = 0; i < numEdgesToRemove; ++i) {\n        EndpointPair<Integer> edge = edgeList.get(i);\n        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      int numNodesToRemove = gen.nextInt(NUM_NODES);\n      for (int i = 0; i < numNodesToRemove; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);\n      \r\n      AbstractGraphTest.validateGraph(graph);\n\n      for (int i = numNodesToRemove; i < NUM_NODES; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty(); \r\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      for (Integer node : nodeList) {\n        assertThat(graph.addNode(node)).isTrue();\n      }\n      Collections.shuffle(edgeList, gen);\n      for (EndpointPair<Integer> edge : edgeList) {\n        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n    }\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/GraphMutationTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"M"},{"authorDate":"2017-08-18 23:57:56","commitOrder":3,"curCode":"  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n    Random gen = new Random(42); \r\n\n    for (int trial = 0; trial < NUM_TRIALS; ++trial) {\n      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty();\n      AbstractGraphTest.validateGraph(graph);\n\n      while (graph.nodes().size() < NUM_NODES) {\n        graph.addNode(gen.nextInt(NODE_POOL_SIZE));\n      }\n      ArrayList<Integer> nodeList = new ArrayList<>(graph.nodes());\n      while (graph.edges().size() < NUM_EDGES) {\n        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));\n      }\n      ArrayList<EndpointPair<Integer>> edgeList = new ArrayList<>(graph.edges());\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(edgeList, gen);\n      int numEdgesToRemove = gen.nextInt(NUM_EDGES);\n      for (int i = 0; i < numEdgesToRemove; ++i) {\n        EndpointPair<Integer> edge = edgeList.get(i);\n        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      int numNodesToRemove = gen.nextInt(NUM_NODES);\n      for (int i = 0; i < numNodesToRemove; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);\n      \r\n      AbstractGraphTest.validateGraph(graph);\n\n      for (int i = numNodesToRemove; i < NUM_NODES; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty(); \r\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      for (Integer node : nodeList) {\n        assertThat(graph.addNode(node)).isTrue();\n      }\n      Collections.shuffle(edgeList, gen);\n      for (EndpointPair<Integer> edge : edgeList) {\n        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n    }\n  }\n","date":"2017-08-19 00:17:46","endLine":114,"groupId":"101015","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testGraphMutation","params":"(GraphBuilder<?superInteger>graphBuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/82/ff96756723b6595e73c9574565877c2fd75270.src","preCode":"  private static void testGraphMutation(GraphBuilder<? super Integer> graphBuilder) {\n    Random gen = new Random(42); \r\n\n    for (int trial = 0; trial < NUM_TRIALS; ++trial) {\n      MutableGraph<Integer> graph = graphBuilder.allowsSelfLoops(true).build();\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty();\n      AbstractGraphTest.validateGraph(graph);\n\n      while (graph.nodes().size() < NUM_NODES) {\n        graph.addNode(gen.nextInt(NODE_POOL_SIZE));\n      }\n      ArrayList<Integer> nodeList = new ArrayList<Integer>(graph.nodes());\n      while (graph.edges().size() < NUM_EDGES) {\n        graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen));\n      }\n      ArrayList<EndpointPair<Integer>> edgeList =\n          new ArrayList<EndpointPair<Integer>>(graph.edges());\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(edgeList, gen);\n      int numEdgesToRemove = gen.nextInt(NUM_EDGES);\n      for (int i = 0; i < numEdgesToRemove; ++i) {\n        EndpointPair<Integer> edge = edgeList.get(i);\n        assertThat(graph.removeEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES - numEdgesToRemove);\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      int numNodesToRemove = gen.nextInt(NUM_NODES);\n      for (int i = 0; i < numNodesToRemove; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES - numNodesToRemove);\n      \r\n      AbstractGraphTest.validateGraph(graph);\n\n      for (int i = numNodesToRemove; i < NUM_NODES; ++i) {\n        assertThat(graph.removeNode(nodeList.get(i))).isTrue();\n      }\n\n      assertThat(graph.nodes()).isEmpty();\n      assertThat(graph.edges()).isEmpty(); \r\n      AbstractGraphTest.validateGraph(graph);\n\n      Collections.shuffle(nodeList, gen);\n      for (Integer node : nodeList) {\n        assertThat(graph.addNode(node)).isTrue();\n      }\n      Collections.shuffle(edgeList, gen);\n      for (EndpointPair<Integer> edge : edgeList) {\n        assertThat(graph.putEdge(edge.nodeU(), edge.nodeV())).isTrue();\n      }\n\n      assertThat(graph.nodes()).hasSize(NUM_NODES);\n      assertThat(graph.edges()).hasSize(NUM_EDGES);\n      AbstractGraphTest.validateGraph(graph);\n    }\n  }\n","realPath":"guava-tests/test/com/google/common/graph/GraphMutationTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":49,"status":"M"}],"commitId":"16f262fbde011c89d770472540c33bdb4588371b","commitMessage":"@@@Use diamond operator for all test targets except 'collect'\n\n[]\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=165710863\n","date":"2017-08-19 00:17:46","modifiedFileCount":"64","status":"M","submitter":"jijiang"}]
