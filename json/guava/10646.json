[{"authorTime":"2017-05-23 00:56:43","codes":[{"authorDate":"2017-05-23 00:56:43","commitOrder":12,"curCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","date":"2017-05-23 01:39:27","endLine":289,"groupId":"8785","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"validateNetwork","params":"(Network<N@E>network)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/d7/7a73837184b10b6871bfe92e4a01468993188b.src","preCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/AbstractNetworkTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"MB"},{"authorDate":"2017-05-23 00:56:43","commitOrder":12,"curCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","date":"2017-05-23 01:39:27","endLine":289,"groupId":"8785","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"validateNetwork","params":"(Network<N@E>network)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/d7/7a73837184b10b6871bfe92e4a01468993188b.src","preCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","realPath":"guava-tests/test/com/google/common/graph/AbstractNetworkTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"MB"}],"commitId":"bc996973fe6ce1ecb67803aa1ff5bdf5df59d182","commitMessage":"@@@common.graph classes: mark types and methods as @GoogleInternal that are not yet ready for release in Guava 22.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=156749408\n","date":"2017-05-23 01:39:27","modifiedFileCount":"24","status":"M","submitter":"jrtom"},{"authorTime":"2017-06-22 05:57:06","codes":[{"authorDate":"2017-06-22 05:57:06","commitOrder":13,"curCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n        switch (edgesConnecting.size()) {\n            case 0:\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull();\n              break;\n            case 1:\n              assertThat(network.edgeConnectingOrNull(node, otherNode))\n                  .isEqualTo(edgesConnecting.iterator().next());\n              break;\n            default:\n              try {\n                network.edgeConnectingOrNull(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n        }\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","date":"2017-06-23 00:09:26","endLine":303,"groupId":"2657","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"validateNetwork","params":"(Network<N@E>network)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/53/4e6a94ca242b2351f8d19b4ec9c3eb8ea4d83d.src","preCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/AbstractNetworkTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"M"},{"authorDate":"2017-06-22 05:57:06","commitOrder":13,"curCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n        switch (edgesConnecting.size()) {\n            case 0:\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull();\n              assertThat(network.edgeConnecting(node, otherNode).isPresent()).isFalse();\n              break;\n            case 1:\n              E edge = edgesConnecting.iterator().next();\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isEqualTo(edge);\n              assertThat(network.edgeConnecting(node, otherNode).get()).isEqualTo(edge);\n              break;\n            default:\n              try {\n                network.edgeConnectingOrNull(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n              try {\n                network.edgeConnecting(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n        }\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","date":"2017-06-23 00:09:26","endLine":309,"groupId":"5742","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"validateNetwork","params":"(Network<N@E>network)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/cb/80092fbb58a94628326c01d2f2ce342c3fa11c.src","preCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","realPath":"guava-tests/test/com/google/common/graph/AbstractNetworkTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":144,"status":"M"}],"commitId":"240a807d3d1cbcad99481ede9530af0cdfadf47c","commitMessage":"@@@Network.java: fork edgeConnecting() for java7/Android:\n* current/.../Network.java now provides\n  java.util.Optional<E> edgeConnecting(N.  N)\n  E edgeConnectingOrNull(N.  N)\n* java7/.../Network.java now provides\n  E edgeConnectingOrNull(N.  N)\n\nNeither current/ nor java7/ use common.base.Optional in external APIs any more.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=159748595\n","date":"2017-06-23 00:09:26","modifiedFileCount":"10","status":"M","submitter":"jrtom"},{"authorTime":"2017-06-29 06:00:12","codes":[{"authorDate":"2017-06-29 06:00:12","commitOrder":14,"curCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n        switch (edgesConnecting.size()) {\n            case 0:\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull();\n              assertThat(network.hasEdgeConnecting(node, otherNode)).isFalse();\n              break;\n            case 1:\n              assertThat(network.edgeConnectingOrNull(node, otherNode))\n                  .isEqualTo(edgesConnecting.iterator().next());\n              assertThat(network.hasEdgeConnecting(node, otherNode)).isTrue();\n              break;\n            default:\n              assertThat(network.hasEdgeConnecting(node, otherNode)).isTrue();\n              try {\n                network.edgeConnectingOrNull(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n        }\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","date":"2017-06-29 11:36:54","endLine":304,"groupId":"10646","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"validateNetwork","params":"(Network<N@E>network)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/d7/2119dc2c77d2fc967766885155d540e31b191f.src","preCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n        switch (edgesConnecting.size()) {\n            case 0:\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull();\n              break;\n            case 1:\n              assertThat(network.edgeConnectingOrNull(node, otherNode))\n                  .isEqualTo(edgesConnecting.iterator().next());\n              break;\n            default:\n              try {\n                network.edgeConnectingOrNull(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n        }\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","realPath":"android/guava-tests/test/com/google/common/graph/AbstractNetworkTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"},{"authorDate":"2017-06-29 06:00:12","commitOrder":14,"curCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n        switch (edgesConnecting.size()) {\n            case 0:\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull();\n              assertThat(network.edgeConnecting(node, otherNode).isPresent()).isFalse();\n              assertThat(network.hasEdgeConnecting(node, otherNode)).isFalse();\n              break;\n            case 1:\n              E edge = edgesConnecting.iterator().next();\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isEqualTo(edge);\n              assertThat(network.edgeConnecting(node, otherNode).get()).isEqualTo(edge);\n              assertThat(network.hasEdgeConnecting(node, otherNode)).isTrue();\n              break;\n            default:\n              assertThat(network.hasEdgeConnecting(node, otherNode)).isTrue();\n              try {\n                network.edgeConnectingOrNull(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n              try {\n                network.edgeConnecting(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n        }\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","date":"2017-06-29 11:36:54","endLine":310,"groupId":"10646","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"validateNetwork","params":"(Network<N@E>network)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-guava-10-0.7/blobInfo/CC_OUT/blobs/6d/c3de7218b256e5b629ab039187135ced0e5d39.src","preCode":"  static <N, E> void validateNetwork(Network<N, E> network) {\n    assertStronglyEquivalent(network, Graphs.copyOf(network));\n    assertStronglyEquivalent(network, ImmutableNetwork.copyOf(network));\n\n    String networkString = network.toString();\n    assertThat(networkString).contains(\"isDirected: \" + network.isDirected());\n    assertThat(networkString).contains(\"allowsParallelEdges: \" + network.allowsParallelEdges());\n    assertThat(networkString).contains(\"allowsSelfLoops: \" + network.allowsSelfLoops());\n\n    int nodeStart = networkString.indexOf(\"nodes:\");\n    int edgeStart = networkString.indexOf(\"edges:\");\n    String nodeString = networkString.substring(nodeStart, edgeStart);\n    String edgeString = networkString.substring(edgeStart);\n\n    Graph<N> asGraph = network.asGraph();\n    AbstractGraphTest.validateGraph(asGraph);\n    assertThat(network.nodes()).isEqualTo(asGraph.nodes());\n    assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());\n    assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());\n    assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());\n    assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n\n    for (E edge : sanityCheckSet(network.edges())) {\n      \r\n      assertThat(edgeString).contains(edge.toString());\n\n      EndpointPair<N> endpointPair = network.incidentNodes(edge);\n      N nodeU = endpointPair.nodeU();\n      N nodeV = endpointPair.nodeV();\n      assertThat(asGraph.edges()).contains(EndpointPair.of(network, nodeU, nodeV));\n      assertThat(network.edgesConnecting(nodeU, nodeV)).contains(edge);\n      assertThat(network.successors(nodeU)).contains(nodeV);\n      assertThat(network.adjacentNodes(nodeU)).contains(nodeV);\n      assertThat(network.outEdges(nodeU)).contains(edge);\n      assertThat(network.incidentEdges(nodeU)).contains(edge);\n      assertThat(network.predecessors(nodeV)).contains(nodeU);\n      assertThat(network.adjacentNodes(nodeV)).contains(nodeU);\n      assertThat(network.inEdges(nodeV)).contains(edge);\n      assertThat(network.incidentEdges(nodeV)).contains(edge);\n\n      for (N incidentNode : network.incidentNodes(edge)) {\n        assertThat(network.nodes()).contains(incidentNode);\n        for (E adjacentEdge : network.incidentEdges(incidentNode)) {\n          assertTrue(\n              edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));\n        }\n      }\n    }\n\n    for (N node : sanityCheckSet(network.nodes())) {\n      assertThat(nodeString).contains(node.toString());\n\n      assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n      assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));\n      assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));\n\n      int selfLoopCount = network.edgesConnecting(node, node).size();\n      assertThat(network.incidentEdges(node).size() + selfLoopCount)\n          .isEqualTo(network.degree(node));\n\n      if (network.isDirected()) {\n        assertThat(network.incidentEdges(node).size() + selfLoopCount)\n            .isEqualTo(network.inDegree(node) + network.outDegree(node));\n        assertThat(network.inEdges(node)).hasSize(network.inDegree(node));\n        assertThat(network.outEdges(node)).hasSize(network.outDegree(node));\n      } else {\n        assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));\n        assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));\n        assertThat(network.inDegree(node)).isEqualTo(network.degree(node));\n        assertThat(network.outDegree(node)).isEqualTo(network.degree(node));\n      }\n\n      for (N otherNode : network.nodes()) {\n        Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));\n        switch (edgesConnecting.size()) {\n            case 0:\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull();\n              assertThat(network.edgeConnecting(node, otherNode).isPresent()).isFalse();\n              break;\n            case 1:\n              E edge = edgesConnecting.iterator().next();\n              assertThat(network.edgeConnectingOrNull(node, otherNode)).isEqualTo(edge);\n              assertThat(network.edgeConnecting(node, otherNode).get()).isEqualTo(edge);\n              break;\n            default:\n              try {\n                network.edgeConnectingOrNull(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n              try {\n                network.edgeConnecting(node, otherNode);\n                fail();\n              } catch (IllegalArgumentException expected) {}\n        }\n\n        boolean isSelfLoop = node.equals(otherNode);\n        boolean connected = !edgesConnecting.isEmpty();\n        if (network.isDirected() || !isSelfLoop) {\n          assertThat(edgesConnecting)\n              .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));\n        }\n        if (!network.allowsParallelEdges()) {\n          assertThat(edgesConnecting.size()).isAtMost(1);\n        }\n        if (!network.allowsSelfLoops() && isSelfLoop) {\n          assertThat(connected).isFalse();\n        }\n\n        assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);\n        assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);\n        for (E edge : edgesConnecting) {\n          assertThat(network.incidentNodes(edge))\n              .isEqualTo(EndpointPair.of(network, node, otherNode));\n          assertThat(network.outEdges(node)).contains(edge);\n          assertThat(network.inEdges(otherNode)).contains(edge);\n        }\n      }\n\n      for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {\n        assertTrue(\n            network.predecessors(node).contains(adjacentNode)\n                || network.successors(node).contains(adjacentNode));\n        assertTrue(\n            !network.edgesConnecting(node, adjacentNode).isEmpty()\n                || !network.edgesConnecting(adjacentNode, node).isEmpty());\n      }\n\n      for (N predecessor : sanityCheckSet(network.predecessors(node))) {\n        assertThat(network.successors(predecessor)).contains(node);\n        assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();\n      }\n\n      for (N successor : sanityCheckSet(network.successors(node))) {\n        assertThat(network.predecessors(successor)).contains(node);\n        assertThat(network.edgesConnecting(node, successor)).isNotEmpty();\n      }\n\n      for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {\n        assertTrue(\n            network.inEdges(node).contains(incidentEdge)\n                || network.outEdges(node).contains(incidentEdge));\n        assertThat(network.edges()).contains(incidentEdge);\n        assertThat(network.incidentNodes(incidentEdge)).contains(node);\n      }\n\n      for (E inEdge : sanityCheckSet(network.inEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(inEdge);\n        assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))\n            .contains(inEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);\n        }\n      }\n\n      for (E outEdge : sanityCheckSet(network.outEdges(node))) {\n        assertThat(network.incidentEdges(node)).contains(outEdge);\n        assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))\n            .contains(outEdge);\n        if (network.isDirected()) {\n          assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);\n        }\n      }\n    }\n  }\n","realPath":"guava-tests/test/com/google/common/graph/AbstractNetworkTest.java","repoName":"guava","snippetEndLine":0,"snippetStartLine":0,"startLine":142,"status":"M"}],"commitId":"49e145257d6dfb36ca1dd17a144d81c635504b9e","commitMessage":"@@@hasEdge(): rename to hasEdgeConnecting().  remove @GoogleInternal annotation.  and add to Network as well.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=160455853\n","date":"2017-06-29 11:36:54","modifiedFileCount":"22","status":"M","submitter":"jrtom"}]
