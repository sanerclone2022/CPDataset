[{"authorTime":"2017-11-16 01:00:23","codes":[{"authorDate":"2019-11-20 22:28:02","commitOrder":3,"curCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    List<byte[]> sideInputsValues =\n        (List<byte[]>) broadcastStateData.getBroadcastValue(tag.getId()).getValue();\n    Coder<?> coder = broadcastStateData.getCoder(tag.getId());\n\n    List<WindowedValue<?>> decodedValues = new ArrayList<>();\n    for (byte[] value : sideInputsValues) {\n      decodedValues.add((WindowedValue<?>) CoderHelpers.fromByteArray(value, coder));\n    }\n\n    Map<BoundedWindow, T> sideInputs = initializeBroadcastVariable(decodedValues, view);\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<Materializations.MultimapView, T> viewFn =\n          (ViewFn<Materializations.MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(EMPTY_MULTIMAP_VIEW);\n    }\n    return result;\n  }\n","date":"2019-11-20 22:28:02","endLine":98,"groupId":"7225","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"get","params":"(PCollectionView<T>view@BoundedWindowwindow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-beam-10-0.7/blobInfo/CC_OUT/blobs/5d/49767fc591f942b58288b3ac29fb77f5238ca8.src","preCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    List<byte[]> sideInputsValues =\n        (List<byte[]>) broadcastStateData.getBroadcastValue(tag.getId()).getValue();\n    Coder<?> coder = broadcastStateData.getCoder(tag.getId());\n\n    List<WindowedValue<?>> decodedValues = new ArrayList<>();\n    for (byte[] value : sideInputsValues) {\n      decodedValues.add((WindowedValue<?>) CoderHelpers.fromByteArray(value, coder));\n    }\n\n    Map<BoundedWindow, T> sideInputs = initializeBroadcastVariable(decodedValues, view);\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<Materializations.MultimapView, T> viewFn =\n          (ViewFn<Materializations.MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(EMPTY_MULTIMAP_VIEW);\n    }\n    return result;\n  }\n","realPath":"runners/spark/src/main/java/org/apache/beam/runners/spark/structuredstreaming/translation/batch/functions/SparkSideInputReader.java","repoName":"beam","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"B"},{"authorDate":"2017-11-16 01:00:23","commitOrder":3,"curCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(\n        sideInputs.get(tag),\n        \"Side input for \" + view + \" not available.\");\n\n    Map<BoundedWindow, T> sideInputs =\n        runtimeContext.getBroadcastVariableWithInitializer(\n            tag.getId(), new SideInputInitializer<>(view));\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(EMPTY_MULTMAP_VIEW);\n    }\n    return result;\n  }\n","date":"2017-11-16 01:00:23","endLine":90,"groupId":"10158","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"get","params":"(PCollectionView<T>view@BoundedWindowwindow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-beam-10-0.7/blobInfo/CC_OUT/blobs/fb/3f375fdd91b84ec59021dc9b6602c057e65da6.src","preCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(\n        sideInputs.get(tag),\n        \"Side input for \" + view + \" not available.\");\n\n    Map<BoundedWindow, T> sideInputs =\n        runtimeContext.getBroadcastVariableWithInitializer(\n            tag.getId(), new SideInputInitializer<>(view));\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(EMPTY_MULTMAP_VIEW);\n    }\n    return result;\n  }\n","realPath":"runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkSideInputReader.java","repoName":"beam","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"NB"}],"commitId":"18059eecad850b6e30bc7e376e70937915dd11fb","commitMessage":"@@@Merge pull request #9866: [BEAM-8470] Create a new Spark runner based on Spark Structured streaming framework\n\n","date":"2019-11-20 22:28:02","modifiedFileCount":"3","status":"M","submitter":"Alexey Romanenko"},{"authorTime":"2019-11-21 03:25:16","codes":[{"authorDate":"2019-11-20 22:28:02","commitOrder":4,"curCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    List<byte[]> sideInputsValues =\n        (List<byte[]>) broadcastStateData.getBroadcastValue(tag.getId()).getValue();\n    Coder<?> coder = broadcastStateData.getCoder(tag.getId());\n\n    List<WindowedValue<?>> decodedValues = new ArrayList<>();\n    for (byte[] value : sideInputsValues) {\n      decodedValues.add((WindowedValue<?>) CoderHelpers.fromByteArray(value, coder));\n    }\n\n    Map<BoundedWindow, T> sideInputs = initializeBroadcastVariable(decodedValues, view);\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<Materializations.MultimapView, T> viewFn =\n          (ViewFn<Materializations.MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(EMPTY_MULTIMAP_VIEW);\n    }\n    return result;\n  }\n","date":"2019-11-20 22:28:02","endLine":98,"groupId":"7225","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"get","params":"(PCollectionView<T>view@BoundedWindowwindow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-beam-10-0.7/blobInfo/CC_OUT/blobs/5d/49767fc591f942b58288b3ac29fb77f5238ca8.src","preCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    List<byte[]> sideInputsValues =\n        (List<byte[]>) broadcastStateData.getBroadcastValue(tag.getId()).getValue();\n    Coder<?> coder = broadcastStateData.getCoder(tag.getId());\n\n    List<WindowedValue<?>> decodedValues = new ArrayList<>();\n    for (byte[] value : sideInputsValues) {\n      decodedValues.add((WindowedValue<?>) CoderHelpers.fromByteArray(value, coder));\n    }\n\n    Map<BoundedWindow, T> sideInputs = initializeBroadcastVariable(decodedValues, view);\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<Materializations.MultimapView, T> viewFn =\n          (ViewFn<Materializations.MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(EMPTY_MULTIMAP_VIEW);\n    }\n    return result;\n  }\n","realPath":"runners/spark/src/main/java/org/apache/beam/runners/spark/structuredstreaming/translation/batch/functions/SparkSideInputReader.java","repoName":"beam","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"N"},{"authorDate":"2019-11-21 03:25:16","commitOrder":4,"curCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    Map<BoundedWindow, T> sideInputs =\n        runtimeContext.getBroadcastVariableWithInitializer(\n            tag.getId(), new SideInputInitializer<>(view));\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(InMemoryMultimapSideInputView.empty());\n    }\n    return result;\n  }\n","date":"2019-11-21 03:25:16","endLine":78,"groupId":"10158","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"get","params":"(PCollectionView<T>view@BoundedWindowwindow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-beam-10-0.7/blobInfo/CC_OUT/blobs/34/530c36e472e797c20ff75a236f82e5e43f4c37.src","preCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    Map<BoundedWindow, T> sideInputs =\n        runtimeContext.getBroadcastVariableWithInitializer(\n            tag.getId(), new SideInputInitializer<>(view));\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(EMPTY_MULTMAP_VIEW);\n    }\n    return result;\n  }\n","realPath":"runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkSideInputReader.java","repoName":"beam","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"}],"commitId":"940757816402f198404e3c26c110a6d0e7c81f47","commitMessage":"@@@[BEAM-3419] Flesh out iterable side inputs and key enumeration for multimaps in shared libraries (#10147)\n\nThis now removed the byte[] that was used as the key and exposed the SDKs coder specifically using the structural value for comparison.\n\nUpdate portable Python to use the iterable state key. Note that this doesn't effect Dataflow since dataflow_runner.py converts all iterable side inputs into multimap right now and no SDK performs key enumeration yet.\n\nUpdate both Flink and Spark to support iterable API and also key enumeration for multimaps. To minimize the extent of this change.  I did the minimal modification for Dataflow. A follow-up PR will do the same for Dataflow and then enable multimap side input key enumeration and iterable lookup within various SDKs.","date":"2019-11-21 03:25:16","modifiedFileCount":"19","status":"M","submitter":"Lukasz Cwik"},{"authorTime":"2020-06-18 04:27:46","codes":[{"authorDate":"2020-06-18 04:27:46","commitOrder":5,"curCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    List<byte[]> sideInputsValues =\n        (List<byte[]>) broadcastStateData.getBroadcastValue(tag.getId()).getValue();\n    Coder<?> coder = broadcastStateData.getCoder(tag.getId());\n\n    List<WindowedValue<?>> decodedValues = new ArrayList<>();\n    for (byte[] value : sideInputsValues) {\n      decodedValues.add((WindowedValue<?>) CoderHelpers.fromByteArray(value, coder));\n    }\n\n    Map<BoundedWindow, T> sideInputs = initializeBroadcastVariable(decodedValues, view);\n    T result = sideInputs.get(window);\n    if (result == null) {\n      switch (view.getViewFn().getMaterialization().getUrn()) {\n        case Materializations.ITERABLE_MATERIALIZATION_URN:\n          {\n            ViewFn<IterableView, T> viewFn = (ViewFn<IterableView, T>) view.getViewFn();\n            return viewFn.apply(() -> Collections.emptyList());\n          }\n        case Materializations.MULTIMAP_MATERIALIZATION_URN:\n          {\n            ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n            return viewFn.apply(InMemoryMultimapSideInputView.empty());\n          }\n        default:\n          throw new IllegalStateException(\n              String.format(\n                  \"Unknown side input materialization format requested '%s'\",\n                  view.getViewFn().getMaterialization().getUrn()));\n      }\n    }\n    return result;\n  }\n","date":"2020-06-18 04:27:46","endLine":115,"groupId":"7225","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"get","params":"(PCollectionView<T>view@BoundedWindowwindow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-beam-10-0.7/blobInfo/CC_OUT/blobs/56/e3ee81e757a2d730d7e5e2550de2a6a4444cd0.src","preCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    List<byte[]> sideInputsValues =\n        (List<byte[]>) broadcastStateData.getBroadcastValue(tag.getId()).getValue();\n    Coder<?> coder = broadcastStateData.getCoder(tag.getId());\n\n    List<WindowedValue<?>> decodedValues = new ArrayList<>();\n    for (byte[] value : sideInputsValues) {\n      decodedValues.add((WindowedValue<?>) CoderHelpers.fromByteArray(value, coder));\n    }\n\n    Map<BoundedWindow, T> sideInputs = initializeBroadcastVariable(decodedValues, view);\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<Materializations.MultimapView, T> viewFn =\n          (ViewFn<Materializations.MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(EMPTY_MULTIMAP_VIEW);\n    }\n    return result;\n  }\n","realPath":"runners/spark/src/main/java/org/apache/beam/runners/spark/structuredstreaming/translation/batch/functions/SparkSideInputReader.java","repoName":"beam","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2020-06-18 04:27:46","commitOrder":5,"curCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    Map<BoundedWindow, T> sideInputs =\n        runtimeContext.getBroadcastVariableWithInitializer(\n            tag.getId(), new SideInputInitializer<>(view));\n    T result = sideInputs.get(window);\n    if (result == null) {\n      switch (view.getViewFn().getMaterialization().getUrn()) {\n        case Materializations.ITERABLE_MATERIALIZATION_URN:\n          {\n            ViewFn<IterableView, T> viewFn = (ViewFn<IterableView, T>) view.getViewFn();\n            return viewFn.apply(() -> Collections.emptyList());\n          }\n        case Materializations.MULTIMAP_MATERIALIZATION_URN:\n          {\n            ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n            return viewFn.apply(InMemoryMultimapSideInputView.empty());\n          }\n        default:\n          throw new IllegalStateException(\n              String.format(\n                  \"Unknown side input materialization format requested '%s'\",\n                  view.getViewFn().getMaterialization().getUrn()));\n      }\n    }\n    return result;\n  }\n","date":"2020-06-18 04:27:46","endLine":101,"groupId":"7225","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"get","params":"(PCollectionView<T>view@BoundedWindowwindow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-beam-10-0.7/blobInfo/CC_OUT/blobs/b1/2bcf998701163a14a0dd7c3af1f46de3b3c31f.src","preCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    Map<BoundedWindow, T> sideInputs =\n        runtimeContext.getBroadcastVariableWithInitializer(\n            tag.getId(), new SideInputInitializer<>(view));\n    T result = sideInputs.get(window);\n    if (result == null) {\n      ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n      result = viewFn.apply(InMemoryMultimapSideInputView.empty());\n    }\n    return result;\n  }\n","realPath":"runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkSideInputReader.java","repoName":"beam","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"}],"commitId":"d1c6ef6c9803536dddc67e064e6da53c04ce0f60","commitMessage":"@@@[BEAM-10097.  BEAM-5982.  BEAM-3080] Use primitive views directly instead of transforming KV<Void.  Iterable<T>> to the view type via a naive mapping. (#11821)\n\n* [BEAM-10097.  BEAM-5982.  BEAM-3080] Use primitive views directly instead of transforming KV<Void.  Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable runners since the new expansion is guarded by the experiment \"beam_fn_api\".\nThis currently has little benefit for portable runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions.\nThe singleton and iterable views can't be translated except if using the Dataflow runner v2 experiment since runner v1 doesn't support the iterable access pattern.\n\n* fixup! Fix test after rebase on master","date":"2020-06-18 04:27:46","modifiedFileCount":"29","status":"M","submitter":"Lukasz Cwik"},{"authorTime":"2020-10-25 06:13:33","codes":[{"authorDate":"2020-10-25 06:13:33","commitOrder":6,"curCode":"  public <T> @Nullable T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    List<byte[]> sideInputsValues =\n        (List<byte[]>) broadcastStateData.getBroadcastValue(tag.getId()).getValue();\n    Coder<?> coder = broadcastStateData.getCoder(tag.getId());\n\n    List<WindowedValue<?>> decodedValues = new ArrayList<>();\n    for (byte[] value : sideInputsValues) {\n      decodedValues.add((WindowedValue<?>) CoderHelpers.fromByteArray(value, coder));\n    }\n\n    Map<BoundedWindow, T> sideInputs = initializeBroadcastVariable(decodedValues, view);\n    T result = sideInputs.get(window);\n    if (result == null) {\n      switch (view.getViewFn().getMaterialization().getUrn()) {\n        case Materializations.ITERABLE_MATERIALIZATION_URN:\n          {\n            ViewFn<IterableView, T> viewFn = (ViewFn<IterableView, T>) view.getViewFn();\n            return viewFn.apply(() -> Collections.emptyList());\n          }\n        case Materializations.MULTIMAP_MATERIALIZATION_URN:\n          {\n            ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n            return viewFn.apply(InMemoryMultimapSideInputView.empty());\n          }\n        default:\n          throw new IllegalStateException(\n              String.format(\n                  \"Unknown side input materialization format requested '%s'\",\n                  view.getViewFn().getMaterialization().getUrn()));\n      }\n    }\n    return result;\n  }\n","date":"2020-10-25 06:13:33","endLine":115,"groupId":"10139","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"get","params":"(PCollectionView<T>view@BoundedWindowwindow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-beam-10-0.7/blobInfo/CC_OUT/blobs/e2/1676fd4327c4124b094d7f235355d74e0c44cc.src","preCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    List<byte[]> sideInputsValues =\n        (List<byte[]>) broadcastStateData.getBroadcastValue(tag.getId()).getValue();\n    Coder<?> coder = broadcastStateData.getCoder(tag.getId());\n\n    List<WindowedValue<?>> decodedValues = new ArrayList<>();\n    for (byte[] value : sideInputsValues) {\n      decodedValues.add((WindowedValue<?>) CoderHelpers.fromByteArray(value, coder));\n    }\n\n    Map<BoundedWindow, T> sideInputs = initializeBroadcastVariable(decodedValues, view);\n    T result = sideInputs.get(window);\n    if (result == null) {\n      switch (view.getViewFn().getMaterialization().getUrn()) {\n        case Materializations.ITERABLE_MATERIALIZATION_URN:\n          {\n            ViewFn<IterableView, T> viewFn = (ViewFn<IterableView, T>) view.getViewFn();\n            return viewFn.apply(() -> Collections.emptyList());\n          }\n        case Materializations.MULTIMAP_MATERIALIZATION_URN:\n          {\n            ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n            return viewFn.apply(InMemoryMultimapSideInputView.empty());\n          }\n        default:\n          throw new IllegalStateException(\n              String.format(\n                  \"Unknown side input materialization format requested '%s'\",\n                  view.getViewFn().getMaterialization().getUrn()));\n      }\n    }\n    return result;\n  }\n","realPath":"runners/spark/src/main/java/org/apache/beam/runners/spark/structuredstreaming/translation/batch/functions/SparkSideInputReader.java","repoName":"beam","snippetEndLine":0,"snippetStartLine":0,"startLine":79,"status":"M"},{"authorDate":"2020-10-25 06:13:33","commitOrder":6,"curCode":"  public <T> @Nullable T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    Map<BoundedWindow, T> sideInputs =\n        runtimeContext.getBroadcastVariableWithInitializer(\n            tag.getId(), new SideInputInitializer<>(view));\n    T result = sideInputs.get(window);\n    if (result == null) {\n      switch (view.getViewFn().getMaterialization().getUrn()) {\n        case Materializations.ITERABLE_MATERIALIZATION_URN:\n          {\n            ViewFn<IterableView, T> viewFn = (ViewFn<IterableView, T>) view.getViewFn();\n            return viewFn.apply(() -> Collections.emptyList());\n          }\n        case Materializations.MULTIMAP_MATERIALIZATION_URN:\n          {\n            ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n            return viewFn.apply(InMemoryMultimapSideInputView.empty());\n          }\n        default:\n          throw new IllegalStateException(\n              String.format(\n                  \"Unknown side input materialization format requested '%s'\",\n                  view.getViewFn().getMaterialization().getUrn()));\n      }\n    }\n    return result;\n  }\n","date":"2020-10-25 06:13:33","endLine":100,"groupId":"10139","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"get","params":"(PCollectionView<T>view@BoundedWindowwindow)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-beam-10-0.7/blobInfo/CC_OUT/blobs/2f/acde364173591440cdd69b79907f9c24bd68a3.src","preCode":"  public <T> T get(PCollectionView<T> view, BoundedWindow window) {\n    checkNotNull(view, \"View passed to sideInput cannot be null\");\n    TupleTag<?> tag = view.getTagInternal();\n    checkNotNull(sideInputs.get(tag), \"Side input for \" + view + \" not available.\");\n\n    Map<BoundedWindow, T> sideInputs =\n        runtimeContext.getBroadcastVariableWithInitializer(\n            tag.getId(), new SideInputInitializer<>(view));\n    T result = sideInputs.get(window);\n    if (result == null) {\n      switch (view.getViewFn().getMaterialization().getUrn()) {\n        case Materializations.ITERABLE_MATERIALIZATION_URN:\n          {\n            ViewFn<IterableView, T> viewFn = (ViewFn<IterableView, T>) view.getViewFn();\n            return viewFn.apply(() -> Collections.emptyList());\n          }\n        case Materializations.MULTIMAP_MATERIALIZATION_URN:\n          {\n            ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n            return viewFn.apply(InMemoryMultimapSideInputView.empty());\n          }\n        default:\n          throw new IllegalStateException(\n              String.format(\n                  \"Unknown side input materialization format requested '%s'\",\n                  view.getViewFn().getMaterialization().getUrn()));\n      }\n    }\n    return result;\n  }\n","realPath":"runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkSideInputReader.java","repoName":"beam","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"}],"commitId":"aca9099acca969dc217ab183782e5270347cd354","commitMessage":"@@@Merge pull request #13192: [BEAM-10402] Move @Nullable annotations adjacent to the type they annotate\n\n","date":"2020-10-25 06:13:33","modifiedFileCount":"76","status":"M","submitter":"Kenn Knowles"}]
