[{"authorTime":"2019-11-29 21:49:13","codes":[{"authorDate":"2019-11-29 21:49:13","commitOrder":5,"curCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            \r\n            \r\n            \r\n            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableAddress(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","date":"2019-11-29 21:49:13","endLine":699,"groupId":"4736","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"connectOne","params":"(longsid@MultipleAddresseselectionAddr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/55/c1dc271396f0e18923af80d2d3124dcd23d95f.src","preCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            \r\n            \r\n            \r\n            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableAddress(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":637,"status":"B"},{"authorDate":"2019-11-29 21:49:13","commitOrder":5,"curCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            \r\n            \r\n            \r\n            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","date":"2019-11-29 21:49:13","endLine":742,"groupId":"4736","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"connectOne","params":"(longsid)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/55/c1dc271396f0e18923af80d2d3124dcd23d95f.src","preCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            \r\n            \r\n            \r\n            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":706,"status":"MB"}],"commitId":"815c8f2130b8b43e11abe52b226707f707a93581","commitMessage":"@@@ZOOKEEPER-3188: Improve resilience to network\n\nThis PR is the rebase of the [previous pull request](https://github.com/apache/zookeeper/pull/730).  so all the kudos should go to the original authors...\n\nIn [ZOOKEEPER-3188](https://issues.apache.org/jira/browse/ZOOKEEPER-3188) we add ability to specify several addresses for quorum operations. Also added reconnection attempts if connection to leader lost.\n\nIn this PR I rebased the changes on the current master.  resolving some minor conflicts with:\n- [ZOOKEEPER-3296](https://issues.apache.org/jira/browse/ZOOKEEPER-3296): Explicitly closing the sslsocket when it failed handshake to prevent issue where peers cannot join quorum\n- [ZOOKEEPER-3320](https://issues.apache.org/jira/browse/ZOOKEEPER-3320): Leader election port stop listen when hostname unresolvable for some time\n- [ZOOKEEPER-3385](https://issues.apache.org/jira/browse/ZOOKEEPER-3385): Add admin command to display leader\n- [ZOOKEEPER-3386](https://issues.apache.org/jira/browse/ZOOKEEPER-3386): Add admin command to display voting view\n- [ZOOKEEPER-3398](https://issues.apache.org/jira/browse/ZOOKEEPER-3398): Learner.connectToLeader() may take too long to time-out\n\nI still want to test the feature manually (e.g. using docker containers with multiple virtual networks / interfaces). The steps to the manual test could be recorded in the [google docs](https://docs.google.com/document/d/1iGVwxeHp57qogwfdodCh9b32P2_kOQaJZ2GDo7j36fI/edit?usp=sharing) as well.\n\nAlso I think we could add a few more unit tests where we are using multiple addresses. The current tests are using a single address only.\n\nAlso the Zookeeper documentation needs to be changed (e.g. by a follow-up Jira?) to promote the new feature and the new config format (possibly including also the admin command documentation in relation with [ZOOKEEPER-3386](https://issues.apache.org/jira/browse/ZOOKEEPER-3386) and [ZOOKEEPER-3461](https://issues.apache.org/jira/browse/ZOOKEEPER-3461))\n\nAuthor: Mate Szalay-Beko <szalay.beko.mate@gmail.com>\nAuthor: Mate Szalay-Beko <mszalay@cloudera.com>\n\nReviewers: eolivelli@apache.org.  andor@apache.org\n\nCloses #1048 from symat/ZOOKEEPER-3188 and squashes the following commits:\n\n3c6fc52d7 [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\n356882d46 [Mate Szalay-Beko] ZOOKEEPER-3188: document new configuration format for using multiple addresses\n45b6c0fdb [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\n4b6bcea48 [Mate Szalay-Beko] ZOOKEEPER-3188: MultiAddress unit tests for Quorum TLS and Kerberos/Digest authentication\n40bc44c23 [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\nf875f5c67 [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\n31805e79b [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\n0f95678ca [Mate Szalay-Beko] ZOOKEEPER-3188: skip unreachable addresses when Learner connects to Leader\ne232c55da [Mate Szalay-Beko] ZOOKEEPER-3188: fix flaky unit MultiAddress unit test\ne892d8d8e [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\n6f2ab755f [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\n2eedf2687 [Mate Szalay-Beko] ZOOKEEPER-3188: fix PR commits; handle case when Leader can not bind to port on startup\n483d2fc9c [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\na5d6bcb97 [Mate Szalay-Beko] ZOOKEEPER-3188: support for dynamic reconfig + add more unit tests\ned31d2ce9 [Mate Szalay-Beko] ZOOKEEPER-3188: better shutdown for executors (following PR comments)\n8713a5bbf [Mate Szalay-Beko] ZOOKEEPER-3188: add fixes for PR comments\n05eae83c0 [Mate Szalay-Beko] Merge remote-tracking branch 'apache/master' into ZOOKEEPER-3188\ne823af4b1 [Mate Szalay-Beko] Merge remote-tracking branch 'origin/master' into ZOOKEEPER-3188\nde7bad2a6 [Mate Szalay-Beko] Merge remote-tracking branch 'origin/master' into ZOOKEEPER-3188\nda98a8da6 [Mate Szalay-Beko] ZOOKEEPER-3188: fix JDK-13 warning\n5bd1f4e2c [Mate Szalay-Beko] ZOOKEEPER-3188: supress spotbugs warning\n42a52a688 [Mate Szalay-Beko] ZOOKEEPER-3188: improve based on code review comments\n6c4220a0d [Mate Szalay-Beko] ZOOKEEPER-3188: fix SendWorker.asyncValidateIfSocketIsStillReachable\n5b22432c1 [Mate Szalay-Beko] ZOOKEEPER-3188: fix LeaderElection to work with multiple election addresses\n7bfbe7e5c [Mate Szalay-Beko] ZOOKEEPER-3188: Improve resilience to network\n","date":"2019-11-29 21:49:13","modifiedFileCount":"26","status":"M","submitter":"Mate Szalay-Beko"},{"authorTime":"2020-01-23 20:43:39","codes":[{"authorDate":"2020-01-23 20:43:39","commitOrder":6,"curCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","date":"2020-01-23 20:43:52","endLine":703,"groupId":"4736","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"connectOne","params":"(longsid@MultipleAddresseselectionAddr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/a9/2fc526ded2c84a360b8cc0e77ce6cf61bed7a1.src","preCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            \r\n            \r\n            \r\n            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableAddress(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":639,"status":"M"},{"authorDate":"2020-01-23 20:43:39","commitOrder":6,"curCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","date":"2020-01-23 20:43:52","endLine":748,"groupId":"4736","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"connectOne","params":"(longsid)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/a9/2fc526ded2c84a360b8cc0e77ce6cf61bed7a1.src","preCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            \r\n            \r\n            \r\n            senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":710,"status":"M"}],"commitId":"b4c5a7fdd0f97aa5a9bf18a345b1cee5b0da967a","commitMessage":"@@@ZOOKEEPER-3698: fixing NoRouteToHostException when starting large cluster locally\n\nWhen we tested RC 3.6.0.  we had a problem of starting ZooKeeper cluster with large\nnumber (11+) of ensemble members locally on mac. We found exceptions in the logs\nwhen the new MultiAddress feature tries to filter the unreachable hosts from the\naddress list. This involves the calling of the InetAddress.isReachable method with\na default timeout of 500ms.  which goes down to a native call in java and basically\ntry to do a ping (an ICMP echo request) to the host. Naturally.  the localhost should\nbe always reachable.\n\nThe problem was that on mac we have the ICMP rate limit set to 250 by default.\n\nIn this patch we:\n- changed the reachability check behavior by disabling the check if there is only\na single address provided (so we wouldn't be able to filter the unreachable\naddresses anyway).\n- added and documented a configuration parameter to disable the reachability check\nfor testing. (default: enabled)\n- added and documented a configuration parameter to set the timeout for the\nreachability checks. (default: 1000ms)\n\nAuthor: Mate Szalay-Beko <szalay.beko.mate@gmail.com>\n\nReviewers: eolivelli@apache.org.  andor@apache.org\n\nCloses #1228 from symat/ZOOKEEPER-3698-branch-3.6\n\n(cherry picked from commit 8352f78e752a019387c1eb6095085152e7d1d4ad)\nSigned-off-by: Andor Molnar <andor@apache.org>\n","date":"2020-01-23 20:43:52","modifiedFileCount":"8","status":"M","submitter":"Mate Szalay-Beko"},{"authorTime":"2020-02-16 17:25:14","codes":[{"authorDate":"2020-02-16 17:25:14","commitOrder":7,"curCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","date":"2020-02-16 17:25:14","endLine":720,"groupId":"4736","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"connectOne","params":"(longsid@MultipleAddresseselectionAddr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/45/ffeb84903e1bf9974a70280111bfc18e7a2fe1.src","preCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":656,"status":"M"},{"authorDate":"2020-02-16 17:25:14","commitOrder":7,"curCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","date":"2020-02-16 17:25:14","endLine":765,"groupId":"4736","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"connectOne","params":"(longsid)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/45/ffeb84903e1bf9974a70280111bfc18e7a2fe1.src","preCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":727,"status":"M"}],"commitId":"3aa922c5737c9ef0879f290181cb281261c965e0","commitMessage":"@@@ZOOKEEPER-3720: Fix rolling upgrade failure (invalid protocol version)\n\nThe multi-address feature introduced in ZOOKEEPER-3188 required\nchanges in the Quorum protocol as we had to send all addresses in\nthe connection initiation message to enable the receiving side to\nchoose a reachable address in case of network failure.\n\nThe new code can handle both the old and the new protocol versions to\navoid 'invalid protocol' error e.g. during rolling restarts. However. \nthe new protocol version still can not be used during rolling upgrade\nif the old servers are not supporting this protocol. In this case the\nold and the new servers would form two distinct partitions until all\nthe servers get upgraded. To support rolling upgrades too.  we want to\ndisable the MultiAddress feature by default and use the old protocol.\n\nIf the user would like enable the MultiAddress feature on a 3.6.0\ncluster.  she/he can do it either by 1) starting the cluster from\nscratch (without rolling upgrade).  or 2) performing a rolling upgrade\nwithout the MultiAddress feature enabled then doing a rolling restart\nwith a new configuration where the MultiAddress feature is enabled.\nDuring the rolling restart there will be no partitions.  as all the\nservers in the cluster now will run ZooKeeper version 3.6.0 which\nunderstands now both protocols.\n\nThe changes in this patch:\n- introducing new config property: multiAddress.enabled.  disabled\nby default\n- updating QuorumCnxManager to be able to use both protocol versions\nand to use the old one if MultiAddress is disabled\n- failing with ConfigException if the user provides multiple\naddresses in the config while having MultiAddress disabled\n- updating the existing MultiAddress related tests to enable the\nfeature first\n- add some new tests\n- update the documentation\n\nTesting:\n- I ran all the unit tests\n- Using https://github.com/symat/zk-rolling-upgrade-test\n  - I tested rolling upgrade from 3.5.6\n  - I tested rolling restart to enable the MultiAddress feature\n- Using https://github.com/symat/zookeeper-docker-test\n  - I tested the MultiAddress feature by disabling some virtual\n    interfaces and waiting for the cluster to recover\n\nAuthor: Mate Szalay-Beko <szalay.beko.mate@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>.  Norbert Kalmar <nkalmar@apache.org>.  Andor Molnar <andor@apache.org>\n\nCloses #1251 from symat/ZOOKEEPER-3720\n","date":"2020-02-16 17:25:14","modifiedFileCount":"14","status":"M","submitter":"Mate Szalay-Beko"},{"authorTime":"2020-03-12 21:47:27","codes":[{"authorDate":"2020-02-16 17:25:14","commitOrder":8,"curCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","date":"2020-02-16 17:25:14","endLine":720,"groupId":"4736","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"connectOne","params":"(longsid@MultipleAddresseselectionAddr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/45/ffeb84903e1bf9974a70280111bfc18e7a2fe1.src","preCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":656,"status":"N"},{"authorDate":"2020-03-12 21:47:27","commitOrder":8,"curCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastCommittedView\", self.getId(), sid);\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getId(), sid);\n\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","date":"2020-03-12 21:47:27","endLine":800,"groupId":"4736","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"connectOne","params":"(longsid)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/66/f6883470ab335f68a0819877ce9b68ada8c7b1.src","preCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"M"}],"commitId":"0287c95726e66aa6723f0f91f8d85f9973dbbb60","commitMessage":"@@@ZOOKEEPER-2164: Quorum members can not rejoin after restart\n\nEver since ZOOKEEPER-107 (released in 3.5.0) the servers are sending\ntheir addresses during initial connection requests. The receiving\nserver can potentially use these addresses to send back a new\nconnection request if the challenge is won by the receiver.\n\nIf the server config contains wildcard address (e.g. 0.0.0.0 in case\nof IPv4) then the first connection request sent by A to B will contain\nthis address. If the ID of A is smaller than the ID of B.  then A will\nlose the challenge and the second connection request sent back by B\nwill never reach A.  as B will send the initial message to 0.0.0.0.\n\nSo in any 3.5+ ZooKeeper.  if wildcard addresses are used in the configs. \nthen there might be some servers never able to rejoin to the quorum\nafter they got restarted.\n\nIn 3.5+ for backward compatibility reasons (needed during rolling\nupgrade) there is a version of the QuorumCnxManager.connectOne()\nmethod that needs no election address but use the last known address\nto initiate the connection. In this commit.  we simply call this method\nif the address is a wildcard address.\n\nI also added a few restart realted tests.  to make sure that restart\nstill works when we don't use wildcard addresses. We can not test\nthe original error with unit tests.  as it would require to start\nthe quorum on multiple hosts.\n\nI also tested the patch for rolling restart manually both with and\nwithout wildcard addresses in the config.\n\nAuthor: Mate Szalay-Beko <szalay.beko.mate@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>.  Norbert Kalmar <nkalmar@apache.org>\n\nCloses #1254 from symat/ZOOKEEPER-2164\n","date":"2020-03-12 21:47:27","modifiedFileCount":"3","status":"M","submitter":"Mate Szalay-Beko"},{"authorTime":"2020-03-12 21:47:27","codes":[{"authorDate":"2020-03-23 23:20:05","commitOrder":9,"curCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        \r\n        \r\n        \r\n        return initiateConnectionAsync(electionAddr, sid);\n    }\n","date":"2020-03-23 23:20:05","endLine":733,"groupId":"4736","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"connectOne","params":"(longsid@MultipleAddresseselectionAddr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/08/38492012583ed094debae37ca1932dff92f159.src","preCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        Socket sock = null;\n        try {\n            LOG.debug(\"Opening channel to server {}\", sid);\n            if (self.isSslQuorum()) {\n                sock = self.getX509Util().createSSLSocket();\n            } else {\n                sock = new Socket();\n            }\n            setSockOpts(sock);\n            sock.connect(electionAddr.getReachableOrOne(), cnxTO);\n            if (sock instanceof SSLSocket) {\n                SSLSocket sslSock = (SSLSocket) sock;\n                sslSock.startHandshake();\n                LOG.info(\"SSL handshake complete with {} - {} - {}\",\n                         sslSock.getRemoteSocketAddress(),\n                         sslSock.getSession().getProtocol(),\n                         sslSock.getSession().getCipherSuite());\n            }\n\n            LOG.debug(\"Connected to server {} using election address: {}:{}\",\n                      sid, sock.getInetAddress(), sock.getPort());\n            \r\n            \r\n            \r\n            \r\n            if (quorumSaslAuthEnabled) {\n                initiateConnectionAsync(sock, sid);\n            } else {\n                initiateConnection(sock, sid);\n            }\n            return true;\n        } catch (UnresolvedAddressException e) {\n            \r\n            \r\n            \r\n            \r\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            throw e;\n        } catch (X509Exception e) {\n            LOG.warn(\"Cannot open secure channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        } catch (NoRouteToHostException e) {\n            LOG.warn(\"None of the addresses ({}) are reachable for sid {}\", electionAddr, sid, e);\n            closeSocket(sock);\n            return false;\n        } catch (IOException e) {\n            LOG.warn(\"Cannot open channel to {} at election address {}\", sid, electionAddr, e);\n            closeSocket(sock);\n            return false;\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":717,"status":"M"},{"authorDate":"2020-03-12 21:47:27","commitOrder":9,"curCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastCommittedView\", self.getId(), sid);\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getId(), sid);\n\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","date":"2020-03-12 21:47:27","endLine":800,"groupId":"4736","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"connectOne","params":"(longsid)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/66/f6883470ab335f68a0819877ce9b68ada8c7b1.src","preCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastCommittedView\", self.getId(), sid);\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getId(), sid);\n\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"N"}],"commitId":"4d8caf9851f63073145996fd4a535278014d01be","commitMessage":"@@@ZOOKEEPER-3756: Members slow to rejoin quorum using Kubernetes\n\nWhenever we close the current master ZooKeeper server.  a new leader election\nis triggered. During the new election.  a connection will be established between\nall the servers.  by calling the synchronized 'connectOne' method in\nQuorumCnxManager. The method will open the socket and send a single small\ninitial message to the other server.  usually very quickly. If the destination\nhost is unreachable.  it should fail immediately.\n\nHowever.  when we use Kubernetes.  then the destination host is always reachable\nas it points to Kubernetes services. If the actual container / pod is not\navailable then the 'socket.connect' method will timeout (by default after 5 sec)\ninstead of failing immediately with NoRouteToHostException. As the 'connectOne'\nmethod is synchronized.  this timeout will block the creation of other\nconnections.  so a single unreachable host can cause timeout in the leader\nelection protocol.\n\nOne workaround is to decrease the socket connection timeout with the\n'-Dzookeeper.cnxTimeout' stystem property.  but the proper fix would be to\nmake the connection initiation fully asynchronous.  as using very low timeout can\nhave its own side effect. Fortunately most of the initial message sending\nis already made async: the SASL authentication can take more time.  so the\nsecond (authentication + initial message sending) part of the initiation protocol\nis already called in a separate thread.  when Quorum SASL authentication is enabled.\n\nIn the following patch I made the whole connection initiation async.  by\nalways using the async executor (not only when Quorum SASL is enabled) and\nalso moving the socket.connect call into the async thread.\n\nI also created a unit test to verify my fix. I added a static socket factory that can be\nchanged by the tests using a packet private setter method. My test failed (and\nproduced the same error logs as we see in the original Jira ticket) before I applied\nmy changes and a time-outed as no leader election succeeded after 15 seconds.\nAfter the changes the test runs very quickly.  in 1-2 seconds.\n\nNote: due to the multiAddress changes.  we will need different PRs to the branch 3.5\nand to the 3.6+ branches. I will submit the other PR once this got reviewed.\n\nAuthor: Mate Szalay-Beko <szalay.beko.mate@gmail.com>\nAuthor: Mate Szalay-Beko <mszalay@cloudera.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>.  Norbert Kalmar <nkalmar@apache.org>\n\nCloses #1289 from symat/ZOOKEEPER-3756-master\n","date":"2020-03-23 23:20:05","modifiedFileCount":"1","status":"M","submitter":"Mate Szalay-Beko"},{"authorTime":"2021-03-07 04:52:24","codes":[{"authorDate":"2020-03-23 23:20:05","commitOrder":10,"curCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        \r\n        \r\n        \r\n        return initiateConnectionAsync(electionAddr, sid);\n    }\n","date":"2020-03-23 23:20:05","endLine":733,"groupId":"11751","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"connectOne","params":"(longsid@MultipleAddresseselectionAddr)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/08/38492012583ed094debae37ca1932dff92f159.src","preCode":"    synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return true;\n        }\n\n        \r\n        \r\n        \r\n        return initiateConnectionAsync(electionAddr, sid);\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":717,"status":"N"},{"authorDate":"2021-03-07 04:52:24","commitOrder":10,"curCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastCommittedView\", self.getId(), sid);\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || !lastProposedView.get(sid).electionAddr.equals(lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getId(), sid);\n\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","date":"2021-03-07 04:52:24","endLine":783,"groupId":"11751","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"connectOne","params":"(longsid)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-zookeeper-10-0.7/blobInfo/CC_OUT/blobs/2f/240e9bf95e4379f413b63ff5133a7495c474e6.src","preCode":"    synchronized void connectOne(long sid) {\n        if (senderWorkerMap.get(sid) != null) {\n            LOG.debug(\"There is a connection already for server {}\", sid);\n            if (self.isMultiAddressEnabled() && self.isMultiAddressReachabilityCheckEnabled()) {\n                \r\n                \r\n                \r\n                senderWorkerMap.get(sid).asyncValidateIfSocketIsStillReachable();\n            }\n            return;\n        }\n        synchronized (self.QV_LOCK) {\n            boolean knownId = false;\n            \r\n            \r\n            self.recreateSocketAddresses(sid);\n            Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();\n            QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();\n            Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();\n            if (lastCommittedView.containsKey(sid)) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastCommittedView\", self.getId(), sid);\n                if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (lastSeenQV != null\n                && lastProposedView.containsKey(sid)\n                && (!knownId\n                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n                knownId = true;\n                LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getId(), sid);\n\n                if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {\n                    return;\n                }\n            }\n            if (!knownId) {\n                LOG.warn(\"Invalid server id: {} \", sid);\n            }\n        }\n    }\n","realPath":"zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java","repoName":"zookeeper","snippetEndLine":0,"snippetStartLine":0,"startLine":742,"status":"M"}],"commitId":"6022e03177b21606575152ac323205af3fbbe9d8","commitMessage":"@@@ZOOKEEPER-4220: Potential redundant connection attempts during leader election\n\nWe have a logic in the server code.  that would try to connect to an other quorum member.  based\non its server ID. We identify the address assigned to this ID first based on the last committed\nquorum configuration. If the connection attempt fails (or the server is not known in the\ncommitted configuration) then we try to find the address based on the last proposed quorum\nconfiguration. But we should do the second connection attempt.  only if the address in the\nlast proposed configuration differs from the address in the last committed configuration.\nOtherwise we would just retry to connect to the same address that failed just right before.\n\nIn the current code we have a bug.  because we compare the address object references (use \"!=\")\ninstead of comparing the objects themselves (using \"not equals\"). In certain edge cases (e.g.\nwhen the last proposed and last committed addresses are the same.  but the address is unreachable)\nthis bug can lead to unnecessary retry of connection attempts. The normal behaviour would be to\nmark this connection attempt to be failed and wait for e.g. the next election round or wait for\nthe other server to come online and initiate a connection to us.\n\nAuthor: Mate Szalay-Beko <symat@apache.org>\n\nReviewers: Andor Molnar <anmolnar@apache.org>.  Damien Diederen <ddiederen@apache.org>\n\nCloses #1615 from symat/ZOOKEEPER-4220\n","date":"2021-03-07 04:52:24","modifiedFileCount":"1","status":"M","submitter":"Mate Szalay-Beko"}]
