[{"authorTime":"2014-09-05 18:32:20","codes":[{"authorDate":"2014-09-05 18:32:20","commitOrder":1,"curCode":"    public void start(int port) throws IOException {\n        tcpServer = new NioTcpServer(new FixedSelectorLoopPool(\"Server\", 1), null);\n        tcpServer.getSessionConfig().setReadBufferSize(128 * 1024);\n        tcpServer.getSessionConfig().setTcpNoDelay(true);\n        tcpServer.setIoHandler(new IoHandler() {\n            public void sessionOpened(IoSession session) {\n                session.setAttribute(STATE_ATTRIBUTE, State.WAIT_FOR_FIRST_BYTE_LENGTH);\n            }\n\n            public void messageReceived(IoSession session, Object message) {\n                if (message instanceof ByteBuffer) {\n                    ByteBuffer buffer = (ByteBuffer) message;\n\n                    State state = session.getAttribute(STATE_ATTRIBUTE);\n                    int length = 0;\n\n                    if (session.getAttribute(LENGTH_ATTRIBUTE) != null) {\n                        length = session.getAttribute(LENGTH_ATTRIBUTE);\n                    }\n\n                    while (buffer.remaining() > 0) {\n                        switch (state) {\n                        case WAIT_FOR_FIRST_BYTE_LENGTH:\n                            length = (buffer.get() & 255) << 24;\n                            state = State.WAIT_FOR_SECOND_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_SECOND_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 16;\n                            state = State.WAIT_FOR_THIRD_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_THIRD_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 8;\n                            state = State.WAIT_FOR_FOURTH_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_FOURTH_BYTE_LENGTH:\n                            length += (buffer.get() & 255);\n                            state = State.READING;\n                            if ((length == 0) && (buffer.remaining() == 0)) {\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                            }\n                            break;\n                        case READING:\n                            int remaining = buffer.remaining();\n                            if (length > remaining) {\n                                length -= remaining;\n                                buffer.position(buffer.position() + remaining);\n                            } else {\n                                buffer.position(buffer.position() + length);\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                                length = 0;\n                            }\n                        }\n                    }\n                    session.setAttribute(LENGTH_ATTRIBUTE, length);\n                    session.setAttribute(STATE_ATTRIBUTE, state);\n                }\n            }\n\n            public void exceptionCaught(IoSession session, Exception cause) {\n                cause.printStackTrace();\n            }\n\n            @Override\n            public void sessionClosed(IoSession session) {\n            }\n\n            @Override\n            public void sessionIdle(IoSession session, IdleStatus status) {\n            }\n\n            @Override\n            public void messageSent(IoSession session, Object message) {\n                CounterFilter.messageSent.getAndIncrement();\n            }\n\n            @Override\n            public void serviceActivated(IoService service) {\n            }\n\n            @Override\n            public void serviceInactivated(IoService service) {\n            }\n        });\n\n        tcpServer.bind(new InetSocketAddress(port));\n    }\n","date":"2014-09-05 18:32:20","endLine":151,"groupId":"269","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"start","params":"(intport)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/c8/153a280b6934377a5cd8b6483cae8125d30dff.src","preCode":"    public void start(int port) throws IOException {\n        tcpServer = new NioTcpServer(new FixedSelectorLoopPool(\"Server\", 1), null);\n        tcpServer.getSessionConfig().setReadBufferSize(128 * 1024);\n        tcpServer.getSessionConfig().setTcpNoDelay(true);\n        tcpServer.setIoHandler(new IoHandler() {\n            public void sessionOpened(IoSession session) {\n                session.setAttribute(STATE_ATTRIBUTE, State.WAIT_FOR_FIRST_BYTE_LENGTH);\n            }\n\n            public void messageReceived(IoSession session, Object message) {\n                if (message instanceof ByteBuffer) {\n                    ByteBuffer buffer = (ByteBuffer) message;\n\n                    State state = session.getAttribute(STATE_ATTRIBUTE);\n                    int length = 0;\n\n                    if (session.getAttribute(LENGTH_ATTRIBUTE) != null) {\n                        length = session.getAttribute(LENGTH_ATTRIBUTE);\n                    }\n\n                    while (buffer.remaining() > 0) {\n                        switch (state) {\n                        case WAIT_FOR_FIRST_BYTE_LENGTH:\n                            length = (buffer.get() & 255) << 24;\n                            state = State.WAIT_FOR_SECOND_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_SECOND_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 16;\n                            state = State.WAIT_FOR_THIRD_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_THIRD_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 8;\n                            state = State.WAIT_FOR_FOURTH_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_FOURTH_BYTE_LENGTH:\n                            length += (buffer.get() & 255);\n                            state = State.READING;\n                            if ((length == 0) && (buffer.remaining() == 0)) {\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                            }\n                            break;\n                        case READING:\n                            int remaining = buffer.remaining();\n                            if (length > remaining) {\n                                length -= remaining;\n                                buffer.position(buffer.position() + remaining);\n                            } else {\n                                buffer.position(buffer.position() + length);\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                                length = 0;\n                            }\n                        }\n                    }\n                    session.setAttribute(LENGTH_ATTRIBUTE, length);\n                    session.setAttribute(STATE_ATTRIBUTE, state);\n                }\n            }\n\n            public void exceptionCaught(IoSession session, Exception cause) {\n                cause.printStackTrace();\n            }\n\n            @Override\n            public void sessionClosed(IoSession session) {\n            }\n\n            @Override\n            public void sessionIdle(IoSession session, IdleStatus status) {\n            }\n\n            @Override\n            public void messageSent(IoSession session, Object message) {\n                CounterFilter.messageSent.getAndIncrement();\n            }\n\n            @Override\n            public void serviceActivated(IoService service) {\n            }\n\n            @Override\n            public void serviceInactivated(IoService service) {\n            }\n        });\n\n        tcpServer.bind(new InetSocketAddress(port));\n    }\n","realPath":"benchmarks/common/src/test/java/org/apache/mina/core/nio/tcp/Mina3TcpBenchmarkServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"B"},{"authorDate":"2014-09-05 18:32:20","commitOrder":1,"curCode":"    public void start(int port) throws IOException {\n        UdpSessionConfig config = new DefaultUdpSessionConfig();\n        config.setReadBufferSize(65536);\n        udpServer = new NioUdpServer(config);\n        udpServer.setIoHandler(new IoHandler() {\n            @Override\n            public void sessionOpened(IoSession session) {\n                session.setAttribute(STATE_ATTRIBUTE, State.WAIT_FOR_FIRST_BYTE_LENGTH);\n            }\n\n            @Override\n            public void messageReceived(IoSession session, Object message) {\n                \r\n                if (message instanceof ByteBuffer) {\n                    ByteBuffer buffer = (ByteBuffer) message;\n\n                    State state = session.getAttribute(STATE_ATTRIBUTE);\n                    int length = 0;\n\n                    if (session.getAttribute(LENGTH_ATTRIBUTE) != null) {\n                        length = session.getAttribute(LENGTH_ATTRIBUTE);\n                    }\n\n                    while (buffer.remaining() > 0) {\n                        switch (state) {\n                        case WAIT_FOR_FIRST_BYTE_LENGTH:\n                            length = (buffer.get() & 255) << 24;\n                            state = State.WAIT_FOR_SECOND_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_SECOND_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 16;\n                            state = State.WAIT_FOR_THIRD_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_THIRD_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 8;\n                            state = State.WAIT_FOR_FOURTH_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_FOURTH_BYTE_LENGTH:\n                            length += (buffer.get() & 255);\n                            state = State.READING;\n                            if ((length == 0) && (buffer.remaining() == 0)) {\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                            }\n                            break;\n                        case READING:\n                            int remaining = buffer.remaining();\n                            if (length > remaining) {\n                                length -= remaining;\n                                buffer.position(buffer.position() + remaining);\n                            } else {\n                                buffer.position(buffer.position() + length);\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                                length = 0;\n                            }\n                        }\n                    }\n                    session.setAttribute(LENGTH_ATTRIBUTE, length);\n                    session.setAttribute(STATE_ATTRIBUTE, state);\n                }\n            }\n\n            @Override\n            public void exceptionCaught(IoSession session, Exception cause) {\n                cause.printStackTrace();\n            }\n\n            @Override\n            public void sessionClosed(IoSession session) {\n            }\n\n            @Override\n            public void sessionIdle(IoSession session, IdleStatus status) {\n            }\n\n            @Override\n            public void messageSent(IoSession session, Object message) {\n                CounterFilter.messageSent.getAndIncrement();\n            }\n\n            @Override\n            public void serviceActivated(IoService service) {\n            }\n\n            @Override\n            public void serviceInactivated(IoService service) {\n            }\n        });\n\n        udpServer.bind(new InetSocketAddress(port));\n    }\n","date":"2014-09-05 18:32:20","endLine":158,"groupId":"269","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"start","params":"(intport)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/a9/bf2a97248200d6c52cadc1ada243bf63195688.src","preCode":"    public void start(int port) throws IOException {\n        UdpSessionConfig config = new DefaultUdpSessionConfig();\n        config.setReadBufferSize(65536);\n        udpServer = new NioUdpServer(config);\n        udpServer.setIoHandler(new IoHandler() {\n            @Override\n            public void sessionOpened(IoSession session) {\n                session.setAttribute(STATE_ATTRIBUTE, State.WAIT_FOR_FIRST_BYTE_LENGTH);\n            }\n\n            @Override\n            public void messageReceived(IoSession session, Object message) {\n                \r\n                if (message instanceof ByteBuffer) {\n                    ByteBuffer buffer = (ByteBuffer) message;\n\n                    State state = session.getAttribute(STATE_ATTRIBUTE);\n                    int length = 0;\n\n                    if (session.getAttribute(LENGTH_ATTRIBUTE) != null) {\n                        length = session.getAttribute(LENGTH_ATTRIBUTE);\n                    }\n\n                    while (buffer.remaining() > 0) {\n                        switch (state) {\n                        case WAIT_FOR_FIRST_BYTE_LENGTH:\n                            length = (buffer.get() & 255) << 24;\n                            state = State.WAIT_FOR_SECOND_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_SECOND_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 16;\n                            state = State.WAIT_FOR_THIRD_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_THIRD_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 8;\n                            state = State.WAIT_FOR_FOURTH_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_FOURTH_BYTE_LENGTH:\n                            length += (buffer.get() & 255);\n                            state = State.READING;\n                            if ((length == 0) && (buffer.remaining() == 0)) {\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                            }\n                            break;\n                        case READING:\n                            int remaining = buffer.remaining();\n                            if (length > remaining) {\n                                length -= remaining;\n                                buffer.position(buffer.position() + remaining);\n                            } else {\n                                buffer.position(buffer.position() + length);\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                                length = 0;\n                            }\n                        }\n                    }\n                    session.setAttribute(LENGTH_ATTRIBUTE, length);\n                    session.setAttribute(STATE_ATTRIBUTE, state);\n                }\n            }\n\n            @Override\n            public void exceptionCaught(IoSession session, Exception cause) {\n                cause.printStackTrace();\n            }\n\n            @Override\n            public void sessionClosed(IoSession session) {\n            }\n\n            @Override\n            public void sessionIdle(IoSession session, IdleStatus status) {\n            }\n\n            @Override\n            public void messageSent(IoSession session, Object message) {\n                CounterFilter.messageSent.getAndIncrement();\n            }\n\n            @Override\n            public void serviceActivated(IoService service) {\n            }\n\n            @Override\n            public void serviceInactivated(IoService service) {\n            }\n        });\n\n        udpServer.bind(new InetSocketAddress(port));\n    }\n","realPath":"benchmarks/common/src/test/java/org/apache/mina/core/nio/udp/Mina3UdpBenchmarkServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"B"}],"commitId":"d38458d353ee5dace8c6daed967eccde2e867fe9","commitMessage":"@@@Applied many patches\n\nMerge branch 'trunk' of https://git-wip-us.apache.org/repos/asf/mina into trunk\n","date":"2014-09-05 18:32:20","modifiedFileCount":"0","status":"B","submitter":"Emmanuel L?charny"},{"authorTime":"2014-12-13 05:21:00","codes":[{"authorDate":"2014-12-13 05:21:00","commitOrder":2,"curCode":"    public void start(int port) throws IOException {\n        tcpServer = new NioTcpServer(new FixedSelectorLoopPool(\"Server\", 1), null);\n        tcpServer.getSessionConfig().setReadBufferSize(128 * 1024);\n        tcpServer.getSessionConfig().setTcpNoDelay(true);\n        tcpServer.setIoHandler(new AbstractIoHandler() {\n            public void sessionOpened(IoSession session) {\n                session.setAttribute(STATE_ATTRIBUTE, State.WAIT_FOR_FIRST_BYTE_LENGTH);\n            }\n\n            public void messageReceived(IoSession session, Object message) {\n                if (message instanceof ByteBuffer) {\n                    ByteBuffer buffer = (ByteBuffer) message;\n\n                    State state = session.getAttribute(STATE_ATTRIBUTE);\n                    int length = 0;\n\n                    if (session.getAttribute(LENGTH_ATTRIBUTE) != null) {\n                        length = session.getAttribute(LENGTH_ATTRIBUTE);\n                    }\n\n                    while (buffer.remaining() > 0) {\n                        switch (state) {\n                        case WAIT_FOR_FIRST_BYTE_LENGTH:\n                            length = (buffer.get() & 255) << 24;\n                            state = State.WAIT_FOR_SECOND_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_SECOND_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 16;\n                            state = State.WAIT_FOR_THIRD_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_THIRD_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 8;\n                            state = State.WAIT_FOR_FOURTH_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_FOURTH_BYTE_LENGTH:\n                            length += (buffer.get() & 255);\n                            state = State.READING;\n                            if ((length == 0) && (buffer.remaining() == 0)) {\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                            }\n                            break;\n                        case READING:\n                            int remaining = buffer.remaining();\n                            if (length > remaining) {\n                                length -= remaining;\n                                buffer.position(buffer.position() + remaining);\n                            } else {\n                                buffer.position(buffer.position() + length);\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                                length = 0;\n                            }\n                        }\n                    }\n                    session.setAttribute(LENGTH_ATTRIBUTE, length);\n                    session.setAttribute(STATE_ATTRIBUTE, state);\n                }\n            }\n\n            public void exceptionCaught(IoSession session, Exception cause) {\n                cause.printStackTrace();\n            }\n\n            @Override\n            public void sessionClosed(IoSession session) {\n            }\n\n            @Override\n            public void sessionIdle(IoSession session, IdleStatus status) {\n            }\n\n            @Override\n            public void messageSent(IoSession session, Object message) {\n                CounterFilter.messageSent.getAndIncrement();\n            }\n\n            @Override\n            public void serviceActivated(IoService service) {\n            }\n\n            @Override\n            public void serviceInactivated(IoService service) {\n            }\n        });\n\n        tcpServer.bind(new InetSocketAddress(port));\n    }\n","date":"2014-12-13 05:21:00","endLine":151,"groupId":"10144","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"start","params":"(intport)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/f4/e8c22f3a017c034e9cc2c4f5ee5e508a7d1b37.src","preCode":"    public void start(int port) throws IOException {\n        tcpServer = new NioTcpServer(new FixedSelectorLoopPool(\"Server\", 1), null);\n        tcpServer.getSessionConfig().setReadBufferSize(128 * 1024);\n        tcpServer.getSessionConfig().setTcpNoDelay(true);\n        tcpServer.setIoHandler(new IoHandler() {\n            public void sessionOpened(IoSession session) {\n                session.setAttribute(STATE_ATTRIBUTE, State.WAIT_FOR_FIRST_BYTE_LENGTH);\n            }\n\n            public void messageReceived(IoSession session, Object message) {\n                if (message instanceof ByteBuffer) {\n                    ByteBuffer buffer = (ByteBuffer) message;\n\n                    State state = session.getAttribute(STATE_ATTRIBUTE);\n                    int length = 0;\n\n                    if (session.getAttribute(LENGTH_ATTRIBUTE) != null) {\n                        length = session.getAttribute(LENGTH_ATTRIBUTE);\n                    }\n\n                    while (buffer.remaining() > 0) {\n                        switch (state) {\n                        case WAIT_FOR_FIRST_BYTE_LENGTH:\n                            length = (buffer.get() & 255) << 24;\n                            state = State.WAIT_FOR_SECOND_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_SECOND_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 16;\n                            state = State.WAIT_FOR_THIRD_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_THIRD_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 8;\n                            state = State.WAIT_FOR_FOURTH_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_FOURTH_BYTE_LENGTH:\n                            length += (buffer.get() & 255);\n                            state = State.READING;\n                            if ((length == 0) && (buffer.remaining() == 0)) {\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                            }\n                            break;\n                        case READING:\n                            int remaining = buffer.remaining();\n                            if (length > remaining) {\n                                length -= remaining;\n                                buffer.position(buffer.position() + remaining);\n                            } else {\n                                buffer.position(buffer.position() + length);\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                                length = 0;\n                            }\n                        }\n                    }\n                    session.setAttribute(LENGTH_ATTRIBUTE, length);\n                    session.setAttribute(STATE_ATTRIBUTE, state);\n                }\n            }\n\n            public void exceptionCaught(IoSession session, Exception cause) {\n                cause.printStackTrace();\n            }\n\n            @Override\n            public void sessionClosed(IoSession session) {\n            }\n\n            @Override\n            public void sessionIdle(IoSession session, IdleStatus status) {\n            }\n\n            @Override\n            public void messageSent(IoSession session, Object message) {\n                CounterFilter.messageSent.getAndIncrement();\n            }\n\n            @Override\n            public void serviceActivated(IoService service) {\n            }\n\n            @Override\n            public void serviceInactivated(IoService service) {\n            }\n        });\n\n        tcpServer.bind(new InetSocketAddress(port));\n    }\n","realPath":"benchmarks/common/src/test/java/org/apache/mina/core/nio/tcp/Mina3TcpBenchmarkServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":64,"status":"M"},{"authorDate":"2014-12-13 05:21:00","commitOrder":2,"curCode":"    public void start(int port) throws IOException {\n        UdpSessionConfig config = new DefaultUdpSessionConfig();\n        config.setReadBufferSize(65536);\n        udpServer = new NioUdpServer(config);\n        udpServer.setIoHandler(new AbstractIoHandler() {\n            @Override\n            public void sessionOpened(IoSession session) {\n                session.setAttribute(STATE_ATTRIBUTE, State.WAIT_FOR_FIRST_BYTE_LENGTH);\n            }\n\n            @Override\n            public void messageReceived(IoSession session, Object message) {\n                \r\n                if (message instanceof ByteBuffer) {\n                    ByteBuffer buffer = (ByteBuffer) message;\n\n                    State state = session.getAttribute(STATE_ATTRIBUTE);\n                    int length = 0;\n\n                    if (session.getAttribute(LENGTH_ATTRIBUTE) != null) {\n                        length = session.getAttribute(LENGTH_ATTRIBUTE);\n                    }\n\n                    while (buffer.remaining() > 0) {\n                        switch (state) {\n                        case WAIT_FOR_FIRST_BYTE_LENGTH:\n                            length = (buffer.get() & 255) << 24;\n                            state = State.WAIT_FOR_SECOND_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_SECOND_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 16;\n                            state = State.WAIT_FOR_THIRD_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_THIRD_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 8;\n                            state = State.WAIT_FOR_FOURTH_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_FOURTH_BYTE_LENGTH:\n                            length += (buffer.get() & 255);\n                            state = State.READING;\n                            if ((length == 0) && (buffer.remaining() == 0)) {\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                            }\n                            break;\n                        case READING:\n                            int remaining = buffer.remaining();\n                            if (length > remaining) {\n                                length -= remaining;\n                                buffer.position(buffer.position() + remaining);\n                            } else {\n                                buffer.position(buffer.position() + length);\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                                length = 0;\n                            }\n                        }\n                    }\n                    session.setAttribute(LENGTH_ATTRIBUTE, length);\n                    session.setAttribute(STATE_ATTRIBUTE, state);\n                }\n            }\n\n            @Override\n            public void exceptionCaught(IoSession session, Exception cause) {\n                cause.printStackTrace();\n            }\n\n            @Override\n            public void sessionClosed(IoSession session) {\n            }\n\n            @Override\n            public void sessionIdle(IoSession session, IdleStatus status) {\n            }\n\n            @Override\n            public void messageSent(IoSession session, Object message) {\n                CounterFilter.messageSent.getAndIncrement();\n            }\n\n            @Override\n            public void serviceActivated(IoService service) {\n            }\n\n            @Override\n            public void serviceInactivated(IoService service) {\n            }\n        });\n\n        udpServer.bind(new InetSocketAddress(port));\n    }\n","date":"2014-12-13 05:21:00","endLine":158,"groupId":"10144","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"start","params":"(intport)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/63/aa148ee112349502739596190e6185fe802258.src","preCode":"    public void start(int port) throws IOException {\n        UdpSessionConfig config = new DefaultUdpSessionConfig();\n        config.setReadBufferSize(65536);\n        udpServer = new NioUdpServer(config);\n        udpServer.setIoHandler(new IoHandler() {\n            @Override\n            public void sessionOpened(IoSession session) {\n                session.setAttribute(STATE_ATTRIBUTE, State.WAIT_FOR_FIRST_BYTE_LENGTH);\n            }\n\n            @Override\n            public void messageReceived(IoSession session, Object message) {\n                \r\n                if (message instanceof ByteBuffer) {\n                    ByteBuffer buffer = (ByteBuffer) message;\n\n                    State state = session.getAttribute(STATE_ATTRIBUTE);\n                    int length = 0;\n\n                    if (session.getAttribute(LENGTH_ATTRIBUTE) != null) {\n                        length = session.getAttribute(LENGTH_ATTRIBUTE);\n                    }\n\n                    while (buffer.remaining() > 0) {\n                        switch (state) {\n                        case WAIT_FOR_FIRST_BYTE_LENGTH:\n                            length = (buffer.get() & 255) << 24;\n                            state = State.WAIT_FOR_SECOND_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_SECOND_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 16;\n                            state = State.WAIT_FOR_THIRD_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_THIRD_BYTE_LENGTH:\n                            length += (buffer.get() & 255) << 8;\n                            state = State.WAIT_FOR_FOURTH_BYTE_LENGTH;\n                            break;\n                        case WAIT_FOR_FOURTH_BYTE_LENGTH:\n                            length += (buffer.get() & 255);\n                            state = State.READING;\n                            if ((length == 0) && (buffer.remaining() == 0)) {\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                            }\n                            break;\n                        case READING:\n                            int remaining = buffer.remaining();\n                            if (length > remaining) {\n                                length -= remaining;\n                                buffer.position(buffer.position() + remaining);\n                            } else {\n                                buffer.position(buffer.position() + length);\n                                session.write(ACK.slice());\n                                state = State.WAIT_FOR_FIRST_BYTE_LENGTH;\n                                length = 0;\n                            }\n                        }\n                    }\n                    session.setAttribute(LENGTH_ATTRIBUTE, length);\n                    session.setAttribute(STATE_ATTRIBUTE, state);\n                }\n            }\n\n            @Override\n            public void exceptionCaught(IoSession session, Exception cause) {\n                cause.printStackTrace();\n            }\n\n            @Override\n            public void sessionClosed(IoSession session) {\n            }\n\n            @Override\n            public void sessionIdle(IoSession session, IdleStatus status) {\n            }\n\n            @Override\n            public void messageSent(IoSession session, Object message) {\n                CounterFilter.messageSent.getAndIncrement();\n            }\n\n            @Override\n            public void serviceActivated(IoService service) {\n            }\n\n            @Override\n            public void serviceInactivated(IoService service) {\n            }\n        });\n\n        udpServer.bind(new InetSocketAddress(port));\n    }\n","realPath":"benchmarks/common/src/test/java/org/apache/mina/core/nio/udp/Mina3UdpBenchmarkServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"M"}],"commitId":"904f44473dde13a7dd7848626998f6a0ba06a56e","commitMessage":"@@@Fix previous commit\n","date":"2014-12-13 05:21:00","modifiedFileCount":"5","status":"M","submitter":"Jeff MAURY"}]
