[{"authorTime":"2012-02-15 23:22:50","codes":[{"authorDate":"2012-02-15 23:22:50","commitOrder":1,"curCode":"    public void sessionRead(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","date":"2012-02-15 23:22:50","endLine":80,"groupId":"1219","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"sessionRead","params":"(AbstractIoSessionsession@longtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/29/24f836f610dea8e53afcd85b0e4d45a17ca1b0.src","preCode":"    public void sessionRead(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"B"},{"authorDate":"2012-02-15 23:22:50","commitOrder":1,"curCode":"    public void sessionWritten(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","date":"2012-02-15 23:22:50","endLine":110,"groupId":"1219","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"sessionWritten","params":"(AbstractIoSessionsession@longtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/29/24f836f610dea8e53afcd85b0e4d45a17ca1b0.src","preCode":"    public void sessionWritten(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":86,"status":"B"}],"commitId":"1321c122e8b7563d22bdb3ab381cb6e28d04e64a","commitMessage":"@@@DIRMINA-850 idle checker (WIP)\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/trunk@1244531 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-02-15 23:22:50","modifiedFileCount":"10","status":"B","submitter":"Julien Vermillard"},{"authorTime":"2012-02-15 23:37:21","codes":[{"authorDate":"2012-02-15 23:37:21","commitOrder":2,"curCode":"    public void sessionRead(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","date":"2012-02-15 23:37:21","endLine":106,"groupId":"1517","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"sessionRead","params":"(AbstractIoSessionsession@longtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/01/884922373a3b99787575f8d5c6132fd27ae1bc.src","preCode":"    public void sessionRead(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2012-02-15 23:37:21","commitOrder":2,"curCode":"    public void sessionWritten(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","date":"2012-02-15 23:37:21","endLine":136,"groupId":"1517","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"sessionWritten","params":"(AbstractIoSessionsession@longtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/01/884922373a3b99787575f8d5c6132fd27ae1bc.src","preCode":"    public void sessionWritten(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"M"}],"commitId":"ddce88574135fb4198de4552024c8152e7ec8a79","commitMessage":"@@@DIRMINA-850 idle checker javadoc\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/trunk@1244543 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-02-15 23:37:21","modifiedFileCount":"2","status":"M","submitter":"Julien Vermillard"},{"authorTime":"2012-02-15 23:37:21","codes":[{"authorDate":"2012-02-18 17:23:57","commitOrder":3,"curCode":"    public void sessionRead(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            LOG.debug(\"marking session {} idle for index {}\", session, index);\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","date":"2012-02-18 17:23:57","endLine":107,"groupId":"1517","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"sessionRead","params":"(AbstractIoSessionsession@longtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/ac/9675c5ad98cad3cae648575d56a7bd67adbc31.src","preCode":"    public void sessionRead(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"M"},{"authorDate":"2012-02-15 23:37:21","commitOrder":3,"curCode":"    public void sessionWritten(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","date":"2012-02-15 23:37:21","endLine":136,"groupId":"1517","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"sessionWritten","params":"(AbstractIoSessionsession@longtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/01/884922373a3b99787575f8d5c6132fd27ae1bc.src","preCode":"    public void sessionWritten(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":112,"status":"N"}],"commitId":"c858dc11011c9f0028b57df2d84748730766a4a2","commitMessage":"@@@DIRMINA-850 idle checker unit tests (WIP)\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/trunk@1245895 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-02-18 17:23:57","modifiedFileCount":"2","status":"M","submitter":"Julien Vermillard"},{"authorTime":"2012-11-07 20:02:09","codes":[{"authorDate":"2012-11-07 20:02:09","commitOrder":4,"curCode":"    public void sessionRead(final AbstractIoSession session, final long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        final Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        final long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            final int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            final int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            LOG.debug(\"marking session {} idle for index {}\", session, index);\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","date":"2012-11-07 20:02:09","endLine":140,"groupId":"1517","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"sessionRead","params":"(finalAbstractIoSessionsession@finallongtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/3d/f88ee6965ad70844f30a817187af75e9e98d6b.src","preCode":"    public void sessionRead(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            LOG.debug(\"marking session {} idle for index {}\", session, index);\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"},{"authorDate":"2012-11-07 20:02:09","commitOrder":4,"curCode":"    public void sessionWritten(final AbstractIoSession session, final long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        final Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        final long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            final int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            final int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","date":"2012-11-07 20:02:09","endLine":171,"groupId":"1517","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"sessionWritten","params":"(finalAbstractIoSessionsession@finallongtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/3d/f88ee6965ad70844f30a817187af75e9e98d6b.src","preCode":"    public void sessionWritten(AbstractIoSession session, long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = new HashSet<AbstractIoSession>();\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"}],"commitId":"71cf543247fcaabbf4dfd54a1cc66d0ddf5a53d8","commitMessage":"@@@now idle checker use its own thread\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/mina/trunk@1406579 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-11-07 20:02:09","modifiedFileCount":"5","status":"M","submitter":"Julien Vermillard"},{"authorTime":"2013-05-19 21:56:17","codes":[{"authorDate":"2013-05-19 21:56:17","commitOrder":5,"curCode":"    public void sessionRead(final AbstractIoSession session, final long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        final Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        final long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            final int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            final int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            LOG.debug(\"computed index : {}\", index);\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            LOG.debug(\"marking session {} idle for index {}\", session, index);\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","date":"2013-05-19 21:56:17","endLine":143,"groupId":"0","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"sessionRead","params":"(finalAbstractIoSessionsession@finallongtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/51/ebaee426ed77a0377ee7d5eea5d4a536f59fd6.src","preCode":"    public void sessionRead(final AbstractIoSession session, final long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        final Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        final long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            final int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            final int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            LOG.debug(\"marking session {} idle for index {}\", session, index);\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2013-05-19 21:56:17","commitOrder":5,"curCode":"    public void sessionWritten(final AbstractIoSession session, final long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        final Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        final long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            final int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            final int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","date":"2013-05-19 21:56:17","endLine":174,"groupId":"1219","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"sessionWritten","params":"(finalAbstractIoSessionsession@finallongtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/51/ebaee426ed77a0377ee7d5eea5d4a536f59fd6.src","preCode":"    public void sessionWritten(final AbstractIoSession session, final long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        final Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        final long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            final int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L) + 1;\n            final int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":149,"status":"M"}],"commitId":"32adf24ee3057d9b8b73bbc0d617d173cca73517","commitMessage":"@@@bug fix : don't send premature idle events\n","date":"2013-05-19 21:56:17","modifiedFileCount":"3","status":"M","submitter":"jvermillard"},{"authorTime":"2013-05-28 02:00:48","codes":[{"authorDate":"2013-05-28 02:00:48","commitOrder":6,"curCode":"    public void sessionRead(AbstractIoSession session, long timeInMs) {\n        if (IS_DEBUG) {\n            LOG.debug(\"session read event, compute idle index of session {}\", session);\n        }\n\n        \r\n        Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            if (IS_DEBUG) {\n                LOG.debug(\"remove for old index {}\", oldIndex);\n            }\n\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n\n        \r\n        if (idleTimeInMs <= 0L) {\n            if (IS_DEBUG) {\n                LOG.debug(\"no read idle configuration\");\n            }\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n\n            if (IS_DEBUG) {\n                LOG.debug(\"computed index : {}\", index);\n            }\n\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            if (IS_DEBUG) {\n                LOG.debug(\"marking session {} idle for index {}\", session, index);\n            }\n\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","date":"2013-05-28 02:00:48","endLine":163,"groupId":"1054","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"sessionRead","params":"(AbstractIoSessionsession@longtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/60/066a6f74f28c62535aa571a958e711a981e5a5.src","preCode":"    public void sessionRead(final AbstractIoSession session, final long timeInMs) {\n        LOG.debug(\"session read event, compute idle index of session {}\", session);\n\n        \r\n        final Integer oldIndex = session.getAttribute(READ_IDLE_INDEX);\n        if (oldIndex != null && readIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            readIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        final long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.READ_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no read idle configuration\");\n        } else {\n            final int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            final int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            LOG.debug(\"computed index : {}\", index);\n            if (readIdleSessionIndex[index] == null) {\n                readIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            LOG.debug(\"marking session {} idle for index {}\", session, index);\n            readIdleSessionIndex[index].add(session);\n            session.setAttribute(READ_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":120,"status":"M"},{"authorDate":"2013-05-28 02:00:48","commitOrder":6,"curCode":"    public void sessionWritten(AbstractIoSession session, long timeInMs) {\n        if (IS_DEBUG) {\n            LOG.debug(\"session write event, compute idle index of session {}\", session);\n        }\n\n        \r\n        Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            if (IS_DEBUG) {\n                LOG.debug(\"remove for old index {}\", oldIndex);\n            }\n\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n\n        \r\n        if (idleTimeInMs <= 0L) {\n            if (IS_DEBUG) {\n                LOG.debug(\"no write idle configuration\");\n            }\n        } else {\n            int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","date":"2013-05-28 02:00:48","endLine":204,"groupId":"1054","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"sessionWritten","params":"(AbstractIoSessionsession@longtimeInMs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/60/066a6f74f28c62535aa571a958e711a981e5a5.src","preCode":"    public void sessionWritten(final AbstractIoSession session, final long timeInMs) {\n        LOG.debug(\"session write event, compute idle index of session {}\", session);\n\n        \r\n        final Integer oldIndex = session.getAttribute(WRITE_IDLE_INDEX);\n        if (oldIndex != null && writeIdleSessionIndex[oldIndex] != null) {\n            LOG.debug(\"remove for old index {}\", oldIndex);\n            writeIdleSessionIndex[oldIndex].remove(session);\n        }\n\n        final long idleTimeInMs = session.getConfig().getIdleTimeInMillis(IdleStatus.WRITE_IDLE);\n        \r\n        if (idleTimeInMs <= 0L) {\n            LOG.debug(\"no write idle configuration\");\n        } else {\n            final int nextIdleTimeInSeconds = (int) ((timeInMs + idleTimeInMs) / 1000L);\n            final int index = nextIdleTimeInSeconds % MAX_IDLE_TIME_IN_SEC;\n            if (writeIdleSessionIndex[index] == null) {\n                writeIdleSessionIndex[index] = Collections\n                        .newSetFromMap(new ConcurrentHashMap<AbstractIoSession, Boolean>());\n            }\n\n            writeIdleSessionIndex[index].add(session);\n            session.setAttribute(WRITE_IDLE_INDEX, index);\n        }\n    }\n","realPath":"core/src/main/java/org/apache/mina/service/idlechecker/IndexedIdleChecker.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":169,"status":"M"}],"commitId":"b39ee919caa082f8015b9e4430f292e43bde1851","commitMessage":"@@@o Using a static final IS_DEBUG constant to speed up the Log\no Removed some final\no Modified the NioUdpSession.convertToDirectBuffer() method : we don't\nanymore copy the ByteBuffer into a DirectBuffer.  this is a waste of\ntime. The gain is significant : between 10* to 100%","date":"2013-05-28 02:00:48","modifiedFileCount":"6","status":"M","submitter":"Emmanuel L?charny"}]
