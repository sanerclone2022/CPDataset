[{"authorTime":"2012-12-28 21:01:20","codes":[{"authorDate":"2012-12-28 21:01:20","commitOrder":7,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","date":"2012-12-28 21:01:20","endLine":142,"groupId":"941","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/67/b79dd2a77d4f577e904d42db74609ef97187a9.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"B"},{"authorDate":"2012-12-28 21:01:20","commitOrder":7,"curCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n            }\n        });\n        session.setConnected();\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2012-12-28 21:01:20","endLine":301,"groupId":"941","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(finalSocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/66/aab399ded6c08c14cf2ca3984029a855d81789.src","preCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n            }\n        });\n        session.setConnected();\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"MB"}],"commitId":"c216982db793cf2423b5672921d6daf30c6fb563","commitMessage":"@@@TCP client (WIP)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/mina/trunk@1426490 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-12-28 21:01:20","modifiedFileCount":"15","status":"M","submitter":"Julien Vermillard"},{"authorTime":"2012-12-28 21:01:20","codes":[{"authorDate":"2012-12-29 17:43:17","commitOrder":8,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        final TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","date":"2012-12-29 17:43:17","endLine":206,"groupId":"941","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/b8/9f871f22d960f6fc020e7842ff2cf0c5e443bb.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2012-12-28 21:01:20","commitOrder":8,"curCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n            }\n        });\n        session.setConnected();\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2012-12-28 21:01:20","endLine":301,"groupId":"941","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(finalSocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/66/aab399ded6c08c14cf2ca3984029a855d81789.src","preCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n            }\n        });\n        session.setConnected();\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"N"}],"commitId":"07902d3e801fcf7d1efcbb78c1f9816742036ec3","commitMessage":"@@@set TCP connection timeout (only TCP client now)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/mina/trunk@1426730 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-12-29 17:43:17","modifiedFileCount":"4","status":"M","submitter":"Julien Vermillard"},{"authorTime":"2012-12-28 21:01:20","codes":[{"authorDate":"2013-01-02 20:45:48","commitOrder":9,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","date":"2013-01-02 20:45:48","endLine":209,"groupId":"941","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/50/400cce3066812d961aafe591319f65911b3372.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        final TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"M"},{"authorDate":"2012-12-28 21:01:20","commitOrder":9,"curCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n            }\n        });\n        session.setConnected();\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2012-12-28 21:01:20","endLine":301,"groupId":"941","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(finalSocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/66/aab399ded6c08c14cf2ca3984029a855d81789.src","preCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n            }\n        });\n        session.setConnected();\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"N"}],"commitId":"caa70e6358fd734a70549ded854158170b0c6f15","commitMessage":"@@@o The default constructor will use only 2 threads in the pool\no Removed useless 'final'\no A bit of formatting\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/mina/trunk@1427772 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-01-02 20:45:48","modifiedFileCount":"2","status":"M","submitter":"Emmanuel Lecharny"},{"authorTime":"2013-01-04 08:32:38","codes":[{"authorDate":"2013-01-02 20:45:48","commitOrder":10,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","date":"2013-01-02 20:45:48","endLine":209,"groupId":"941","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/50/400cce3066812d961aafe591319f65911b3372.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":105,"status":"N"},{"authorDate":"2013-01-04 08:32:38","commitOrder":10,"curCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2013-01-04 08:32:38","endLine":302,"groupId":"941","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(finalSocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/4f/941c3444ab1efd608a9f8cf1282c06504b722e.src","preCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n            }\n        });\n        session.setConnected();\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"}],"commitId":"0d23710f57b56ed73b2b68a7809e6b1dde691c5a","commitMessage":"@@@Moved the setConnected() into the register callback.  to make sure it's executed on one single thread\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/mina/trunk@1428682 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-01-04 08:32:38","modifiedFileCount":"2","status":"M","submitter":"Emmanuel Lecharny"},{"authorTime":"2013-01-04 08:32:38","codes":[{"authorDate":"2013-01-04 08:35:14","commitOrder":11,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        address = remoteAddress;\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","date":"2013-01-04 08:35:14","endLine":217,"groupId":"941","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/37/23658b5aec9f5f018b4716a2ae7d8a2972e47e.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"M"},{"authorDate":"2013-01-04 08:32:38","commitOrder":11,"curCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2013-01-04 08:32:38","endLine":302,"groupId":"941","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(finalSocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/4f/941c3444ab1efd608a9f8cf1282c06504b722e.src","preCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"N"}],"commitId":"c1968c8e8695d7d68309a5e1eb49454dba96f51e","commitMessage":"@@@o Added a prefix to the FixedSelectorLooPool to be able to distinguish between a Client and a Server\no Some minor refactoring\n\ngit-svn-id: https://svn.apache.org/repos/asf/mina/mina/trunk@1428683 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-01-04 08:35:14","modifiedFileCount":"7","status":"M","submitter":"Emmanuel Lecharny"},{"authorTime":"2013-03-20 23:36:39","codes":[{"authorDate":"2013-03-20 23:36:39","commitOrder":12,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        address = remoteAddress;\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","date":"2013-03-20 23:36:39","endLine":217,"groupId":"941","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/b3/65ae532badf799f2e2ff36cb8b2dd073a3ecd9.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        address = remoteAddress;\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"M"},{"authorDate":"2013-03-20 23:36:39","commitOrder":12,"curCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2013-03-20 23:36:39","endLine":302,"groupId":"941","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(finalSocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/91/9b2221b5c1295b76e3746ebb3450a31d7df9bc.src","preCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReceiveBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReceiveBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"}],"commitId":"626868afa2d79cca9573574e130e5297d49a7cdd","commitMessage":"@@@o Added a .gitgnore in the benchmarks module\no Bumped up to Netty 3.6.3\no Added netty UDP benchmarks\no Created sub-package (nio and tcp) for the various benchmarks\no Started to refactor the IoSessionConfig implementing classes to take care of UDP\no Started to mplement the UDP client and server\n","date":"2013-03-20 23:36:39","modifiedFileCount":"15","status":"M","submitter":"Emmanuel L?charny"},{"authorTime":"2013-03-22 21:04:48","codes":[{"authorDate":"2013-03-20 23:36:39","commitOrder":13,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        address = remoteAddress;\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","date":"2013-03-20 23:36:39","endLine":217,"groupId":"941","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/b3/65ae532badf799f2e2ff36cb8b2dd073a3ecd9.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        address = remoteAddress;\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"N"},{"authorDate":"2013-03-22 21:04:48","commitOrder":13,"curCode":"    private void createSession(SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        SocketChannel socketChannel = clientSocket;\n        TcpSessionConfig config = getSessionConfig();\n        SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2013-03-22 21:04:48","endLine":343,"groupId":"941","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(SocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/46/e79319759fa1d8d7ce5cbc6d0e8c4c5d707fe7.src","preCode":"    private void createSession(final SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        final SocketChannel socketChannel = clientSocket;\n        final TcpSessionConfig config = getSessionConfig();\n        final SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        final Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        final Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        final Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        final Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        final Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        final Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        final Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        final Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":263,"status":"M"}],"commitId":"6426f182d8092d925864f8a76e7d170f82c66e46","commitMessage":"@@@o Removed some final keyword\no Implemented the first part of the NioUdpServer : handling new session","date":"2013-03-22 21:04:48","modifiedFileCount":"2","status":"M","submitter":"Emmanuel L?charny"},{"authorTime":"2013-03-22 21:04:48","codes":[{"authorDate":"2013-05-26 23:06:59","commitOrder":14,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        } else {\n            int rcvBufferSize = clientSocket.socket().getReceiveBufferSize();\n            session.getConfig().setReadBufferSize(rcvBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        } else {\n            int sndBufferSize = clientSocket.socket().getSendBufferSize();\n            session.getConfig().setSendBufferSize(sndBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        ConnectFuture connectFuture = new ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","date":"2013-05-26 23:06:59","endLine":220,"groupId":"2325","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/80/2bae938f70ffd8f64f13bde04729f89df853ad.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        address = remoteAddress;\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        NioTcpSession.ConnectFuture connectFuture = new NioTcpSession.ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"M"},{"authorDate":"2013-03-22 21:04:48","commitOrder":14,"curCode":"    private void createSession(SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        SocketChannel socketChannel = clientSocket;\n        TcpSessionConfig config = getSessionConfig();\n        SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2013-03-22 21:04:48","endLine":343,"groupId":"941","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(SocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/46/e79319759fa1d8d7ce5cbc6d0e8c4c5d707fe7.src","preCode":"    private void createSession(SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        SocketChannel socketChannel = clientSocket;\n        TcpSessionConfig config = getSessionConfig();\n        SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":263,"status":"N"}],"commitId":"8ee4890b444f3315ab5cc960d905edc83339d82b","commitMessage":"@@@adding BIO based UDP server (WIP)\n","date":"2013-05-26 23:06:59","modifiedFileCount":"24","status":"M","submitter":"jvermillard"},{"authorTime":"2013-03-22 21:04:48","codes":[{"authorDate":"2013-06-06 21:18:06","commitOrder":15,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket;\n        try {\n            clientSocket = SocketChannel.open();\n        } catch (IOException e) {\n            throw new MinaRuntimeException(\"can't create a new socket, out of file descriptors ?\", e);\n        }\n\n        try {\n            clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n        } catch (SocketException e) {\n            throw new MinaRuntimeException(\"can't set socket timeout\", e);\n        }\n\n        \r\n        try {\n            clientSocket.configureBlocking(false);\n        } catch (IOException e) {\n            throw new MinaRuntimeException(\"can't configure socket as non-blocking\", e);\n        }\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        } else {\n            int rcvBufferSize;\n            try {\n                rcvBufferSize = clientSocket.socket().getReceiveBufferSize();\n            } catch (SocketException e) {\n                throw new MinaRuntimeException(\"can't configure socket receive buffer size\", e);\n            }\n            session.getConfig().setReadBufferSize(rcvBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        } else {\n            int sndBufferSize;\n            try {\n                sndBufferSize = clientSocket.socket().getSendBufferSize();\n            } catch (SocketException e) {\n                throw new MinaRuntimeException(\"can't configure socket send buffe size\", e);\n            }\n            session.getConfig().setSendBufferSize(sndBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected;\n        try {\n            connected = clientSocket.connect(remoteAddress);\n        } catch (IOException e) {\n            ConnectFuture future = new ConnectFuture();\n            future.cannotConnect(e);\n            return future;\n        }\n\n        ConnectFuture connectFuture = new ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","date":"2013-06-06 21:18:06","endLine":252,"groupId":"2325","id":17,"instanceNumber":1,"isCurCommit":1,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/1d/ae3335f8b01590578f3f87e3018466c11d7f01.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) throws IOException {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket = SocketChannel.open();\n\n        clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n\n        \r\n        clientSocket.configureBlocking(false);\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        } else {\n            int rcvBufferSize = clientSocket.socket().getReceiveBufferSize();\n            session.getConfig().setReadBufferSize(rcvBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        } else {\n            int sndBufferSize = clientSocket.socket().getSendBufferSize();\n            session.getConfig().setSendBufferSize(sndBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected = clientSocket.connect(remoteAddress);\n\n        ConnectFuture connectFuture = new ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"M"},{"authorDate":"2013-03-22 21:04:48","commitOrder":15,"curCode":"    private void createSession(SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        SocketChannel socketChannel = clientSocket;\n        TcpSessionConfig config = getSessionConfig();\n        SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2013-03-22 21:04:48","endLine":343,"groupId":"941","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"createSession","params":"(SocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/46/e79319759fa1d8d7ce5cbc6d0e8c4c5d707fe7.src","preCode":"    private void createSession(SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        SocketChannel socketChannel = clientSocket;\n        TcpSessionConfig config = getSessionConfig();\n        SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":263,"status":"N"}],"commitId":"7b9e82d2532cf4e58c922c04b710f4848eed5b1a","commitMessage":"@@@removed IOException on connection methods\n","date":"2013-06-06 21:18:06","modifiedFileCount":"10","status":"M","submitter":"jvermillard"},{"authorTime":"2013-06-20 08:17:48","codes":[{"authorDate":"2013-06-06 21:18:06","commitOrder":16,"curCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket;\n        try {\n            clientSocket = SocketChannel.open();\n        } catch (IOException e) {\n            throw new MinaRuntimeException(\"can't create a new socket, out of file descriptors ?\", e);\n        }\n\n        try {\n            clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n        } catch (SocketException e) {\n            throw new MinaRuntimeException(\"can't set socket timeout\", e);\n        }\n\n        \r\n        try {\n            clientSocket.configureBlocking(false);\n        } catch (IOException e) {\n            throw new MinaRuntimeException(\"can't configure socket as non-blocking\", e);\n        }\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        } else {\n            int rcvBufferSize;\n            try {\n                rcvBufferSize = clientSocket.socket().getReceiveBufferSize();\n            } catch (SocketException e) {\n                throw new MinaRuntimeException(\"can't configure socket receive buffer size\", e);\n            }\n            session.getConfig().setReadBufferSize(rcvBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        } else {\n            int sndBufferSize;\n            try {\n                sndBufferSize = clientSocket.socket().getSendBufferSize();\n            } catch (SocketException e) {\n                throw new MinaRuntimeException(\"can't configure socket send buffe size\", e);\n            }\n            session.getConfig().setSendBufferSize(sndBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected;\n        try {\n            connected = clientSocket.connect(remoteAddress);\n        } catch (IOException e) {\n            ConnectFuture future = new ConnectFuture();\n            future.cannotConnect(e);\n            return future;\n        }\n\n        ConnectFuture connectFuture = new ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","date":"2013-06-06 21:18:06","endLine":252,"groupId":"1043","id":19,"instanceNumber":1,"isCurCommit":1,"methodName":"connect","params":"(SocketAddressremoteAddress)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/1d/ae3335f8b01590578f3f87e3018466c11d7f01.src","preCode":"    public IoFuture<IoSession> connect(SocketAddress remoteAddress) {\n        Assert.assertNotNull(remoteAddress, \"remoteAddress\");\n\n        SocketChannel clientSocket;\n        try {\n            clientSocket = SocketChannel.open();\n        } catch (IOException e) {\n            throw new MinaRuntimeException(\"can't create a new socket, out of file descriptors ?\", e);\n        }\n\n        try {\n            clientSocket.socket().setSoTimeout(getConnectTimeoutMillis());\n        } catch (SocketException e) {\n            throw new MinaRuntimeException(\"can't set socket timeout\", e);\n        }\n\n        \r\n        try {\n            clientSocket.configureBlocking(false);\n        } catch (IOException e) {\n            throw new MinaRuntimeException(\"can't configure socket as non-blocking\", e);\n        }\n\n        \r\n        \r\n        final NioTcpSession session = new NioTcpSession(this, clientSocket, readWriteSelectorPool.getSelectorLoop(),\n                idleChecker);\n        TcpSessionConfig config = getSessionConfig();\n\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        } else {\n            int rcvBufferSize;\n            try {\n                rcvBufferSize = clientSocket.socket().getReceiveBufferSize();\n            } catch (SocketException e) {\n                throw new MinaRuntimeException(\"can't configure socket receive buffer size\", e);\n            }\n            session.getConfig().setReadBufferSize(rcvBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        } else {\n            int sndBufferSize;\n            try {\n                sndBufferSize = clientSocket.socket().getSendBufferSize();\n            } catch (SocketException e) {\n                throw new MinaRuntimeException(\"can't configure socket send buffe size\", e);\n            }\n            session.getConfig().setSendBufferSize(sndBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        \r\n        boolean connected;\n        try {\n            connected = clientSocket.connect(remoteAddress);\n        } catch (IOException e) {\n            ConnectFuture future = new ConnectFuture();\n            future.cannotConnect(e);\n            return future;\n        }\n\n        ConnectFuture connectFuture = new ConnectFuture();\n        session.setConnectFuture(connectFuture);\n\n        if (!connected) {\n            \r\n            \r\n            connectSelectorLoop.register(false, true, false, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n        } else {\n            \r\n            \r\n            connectSelectorLoop.register(false, false, true, false, session, clientSocket, new RegistrationCallback() {\n\n                @Override\n                public void done(SelectionKey selectionKey) {\n                    session.setSelectionKey(selectionKey);\n                }\n            });\n\n            session.setConnected();\n        }\n\n        return connectFuture;\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpClient.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":110,"status":"N"},{"authorDate":"2013-06-20 08:17:48","commitOrder":16,"curCode":"    private synchronized void createSession(SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        SocketChannel socketChannel = clientSocket;\n        TcpSessionConfig config = getSessionConfig();\n        SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","date":"2013-06-20 08:17:48","endLine":353,"groupId":"1043","id":20,"instanceNumber":2,"isCurCommit":1,"methodName":"createSession","params":"(SocketChannelclientSocket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/ef/5bf4b6bc478a5890e4da879c822c8e4192d35d.src","preCode":"    private void createSession(SocketChannel clientSocket) throws IOException {\n        LOG.debug(\"create session\");\n        SocketChannel socketChannel = clientSocket;\n        TcpSessionConfig config = getSessionConfig();\n        SelectorLoop readWriteSelectorLoop = readWriteSelectorPool.getSelectorLoop();\n        final NioTcpSession session = new NioTcpSession(this, socketChannel, readWriteSelectorLoop, idleChecker);\n\n        socketChannel.configureBlocking(false);\n\n        \r\n        session.getConfig().setIdleTimeInMillis(IdleStatus.READ_IDLE, config.getIdleTimeInMillis(IdleStatus.READ_IDLE));\n        session.getConfig().setIdleTimeInMillis(IdleStatus.WRITE_IDLE,\n                config.getIdleTimeInMillis(IdleStatus.WRITE_IDLE));\n\n        \r\n        Boolean keepAlive = config.isKeepAlive();\n\n        if (keepAlive != null) {\n            session.getConfig().setKeepAlive(keepAlive);\n        }\n\n        Boolean oobInline = config.isOobInline();\n\n        if (oobInline != null) {\n            session.getConfig().setOobInline(oobInline);\n        }\n\n        Boolean reuseAddress = config.isReuseAddress();\n\n        if (reuseAddress != null) {\n            session.getConfig().setReuseAddress(reuseAddress);\n        }\n\n        Boolean tcpNoDelay = config.isTcpNoDelay();\n\n        if (tcpNoDelay != null) {\n            session.getConfig().setTcpNoDelay(tcpNoDelay);\n        }\n\n        Integer receiveBufferSize = config.getReadBufferSize();\n\n        if (receiveBufferSize != null) {\n            session.getConfig().setReadBufferSize(receiveBufferSize);\n        }\n\n        Integer sendBufferSize = config.getSendBufferSize();\n\n        if (sendBufferSize != null) {\n            session.getConfig().setSendBufferSize(sendBufferSize);\n        }\n\n        Integer trafficClass = config.getTrafficClass();\n\n        if (trafficClass != null) {\n            session.getConfig().setTrafficClass(trafficClass);\n        }\n\n        Integer soLinger = config.getSoLinger();\n\n        if (soLinger != null) {\n            session.getConfig().setSoLinger(soLinger);\n        }\n\n        \r\n        if (config.isSecured()) {\n            session.initSecure(config.getSslContext());\n        }\n\n        \r\n        readWriteSelectorLoop.register(false, false, true, false, session, socketChannel, new RegistrationCallback() {\n\n            @Override\n            public void done(SelectionKey selectionKey) {\n                session.setSelectionKey(selectionKey);\n                session.setConnected();\n            }\n        });\n\n        idleChecker.sessionRead(session, System.currentTimeMillis());\n        idleChecker.sessionWritten(session, System.currentTimeMillis());\n    }\n","realPath":"core/src/main/java/org/apache/mina/transport/nio/NioTcpServer.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":273,"status":"M"}],"commitId":"0163b5b1b61009bfbfbd4d250fdb38efd01a8cdb","commitMessage":"@@@Updated the NOTICE and LICENSE files\n","date":"2013-06-20 08:17:48","modifiedFileCount":"2","status":"M","submitter":"Emmanuel L?charny"}]
