[{"authorTime":"2013-04-08 00:21:47","codes":[{"authorDate":"2013-04-08 00:21:47","commitOrder":1,"curCode":"    private String[] decodeAuto(Context ctx, ByteBuffer in) {\n        List<String> decoded = new ArrayList<String>();\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining()) {\n            byte b = in.get();\n            boolean matched = false;\n\n            switch (b) {\n            case '\\r':\n                \r\n                \r\n                matchCount++;\n                break;\n\n            case '\\n':\n                \r\n                matchCount++;\n                matched = true;\n                break;\n\n            default:\n                matchCount = 0;\n            }\n\n            if (matched) {\n                \r\n                int pos = in.position();\n                in.limit(pos);\n                in.position(oldPos);\n\n                ctx.append(in);\n\n                in.limit(oldLimit);\n                in.position(pos);\n\n                try {\n                    if (ctx.getOverflowLength() == 0) {\n                        ByteBuffer buf = ctx.getBuffer();\n                        buf.flip();\n                        buf.limit(buf.limit() - matchCount);\n\n                        CharsetDecoder decoder = ctx.getDecoder();\n                        CharBuffer buffer = decoder.decode(buf);\n                        String str = new String(buffer.array());\n                        decoded.add(str);\n                    } else {\n                        int overflowPosition = ctx.getOverflowLength();\n                        throw new IllegalStateException(\"Line is too long: \" + overflowPosition);\n                    }\n                } catch (CharacterCodingException cce) {\n                    throw new RuntimeException(cce);\n                } finally {\n                    ctx.reset();\n                }\n                oldPos = pos;\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded.toArray(new String[decoded.size()]);\n    }\n","date":"2013-04-08 00:21:47","endLine":258,"groupId":"354","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"decodeAuto","params":"(Contextctx@ByteBufferin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/84/5ee242dce81445368d0191a0f603bc8c09e399.src","preCode":"    private String[] decodeAuto(Context ctx, ByteBuffer in) {\n        List<String> decoded = new ArrayList<String>();\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining()) {\n            byte b = in.get();\n            boolean matched = false;\n\n            switch (b) {\n            case '\\r':\n                \r\n                \r\n                matchCount++;\n                break;\n\n            case '\\n':\n                \r\n                matchCount++;\n                matched = true;\n                break;\n\n            default:\n                matchCount = 0;\n            }\n\n            if (matched) {\n                \r\n                int pos = in.position();\n                in.limit(pos);\n                in.position(oldPos);\n\n                ctx.append(in);\n\n                in.limit(oldLimit);\n                in.position(pos);\n\n                try {\n                    if (ctx.getOverflowLength() == 0) {\n                        ByteBuffer buf = ctx.getBuffer();\n                        buf.flip();\n                        buf.limit(buf.limit() - matchCount);\n\n                        CharsetDecoder decoder = ctx.getDecoder();\n                        CharBuffer buffer = decoder.decode(buf);\n                        String str = new String(buffer.array());\n                        decoded.add(str);\n                    } else {\n                        int overflowPosition = ctx.getOverflowLength();\n                        throw new IllegalStateException(\"Line is too long: \" + overflowPosition);\n                    }\n                } catch (CharacterCodingException cce) {\n                    throw new RuntimeException(cce);\n                } finally {\n                    ctx.reset();\n                }\n                oldPos = pos;\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded.toArray(new String[decoded.size()]);\n    }\n","realPath":"codec/src/main/java/org/apache/mina/codec/textline/TextLineDecoder.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"B"},{"authorDate":"2013-04-08 00:21:47","commitOrder":1,"curCode":"    private String[] decodeNormal(Context ctx, ByteBuffer in) {\n        List<String> decoded = new ArrayList<String>();\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining()) {\n            byte b = in.get();\n\n            if (delimBuf.get(matchCount) == b) {\n                matchCount++;\n\n                if (matchCount == delimBuf.limit()) {\n                    \r\n                    int pos = in.position();\n                    in.limit(pos);\n                    in.position(oldPos);\n\n                    ctx.append(in);\n\n                    in.limit(oldLimit);\n                    in.position(pos);\n\n                    try {\n                        if (ctx.getOverflowLength() == 0) {\n                            ByteBuffer buf = ctx.getBuffer();\n                            buf.flip();\n                            buf.limit(buf.limit() - matchCount);\n\n                            CharsetDecoder decoder = ctx.getDecoder();\n                            CharBuffer buffer = decoder.decode(buf);\n                            String str = new String(buffer.array());\n                            decoded.add(str);\n                        } else {\n                            int overflowLength = ctx.getOverflowLength();\n                            throw new IllegalStateException(\"Line is too long: \" + overflowLength);\n                        }\n                    } catch (CharacterCodingException cce) {\n                        throw new RuntimeException(cce);\n                    } finally {\n                        ctx.reset();\n                    }\n                    \n\n                    oldPos = pos;\n                    matchCount = 0;\n                }\n            } else {\n                \r\n                in.position(Math.max(0, in.position() - matchCount));\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded.toArray(new String[decoded.size()]);\n    }\n","date":"2013-04-08 00:21:47","endLine":326,"groupId":"355","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"decodeNormal","params":"(Contextctx@ByteBufferin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/84/5ee242dce81445368d0191a0f603bc8c09e399.src","preCode":"    private String[] decodeNormal(Context ctx, ByteBuffer in) {\n        List<String> decoded = new ArrayList<String>();\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining()) {\n            byte b = in.get();\n\n            if (delimBuf.get(matchCount) == b) {\n                matchCount++;\n\n                if (matchCount == delimBuf.limit()) {\n                    \r\n                    int pos = in.position();\n                    in.limit(pos);\n                    in.position(oldPos);\n\n                    ctx.append(in);\n\n                    in.limit(oldLimit);\n                    in.position(pos);\n\n                    try {\n                        if (ctx.getOverflowLength() == 0) {\n                            ByteBuffer buf = ctx.getBuffer();\n                            buf.flip();\n                            buf.limit(buf.limit() - matchCount);\n\n                            CharsetDecoder decoder = ctx.getDecoder();\n                            CharBuffer buffer = decoder.decode(buf);\n                            String str = new String(buffer.array());\n                            decoded.add(str);\n                        } else {\n                            int overflowLength = ctx.getOverflowLength();\n                            throw new IllegalStateException(\"Line is too long: \" + overflowLength);\n                        }\n                    } catch (CharacterCodingException cce) {\n                        throw new RuntimeException(cce);\n                    } finally {\n                        ctx.reset();\n                    }\n                    \n\n                    oldPos = pos;\n                    matchCount = 0;\n                }\n            } else {\n                \r\n                in.position(Math.max(0, in.position() - matchCount));\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded.toArray(new String[decoded.size()]);\n    }\n","realPath":"codec/src/main/java/org/apache/mina/codec/textline/TextLineDecoder.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":264,"status":"B"}],"commitId":"653d1a5ff37904e4515bc375d24dcb301862dad4","commitMessage":"@@@Added text line coded and related unit tests\n","date":"2013-04-08 00:21:47","modifiedFileCount":"0","status":"B","submitter":"Jeff MAURY"},{"authorTime":"2013-04-10 20:27:18","codes":[{"authorDate":"2013-04-10 20:27:18","commitOrder":2,"curCode":"    private String decodeAuto(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n            boolean matched = false;\n\n            switch (b) {\n            case '\\r':\n                \r\n                \r\n                matchCount++;\n                break;\n\n            case '\\n':\n                \r\n                matchCount++;\n                matched = true;\n                break;\n\n            default:\n                matchCount = 0;\n            }\n\n            if (matched) {\n                \r\n                int pos = in.position();\n                in.limit(pos);\n                in.position(oldPos);\n\n                ctx.append(in);\n\n                in.limit(oldLimit);\n                in.position(pos);\n\n                try {\n                    if (ctx.getOverflowLength() == 0) {\n                        ByteBuffer buf = ctx.getBuffer();\n                        buf.flip();\n                        buf.limit(buf.limit() - matchCount);\n\n                        CharsetDecoder decoder = ctx.getDecoder();\n                        CharBuffer buffer = decoder.decode(buf);\n                        decoded = new String(buffer.array());\n                    } else {\n                        int overflowPosition = ctx.getOverflowLength();\n                        throw new IllegalStateException(\"Line is too long: \" + overflowPosition);\n                    }\n                } catch (CharacterCodingException cce) {\n                    throw new RuntimeException(cce);\n                } finally {\n                    ctx.reset();\n                }\n                oldPos = pos;\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","date":"2013-04-10 20:27:18","endLine":245,"groupId":"354","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"decodeAuto","params":"(Contextctx@ByteBufferin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/9c/cb324971bd91ffbb3d33c1edd47576368bb4f2.src","preCode":"    private String[] decodeAuto(Context ctx, ByteBuffer in) {\n        List<String> decoded = new ArrayList<String>();\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining()) {\n            byte b = in.get();\n            boolean matched = false;\n\n            switch (b) {\n            case '\\r':\n                \r\n                \r\n                matchCount++;\n                break;\n\n            case '\\n':\n                \r\n                matchCount++;\n                matched = true;\n                break;\n\n            default:\n                matchCount = 0;\n            }\n\n            if (matched) {\n                \r\n                int pos = in.position();\n                in.limit(pos);\n                in.position(oldPos);\n\n                ctx.append(in);\n\n                in.limit(oldLimit);\n                in.position(pos);\n\n                try {\n                    if (ctx.getOverflowLength() == 0) {\n                        ByteBuffer buf = ctx.getBuffer();\n                        buf.flip();\n                        buf.limit(buf.limit() - matchCount);\n\n                        CharsetDecoder decoder = ctx.getDecoder();\n                        CharBuffer buffer = decoder.decode(buf);\n                        String str = new String(buffer.array());\n                        decoded.add(str);\n                    } else {\n                        int overflowPosition = ctx.getOverflowLength();\n                        throw new IllegalStateException(\"Line is too long: \" + overflowPosition);\n                    }\n                } catch (CharacterCodingException cce) {\n                    throw new RuntimeException(cce);\n                } finally {\n                    ctx.reset();\n                }\n                oldPos = pos;\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded.toArray(new String[decoded.size()]);\n    }\n","realPath":"codec/src/main/java/org/apache/mina/codec/textline/TextLineDecoder.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"M"},{"authorDate":"2013-04-10 20:27:18","commitOrder":2,"curCode":"    private String decodeNormal(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n\n            if (delimBuf.get(matchCount) == b) {\n                matchCount++;\n\n                if (matchCount == delimBuf.limit()) {\n                    \r\n                    int pos = in.position();\n                    in.limit(pos);\n                    in.position(oldPos);\n\n                    ctx.append(in);\n\n                    in.limit(oldLimit);\n                    in.position(pos);\n\n                    try {\n                        if (ctx.getOverflowLength() == 0) {\n                            ByteBuffer buf = ctx.getBuffer();\n                            buf.flip();\n                            buf.limit(buf.limit() - matchCount);\n\n                            CharsetDecoder decoder = ctx.getDecoder();\n                            CharBuffer buffer = decoder.decode(buf);\n                            decoded = new String(buffer.array());\n                        } else {\n                            int overflowLength = ctx.getOverflowLength();\n                            throw new IllegalStateException(\"Line is too long: \" + overflowLength);\n                        }\n                    } catch (CharacterCodingException cce) {\n                        throw new RuntimeException(cce);\n                    } finally {\n                        ctx.reset();\n                    }\n\n                    oldPos = pos;\n                    matchCount = 0;\n                }\n            } else {\n                \r\n                in.position(Math.max(0, in.position() - matchCount));\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","date":"2013-04-10 20:27:18","endLine":312,"groupId":"355","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"decodeNormal","params":"(Contextctx@ByteBufferin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/9c/cb324971bd91ffbb3d33c1edd47576368bb4f2.src","preCode":"    private String[] decodeNormal(Context ctx, ByteBuffer in) {\n        List<String> decoded = new ArrayList<String>();\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining()) {\n            byte b = in.get();\n\n            if (delimBuf.get(matchCount) == b) {\n                matchCount++;\n\n                if (matchCount == delimBuf.limit()) {\n                    \r\n                    int pos = in.position();\n                    in.limit(pos);\n                    in.position(oldPos);\n\n                    ctx.append(in);\n\n                    in.limit(oldLimit);\n                    in.position(pos);\n\n                    try {\n                        if (ctx.getOverflowLength() == 0) {\n                            ByteBuffer buf = ctx.getBuffer();\n                            buf.flip();\n                            buf.limit(buf.limit() - matchCount);\n\n                            CharsetDecoder decoder = ctx.getDecoder();\n                            CharBuffer buffer = decoder.decode(buf);\n                            String str = new String(buffer.array());\n                            decoded.add(str);\n                        } else {\n                            int overflowLength = ctx.getOverflowLength();\n                            throw new IllegalStateException(\"Line is too long: \" + overflowLength);\n                        }\n                    } catch (CharacterCodingException cce) {\n                        throw new RuntimeException(cce);\n                    } finally {\n                        ctx.reset();\n                    }\n                    \n\n                    oldPos = pos;\n                    matchCount = 0;\n                }\n            } else {\n                \r\n                in.position(Math.max(0, in.position() - matchCount));\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded.toArray(new String[decoded.size()]);\n    }\n","realPath":"codec/src/main/java/org/apache/mina/codec/textline/TextLineDecoder.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"M"}],"commitId":"3d3767d6287bb12377b96fa12922aeccfdc9d02e","commitMessage":"@@@now return only one object and not an array from the ProtocolDecoder\n","date":"2013-04-10 20:27:18","modifiedFileCount":"9","status":"M","submitter":"jvermillard"},{"authorTime":"2013-05-15 23:03:47","codes":[{"authorDate":"2013-05-15 23:03:47","commitOrder":3,"curCode":"    private String decodeAuto(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n            boolean matched = false;\n\n            switch (b) {\n            case '\\r':\n                \r\n                \r\n                matchCount++;\n                break;\n\n            case '\\n':\n                \r\n                matchCount++;\n                matched = true;\n                break;\n\n            default:\n                matchCount = 0;\n            }\n\n            if (matched) {\n                \r\n                int pos = in.position();\n                in.limit(pos);\n                in.position(oldPos);\n\n                ctx.append(in);\n\n                in.limit(oldLimit);\n                in.position(pos);\n\n                try {\n                    if (ctx.getOverflowLength() == 0) {\n                        ByteBuffer buf = ctx.getBuffer();\n                        buf.flip();\n                        buf.limit(buf.limit() - matchCount);\n\n                        CharsetDecoder decoder = ctx.getDecoder();\n                        CharBuffer buffer = decoder.decode(buf);\n                        decoded = new String(buffer.array());\n                    } else {\n                        int overflowPosition = ctx.getOverflowLength();\n                        throw new IllegalStateException(\"Line is too long: \" + overflowPosition);\n                    }\n                } catch (CharacterCodingException cce) {\n                    throw new ProtocolDecoderException(cce);\n                } finally {\n                    ctx.reset();\n                }\n                oldPos = pos;\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","date":"2013-05-15 23:03:47","endLine":246,"groupId":"354","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"decodeAuto","params":"(Contextctx@ByteBufferin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/66/16b39ec220bef189e35344b399f87d0cb4fb1e.src","preCode":"    private String decodeAuto(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n            boolean matched = false;\n\n            switch (b) {\n            case '\\r':\n                \r\n                \r\n                matchCount++;\n                break;\n\n            case '\\n':\n                \r\n                matchCount++;\n                matched = true;\n                break;\n\n            default:\n                matchCount = 0;\n            }\n\n            if (matched) {\n                \r\n                int pos = in.position();\n                in.limit(pos);\n                in.position(oldPos);\n\n                ctx.append(in);\n\n                in.limit(oldLimit);\n                in.position(pos);\n\n                try {\n                    if (ctx.getOverflowLength() == 0) {\n                        ByteBuffer buf = ctx.getBuffer();\n                        buf.flip();\n                        buf.limit(buf.limit() - matchCount);\n\n                        CharsetDecoder decoder = ctx.getDecoder();\n                        CharBuffer buffer = decoder.decode(buf);\n                        decoded = new String(buffer.array());\n                    } else {\n                        int overflowPosition = ctx.getOverflowLength();\n                        throw new IllegalStateException(\"Line is too long: \" + overflowPosition);\n                    }\n                } catch (CharacterCodingException cce) {\n                    throw new RuntimeException(cce);\n                } finally {\n                    ctx.reset();\n                }\n                oldPos = pos;\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","realPath":"codec/src/main/java/org/apache/mina/codec/textline/TextLineDecoder.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":177,"status":"M"},{"authorDate":"2013-05-15 23:03:47","commitOrder":3,"curCode":"    private String decodeNormal(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n\n            if (delimBuf.get(matchCount) == b) {\n                matchCount++;\n\n                if (matchCount == delimBuf.limit()) {\n                    \r\n                    int pos = in.position();\n                    in.limit(pos);\n                    in.position(oldPos);\n\n                    ctx.append(in);\n\n                    in.limit(oldLimit);\n                    in.position(pos);\n\n                    try {\n                        if (ctx.getOverflowLength() == 0) {\n                            ByteBuffer buf = ctx.getBuffer();\n                            buf.flip();\n                            buf.limit(buf.limit() - matchCount);\n\n                            CharsetDecoder decoder = ctx.getDecoder();\n                            CharBuffer buffer = decoder.decode(buf);\n                            decoded = new String(buffer.array());\n                        } else {\n                            int overflowLength = ctx.getOverflowLength();\n                            throw new IllegalStateException(\"Line is too long: \" + overflowLength);\n                        }\n                    } catch (CharacterCodingException cce) {\n                        throw new ProtocolDecoderException(cce);\n                    } finally {\n                        ctx.reset();\n                    }\n\n                    oldPos = pos;\n                    matchCount = 0;\n                }\n            } else {\n                \r\n                in.position(Math.max(0, in.position() - matchCount));\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","date":"2013-05-15 23:03:47","endLine":313,"groupId":"355","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"decodeNormal","params":"(Contextctx@ByteBufferin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/66/16b39ec220bef189e35344b399f87d0cb4fb1e.src","preCode":"    private String decodeNormal(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n\n            if (delimBuf.get(matchCount) == b) {\n                matchCount++;\n\n                if (matchCount == delimBuf.limit()) {\n                    \r\n                    int pos = in.position();\n                    in.limit(pos);\n                    in.position(oldPos);\n\n                    ctx.append(in);\n\n                    in.limit(oldLimit);\n                    in.position(pos);\n\n                    try {\n                        if (ctx.getOverflowLength() == 0) {\n                            ByteBuffer buf = ctx.getBuffer();\n                            buf.flip();\n                            buf.limit(buf.limit() - matchCount);\n\n                            CharsetDecoder decoder = ctx.getDecoder();\n                            CharBuffer buffer = decoder.decode(buf);\n                            decoded = new String(buffer.array());\n                        } else {\n                            int overflowLength = ctx.getOverflowLength();\n                            throw new IllegalStateException(\"Line is too long: \" + overflowLength);\n                        }\n                    } catch (CharacterCodingException cce) {\n                        throw new RuntimeException(cce);\n                    } finally {\n                        ctx.reset();\n                    }\n\n                    oldPos = pos;\n                    matchCount = 0;\n                }\n            } else {\n                \r\n                in.position(Math.max(0, in.position() - matchCount));\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","realPath":"codec/src/main/java/org/apache/mina/codec/textline/TextLineDecoder.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"M"}],"commitId":"bf206173164866cd7c4091e84c6eb0da5189d472","commitMessage":"@@@Merge branch 'trunk' of http://git-wip-us.apache.org/repos/asf/mina into trunk\n","date":"2013-05-15 23:03:47","modifiedFileCount":"9","status":"M","submitter":"Emmanuel L?charny"},{"authorTime":"2013-05-15 23:03:47","codes":[{"authorDate":"2014-09-05 18:26:31","commitOrder":4,"curCode":"    private String decodeAuto(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n            boolean matched = false;\n\n            switch (b) {\n            case '\\r':\n                \r\n                \r\n                matchCount++;\n                break;\n\n            case '\\n':\n                \r\n                matchCount++;\n                matched = true;\n                break;\n\n            default:\n                matchCount = 0;\n            }\n\n            if (matched) {\n                \r\n                int pos = in.position();\n                in.limit(pos);\n                in.position(oldPos);\n\n                ctx.append(in);\n\n                in.limit(oldLimit);\n                in.position(pos);\n\n                try {\n                    if (ctx.getOverflowLength() == 0) {\n                        ByteBuffer buf = ctx.getBuffer();\n                        buf.flip();\n                        buf.limit(buf.limit() - matchCount);\n\n                        CharsetDecoder decoder = ctx.getDecoder();\n                        CharBuffer buffer = decoder.decode(buf);\n                        decoded = buffer.toString();\n                    } else {\n                        int overflowPosition = ctx.getOverflowLength();\n                        throw new IllegalStateException(\"Line is too long: \" + overflowPosition);\n                    }\n                } catch (CharacterCodingException cce) {\n                    throw new ProtocolDecoderException(cce);\n                } finally {\n                    ctx.reset();\n                }\n                oldPos = pos;\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","date":"2014-09-05 18:26:31","endLine":257,"groupId":"10129","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"decodeAuto","params":"(Contextctx@ByteBufferin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/0a/cd2b0a03c5bac6c93f4fc4f3d3d4223ad619b3.src","preCode":"    private String decodeAuto(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n            boolean matched = false;\n\n            switch (b) {\n            case '\\r':\n                \r\n                \r\n                matchCount++;\n                break;\n\n            case '\\n':\n                \r\n                matchCount++;\n                matched = true;\n                break;\n\n            default:\n                matchCount = 0;\n            }\n\n            if (matched) {\n                \r\n                int pos = in.position();\n                in.limit(pos);\n                in.position(oldPos);\n\n                ctx.append(in);\n\n                in.limit(oldLimit);\n                in.position(pos);\n\n                try {\n                    if (ctx.getOverflowLength() == 0) {\n                        ByteBuffer buf = ctx.getBuffer();\n                        buf.flip();\n                        buf.limit(buf.limit() - matchCount);\n\n                        CharsetDecoder decoder = ctx.getDecoder();\n                        CharBuffer buffer = decoder.decode(buf);\n                        decoded = new String(buffer.array());\n                    } else {\n                        int overflowPosition = ctx.getOverflowLength();\n                        throw new IllegalStateException(\"Line is too long: \" + overflowPosition);\n                    }\n                } catch (CharacterCodingException cce) {\n                    throw new ProtocolDecoderException(cce);\n                } finally {\n                    ctx.reset();\n                }\n                oldPos = pos;\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","realPath":"codec/src/main/java/org/apache/mina/codec/textline/TextLineDecoder.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":188,"status":"M"},{"authorDate":"2013-05-15 23:03:47","commitOrder":4,"curCode":"    private String decodeNormal(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n\n            if (delimBuf.get(matchCount) == b) {\n                matchCount++;\n\n                if (matchCount == delimBuf.limit()) {\n                    \r\n                    int pos = in.position();\n                    in.limit(pos);\n                    in.position(oldPos);\n\n                    ctx.append(in);\n\n                    in.limit(oldLimit);\n                    in.position(pos);\n\n                    try {\n                        if (ctx.getOverflowLength() == 0) {\n                            ByteBuffer buf = ctx.getBuffer();\n                            buf.flip();\n                            buf.limit(buf.limit() - matchCount);\n\n                            CharsetDecoder decoder = ctx.getDecoder();\n                            CharBuffer buffer = decoder.decode(buf);\n                            decoded = new String(buffer.array());\n                        } else {\n                            int overflowLength = ctx.getOverflowLength();\n                            throw new IllegalStateException(\"Line is too long: \" + overflowLength);\n                        }\n                    } catch (CharacterCodingException cce) {\n                        throw new ProtocolDecoderException(cce);\n                    } finally {\n                        ctx.reset();\n                    }\n\n                    oldPos = pos;\n                    matchCount = 0;\n                }\n            } else {\n                \r\n                in.position(Math.max(0, in.position() - matchCount));\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","date":"2013-05-15 23:03:47","endLine":313,"groupId":"10129","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"decodeNormal","params":"(Contextctx@ByteBufferin)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-mina-10-0.7/blobInfo/CC_OUT/blobs/66/16b39ec220bef189e35344b399f87d0cb4fb1e.src","preCode":"    private String decodeNormal(Context ctx, ByteBuffer in) {\n        String decoded = null;\n        int matchCount = ctx.getMatchCount();\n\n        \r\n        int oldPos = in.position();\n        int oldLimit = in.limit();\n\n        while (in.hasRemaining() && decoded == null) {\n            byte b = in.get();\n\n            if (delimBuf.get(matchCount) == b) {\n                matchCount++;\n\n                if (matchCount == delimBuf.limit()) {\n                    \r\n                    int pos = in.position();\n                    in.limit(pos);\n                    in.position(oldPos);\n\n                    ctx.append(in);\n\n                    in.limit(oldLimit);\n                    in.position(pos);\n\n                    try {\n                        if (ctx.getOverflowLength() == 0) {\n                            ByteBuffer buf = ctx.getBuffer();\n                            buf.flip();\n                            buf.limit(buf.limit() - matchCount);\n\n                            CharsetDecoder decoder = ctx.getDecoder();\n                            CharBuffer buffer = decoder.decode(buf);\n                            decoded = new String(buffer.array());\n                        } else {\n                            int overflowLength = ctx.getOverflowLength();\n                            throw new IllegalStateException(\"Line is too long: \" + overflowLength);\n                        }\n                    } catch (CharacterCodingException cce) {\n                        throw new ProtocolDecoderException(cce);\n                    } finally {\n                        ctx.reset();\n                    }\n\n                    oldPos = pos;\n                    matchCount = 0;\n                }\n            } else {\n                \r\n                in.position(Math.max(0, in.position() - matchCount));\n                matchCount = 0;\n            }\n        }\n\n        \r\n        in.position(oldPos);\n        ctx.append(in);\n\n        ctx.setMatchCount(matchCount);\n        return decoded;\n    }\n","realPath":"codec/src/main/java/org/apache/mina/codec/textline/TextLineDecoder.java","repoName":"mina","snippetEndLine":0,"snippetStartLine":0,"startLine":253,"status":"N"}],"commitId":"f80e27db1ec976e09787acfb271b561f2d5a199c","commitMessage":"@@@Fix for DIRMINA-943","date":"2014-09-05 18:26:31","modifiedFileCount":"1","status":"M","submitter":"Emmanuel L?charny"}]
