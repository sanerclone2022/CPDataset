[{"authorTime":"2018-01-23 20:35:14","codes":[{"authorDate":"2017-12-05 10:08:58","commitOrder":3,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfitDerivative function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      \r\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        \r\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n    UnivariateFunction univariateFunction = pf.derivative();\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= univariateFunction.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","date":"2017-12-05 10:09:41","endLine":103,"groupId":"26818","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/77/5693842cf1caffe2555ec678772b14f2ee31aa.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfitDerivative function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      \r\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        \r\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n    UnivariateFunction univariateFunction = pf.derivative();\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= univariateFunction.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitDerivativeEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"NB"},{"authorDate":"2018-01-23 20:35:14","commitOrder":3,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n    } else if(objects.length == 2) {\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n    }\n\n    AkimaSplineInterpolator interpolator = new AkimaSplineInterpolator();\n    PolynomialSplineFunction spline = interpolator.interpolate(x, y);\n\n    List<Number> list = new ArrayList();\n    for(double xvalue : x) {\n      list.add(spline.value(xvalue));\n    }\n\n    VectorFunction vec = new VectorFunction(spline, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n","date":"2018-01-23 20:35:14","endLine":69,"groupId":"664","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ff/68963bbd47e528d7437c5969d409c8d98f149b.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n    } else if(objects.length == 2) {\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n    }\n\n    AkimaSplineInterpolator interpolator = new AkimaSplineInterpolator();\n    PolynomialSplineFunction spline = interpolator.interpolate(x, y);\n\n    List<Number> list = new ArrayList();\n    for(double xvalue : x) {\n      list.add(spline.value(xvalue));\n    }\n\n    VectorFunction vec = new VectorFunction(spline, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/AkimaEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"B"}],"commitId":"653935bbdfd70fa9490f8c363ffcf9832d3141a5","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2018-01-23 20:35:14","modifiedFileCount":"279","status":"M","submitter":"Karl Wright"},{"authorTime":"2020-06-08 09:31:51","codes":[{"authorDate":"2020-06-08 09:31:51","commitOrder":4,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfitDerivative function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      \r\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        \r\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n    UnivariateFunction univariateFunction = pf.derivative();\n\n    @SuppressWarnings({\"rawtypes\"})\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= univariateFunction.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","date":"2020-06-08 09:31:51","endLine":104,"groupId":"26818","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ec/02316c7bd7d63628e6936a2be52399257eded6.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfitDerivative function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      \r\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        \r\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n    UnivariateFunction univariateFunction = pf.derivative();\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= univariateFunction.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitDerivativeEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"M"},{"authorDate":"2020-06-08 09:31:51","commitOrder":4,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n    } else if(objects.length == 2) {\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n    }\n\n    AkimaSplineInterpolator interpolator = new AkimaSplineInterpolator();\n    PolynomialSplineFunction spline = interpolator.interpolate(x, y);\n\n    List<Number> list = new ArrayList<>();\n    for(double xvalue : x) {\n      list.add(spline.value(xvalue));\n    }\n\n    VectorFunction vec = new VectorFunction(spline, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n","date":"2020-06-08 09:31:51","endLine":70,"groupId":"664","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/58/37b32b043d50e7ae64038218a429a148b1779e.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n    } else if(objects.length == 2) {\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n    }\n\n    AkimaSplineInterpolator interpolator = new AkimaSplineInterpolator();\n    PolynomialSplineFunction spline = interpolator.interpolate(x, y);\n\n    List<Number> list = new ArrayList();\n    for(double xvalue : x) {\n      list.add(spline.value(xvalue));\n    }\n\n    VectorFunction vec = new VectorFunction(spline, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/AkimaEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":37,"status":"M"}],"commitId":"7bf59a16bda85b19b68b639b395d143019a89fde","commitMessage":"@@@SOLR-14544: Fix or suppress warnings in solr/client/solrj/io/eval\n","date":"2020-06-08 09:31:51","modifiedFileCount":"110","status":"M","submitter":"Erick Erickson"},{"authorTime":"2021-06-22 00:19:37","codes":[{"authorDate":"2021-06-22 00:19:37","commitOrder":5,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfitDerivative function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      \r\n\n      Object second = objects[1];\n      x = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List<?>) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        \r\n        Object second = objects[1];\n        x = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List<?>) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        \r\n        y = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n    UnivariateFunction univariateFunction = pf.derivative();\n\n    List<Double> list = new ArrayList<>();\n    for(double xvalue : x) {\n      double yvalue= univariateFunction.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","date":"2021-06-22 00:19:37","endLine":102,"groupId":"10144","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cb/60ab9b480e9570da7ec700f29205dc2df0b415.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfitDerivative function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      \r\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        \r\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n    UnivariateFunction univariateFunction = pf.derivative();\n\n    @SuppressWarnings({\"rawtypes\"})\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= univariateFunction.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitDerivativeEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":39,"status":"M"},{"authorDate":"2021-06-22 00:19:37","commitOrder":5,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n      y = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n    } else if(objects.length == 2) {\n      Object second = objects[1];\n      x = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List<?>) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n    }\n\n    AkimaSplineInterpolator interpolator = new AkimaSplineInterpolator();\n    PolynomialSplineFunction spline = interpolator.interpolate(x, y);\n\n    List<Number> list = new ArrayList<>();\n    for(double xvalue : x) {\n      list.add(spline.value(xvalue));\n    }\n\n    VectorFunction vec = new VectorFunction(spline, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n","date":"2021-06-22 00:19:37","endLine":69,"groupId":"10144","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e3/c66809572edb89f20f198ccfd9b937d85bfdd1.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n    } else if(objects.length == 2) {\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n    }\n\n    AkimaSplineInterpolator interpolator = new AkimaSplineInterpolator();\n    PolynomialSplineFunction spline = interpolator.interpolate(x, y);\n\n    List<Number> list = new ArrayList<>();\n    for(double xvalue : x) {\n      list.add(spline.value(xvalue));\n    }\n\n    VectorFunction vec = new VectorFunction(spline, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/AkimaEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":36,"status":"M"}],"commitId":"1725e778ac86d88e2deff8f7339d45bb4e50a719","commitMessage":"@@@SOLR-15385 RawTypes Part III.  contrib and solrj (#169)\n\n* SOLR-15385 RawTypes Part III.  contrib and solrj\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>","date":"2021-06-22 00:19:37","modifiedFileCount":"216","status":"M","submitter":"Mike Drob"}]
