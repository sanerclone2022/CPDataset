[{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2011-07-10 07:01:53","commitOrder":1,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2011-07-10 07:01:53","endLine":1297,"groupId":"11623","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/51/3fcab7b095844cb2731097ff0c683873643a68.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1169,"status":"B"},{"authorDate":"2011-07-10 07:01:53","commitOrder":1,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2011-07-10 07:01:53","endLine":1434,"groupId":"31342","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/51/3fcab7b095844cb2731097ff0c683873643a68.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1301,"status":"B"}],"commitId":"429093b236e30940d69edc8869346819c337cd10","commitMessage":"@@@SOLR-2452: Rewrote Solr build system (tighter integration with the Lucene build system) and restructured Solr internal and contrib modules\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1144761 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2011-07-10 07:01:53","modifiedFileCount":"0","status":"B","submitter":"Steven Rowe"},{"authorTime":"2011-11-12 10:22:06","codes":[{"authorDate":"2011-11-12 10:22:06","commitOrder":2,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2011-11-12 10:22:06","endLine":1358,"groupId":"14897","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6c/8d7c6728f50f3d40cc41e1e51b0e002b8bec1e.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1230,"status":"M"},{"authorDate":"2011-11-12 10:22:06","commitOrder":2,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2011-11-12 10:22:06","endLine":1495,"groupId":"44978","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6c/8d7c6728f50f3d40cc41e1e51b0e002b8bec1e.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1362,"status":"M"}],"commitId":"03cc61203638fb3dc6fe70026f2e4d46253a2bd8","commitMessage":"@@@LUCENE-2822: prevent TimeLimitedCollector from starting a statically referenced thread\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1201165 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2011-11-12 10:22:06","modifiedFileCount":"4","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2011-11-12 10:22:06","codes":[{"authorDate":"2012-02-02 00:01:34","commitOrder":3,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); \r\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2012-02-02 00:01:34","endLine":1402,"groupId":"11623","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d0/5f42dbfffa27dac59fa42fa2f6dc215c52f78b.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1271,"status":"M"},{"authorDate":"2011-11-12 10:22:06","commitOrder":3,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2011-11-12 10:22:06","endLine":1495,"groupId":"44978","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6c/8d7c6728f50f3d40cc41e1e51b0e002b8bec1e.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1362,"status":"N"}],"commitId":"b912f6da984ea75d550f76f6d68aa0322777066f","commitMessage":"@@@SOLR-1726: add deep paging support\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1239181 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-02-02 00:01:34","modifiedFileCount":"6","status":"M","submitter":"Grant Ingersoll"},{"authorTime":"2012-06-29 00:39:25","codes":[{"authorDate":"2012-06-29 00:39:25","commitOrder":4,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); \r\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2012-06-29 00:39:25","endLine":1405,"groupId":"11623","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/10/9eb26a25275f957db4f76c46a4a960819e92b8.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); \r\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1274,"status":"M"},{"authorDate":"2012-06-29 00:39:25","commitOrder":4,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2012-06-29 00:39:25","endLine":1542,"groupId":"44978","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/10/9eb26a25275f957db4f76c46a4a960819e92b8.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1409,"status":"M"}],"commitId":"fd16190940d7495e985f44ce7504562c8bbc91e6","commitMessage":"@@@LUCENE-4172: clean up redundant throws clauses\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1355069 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-06-29 00:39:25","modifiedFileCount":"402","status":"M","submitter":"Steven Rowe"},{"authorTime":"2013-05-07 00:49:46","codes":[{"authorDate":"2013-05-07 00:49:46","commitOrder":5,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); \r\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2013-05-07 00:49:46","endLine":1523,"groupId":"29808","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ac/25388e87cbd42b1e8782310990f04cc4e41758.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); \r\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1386,"status":"M"},{"authorDate":"2013-05-07 00:49:46","commitOrder":5,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2013-05-07 00:49:46","endLine":1665,"groupId":"18909","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ac/25388e87cbd42b1e8782310990f04cc4e41758.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1527,"status":"M"}],"commitId":"7141cb35a761eea1f0e6f3ad6abf84a4c972fedc","commitMessage":"@@@SOLR-3240: add \"spellcheck.collateMaxCollectDocs\" for estimating collation hit-counts.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1479638 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-05-07 00:49:46","modifiedFileCount":"5","status":"M","submitter":"James Dyer"},{"authorTime":"2013-07-10 00:54:55","codes":[{"authorDate":"2013-07-10 00:54:55","commitOrder":6,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); \r\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2013-07-10 00:54:55","endLine":1528,"groupId":"29808","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/44/ba1660aff2ce7a13fece09a7289ca2a5a7a12b.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); \r\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1385,"status":"M"},{"authorDate":"2013-07-10 00:54:55","commitOrder":6,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2013-07-10 00:54:55","endLine":1676,"groupId":"18909","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/44/ba1660aff2ce7a13fece09a7289ca2a5a7a12b.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1532,"status":"M"}],"commitId":"fd914505ea40b877ae1eb9cf1584bfe65cf8673e","commitMessage":"@@@SOLR-5020: add DelegatingCollector.final()\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1501376 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-07-10 00:54:55","modifiedFileCount":"2","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2014-01-07 05:15:45","codes":[{"authorDate":"2014-01-07 05:15:45","commitOrder":7,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2014-01-07 05:15:45","endLine":1636,"groupId":"29808","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/86/89bcfe3956f6acb715f2d51f38a0c79205d424.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); \r\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1499,"status":"M"},{"authorDate":"2014-01-07 05:15:45","commitOrder":7,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2014-01-07 05:15:45","endLine":1780,"groupId":"18909","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/86/89bcfe3956f6acb715f2d51f38a0c79205d424.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1640,"status":"M"}],"commitId":"5efc4132f10d476373b7da72e23f475eeec4046a","commitMessage":"@@@SOLR-5463: new 'cursorMark' request param for deep paging of sorted result sets\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1556036 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-01-07 05:15:45","modifiedFileCount":"10","status":"M","submitter":"Chris M. Hostetter"},{"authorTime":"2014-04-04 23:31:00","codes":[{"authorDate":"2014-04-04 23:31:00","commitOrder":8,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2014-04-04 23:31:00","endLine":1632,"groupId":"29458","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/17/6c0df733f2a9ee35c848b752103b4dff0827da.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1504,"status":"M"},{"authorDate":"2014-04-04 23:31:00","commitOrder":8,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2014-04-04 23:31:00","endLine":1779,"groupId":"29459","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/17/6c0df733f2a9ee35c848b752103b4dff0827da.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1636,"status":"M"}],"commitId":"85642f59ddf00c469b502f46fbc39944e076190e","commitMessage":"@@@LUCENE-5527: Refactor Collector API to use a dedicated Collector per leaf.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1584747 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-04-04 23:31:00","modifiedFileCount":"98","status":"M","submitter":"Adrien Grand"},{"authorTime":"2014-06-10 05:26:26","codes":[{"authorDate":"2014-06-10 05:26:26","commitOrder":9,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2014-06-10 05:26:26","endLine":1651,"groupId":"27360","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/82/7e90ab874168f1c3f6215bb702c0c629c3ac68.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1563,"status":"M"},{"authorDate":"2014-06-10 05:26:26","commitOrder":9,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2014-06-10 05:26:26","endLine":1759,"groupId":"33946","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/82/7e90ab874168f1c3f6215bb702c0c629c3ac68.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1655,"status":"M"}],"commitId":"3e7f0ae52e6f2962d03f25c478d7c05ba5958273","commitMessage":"@@@SOLR-6067: Refactor duplicate Collector code in SolrIndexSearcher\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1601511 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-06-10 05:26:26","modifiedFileCount":"1","status":"M","submitter":"Chris M. Hostetter"},{"authorTime":"2015-01-15 17:35:20","codes":[{"authorDate":"2015-01-15 17:35:20","commitOrder":10,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2015-01-15 17:35:20","endLine":1696,"groupId":"27360","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/83/8fccf92d5d14f2685e46d2ffd8508d84698315.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1616,"status":"M"},{"authorDate":"2015-01-15 17:35:20","commitOrder":10,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2015-01-15 17:35:20","endLine":1799,"groupId":"5721","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/83/8fccf92d5d14f2685e46d2ffd8508d84698315.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1700,"status":"M"}],"commitId":"457e70ab944e8ea68dd1777d7d0fca49ad920e79","commitMessage":"@@@LUCENE-6179: Disallow out-of-order scoring.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1652013 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-15 17:35:20","modifiedFileCount":"90","status":"M","submitter":"Adrien Grand"},{"authorTime":"2015-02-05 20:34:28","codes":[{"authorDate":"2015-02-05 20:34:28","commitOrder":11,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2015-02-05 20:34:28","endLine":1703,"groupId":"27360","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4a/63360111052c3c8c8fdff4fa22805d27f7c55a.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1613,"status":"M"},{"authorDate":"2015-02-05 20:34:28","commitOrder":11,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2015-02-05 20:34:28","endLine":1811,"groupId":"5721","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4a/63360111052c3c8c8fdff4fa22805d27f7c55a.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1707,"status":"M"}],"commitId":"010e352f60301b1ab3967ad70413240163703ec4","commitMessage":"@@@LUCENE-6218: don't decode freqs or enumerate all positions when scoring is not needed\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1657554 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-02-05 20:34:28","modifiedFileCount":"105","status":"M","submitter":"Robert Muir"},{"authorTime":"2015-02-25 01:43:10","codes":[{"authorDate":"2015-02-25 01:43:10","commitOrder":12,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new FilteredQuery(query, pf.filter);\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2015-02-25 01:43:10","endLine":1679,"groupId":"9606","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/53/af8efc0a2b13a84fa25c7178d693f4a143a06e.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1587,"status":"M"},{"authorDate":"2015-02-25 01:43:10","commitOrder":12,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new FilteredQuery(query, pf.filter);\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2015-02-25 01:43:10","endLine":1788,"groupId":"10335","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/53/af8efc0a2b13a84fa25c7178d693f4a143a06e.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1683,"status":"M"}],"commitId":"2cd3fb807daf7a82d71c2ffeb44c75e2bd0814fc","commitMessage":"@@@LUCENE-6286: Removed IndexSearcher methods that take a Filter object.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1662059 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-02-25 01:43:10","modifiedFileCount":"123","status":"M","submitter":"Adrien Grand"},{"authorTime":"2015-06-18 20:29:56","codes":[{"authorDate":"2015-06-18 20:29:56","commitOrder":13,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2015-06-18 20:29:56","endLine":1716,"groupId":"9606","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/91797fd261d1979c2a9578d0961e03554eb8b9.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new FilteredQuery(query, pf.filter);\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1621,"status":"M"},{"authorDate":"2015-06-18 20:29:56","commitOrder":13,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2015-06-18 20:29:56","endLine":1828,"groupId":"10335","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/91797fd261d1979c2a9578d0961e03554eb8b9.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new FilteredQuery(query, pf.filter);\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1720,"status":"M"}],"commitId":"35c0ff0ec64d2428059318aca830425367541896","commitMessage":"@@@LUCENE-6583: Remove FilteredQuery.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1686203 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-18 20:29:56","modifiedFileCount":"50","status":"M","submitter":"Adrien Grand"},{"authorTime":"2015-09-12 11:14:34","codes":[{"authorDate":"2015-06-18 20:29:56","commitOrder":14,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2015-06-18 20:29:56","endLine":1716,"groupId":"9606","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/91797fd261d1979c2a9578d0961e03554eb8b9.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1621,"status":"N"},{"authorDate":"2015-09-12 11:14:34","commitOrder":14,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","date":"2015-09-12 11:14:34","endLine":1811,"groupId":"34700","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/65/4c1a68001a5d09e86bef9f2f56ba86896aef4b.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1704,"status":"M"}],"commitId":"68d942eee149c7041f5a748dd03b130fcac1b0e4","commitMessage":"@@@SOLR-8043: add DocSetCollector constructor that calculates small-set-size.  add DocSetUtil.smallSetSize\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1702586 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-09-12 11:14:34","modifiedFileCount":"6","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2017-02-01 00:52:04","codes":[{"authorDate":"2015-06-18 20:29:56","commitOrder":15,"curCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","date":"2015-06-18 20:29:56","endLine":1716,"groupId":"9606","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/91797fd261d1979c2a9578d0961e03554eb8b9.src","preCode":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    \r\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1621,"status":"N"},{"authorDate":"2017-02-01 00:52:04","commitOrder":15,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2017-02-01 00:52:04","endLine":2036,"groupId":"7407","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ff/7054b2f5bd3cb7ab9504801a58d40c934f26bb.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1932,"status":"M"}],"commitId":"a43ef8f480c6a32dd77e43d02c2dca2299a05eb3","commitMessage":"@@@SOLR-9764: share liveDocs for any DocSet of size numDocs\n","date":"2017-02-01 00:52:04","modifiedFileCount":"12","status":"M","submitter":"yonik"},{"authorTime":"2017-12-08 18:41:33","codes":[{"authorDate":"2017-12-08 18:41:33","commitOrder":16,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","date":"2017-12-08 18:41:33","endLine":1619,"groupId":"29881","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/e5199bdf7511c70f2cc616c123292c97d36b5b.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1525,"status":"M"},{"authorDate":"2017-12-08 18:41:33","commitOrder":16,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2017-12-08 18:41:33","endLine":1727,"groupId":"57659","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/e5199bdf7511c70f2cc616c123292c97d36b5b.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1623,"status":"M"}],"commitId":"dcb84701a4c6d293b8eb30c676630d16d6cdcaa8","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2017-12-08 18:41:33","modifiedFileCount":"293","status":"M","submitter":"Karl Wright"},{"authorTime":"2018-05-24 03:37:33","codes":[{"authorDate":"2017-12-08 18:41:33","commitOrder":17,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","date":"2017-12-08 18:41:33","endLine":1619,"groupId":"29881","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/e5199bdf7511c70f2cc616c123292c97d36b5b.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1525,"status":"N"},{"authorDate":"2018-05-24 03:37:33","commitOrder":17,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2018-05-24 03:37:33","endLine":1731,"groupId":"7634","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a8/c168ed8fc8226f2e0363b07537f0d42800a272.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1627,"status":"M"}],"commitId":"53a3de3b98a5a06146a33251c176b7e4475270e4","commitMessage":"@@@SOLR-12375: Optimize Lucene ScoreMode use:\n* A non-cached filter query could be told incorrectly that scores were needed.\n* The /export (ExportQParserPlugin) would declare incorrectly that scores are needed.\n* Expanded docs (expand component) could be told incorrectly that scores are needed.\n","date":"2018-05-24 03:37:33","modifiedFileCount":"4","status":"M","submitter":"David Smiley"},{"authorTime":"2018-07-18 14:31:44","codes":[{"authorDate":"2018-07-18 14:31:44","commitOrder":18,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","date":"2018-07-18 14:38:57","endLine":1646,"groupId":"32871","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/12/2de2b1daa5bb1a80ae5390c628153a18331f56.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1547,"status":"M"},{"authorDate":"2018-07-18 14:31:44","commitOrder":18,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2018-07-18 14:38:57","endLine":1762,"groupId":"7634","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/12/2de2b1daa5bb1a80ae5390c628153a18331f56.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1650,"status":"M"}],"commitId":"331ccf391067b7775db371bec1ec8e8c9004e904","commitMessage":"@@@LUCENE-8405: Remove TopDocs.maxScore.\n","date":"2018-07-18 14:38:57","modifiedFileCount":"67","status":"M","submitter":"Adrien Grand"},{"authorTime":"2018-07-23 15:05:02","codes":[{"authorDate":"2018-07-23 15:05:02","commitOrder":19,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","date":"2018-07-23 15:06:49","endLine":1645,"groupId":"32871","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6c/bcd0d6843594978919da29cf70312027c2b7a2.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1543,"status":"M"},{"authorDate":"2018-07-23 15:05:02","commitOrder":19,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2018-07-23 15:06:49","endLine":1764,"groupId":"7634","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6c/bcd0d6843594978919da29cf70312027c2b7a2.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1649,"status":"M"}],"commitId":"55bfadbce115a825a75686fe0bfe71406bc3ee44","commitMessage":"@@@LUCENE-8412: TopFieldCollector no longer takes a trackDocScores option.\n","date":"2018-07-23 15:06:49","modifiedFileCount":"30","status":"M","submitter":"Adrien Grand"},{"authorTime":"2018-09-03 23:46:59","codes":[{"authorDate":"2018-09-03 23:46:59","commitOrder":20,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","date":"2018-09-04 18:01:44","endLine":1645,"groupId":"32871","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ae/9e485b7d526a640112bb7f72df37e1db0847f4.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1543,"status":"M"},{"authorDate":"2018-09-03 23:46:59","commitOrder":20,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2018-09-04 18:01:44","endLine":1764,"groupId":"7634","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ae/9e485b7d526a640112bb7f72df37e1db0847f4.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1649,"status":"M"}],"commitId":"910a0231f6fc668426056e31d43e293248ff5ce1","commitMessage":"@@@LUCENE-6228: Add Scorable class and make LeafCollector.setScorer() take Scorable\n","date":"2018-09-04 18:01:44","modifiedFileCount":"97","status":"M","submitter":"Alan Woodward"},{"authorTime":"2019-02-20 21:24:52","codes":[{"authorDate":"2018-09-03 23:46:59","commitOrder":21,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","date":"2018-09-04 18:01:44","endLine":1645,"groupId":"32871","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ae/9e485b7d526a640112bb7f72df37e1db0847f4.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1543,"status":"N"},{"authorDate":"2019-02-20 21:24:52","commitOrder":21,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2019-03-04 22:41:57","endLine":1746,"groupId":"21237","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ab/0996d31df516c35f032bfc4aae40f29c785d41.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1631,"status":"M"}],"commitId":"b8d569aff0c4417b0f9cd52d54455ab9b66236a1","commitMessage":"@@@SOLR-9882: reporting timeAllowed breach as partialResults instead of 500 error\n","date":"2019-03-04 22:41:57","modifiedFileCount":"16","status":"M","submitter":"Mikhail Khludnev"},{"authorTime":"2019-02-20 21:24:52","codes":[{"authorDate":"2020-03-26 12:29:46","commitOrder":22,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    query = QueryUtils.combineQueryAndFilter(query, pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","date":"2020-04-04 07:20:55","endLine":1642,"groupId":"32871","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d6/39b891039d3de62a89c2b3b20441ab6adb6ab3.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1542,"status":"M"},{"authorDate":"2019-02-20 21:24:52","commitOrder":22,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2019-03-04 22:41:57","endLine":1746,"groupId":"21237","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ab/0996d31df516c35f032bfc4aae40f29c785d41.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1631,"status":"N"}],"commitId":"7b3980c0804b0de16841faf16478b2b1bd217088","commitMessage":"@@@SOLR-14364: LTR SolrFeature fq improvements\n  Mostly general code improvements.  though it should support postFilters now\nAdd QueryUtils.combineQueryAndFilter\n","date":"2020-04-04 07:20:55","modifiedFileCount":"6","status":"M","submitter":"David Smiley"},{"authorTime":"2020-04-05 23:28:33","codes":[{"authorDate":"2020-04-05 23:28:33","commitOrder":23,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","date":"2020-04-15 04:45:59","endLine":1666,"groupId":"32871","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/5e2317ab17c85da844e1af2a8572055d1ec6a3.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    query = QueryUtils.combineQueryAndFilter(query, pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1568,"status":"M"},{"authorDate":"2020-04-05 23:28:33","commitOrder":23,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2020-04-15 04:45:59","endLine":1782,"groupId":"21237","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/5e2317ab17c85da844e1af2a8572055d1ec6a3.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1670,"status":"M"}],"commitId":"1fc4a546df958fc880337e9071acfc6ca53e1291","commitMessage":"@@@Solr: Use QueryUtils.combineQueryAndFilter more\n and check MatchAllDocsQuery (minor & cheap optimization)\n Closes #1407\n","date":"2020-04-15 04:45:59","modifiedFileCount":"8","status":"M","submitter":"David Smiley"},{"authorTime":"2020-05-09 05:25:47","codes":[{"authorDate":"2020-05-09 05:25:47","commitOrder":24,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      hitsRelation = topDocs.totalHits.relation;\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","date":"2020-05-09 05:25:47","endLine":1607,"groupId":"60086","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e2/d81073d64777cb93cc1cceb4ad88818fafc2ec.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1506,"status":"M"},{"authorDate":"2020-05-09 05:25:47","commitOrder":24,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactHits(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2020-05-09 05:25:47","endLine":1723,"groupId":"21237","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e2/d81073d64777cb93cc1cceb4ad88818fafc2ec.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1611,"status":"M"}],"commitId":"d9f9d6dd47c06f5fe092d43d6bf0c77c5ff2019f","commitMessage":"@@@SOLR-13289: Add Support for BlockMax WAND (#1456)\n\nAdd support for BlockMax WAND via a minExactHits parameter. Hits will be counted accurately at least until this value.  and above that.  the count will be an approximation. In distributed search requests.  the count will be per shard.  so potentially the count will be accurately counted until numShards * minExactHits. The response will include the value numFoundExact which can be true (The value in numFound is exact) or false (the value in numFound is an approximation).","date":"2020-05-09 05:25:47","modifiedFileCount":"47","status":"M","submitter":"Tomas Fernandez Lobbe"},{"authorTime":"2020-05-22 08:29:24","codes":[{"authorDate":"2020-05-22 08:29:24","commitOrder":25,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","date":"2020-05-22 08:29:24","endLine":1613,"groupId":"60086","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a7/79bd89b33c6173cfcde69cd7cc6de9886fb95c.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      hitsRelation = topDocs.totalHits.relation;\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1508,"status":"M"},{"authorDate":"2020-05-22 08:29:24","commitOrder":25,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2020-05-22 08:29:24","endLine":1729,"groupId":"21237","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a7/79bd89b33c6173cfcde69cd7cc6de9886fb95c.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactHits(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1617,"status":"M"}],"commitId":"3db79ed9ff600381277367b94b875467aac60d93","commitMessage":"@@@Merge branch 'master' of https://gitbox.apache.org/repos/asf/lucene-solr\n","date":"2020-05-22 08:29:24","modifiedFileCount":"13","status":"M","submitter":"Erick Erickson"},{"authorTime":"2020-06-08 09:20:25","codes":[{"authorDate":"2020-05-22 08:29:24","commitOrder":26,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","date":"2020-05-22 08:29:24","endLine":1613,"groupId":"60086","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a7/79bd89b33c6173cfcde69cd7cc6de9886fb95c.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1508,"status":"N"},{"authorDate":"2020-06-08 09:20:25","commitOrder":26,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      @SuppressWarnings({\"rawtypes\"})\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2020-06-08 09:20:25","endLine":1741,"groupId":"27021","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6f/fe8d24cc306373c4eaa1d589f100b68396cf09.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1628,"status":"M"}],"commitId":"04ba04c29d5079d74231aa5a54d5f0a93bd16f2b","commitMessage":"@@@SOLR-14543: Fix or suppress warnings in apache/solr/search\n","date":"2020-06-08 09:20:25","modifiedFileCount":"42","status":"M","submitter":"Erick Erickson"},{"authorTime":"2020-11-12 20:51:21","codes":[{"authorDate":"2020-11-12 20:51:21","commitOrder":27,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && cmd.getQuery() instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","date":"2020-11-12 20:51:21","endLine":1627,"groupId":"60086","id":53,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9a/5ac707ce8215f7e628187dcd866eaafa716237.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1522,"status":"M"},{"authorDate":"2020-11-12 20:51:21","commitOrder":27,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      @SuppressWarnings({\"rawtypes\"})\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && cmd.getQuery() instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2020-11-12 20:51:21","endLine":1744,"groupId":"42102","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9a/5ac707ce8215f7e628187dcd866eaafa716237.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      @SuppressWarnings({\"rawtypes\"})\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1631,"status":"M"}],"commitId":"2f02040a4c45e4dfdb1f569ae05637c86f0f001b","commitMessage":"@@@SOLR-14983: Fix response returning original score instead of reranked score due to query and filter combining.\n(Krishan Goyal.  Jason Baik.  Christine Poerschke)\n","date":"2020-11-12 20:51:21","modifiedFileCount":"2","status":"M","submitter":"Christine Poerschke"},{"authorTime":"2021-07-13 23:49:56","codes":[{"authorDate":"2020-11-12 20:51:21","commitOrder":28,"curCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && cmd.getQuery() instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","date":"2020-11-12 20:51:21","endLine":1627,"groupId":"102098","id":55,"instanceNumber":1,"isCurCommit":0,"methodName":"getDocListNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9a/5ac707ce8215f7e628187dcd866eaafa716237.src","preCode":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && cmd.getQuery() instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1522,"status":"N"},{"authorDate":"2021-07-13 23:49:56","commitOrder":28,"curCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector<? extends ScoreDoc> topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && cmd.getQuery() instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","date":"2021-07-13 23:49:56","endLine":1723,"groupId":"102098","id":56,"instanceNumber":2,"isCurCommit":0,"methodName":"getDocListAndSetNC","params":"(QueryResultqr@QueryCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1b/d4b95198db59111b3dc7de377961ace98fa7ab.src","preCode":"  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);\r\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    \r\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      \r\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      @SuppressWarnings({\"rawtypes\"})\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && cmd.getQuery() instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    \r\n    \r\n    qr.setDocSet(set);\n\n    \r\n    \r\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1611,"status":"M"}],"commitId":"09986130545fabfb2cc76ced85a0da6ba536acf0","commitMessage":"@@@SOLR-15385 RawTypes Part VI (#207)\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>","date":"2021-07-13 23:49:56","modifiedFileCount":"185","status":"M","submitter":"Mike Drob"}]
