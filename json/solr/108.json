[{"authorTime":"2012-12-12 03:21:12","codes":[{"authorDate":"2012-12-12 03:21:12","commitOrder":2,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask2) != mask2)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask2) - increment ;\n        long roundUp = (end | mask2) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2012-12-12 03:21:12","endLine":196,"groupId":"11579","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ab/98ed5c5754788863518cde416b3398e0fa77a8.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask2) != mask2)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask2) - increment ;\n        long roundUp = (end | mask2) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"B"},{"authorDate":"2012-12-12 03:21:12","commitOrder":2,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    while (end < max) {\n      end = start + rangeStep;\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2012-12-12 03:21:12","endLine":155,"groupId":"55263","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/85/f301eb80f4e949b06ce7e6ef30aeec8c975c34.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    while (end < max) {\n      end = start + rangeStep;\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"MB"}],"commitId":"5b04be1195e871d7f49b46d39c326a783873a13a","commitMessage":"@@@SOLR-2592: avoid splitting composite router hash domains\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1420338 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-12-12 03:21:12","modifiedFileCount":"3","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2012-12-12 03:21:12","codes":[{"authorDate":"2013-11-15 22:01:41","commitOrder":3,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment ;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2013-11-15 22:01:41","endLine":176,"groupId":"28064","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/53/411791b394e4b68dc0d51a5da94ea971fb54cb.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    boolean round = rangeStep >= (1<<bits)*16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask2) != mask2)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask2) - increment ;\n        long roundUp = (end | mask2) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"},{"authorDate":"2012-12-12 03:21:12","commitOrder":3,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    while (end < max) {\n      end = start + rangeStep;\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2012-12-12 03:21:12","endLine":155,"groupId":"55263","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/85/f301eb80f4e949b06ce7e6ef30aeec8c975c34.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    while (end < max) {\n      end = start + rangeStep;\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"N"}],"commitId":"f61d23263064ebb7217bce51116106e580624feb","commitMessage":"@@@SOLR-5320: Added support for tri-level compositeId routing\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1542272 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-11-15 22:01:41","modifiedFileCount":"3","status":"M","submitter":"Shalin Shekhar Mangar"},{"authorTime":"2014-03-12 22:39:17","codes":[{"authorDate":"2014-03-12 22:39:17","commitOrder":4,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2014-03-12 22:39:17","endLine":177,"groupId":"28064","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d0/1644ff6aa80ef77021caede5fcfbe9e6604b54.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2014-03-12 22:39:17","commitOrder":4,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    while (end < max) {\n      end = start + rangeStep;\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2014-03-12 22:39:17","endLine":193,"groupId":"3933","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/08/8d272a26c6a32863010b26eeb51ac407106739.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<Range>(partitions);\n\n    long start = min;\n    long end = start;\n\n    while (end < max) {\n      end = start + rangeStep;\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":168,"status":"M"}],"commitId":"3b67b17493216f6b0c81a981073fd5f61eace6f4","commitMessage":"@@@LUCENE-5512: remove redundant typing (diamond operator) in trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1576755 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-03-12 22:39:17","modifiedFileCount":"1241","status":"M","submitter":"Robert Muir"},{"authorTime":"2019-01-08 02:14:54","codes":[{"authorDate":"2014-03-12 22:39:17","commitOrder":5,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2014-03-12 22:39:17","endLine":177,"groupId":"28064","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d0/1644ff6aa80ef77021caede5fcfbe9e6604b54.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"N"},{"authorDate":"2019-01-08 02:14:54","commitOrder":5,"curCode":"  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2019-01-08 02:14:54","endLine":212,"groupId":"8323","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange@floatfuzz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/11/1c74b7f0b7379409ce4a61478e6d454dbb1b5f.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    while (end < max) {\n      end = start + rangeStep;\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"M"}],"commitId":"6e745bd25007511266741b516cffdba757fa22a3","commitMessage":"@@@SOLR-12730: Implement staggered SPLITSHARD requests in IndexSizeTrigger.\n","date":"2019-01-08 02:14:54","modifiedFileCount":"14","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2019-01-08 02:14:54","codes":[{"authorDate":"2019-11-25 02:24:40","commitOrder":6,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.emptyList();\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2019-11-25 02:24:40","endLine":197,"groupId":"28064","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c5/2fd61b90e1ae70c56f81c3060fa14b6e7f0f8b.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"},{"authorDate":"2019-01-08 02:14:54","commitOrder":6,"curCode":"  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2019-01-08 02:14:54","endLine":212,"groupId":"8323","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange@floatfuzz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/11/1c74b7f0b7379409ce4a61478e6d454dbb1b5f.src","preCode":"  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"N"}],"commitId":"4b34d726ab015172e87534cb0685f8626e63c9fe","commitMessage":"@@@SOLR-13952: Separate out Gradle-specific code from other (mostly test) changes and commit separately\n","date":"2019-11-25 02:24:40","modifiedFileCount":"277","status":"M","submitter":"Erick Erickson"},{"authorTime":"2019-01-08 02:14:54","codes":[{"authorDate":"2019-11-26 00:56:20","commitOrder":7,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2019-11-26 00:56:20","endLine":197,"groupId":"28064","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d7/00464c6901ee1d7986313b4e8e5cafa870e057.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.emptyList();\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":147,"status":"M"},{"authorDate":"2019-01-08 02:14:54","commitOrder":7,"curCode":"  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2019-01-08 02:14:54","endLine":212,"groupId":"8323","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange@floatfuzz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/11/1c74b7f0b7379409ce4a61478e6d454dbb1b5f.src","preCode":"  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":172,"status":"N"}],"commitId":"063c82ebd6c3691a7135c46a78c6f9c9df4d0d2e","commitMessage":"@@@SOLR-13952: reverting Erick's commit (with permission).\n","date":"2019-11-26 00:56:20","modifiedFileCount":"277","status":"M","submitter":"Dawid Weiss"},{"authorTime":"2020-07-13 10:41:08","codes":[{"authorDate":"2020-07-13 10:41:08","commitOrder":8,"curCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.emptyList();\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2020-07-13 10:41:08","endLine":241,"groupId":"108","id":13,"instanceNumber":1,"isCurCommit":1,"methodName":"partitionRange","params":"(intpartitions@Rangerange)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4b/7acc1a362420a0054fea9ce1720c409d4cf4dc.src","preCode":"  public List<Range> partitionRange(int partitions, Range range) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long) max - (long) min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n\n    \r\n    long targetStart = min;\n    long targetEnd = targetStart;\n\n    \r\n    \r\n    \r\n    int mask = 0x0000ffff;\n    boolean round = rangeStep >= (1 << bits) * 16;\n\n    while (end < max) {\n      targetEnd = targetStart + rangeStep;\n      end = targetEnd;\n\n      if (round && ((end & mask) != mask)) {\n        \r\n        int increment = 1 << bits;  \r\n        long roundDown = (end | mask) - increment;\n        long roundUp = (end | mask) + increment;\n        if (end - roundDown < roundUp - end && roundDown > start) {\n          end = roundDown;\n        } else {\n          end = roundUp;\n        }\n      }\n\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int) start, (int) end));\n      start = end + 1L;\n      targetStart = targetEnd + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":191,"status":"M"},{"authorDate":"2020-07-13 10:41:08","commitOrder":8,"curCode":"  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.emptyList();\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","date":"2020-07-13 10:41:08","endLine":213,"groupId":"108","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"partitionRange","params":"(intpartitions@Rangerange@floatfuzz)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0f/45231e31075a2857731e9d737e5638acae8098.src","preCode":"  public List<Range> partitionRange(int partitions, Range range, float fuzz) {\n    int min = range.min;\n    int max = range.max;\n\n    assert max >= min;\n    if (fuzz > 0.5f) {\n      throw new IllegalArgumentException(\"'fuzz' parameter must be <= 0.5f but was \" + fuzz);\n    } else if (fuzz < 0.0f) {\n      fuzz = 0.0f;\n    }\n    if (partitions == 0) return Collections.EMPTY_LIST;\n    long rangeSize = (long)max - (long)min;\n    long rangeStep = Math.max(1, rangeSize / partitions);\n    long fuzzStep = Math.round(rangeStep * (double)fuzz / 2.0);\n\n    List<Range> ranges = new ArrayList<>(partitions);\n\n    long start = min;\n    long end = start;\n    boolean odd = true;\n\n    while (end < max) {\n      end = start + rangeStep;\n      if (fuzzStep > 0) {\n        if (odd) {\n          end = end + fuzzStep;\n        } else {\n          end = end - fuzzStep;\n        }\n        odd = !odd;\n      }\n      \r\n      if (ranges.size() == partitions - 1) {\n        end = max;\n      }\n      ranges.add(new Range((int)start, (int)end));\n      start = end + 1L;\n    }\n\n    return ranges;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/DocRouter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"M"}],"commitId":"c346881ad6a4ff61d6776a2a41e5c506f217ef2c","commitMessage":"@@@SOLR-13939: https://issues.apache.org/jira/browse/SOLR-13939\n","date":"2020-07-13 10:41:08","modifiedFileCount":"25","status":"M","submitter":"Erick Erickson"}]
