[{"authorTime":"2019-05-01 04:31:06","codes":[{"authorDate":"2019-04-10 15:02:59","commitOrder":2,"curCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":887,"groupId":"6599","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doLocalDeleteByQuery","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"NB"},{"authorDate":"2019-05-01 04:31:06","commitOrder":2,"curCode":"  private boolean doVersionDelete(DeleteUpdateCommand cmd, long versionOnUpdate, long signedVersionOnUpdate,\n      boolean isReplayOrPeersync, boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket)\n      throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      if (versionsStored) {\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            log.info(\"Removing version field from doc: \" + cmd.getId());\n            versionOnUpdate = signedVersionOnUpdate = 0;\n          }\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && !isReplayOrPeersync) {\n            \r\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          if (signedVersionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                  + signedVersionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          bucket.updateHighest(version);\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          \r\n          if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n            \r\n            \r\n            bucket.updateHighest(versionOnUpdate);\n          } else {\n            \r\n            \r\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n              \r\n              log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n              return true;\n            }\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      doLocalDelete(cmd);\n      return false;\n    } finally {\n      bucket.unlock();\n    }\n  }\n","date":"2019-05-01 04:31:44","endLine":1041,"groupId":"6599","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doVersionDelete","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@longsignedVersionOnUpdate@booleanisReplayOrPeersync@booleanleaderLogic@booleanforwardedFromCollection@VersionBucketbucket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ed/48c758f47592c9980d29aab7abd4b35f61d414.src","preCode":"  private boolean doVersionDelete(DeleteUpdateCommand cmd, long versionOnUpdate, long signedVersionOnUpdate,\n      boolean isReplayOrPeersync, boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket)\n      throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      if (versionsStored) {\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            log.info(\"Removing version field from doc: \" + cmd.getId());\n            versionOnUpdate = signedVersionOnUpdate = 0;\n          }\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && !isReplayOrPeersync) {\n            \r\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          if (signedVersionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                  + signedVersionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          bucket.updateHighest(version);\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          \r\n          if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n            \r\n            \r\n            bucket.updateHighest(versionOnUpdate);\n          } else {\n            \r\n            \r\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n              \r\n              log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n              return true;\n            }\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      doLocalDelete(cmd);\n      return false;\n    } finally {\n      bucket.unlock();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":961,"status":"B"}],"commitId":"70e090717d21a9713c45b8a52e35df940a4277df","commitMessage":"@@@SOLR-12833: Avoid unnecessary memory cost when DistributedUpdateProcessor timed-out lock is not used.\n","date":"2019-05-01 04:31:44","modifiedFileCount":"4","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2020-04-21 09:08:15","codes":[{"authorDate":"2019-04-10 15:02:59","commitOrder":3,"curCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":887,"groupId":"102057","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doLocalDeleteByQuery","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"N"},{"authorDate":"2020-04-21 09:08:15","commitOrder":3,"curCode":"  private boolean doVersionDelete(DeleteUpdateCommand cmd, long versionOnUpdate, long signedVersionOnUpdate,\n      boolean isReplayOrPeersync, boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket)\n      throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      if (versionsStored) {\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getId());\n            }\n            versionOnUpdate = signedVersionOnUpdate = 0;\n          }\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && !isReplayOrPeersync) {\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          if (signedVersionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                  + signedVersionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          bucket.updateHighest(version);\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          \r\n          if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n            \r\n            \r\n            bucket.updateHighest(versionOnUpdate);\n          } else {\n            \r\n            \r\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n              \r\n              if (log.isDebugEnabled()) {\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n              }\n              return true;\n            }\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      doLocalDelete(cmd);\n      return false;\n    } finally {\n      bucket.unlock();\n    }\n  }\n","date":"2020-04-21 09:08:15","endLine":1081,"groupId":"102057","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doVersionDelete","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@longsignedVersionOnUpdate@booleanisReplayOrPeersync@booleanleaderLogic@booleanforwardedFromCollection@VersionBucketbucket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4f/b5107d6c2e919070ec5dd04a6a02ae83bf6c15.src","preCode":"  private boolean doVersionDelete(DeleteUpdateCommand cmd, long versionOnUpdate, long signedVersionOnUpdate,\n      boolean isReplayOrPeersync, boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket)\n      throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      if (versionsStored) {\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            log.info(\"Removing version field from doc: \" + cmd.getId());\n            versionOnUpdate = signedVersionOnUpdate = 0;\n          }\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && !isReplayOrPeersync) {\n            \r\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          if (signedVersionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                  + signedVersionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          bucket.updateHighest(version);\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          \r\n          if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n            \r\n            \r\n            bucket.updateHighest(versionOnUpdate);\n          } else {\n            \r\n            \r\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n              \r\n              log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n              return true;\n            }\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      doLocalDelete(cmd);\n      return false;\n    } finally {\n      bucket.unlock();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":995,"status":"M"}],"commitId":"c94770c2b9c00ccdc2d617d595d62f85a332dc0c","commitMessage":"@@@LUCENE-7788: fail precommit on unparameterised log messages and examine for wasted work/objects\n","date":"2020-04-21 09:08:15","modifiedFileCount":"38","status":"M","submitter":"Erick Erickson"}]
