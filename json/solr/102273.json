[{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2014-10-29 02:12:31","commitOrder":2,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(\"id\");\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \r\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2014-10-29 02:12:31","endLine":93,"groupId":"28796","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/83/2c70ef9b9543efee6a6244d41255b0a2b6eae9.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(\"id\");\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \r\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"B"},{"authorDate":"2011-07-10 07:01:53","commitOrder":2,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","date":"2011-07-10 07:01:53","endLine":341,"groupId":"28039","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/6c26305fd0988a8d05ae3ae61b7ed5415f8595.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"NB"}],"commitId":"a5ba0b84f7c707d04da1f2385dbc79c0e7cf9a40","commitMessage":"@@@SOLR-6248: MoreLikeThis QParser that works in standalone/cloud mode\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1634937 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-10-29 02:12:31","modifiedFileCount":"3","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2014-10-30 07:10:17","commitOrder":3,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \r\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2014-10-30 07:10:17","endLine":94,"groupId":"28796","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/32/89d36a87992bc9f2332b1e138be75ba30faba9.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(\"id\");\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \r\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2011-07-10 07:01:53","commitOrder":3,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","date":"2011-07-10 07:01:53","endLine":341,"groupId":"28039","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/6c26305fd0988a8d05ae3ae61b7ed5415f8595.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"N"}],"commitId":"d7a142343927505f6df27e10ab22befac945f9b1","commitMessage":"@@@SOLR-6248: Changing the format of mlt query parser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1635329 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-10-30 07:10:17","modifiedFileCount":"6","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2015-06-18 07:12:15","commitOrder":4,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2015-06-18 07:12:15","endLine":104,"groupId":"28796","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/06b87dcf03a73c30d5b01f77679842986a81ec.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \r\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2011-07-10 07:01:53","commitOrder":4,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","date":"2011-07-10 07:01:53","endLine":341,"groupId":"28039","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/6c26305fd0988a8d05ae3ae61b7ed5415f8595.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"N"}],"commitId":"2b96b2504677c0673bbf8300d2217205684056c6","commitMessage":"@@@SOLR-7639: MoreLikeThis QParser now supports all options provided by the MLT Handler i.e. mintf.  mindf.  minwl.  maxwl.  maxqt.  and maxntp. This commit also fixes an NPE issue in CloudMLTQParser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1686123 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-18 07:12:15","modifiedFileCount":"4","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2015-06-18 15:14:05","codes":[{"authorDate":"2015-06-18 07:12:15","commitOrder":5,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2015-06-18 07:12:15","endLine":104,"groupId":"28796","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/06b87dcf03a73c30d5b01f77679842986a81ec.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"N"},{"authorDate":"2015-06-18 15:14:05","commitOrder":5,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-06-18 15:14:05","endLine":388,"groupId":"4365","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/da/744bb3ec55f481bff31fc3d3c6dc3c00455604.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"M"}],"commitId":"4aafacfbef423a25a349dd8c6e5e6178ac1ba334","commitMessage":"@@@LUCENE-6570: Make BooleanQuery immutable.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1686145 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-18 15:14:05","modifiedFileCount":"184","status":"M","submitter":"Adrien Grand"},{"authorTime":"2015-06-18 15:14:05","codes":[{"authorDate":"2015-06-24 00:03:48","commitOrder":6,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2015-06-24 00:03:48","endLine":108,"groupId":"28796","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/75/562188e80ca58026b679c0b626902d3f38d2df.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2015-06-18 15:14:05","commitOrder":6,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-06-18 15:14:05","endLine":388,"groupId":"4365","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/da/744bb3ec55f481bff31fc3d3c6dc3c00455604.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"N"}],"commitId":"48ea578733bdde3d5254a617ec33bea77bd05530","commitMessage":"@@@SOLR-7639: Fixing maxqt.  and maxntp.  and adding support for maxdf to MLTQParser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1687088 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-24 00:03:48","modifiedFileCount":"2","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2015-06-18 15:14:05","codes":[{"authorDate":"2015-07-07 08:05:23","commitOrder":7,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2015-07-07 08:05:23","endLine":124,"groupId":"28796","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0e/deb10790a3bd8ac6434d55c1a674e4f8b149a1.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"M"},{"authorDate":"2015-06-18 15:14:05","commitOrder":7,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-06-18 15:14:05","endLine":388,"groupId":"4365","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/da/744bb3ec55f481bff31fc3d3c6dc3c00455604.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"N"}],"commitId":"0325ef2ae453796e13962aca300cc2d2685659d7","commitMessage":"@@@SOLR-7143: MoreLikeThis Query parser now handles multiple field names\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1689531 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-07-07 08:05:23","modifiedFileCount":"5","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2015-09-07 21:34:46","codes":[{"authorDate":"2015-07-07 08:05:23","commitOrder":8,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2015-07-07 08:05:23","endLine":124,"groupId":"28796","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0e/deb10790a3bd8ac6434d55c1a674e4f8b149a1.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":50,"status":"N"},{"authorDate":"2015-09-07 21:34:46","commitOrder":8,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          Float b = this.boostFields.get(((TermQuery) q).getTerm().field());\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-09-07 21:34:46","endLine":392,"groupId":"43955","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cf/a0a67a790fc6759fa3d2118007b281977ebb60.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"M"}],"commitId":"962313b83ba9c69379e1f84dffc881a361713ce9","commitMessage":"@@@LUCENE-6590: Replace Query.getBoost.  setBoost and clone with a new BoostQuery.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1701621 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-09-07 21:34:46","modifiedFileCount":"226","status":"M","submitter":"Adrien Grand"},{"authorTime":"2015-09-07 21:34:46","codes":[{"authorDate":"2015-11-24 03:41:08","commitOrder":9,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          Float b = boostFields.get(((TermQuery) q).getTerm().field());\n\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2015-11-24 03:41:08","endLine":162,"groupId":"14284","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/db/ffef40b181ca5cc70d344c5b328aaf8f75470b.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2015-09-07 21:34:46","commitOrder":9,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          Float b = this.boostFields.get(((TermQuery) q).getTerm().field());\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-09-07 21:34:46","endLine":392,"groupId":"43955","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cf/a0a67a790fc6759fa3d2118007b281977ebb60.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          Float b = this.boostFields.get(((TermQuery) q).getTerm().field());\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"N"}],"commitId":"064f9e99701b5bad4ae053927f8d274362fb30fb","commitMessage":"@@@SOLR-7912: Add boost support.  and also exclude the queried document in MoreLikeThis QParser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1715931 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-11-24 03:41:08","modifiedFileCount":"4","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2016-01-01 07:31:25","codes":[{"authorDate":"2016-01-01 07:31:25","commitOrder":10,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2016-01-01 07:31:25","endLine":164,"groupId":"13489","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/19/e78a2db64b23e0c038169f6e3739228e5e0347.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          Float b = boostFields.get(((TermQuery) q).getTerm().field());\n\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-01-01 07:31:25","commitOrder":10,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-01-01 07:31:25","endLine":393,"groupId":"13489","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/14/8c76a05efdf105b4d80b015242e3398a22d343.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          Float b = this.boostFields.get(((TermQuery) q).getTerm().field());\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"M"}],"commitId":"8127db872fde946441d135f454114d84a9aa4eb7","commitMessage":"@@@SOLR-8418: Adapt to changes in LUCENE-6590 for use of boosts with MLTHandler and Simple/CloudMLTQParser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1722478 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-01-01 07:31:25","modifiedFileCount":"6","status":"M","submitter":"Ramkumar Aiyengar"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2016-07-01 01:04:11","commitOrder":11,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2016-07-07 16:02:29","endLine":161,"groupId":"13489","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/96/2f452e91873070d7ea37aca00b0be84ddc344a.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":11,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"M"}],"commitId":"f1528bf338f42ef0e10f6cf1333286eb05139acd","commitMessage":"@@@LUCENE-7369: Similarity.coord and BooleanQuery.disableCoord are removed.\n","date":"2016-07-07 16:02:29","modifiedFileCount":"70","status":"M","submitter":"Adrien Grand"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2016-10-21 21:28:33","commitOrder":12,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n      \r\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\", false));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2016-10-21 21:28:33","endLine":148,"groupId":"13489","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/50/803df2e911c08892d9ccd29938d0d9da4406bb.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":12,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"ccbafdc403fb66e4becfe1b934957f6247b07a7a","commitMessage":"@@@SOLR-9546: Eliminate unnecessary boxing/unboxing going on in SolrParams\n","date":"2016-10-21 21:28:33","modifiedFileCount":"10","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2017-01-10 05:05:21","commitOrder":13,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2017-01-10 05:06:24","endLine":150,"groupId":"22871","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/de/6eb58286b839dfc778c060a56ba947329b7a65.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n      \r\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\", false));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":13,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"2b4e3dd941a7a88274f2a86f18ea57a9d95e4364","commitMessage":"@@@SOLR-9644: Fixed SimpleMLTQParser and CloudMLTQParser to handle boosts properly and CloudMLTQParser to only extract actual values from IndexableField type fields to the filtered document.\n","date":"2017-01-10 05:06:24","modifiedFileCount":"4","status":"M","submitter":"anshum"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2017-02-08 02:38:22","commitOrder":14,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2017-02-08 02:38:22","endLine":150,"groupId":"22871","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/de/a161dbb007445081df43d946c1e6ec17555970.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":14,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"59c41e2a6c685dd9ac943c69d12e9bfe2a7d380e","commitMessage":"@@@SOLR-10011: Add NumberType getNumberType() to FieldType and deprecate LegacyNumericType getNumericType()\n\nModify references to getNumericType() to use the new getNumberType(). NumberType is shared for the different numeric implementations supported in Solr (TrieFields and PointFields).\nCC SOLR-8396\n","date":"2017-02-08 02:38:22","modifiedFileCount":"27","status":"M","submitter":"Tomas Fernandez Lobbe"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2017-06-29 17:00:17","commitOrder":15,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2017-06-29 17:00:17","endLine":151,"groupId":"22871","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4a/3400b70f0653c4a351b10489cd6107612d0c65.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":15,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"b4fa0e785b70e39a3a1420bc020ad1183308b7af","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2017-06-29 17:00:17","modifiedFileCount":"697","status":"M","submitter":"Karl Wright"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2018-07-30 16:08:16","commitOrder":16,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2018-07-30 22:38:05","endLine":151,"groupId":"22871","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/1c62102846a2f9ce73b1cc62ddf0ebfd90939a.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":16,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"9ca053712af0795cbd0d0d9f2d862f24d9e547c3","commitMessage":"@@@LUCENE-8430: TopDocs.totalHits may now be a lower bound of the hit count.\n","date":"2018-07-30 22:38:05","modifiedFileCount":"178","status":"M","submitter":"Adrien Grand"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2019-09-13 20:42:38","commitOrder":17,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (Map.Entry<String, SchemaField> entry : fieldDefinitions.entrySet()) {\n          if (entry.getValue().indexed() && entry.getValue().stored())\n            if (entry.getValue().getType().getNumberType() == null)\n              fields.add(entry.getKey());\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2019-09-13 20:42:38","endLine":151,"groupId":"22871","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c5/7fb00006244485c1edaca50c851a76682ed34a.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":17,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"ec78ef785275e4d46c0f133c6b55be1f974b8db2","commitMessage":"@@@Changing keyset() to entryset() and sometines values(). (#868)\n\n","date":"2019-09-13 20:42:38","modifiedFileCount":"21","status":"M","submitter":"Koen De Groote"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2020-06-08 09:20:25","commitOrder":18,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        ArrayList<String> fields = new ArrayList();\n        for (Map.Entry<String, SchemaField> entry : fieldDefinitions.entrySet()) {\n          if (entry.getValue().indexed() && entry.getValue().stored())\n            if (entry.getValue().getType().getNumberType() == null)\n              fields.add(entry.getKey());\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2020-06-08 09:20:25","endLine":152,"groupId":"21204","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/04/648e0f9d0e15d5dbac8996e023ebb0de80d0a9.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (Map.Entry<String, SchemaField> entry : fieldDefinitions.entrySet()) {\n          if (entry.getValue().indexed() && entry.getValue().stored())\n            if (entry.getValue().getType().getNumberType() == null)\n              fields.add(entry.getKey());\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":18,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"04ba04c29d5079d74231aa5a54d5f0a93bd16f2b","commitMessage":"@@@SOLR-14543: Fix or suppress warnings in apache/solr/search\n","date":"2020-06-08 09:20:25","modifiedFileCount":"42","status":"M","submitter":"Erick Erickson"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2021-06-29 03:06:47","commitOrder":19,"curCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList<>();\n        for (Map.Entry<String, SchemaField> entry : fieldDefinitions.entrySet()) {\n          if (entry.getValue().indexed() && entry.getValue().stored())\n            if (entry.getValue().getType().getNumberType() == null)\n              fields.add(entry.getKey());\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","date":"2021-06-29 03:06:47","endLine":151,"groupId":"102273","id":35,"instanceNumber":1,"isCurCommit":1,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/43/90c257b7df010cc9fd50bdb31a32698ce7c326.src","preCode":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        \r\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        ArrayList<String> fields = new ArrayList();\n        for (Map.Entry<String, SchemaField> entry : fieldDefinitions.entrySet()) {\n          if (entry.getValue().indexed() && entry.getValue().stored())\n            if (entry.getValue().getType().getNumberType() == null)\n              fields.add(entry.getKey());\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":19,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"102273","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"5e7310c344b4d31903acda93c7638bce125b63cf","commitMessage":"@@@SOLR-15385 RawTypes Part IV.  solr-core (#195)\n\n","date":"2021-06-29 03:06:47","modifiedFileCount":"93","status":"M","submitter":"Mike Drob"}]
