[{"authorTime":"2021-01-26 22:16:04","codes":[{"authorDate":"2021-02-04 21:47:30","commitOrder":13,"curCode":"    private List<ReplicaPosition> getReplicaPositions(DocCollection restoreCollection, List<String> nodeList, ClusterState clusterState, List<String> sliceNames) throws IOException, InterruptedException {\n      Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(restoreCollection.getName())\n              .forShard(sliceNames)\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(nodeList)\n              .build();\n      Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ocmh.overseer.getCoreContainer(),\n              clusterState, restoreCollection);\n      return assignStrategy.assign(ocmh.cloudManager, assignRequest);\n    }\n","date":"2021-02-04 21:47:30","endLine":362,"groupId":"36419","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"getReplicaPositions","params":"(DocCollectionrestoreCollection@List<String>nodeList@ClusterStateclusterState@List<String>sliceNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/48/a584bbb4f0a1a2beaf11dfdf6ab48edc884f96.src","preCode":"    private List<ReplicaPosition> getReplicaPositions(DocCollection restoreCollection, List<String> nodeList, ClusterState clusterState, List<String> sliceNames) throws IOException, InterruptedException {\n      Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(restoreCollection.getName())\n              .forShard(sliceNames)\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(nodeList)\n              .build();\n      Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ocmh.overseer.getCoreContainer(),\n              clusterState, restoreCollection);\n      return assignStrategy.assign(ocmh.cloudManager, assignRequest);\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":349,"status":"B"},{"authorDate":"2021-01-26 22:16:04","commitOrder":13,"curCode":"  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); \r\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    \r\n    \r\n    \r\n    \r\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    \r\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ocmh.overseer.getCoreContainer(),\n              clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                \r\n                \r\n                \r\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    \r\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    \r\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    \r\n    \r\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n","date":"2021-01-26 22:16:33","endLine":232,"groupId":"38367","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStatestate@ZkNodePropsmessage@@SuppressWarnings({\"rawtypes\"})NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/71/40946ad98a22ecd0f28203585fffd933023448.src","preCode":"  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); \r\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    \r\n    \r\n    \r\n    \r\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    \r\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ocmh.overseer.getCoreContainer(),\n              clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                \r\n                \r\n                \r\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    \r\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    \r\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    \r\n    \r\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"NB"}],"commitId":"33d16b570c7630fde784552193ad495b63abd3e3","commitMessage":"@@@SOLR-13608: Incremental backup file format (#2250)\n\nThis commit introduces a new way for Solr to do backups (with a new\nunderlying file structure).  This new \"incremental\" backup process\nimproves over the existing backup mechanism in several ways:\n\n- multiple backups \"points\" can now be stored at a given backup\n  location/name.  allowing users to choose which point in time they want\n  to restore\n- subsequent backups skip over uploading files that were uploaded by\n  previous backups.  saving time and network time.\n- files are checksumed as they're uploaded.  ensuring that corrupted\n  indices aren't persisted and accidentally restored later.\n\nIncremental backups are now the default.  and traditional backups\nshould now be considered 'deprecated' but can still be created by\npassing an `incremental=false` parameter on backup requests.","date":"2021-02-04 21:47:30","modifiedFileCount":"23","status":"M","submitter":"Jason Gerlowski"},{"authorTime":"2021-02-19 21:40:23","codes":[{"authorDate":"2021-02-19 21:40:23","commitOrder":14,"curCode":"    private List<ReplicaPosition> getReplicaPositions(DocCollection restoreCollection, List<String> nodeList, ClusterState clusterState, List<String> sliceNames) throws IOException, InterruptedException {\n      Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(restoreCollection.getName())\n              .forShard(sliceNames)\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(nodeList)\n              .build();\n      Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ccc.getCoreContainer(),\n              clusterState, restoreCollection);\n      return assignStrategy.assign(ccc.getSolrCloudManager(), assignRequest);\n    }\n","date":"2021-02-19 21:40:23","endLine":368,"groupId":"36419","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"getReplicaPositions","params":"(DocCollectionrestoreCollection@List<String>nodeList@ClusterStateclusterState@List<String>sliceNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/86/0605cda463d7d0908bf8d0a31dd31f476a6148.src","preCode":"    private List<ReplicaPosition> getReplicaPositions(DocCollection restoreCollection, List<String> nodeList, ClusterState clusterState, List<String> sliceNames) throws IOException, InterruptedException {\n      Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(restoreCollection.getName())\n              .forShard(sliceNames)\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(nodeList)\n              .build();\n      Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ocmh.overseer.getCoreContainer(),\n              clusterState, restoreCollection);\n      return assignStrategy.assign(ocmh.cloudManager, assignRequest);\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":355,"status":"M"},{"authorDate":"2021-02-19 21:40:23","commitOrder":14,"curCode":"  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); \r\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    \r\n    \r\n    \r\n    \r\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    \r\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ccc.getCloseableToLatchOn());\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ccc.getCloseableToLatchOn());\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ccc.getSolrCloudManager().getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ccc.getCoreContainer(),\n              clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ccc.getSolrCloudManager(), assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = new AddReplicaCmd(ccc).addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                \r\n                \r\n                \r\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    \r\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    \r\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ccc.getCloseableToLatchOn());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          new DeleteReplicaCmd(ccc).deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    \r\n    \r\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ccc, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n","date":"2021-02-19 21:40:23","endLine":232,"groupId":"10109","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStatestate@ZkNodePropsmessage@@SuppressWarnings({\"rawtypes\"})NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/42/8e165f4a27a2fd34e9f790c1fa3a6f83aac93f.src","preCode":"  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); \r\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    \r\n    \r\n    \r\n    \r\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    \r\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ocmh.overseer.getCoreContainer(),\n              clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                \r\n                \r\n                \r\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    \r\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    \r\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    \r\n    \r\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"}],"commitId":"e7c80f6445a04cb3d1b49d85d773fde283c916fe","commitMessage":"@@@SOLR-15157: refactor Collection API to separate from Overseer and message handling abstractions (#2390)\n\nNo functional changes. In preparation of distributing the Collection API command execution.","date":"2021-02-19 21:40:23","modifiedFileCount":"42","status":"M","submitter":"Ilan Ginzburg"},{"authorTime":"2021-07-13 23:49:56","codes":[{"authorDate":"2021-02-19 21:40:23","commitOrder":15,"curCode":"    private List<ReplicaPosition> getReplicaPositions(DocCollection restoreCollection, List<String> nodeList, ClusterState clusterState, List<String> sliceNames) throws IOException, InterruptedException {\n      Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(restoreCollection.getName())\n              .forShard(sliceNames)\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(nodeList)\n              .build();\n      Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ccc.getCoreContainer(),\n              clusterState, restoreCollection);\n      return assignStrategy.assign(ccc.getSolrCloudManager(), assignRequest);\n    }\n","date":"2021-02-19 21:40:23","endLine":368,"groupId":"102433","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"getReplicaPositions","params":"(DocCollectionrestoreCollection@List<String>nodeList@ClusterStateclusterState@List<String>sliceNames)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/86/0605cda463d7d0908bf8d0a31dd31f476a6148.src","preCode":"    private List<ReplicaPosition> getReplicaPositions(DocCollection restoreCollection, List<String> nodeList, ClusterState clusterState, List<String> sliceNames) throws IOException, InterruptedException {\n      Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(restoreCollection.getName())\n              .forShard(sliceNames)\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(nodeList)\n              .build();\n      Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ccc.getCoreContainer(),\n              clusterState, restoreCollection);\n      return assignStrategy.assign(ccc.getSolrCloudManager(), assignRequest);\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":355,"status":"N"},{"authorDate":"2021-07-13 23:49:56","commitOrder":15,"curCode":"  public void call(ClusterState state, ZkNodeProps message, NamedList<Object> results) throws Exception {\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); \r\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    \r\n    \r\n    \r\n    \r\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    \r\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ccc.getCloseableToLatchOn());\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ccc.getCloseableToLatchOn());\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ccc.getSolrCloudManager().getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ccc.getCoreContainer(),\n              clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ccc.getSolrCloudManager(), assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        NamedList<Object> nl = new NamedList<>();\n        final ZkNodeProps addedReplica = new AddReplicaCmd(ccc).addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                \r\n                \r\n                \r\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    \r\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    \r\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ccc.getCloseableToLatchOn());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList<Object> deleteResult = new NamedList<>();\n        try {\n          new DeleteReplicaCmd(ccc).deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    \r\n    \r\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ccc, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n","date":"2021-07-13 23:49:56","endLine":229,"groupId":"102433","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"call","params":"(ClusterStatestate@ZkNodePropsmessage@NamedList<Object>results)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/a6f6ad0cea751cd6936da23e747a869908c0f0.src","preCode":"  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); \r\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    \r\n    \r\n    \r\n    \r\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    \r\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ccc.getCloseableToLatchOn());\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ccc.getCloseableToLatchOn());\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ccc.getSolrCloudManager().getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(\n              ccc.getCoreContainer(),\n              clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ccc.getSolrCloudManager(), assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = new AddReplicaCmd(ccc).addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                \r\n                \r\n                \r\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    \r\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    \r\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ccc.getCloseableToLatchOn());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          new DeleteReplicaCmd(ccc).deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    \r\n    \r\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ccc, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":62,"status":"M"}],"commitId":"09986130545fabfb2cc76ced85a0da6ba536acf0","commitMessage":"@@@SOLR-15385 RawTypes Part VI (#207)\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>","date":"2021-07-13 23:49:56","modifiedFileCount":"185","status":"M","submitter":"Mike Drob"}]
