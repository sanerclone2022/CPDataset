[{"authorTime":"2019-06-18 00:59:43","codes":[{"authorDate":"2018-11-30 01:58:18","commitOrder":3,"curCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n      throws InterruptedException, TimeoutException {\n    \n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n    \n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    CollectionStateWatcher watcher = (n, c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.matches(n, c);\n      if (matches)\n        latch.countDown();\n      \n      return matches;\n    };\n    registerCollectionStateWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    }\n    finally {\n      removeCollectionStateWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","date":"2018-11-30 01:58:51","endLine":1529,"groupId":"11400","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"waitForState","params":"(finalStringcollection@longwait@TimeUnitunit@CollectionStatePredicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ff/53f517c53ef1a4d043c94fa410ec14dc6dee38.src","preCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n      throws InterruptedException, TimeoutException {\n    \n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n    \n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    CollectionStateWatcher watcher = (n, c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.matches(n, c);\n      if (matches)\n        latch.countDown();\n      \n      return matches;\n    };\n    registerCollectionStateWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    }\n    finally {\n      removeCollectionStateWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1499,"status":"NB"},{"authorDate":"2019-06-18 00:59:43","commitOrder":3,"curCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, Predicate<DocCollection> predicate)\n      throws InterruptedException, TimeoutException {\n\n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    DocCollectionWatcher watcher = (c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.test(c);\n      if (matches)\n        latch.countDown();\n\n      return matches;\n    };\n    registerDocCollectionWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    }\n    finally {\n      removeDocCollectionWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","date":"2019-06-18 00:59:43","endLine":1762,"groupId":"48003","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"waitForState","params":"(finalStringcollection@longwait@TimeUnitunit@Predicate<DocCollection>predicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cd/72203eacb801fba6859d03a0f8ad500243ef36.src","preCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, Predicate<DocCollection> predicate)\n      throws InterruptedException, TimeoutException {\n\n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    DocCollectionWatcher watcher = (c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.test(c);\n      if (matches)\n        latch.countDown();\n\n      return matches;\n    };\n    registerDocCollectionWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    }\n    finally {\n      removeDocCollectionWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1732,"status":"B"}],"commitId":"5a974860fa83408a86ca64b417f3111b037da7eb","commitMessage":"@@@SOLR-13490: Fix CollectionStateWatcher/CollectionStatePredicate based APIs in ZkStateReader and CloudSolrClient to be triggered on liveNode changes.\n\nAlso add Predicate<DocCollection> equivilents for callers that don't care about liveNodes.\n","date":"2019-06-18 00:59:43","modifiedFileCount":"15","status":"M","submitter":"Chris Hostetter"},{"authorTime":"2021-01-30 00:20:16","codes":[{"authorDate":"2018-11-30 01:58:18","commitOrder":4,"curCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n      throws InterruptedException, TimeoutException {\n    \n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n    \n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    CollectionStateWatcher watcher = (n, c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.matches(n, c);\n      if (matches)\n        latch.countDown();\n      \n      return matches;\n    };\n    registerCollectionStateWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    }\n    finally {\n      removeCollectionStateWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","date":"2018-11-30 01:58:51","endLine":1529,"groupId":"11400","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"waitForState","params":"(finalStringcollection@longwait@TimeUnitunit@CollectionStatePredicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ff/53f517c53ef1a4d043c94fa410ec14dc6dee38.src","preCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n      throws InterruptedException, TimeoutException {\n    \n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n    \n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    CollectionStateWatcher watcher = (n, c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.matches(n, c);\n      if (matches)\n        latch.countDown();\n      \n      return matches;\n    };\n    registerCollectionStateWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    }\n    finally {\n      removeCollectionStateWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1499,"status":"N"},{"authorDate":"2021-01-30 00:20:16","commitOrder":4,"curCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, Predicate<DocCollection> predicate)\n      throws InterruptedException, TimeoutException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Waiting up to {}ms for state {}\", unit.toMillis(wait), predicate);\n    }\n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    DocCollectionWatcher watcher = (c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.test(c);\n      if (matches)\n        latch.countDown();\n\n      return matches;\n    };\n    registerDocCollectionWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    } finally {\n      removeDocCollectionWatcher(collection, watcher);\n      waitLatches.remove(latch);\n      if (log.isDebugEnabled()) {\n        log.debug(\"Completed wait for {}\", predicate);\n      }\n    }\n  }\n","date":"2021-01-30 00:20:16","endLine":1744,"groupId":"48003","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"waitForState","params":"(finalStringcollection@longwait@TimeUnitunit@Predicate<DocCollection>predicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d3/834caefb7c3ae17f1a616c1f51293b5630b80f.src","preCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, Predicate<DocCollection> predicate)\n      throws InterruptedException, TimeoutException {\n\n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    DocCollectionWatcher watcher = (c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.test(c);\n      if (matches)\n        latch.countDown();\n\n      return matches;\n    };\n    registerDocCollectionWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    } finally {\n      removeDocCollectionWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1710,"status":"M"}],"commitId":"0d4769e174aad3eede7e7b281d14682bab483468","commitMessage":"@@@SOLR-15120 Reduce duplicated core creation work (#2266)\n\nUse j.u.c collections instead of sync block\nRework how we load implicit handlers\nAdditional debug and trace logging for zookeeper comms","date":"2021-01-30 00:20:16","modifiedFileCount":"13","status":"M","submitter":"Mike Drob"},{"authorTime":"2021-02-04 04:40:07","codes":[{"authorDate":"2018-11-30 01:58:18","commitOrder":5,"curCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n      throws InterruptedException, TimeoutException {\n    \n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n    \n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    CollectionStateWatcher watcher = (n, c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.matches(n, c);\n      if (matches)\n        latch.countDown();\n      \n      return matches;\n    };\n    registerCollectionStateWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    }\n    finally {\n      removeCollectionStateWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","date":"2018-11-30 01:58:51","endLine":1529,"groupId":"1116","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"waitForState","params":"(finalStringcollection@longwait@TimeUnitunit@CollectionStatePredicatepredicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ff/53f517c53ef1a4d043c94fa410ec14dc6dee38.src","preCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n      throws InterruptedException, TimeoutException {\n    \n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n    \n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    CollectionStateWatcher watcher = (n, c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.matches(n, c);\n      if (matches)\n        latch.countDown();\n      \n      return matches;\n    };\n    registerCollectionStateWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    }\n    finally {\n      removeCollectionStateWatcher(collection, watcher);\n      waitLatches.remove(latch);\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1499,"status":"N"},{"authorDate":"2021-02-04 04:40:07","commitOrder":5,"curCode":"  public DocCollection waitForState(final String collection, long wait, TimeUnit unit, Predicate<DocCollection> predicate)\n      throws InterruptedException, TimeoutException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Waiting up to {}ms for state {}\", unit.toMillis(wait), predicate);\n    }\n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    DocCollectionWatcher watcher = (c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.test(c);\n      if (matches)\n        latch.countDown();\n\n      return matches;\n    };\n    registerDocCollectionWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n      return docCollection.get();\n    } finally {\n      removeDocCollectionWatcher(collection, watcher);\n      waitLatches.remove(latch);\n      if (log.isDebugEnabled()) {\n        log.debug(\"Completed wait for {}\", predicate);\n      }\n    }\n  }\n","date":"2021-02-04 04:40:07","endLine":1746,"groupId":"1116","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"waitForState","params":"(finalStringcollection@longwait@TimeUnitunit@Predicate<DocCollection>predicate)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/8a/ad1392b189dc7e9f14332e0a2fb17e180df1d3.src","preCode":"  public void waitForState(final String collection, long wait, TimeUnit unit, Predicate<DocCollection> predicate)\n      throws InterruptedException, TimeoutException {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Waiting up to {}ms for state {}\", unit.toMillis(wait), predicate);\n    }\n    if (closed) {\n      throw new AlreadyClosedException();\n    }\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    waitLatches.add(latch);\n    AtomicReference<DocCollection> docCollection = new AtomicReference<>();\n    DocCollectionWatcher watcher = (c) -> {\n      docCollection.set(c);\n      boolean matches = predicate.test(c);\n      if (matches)\n        latch.countDown();\n\n      return matches;\n    };\n    registerDocCollectionWatcher(collection, watcher);\n\n    try {\n      \r\n      if (!latch.await(wait, unit))\n        throw new TimeoutException(\"Timeout waiting to see state for collection=\" + collection + \" :\" + docCollection.get());\n\n    } finally {\n      removeDocCollectionWatcher(collection, watcher);\n      waitLatches.remove(latch);\n      if (log.isDebugEnabled()) {\n        log.debug(\"Completed wait for {}\", predicate);\n      }\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1712,"status":"M"}],"commitId":"40c5d6b750637eab6fad3e30715a224423b3a56e","commitMessage":"@@@SOLR-14253 Avoid writes in ZKSR.waitForState (#2297)\n\n","date":"2021-02-04 04:40:07","modifiedFileCount":"4","status":"M","submitter":"Mike Drob"}]
