[{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2014-10-29 02:12:31","commitOrder":2,"curCode":"  public Query parse() {\n    String id = localParams.get(\"id\");\n    \r\n    SolrDocument doc = getDocument(id);\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, ArrayList<String>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2014-10-29 02:12:31","endLine":83,"groupId":"45349","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d5/4d62b6c99b2c1c30ca5139edaecc58e8afcbd7.src","preCode":"  public Query parse() {\n    String id = localParams.get(\"id\");\n    \r\n    SolrDocument doc = getDocument(id);\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, ArrayList<String>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"B"},{"authorDate":"2011-07-10 07:01:53","commitOrder":2,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","date":"2011-07-10 07:01:53","endLine":341,"groupId":"28039","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/6c26305fd0988a8d05ae3ae61b7ed5415f8595.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"NB"}],"commitId":"a5ba0b84f7c707d04da1f2385dbc79c0e7cf9a40","commitMessage":"@@@SOLR-6248: MoreLikeThis QParser that works in standalone/cloud mode\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1634937 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-10-29 02:12:31","modifiedFileCount":"3","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2014-10-30 07:10:17","commitOrder":3,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, ArrayList<String>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2014-10-30 07:10:17","endLine":84,"groupId":"45349","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cb/b191276fdaf2cc88d47b142e0bc64a94989e05.src","preCode":"  public Query parse() {\n    String id = localParams.get(\"id\");\n    \r\n    SolrDocument doc = getDocument(id);\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, ArrayList<String>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"},{"authorDate":"2011-07-10 07:01:53","commitOrder":3,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","date":"2011-07-10 07:01:53","endLine":341,"groupId":"28039","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/6c26305fd0988a8d05ae3ae61b7ed5415f8595.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"N"}],"commitId":"d7a142343927505f6df27e10ab22befac945f9b1","commitMessage":"@@@SOLR-6248: Changing the format of mlt query parser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1635329 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-10-30 07:10:17","modifiedFileCount":"6","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2014-11-05 08:21:42","commitOrder":4,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2014-11-05 08:21:42","endLine":100,"groupId":"34989","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/5f/713871a0c8642388a6c34b61d8fc7813a158f0.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, ArrayList<String>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        filteredDocument.put(field, (ArrayList<String>) doc.get(field));\n      }\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"},{"authorDate":"2011-07-10 07:01:53","commitOrder":4,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","date":"2011-07-10 07:01:53","endLine":341,"groupId":"28039","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/6c26305fd0988a8d05ae3ae61b7ed5415f8595.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"N"}],"commitId":"2c8de2f35cacd357f99d6663bdcd855f559ab127","commitMessage":"@@@SOLR-6248: Fixing an exception in case of missing qf\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1636784 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-05 08:21:42","modifiedFileCount":"3","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2015-04-22 08:09:33","commitOrder":5,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2015-04-22 08:09:33","endLine":105,"groupId":"34989","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/5f/2c300f6a58c76663abf1b9521bf0e6519db77c.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"},{"authorDate":"2011-07-10 07:01:53","commitOrder":5,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","date":"2011-07-10 07:01:53","endLine":341,"groupId":"28039","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/6c26305fd0988a8d05ae3ae61b7ed5415f8595.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"N"}],"commitId":"2482af467d152d11d89993436256f848f8acb64a","commitMessage":"@@@SOLR-7418:  Check and raise a SolrException instead of an NPE when an invalid doc id is sent to the MLTQParser in Cloud mode\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1675230 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-04-22 08:09:33","modifiedFileCount":"2","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2015-06-18 07:12:15","commitOrder":6,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2015-06-18 07:12:15","endLine":113,"groupId":"0","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b8/53db2d43ba4cc6ebd202e7c3a2e272c924f341.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \r\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n    \n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"},{"authorDate":"2011-07-10 07:01:53","commitOrder":6,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","date":"2011-07-10 07:01:53","endLine":341,"groupId":"28039","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/21/6c26305fd0988a8d05ae3ae61b7ed5415f8595.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":328,"status":"N"}],"commitId":"2b96b2504677c0673bbf8300d2217205684056c6","commitMessage":"@@@SOLR-7639: MoreLikeThis QParser now supports all options provided by the MLT Handler i.e. mintf.  mindf.  minwl.  maxwl.  maxqt.  and maxntp. This commit also fixes an NPE issue in CloudMLTQParser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1686123 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-18 07:12:15","modifiedFileCount":"4","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2015-06-18 15:14:05","codes":[{"authorDate":"2015-06-18 07:12:15","commitOrder":7,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2015-06-18 07:12:15","endLine":113,"groupId":"0","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b8/53db2d43ba4cc6ebd202e7c3a2e272c924f341.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"N"},{"authorDate":"2015-06-18 15:14:05","commitOrder":7,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-06-18 15:14:05","endLine":388,"groupId":"4365","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/da/744bb3ec55f481bff31fc3d3c6dc3c00455604.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        List clauses = boostedQuery.clauses();\n        for( Object o : clauses ) {\n          TermQuery q = (TermQuery)((BooleanClause)o).getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q.setBoost(b*q.getBoost());\n          }\n        }\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"M"}],"commitId":"4aafacfbef423a25a349dd8c6e5e6178ac1ba334","commitMessage":"@@@LUCENE-6570: Make BooleanQuery immutable.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1686145 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-18 15:14:05","modifiedFileCount":"184","status":"M","submitter":"Adrien Grand"},{"authorTime":"2015-06-18 15:14:05","codes":[{"authorDate":"2015-06-24 00:03:48","commitOrder":8,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2015-06-24 00:03:48","endLine":117,"groupId":"0","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/52/f9ffaeb47804a66f62c7ce4edb199118b19fa9.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"},{"authorDate":"2015-06-18 15:14:05","commitOrder":8,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-06-18 15:14:05","endLine":388,"groupId":"4365","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/da/744bb3ec55f481bff31fc3d3c6dc3c00455604.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"N"}],"commitId":"48ea578733bdde3d5254a617ec33bea77bd05530","commitMessage":"@@@SOLR-7639: Fixing maxqt.  and maxntp.  and adding support for maxdf to MLTQParser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1687088 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-24 00:03:48","modifiedFileCount":"2","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2015-06-18 15:14:05","codes":[{"authorDate":"2015-07-07 08:05:23","commitOrder":9,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    ArrayList<String> fieldNames = new ArrayList();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2015-07-07 08:05:23","endLine":136,"groupId":"0","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a6/8dd9f196f76d0d403f95764472ea5aa02a135e.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    if (qf != null) {\n      mlt.setFieldNames(qf);\n      for (String field : qf) {\n        filteredDocument.put(field, doc.getFieldValues(field));\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      ArrayList<String> fieldNames = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n          filteredDocument.put(field, doc.getFieldValues(field));\n        }\n      }\n      mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"},{"authorDate":"2015-06-18 15:14:05","commitOrder":9,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-06-18 15:14:05","endLine":388,"groupId":"4365","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/da/744bb3ec55f481bff31fc3d3c6dc3c00455604.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"N"}],"commitId":"0325ef2ae453796e13962aca300cc2d2685659d7","commitMessage":"@@@SOLR-7143: MoreLikeThis Query parser now handles multiple field names\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1689531 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-07-07 08:05:23","modifiedFileCount":"5","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2015-09-07 21:34:46","codes":[{"authorDate":"2015-07-07 08:05:23","commitOrder":10,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    ArrayList<String> fieldNames = new ArrayList();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2015-07-07 08:05:23","endLine":136,"groupId":"0","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a6/8dd9f196f76d0d403f95764472ea5aa02a135e.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    ArrayList<String> fieldNames = new ArrayList();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"N"},{"authorDate":"2015-09-07 21:34:46","commitOrder":10,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          Float b = this.boostFields.get(((TermQuery) q).getTerm().field());\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-09-07 21:34:46","endLine":392,"groupId":"43955","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cf/a0a67a790fc6759fa3d2118007b281977ebb60.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery.clone();\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          TermQuery q = (TermQuery) clause.getQuery();\n          Float b = this.boostFields.get(q.getTerm().field());\n          if (b != null) {\n            q = (TermQuery) q.clone();\n            q.setBoost(b*q.getBoost());\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"M"}],"commitId":"962313b83ba9c69379e1f84dffc881a361713ce9","commitMessage":"@@@LUCENE-6590: Replace Query.getBoost.  setBoost and clone with a new BoostQuery.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1701621 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-09-07 21:34:46","modifiedFileCount":"226","status":"M","submitter":"Adrien Grand"},{"authorTime":"2015-09-07 21:34:46","codes":[{"authorDate":"2015-11-24 03:41:08","commitOrder":11,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n    ArrayList<String> fieldNames = new ArrayList();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          Float b = boostFields.get(((TermQuery) q).getTerm().field());\n\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(\"id\", id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2015-11-24 03:41:08","endLine":177,"groupId":"43955","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3d/e5212c1d1f85e1be9863b2cdf8e656f7956f2d.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n\n    ArrayList<String> fieldNames = new ArrayList();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      return mlt.like(filteredDocument);\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2015-09-07 21:34:46","commitOrder":11,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          Float b = this.boostFields.get(((TermQuery) q).getTerm().field());\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2015-09-07 21:34:46","endLine":392,"groupId":"43955","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cf/a0a67a790fc6759fa3d2118007b281977ebb60.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          Float b = this.boostFields.get(((TermQuery) q).getTerm().field());\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":375,"status":"N"}],"commitId":"064f9e99701b5bad4ae053927f8d274362fb30fb","commitMessage":"@@@SOLR-7912: Add boost support.  and also exclude the queried document in MoreLikeThis QParser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1715931 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-11-24 03:41:08","modifiedFileCount":"4","status":"M","submitter":"Anshum Gupta"},{"authorTime":"2016-01-01 07:31:25","codes":[{"authorDate":"2016-01-01 07:31:25","commitOrder":12,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(\"id\", id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2016-01-01 07:31:25","endLine":175,"groupId":"13489","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/db/75517bf89aec7149842bf07461489ac4504933.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap();\n    ArrayList<String> fieldNames = new ArrayList();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          Float b = boostFields.get(((TermQuery) q).getTerm().field());\n\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(\"id\", id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"M"},{"authorDate":"2016-01-01 07:31:25","commitOrder":12,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-01-01 07:31:25","endLine":393,"groupId":"13489","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/14/8c76a05efdf105b4d80b015242e3398a22d343.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          Float b = this.boostFields.get(((TermQuery) q).getTerm().field());\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"M"}],"commitId":"8127db872fde946441d135f454114d84a9aa4eb7","commitMessage":"@@@SOLR-8418: Adapt to changes in LUCENE-6590 for use of boosts with MLTHandler and Simple/CloudMLTQParser\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1722478 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-01-01 07:31:25","modifiedFileCount":"6","status":"M","submitter":"Ramkumar Aiyengar"},{"authorTime":"2016-01-01 07:31:25","codes":[{"authorDate":"2016-03-04 18:54:10","commitOrder":13,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2016-03-04 18:54:10","endLine":174,"groupId":"13489","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f2/ed8b973a0447550e1fb953b0158a8fa0aa853f.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(\"id\", id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2016-01-01 07:31:25","commitOrder":13,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-01-01 07:31:25","endLine":393,"groupId":"13489","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/14/8c76a05efdf105b4d80b015242e3398a22d343.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"N"}],"commitId":"517acece6a210b2d1baf75a39fe3b77ea59926b2","commitMessage":"@@@Merge remote-tracking branch 'origin/master'\n\nConflicts:\n\tsolr/CHANGES.txt\n","date":"2016-03-04 18:54:10","modifiedFileCount":"303","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-01-01 07:31:25","codes":[{"authorDate":"2016-05-23 14:35:53","commitOrder":14,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2016-05-23 14:35:53","endLine":173,"groupId":"13489","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/74/916530ecadb0f695b8e53abade92e83331dbd1.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      Map<String, SchemaField> fields = req.getSchema().getFields();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        if(fields.get(field).stored() \n            && fields.get(field).getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2016-01-01 07:31:25","commitOrder":14,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-01-01 07:31:25","endLine":393,"groupId":"13489","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/14/8c76a05efdf105b4d80b015242e3398a22d343.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":372,"status":"N"}],"commitId":"eae605b53294282e50452e60440c138a3529f11d","commitMessage":"@@@Merge remote-tracking branch 'origin/master'\n","date":"2016-05-23 14:35:53","modifiedFileCount":"309","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2016-07-01 01:04:11","commitOrder":15,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2016-07-07 16:02:29","endLine":171,"groupId":"13489","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/46/b927efd9759804740d960ed9ddb7d760bb37ee.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":15,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"M"}],"commitId":"f1528bf338f42ef0e10f6cf1333286eb05139acd","commitMessage":"@@@LUCENE-7369: Similarity.coord and BooleanQuery.disableCoord are removed.\n","date":"2016-07-07 16:02:29","modifiedFileCount":"70","status":"M","submitter":"Adrien Grand"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2016-10-21 21:28:33","commitOrder":16,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\",MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\",MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\", false));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2016-10-21 21:28:33","endLine":158,"groupId":"13489","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9f/f5a3cc4a0e795fa4b4ea1853ef9a662086eae3.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":16,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"ccbafdc403fb66e4becfe1b934957f6247b07a7a","commitMessage":"@@@SOLR-9546: Eliminate unnecessary boxing/unboxing going on in SolrParams\n","date":"2016-10-21 21:28:33","modifiedFileCount":"10","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2016-10-21 21:46:15","commitOrder":17,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2016-10-21 21:46:15","endLine":171,"groupId":"13489","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0f/85feb13c9959e796ff0028684df4ce88ecc280.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\",MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\",MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\", false));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":17,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"49ca9cea7283ab54086fdedd09889d171c777052","commitMessage":"@@@SOLR-9546: reverted some changes\n","date":"2016-10-21 21:46:15","modifiedFileCount":"1","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2016-11-29 20:32:59","commitOrder":18,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    \n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2016-11-29 20:32:59","endLine":164,"groupId":"13489","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0f/46725eb27e93cc8a5dbb22641813bb5ebac1be.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    if(localParams.getInt(\"mintf\") != null)\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    if(localParams.get(\"minwl\") != null)\n      mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n    if(localParams.get(\"maxwl\") != null)\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n    if(localParams.get(\"maxqt\") != null)\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n    if(localParams.get(\"maxntp\") != null)\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n    \n    if(localParams.get(\"maxdf\") != null) {\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n    }\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":58,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":18,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"70b358960dfe8a6da35991b2a84c93cc9370c3d8","commitMessage":"@@@SOLR-9546: remove unnecessary boxing\n","date":"2016-11-29 20:32:59","modifiedFileCount":"1","status":"M","submitter":"Noble Paul"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2017-01-10 05:05:21","commitOrder":19,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      ArrayList<String> fields = new ArrayList();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      ArrayList<String> fields = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        Collection<Object> values = new ArrayList();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2017-01-10 05:06:24","endLine":175,"groupId":"13489","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/94/5047b097adac0d1356ee084fb0bec74aeca059.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n    \n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n    \n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    \n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    if(localParams.get(\"boost\") != null) {\n      mlt.setBoost(localParams.getBool(\"boost\"));\n      boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n    }\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    ArrayList<String> fieldNames = new ArrayList<>();\n\n    if (qf != null) {\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fieldNames.add(string);\n            }\n          }\n        }\n      }\n    } else {\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fieldNames.add(field);\n        }\n      }\n    }\n\n    if( fieldNames.size() < 1 ) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames.toArray(new String[fieldNames.size()]));\n    for (String field : fieldNames) {\n      filteredDocument.put(field, doc.getFieldValues(field));\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":19,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"2b4e3dd941a7a88274f2a86f18ea57a9d95e4364","commitMessage":"@@@SOLR-9644: Fixed SimpleMLTQParser and CloudMLTQParser to handle boosts properly and CloudMLTQParser to only extract actual values from IndexableField type fields to the filtered document.\n","date":"2017-01-10 05:06:24","modifiedFileCount":"4","status":"M","submitter":"anshum"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2017-06-29 17:00:17","commitOrder":20,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      ArrayList<String> fields = new ArrayList();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      ArrayList<String> fields = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        Collection<Object> values = new ArrayList();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","date":"2017-06-29 17:00:17","endLine":179,"groupId":"13489","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/76/69db8634a2cf3462287573525b90032a53e5b9.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      ArrayList<String> fields = new ArrayList();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      ArrayList<String> fields = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        Collection<Object> values = new ArrayList();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":20,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"b4fa0e785b70e39a3a1420bc020ad1183308b7af","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2017-06-29 17:00:17","modifiedFileCount":"697","status":"M","submitter":"Karl Wright"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2019-04-03 10:45:33","commitOrder":21,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      ArrayList<String> fields = new ArrayList();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      ArrayList<String> fields = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        Collection<Object> values = new ArrayList();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\", e);\n    }\n\n  }\n","date":"2019-04-03 10:45:33","endLine":178,"groupId":"13489","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f7/a79dc82d16fa68a2f9d1923d9bdbea1ac00a70.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      ArrayList<String> fields = new ArrayList();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      ArrayList<String> fields = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        Collection<Object> values = new ArrayList();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\");\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":21,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"2d690885e554dda7b4b4e0f46f2bd9cacdb32df6","commitMessage":"@@@SOLR-13322 - let forbidden apis check for sysout in solr core\n","date":"2019-04-03 10:45:33","modifiedFileCount":"29","status":"M","submitter":"Gus Heck"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2020-06-08 09:20:25","commitOrder":22,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n      ArrayList<String> fields = new ArrayList();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n      ArrayList<String> fields = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        Collection<Object> values = new ArrayList();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\", e);\n    }\n\n  }\n","date":"2020-06-08 09:20:25","endLine":181,"groupId":"13489","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/70/ce4e4cb8f26a68f2729fda20e0bc6639652608.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      ArrayList<String> fields = new ArrayList();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      ArrayList<String> fields = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        Collection<Object> values = new ArrayList();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\", e);\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":22,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"13489","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"04ba04c29d5079d74231aa5a54d5f0a93bd16f2b","commitMessage":"@@@SOLR-14543: Fix or suppress warnings in apache/solr/search\n","date":"2020-06-08 09:20:25","modifiedFileCount":"42","status":"M","submitter":"Erick Erickson"},{"authorTime":"2016-07-01 01:04:11","codes":[{"authorDate":"2021-06-29 03:06:47","commitOrder":23,"curCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      ArrayList<String> fields = new ArrayList<>();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      ArrayList<String> fields = new ArrayList<>();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        Collection<Object> values = new ArrayList<>();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\", e);\n    }\n\n  }\n","date":"2021-06-29 03:06:47","endLine":178,"groupId":"102274","id":43,"instanceNumber":1,"isCurCommit":1,"methodName":"parse","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b7/c91233499733c38b22241694ef1595dee80063.src","preCode":"  public Query parse() {\n    String id = localParams.get(QueryParsing.V);\n    \r\n    SolrDocument doc = getDocument(id);\n    if(doc == null) {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + id + \"]\");\n    }\n\n    String[] qf = localParams.getParams(\"qf\");\n    Map<String,Float> boostFields = new HashMap<>();\n    MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n\n    mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n    mlt.setMinDocFreq(localParams.getInt(\"mindf\", 0));\n    mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n    mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n    mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n    mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n    mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n    Boolean boost = localParams.getBool(\"boost\", MoreLikeThis.DEFAULT_BOOST);\n    mlt.setBoost(boost);\n\n    mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n    Map<String, Collection<Object>> filteredDocument = new HashMap<>();\n    String[] fieldNames;\n\n    if (qf != null) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n      ArrayList<String> fields = new ArrayList();\n      for (String fieldName : qf) {\n        if (!StringUtils.isEmpty(fieldName))  {\n          String[] strings = splitList.split(fieldName);\n          for (String string : strings) {\n            if (!StringUtils.isEmpty(string)) {\n              fields.add(string);\n            }\n          }\n        }\n      }\n      \r\n      boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n      fieldNames = boostFields.keySet().toArray(new String[0]);\n    } else {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n      ArrayList<String> fields = new ArrayList();\n      for (String field : doc.getFieldNames()) {\n        \r\n        \r\n        \r\n        SchemaField f = req.getSchema().getFieldOrNull(field);\n        if (f != null && f.stored() && f.getType().isExplicitAnalyzer()) {\n          fields.add(field);\n        }\n      }\n      fieldNames = fields.toArray(new String[0]);\n    }\n\n    if (fieldNames.length < 1) {\n      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n          \"MoreLikeThis requires at least one similarity field: qf\" );\n    }\n\n    mlt.setFieldNames(fieldNames);\n    for (String field : fieldNames) {\n      Collection<Object> fieldValues = doc.getFieldValues(field);\n      if (fieldValues != null) {\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        Collection<Object> values = new ArrayList();\n        for (Object val : fieldValues) {\n          if (val instanceof IndexableField) {\n            values.add(((IndexableField)val).stringValue());\n          }\n          else {\n            values.add(val);\n          }\n        }\n        filteredDocument.put(field, values);\n      }\n    }\n\n    try {\n      Query rawMLTQuery = mlt.like(filteredDocument);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      \r\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(createIdQuery(req.getSchema().getUniqueKeyField().getName(), id), BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad Request\", e);\n    }\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/mlt/CloudMLTQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"M"},{"authorDate":"2016-07-01 01:04:11","commitOrder":23,"curCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","date":"2016-07-07 16:02:29","endLine":379,"groupId":"102274","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"getBoostedQuery","params":"(Querymltquery)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3f/231b2fca3f99d741e40e6ed8343dd41bf824e0.src","preCode":"    private Query getBoostedQuery(Query mltquery) {\n      BooleanQuery boostedQuery = (BooleanQuery)mltquery;\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedQuery.getMinimumNumberShouldMatch());\n        for (BooleanClause clause : boostedQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n        boostedQuery = newQ.build();\n      }\n      return boostedQuery;\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/MoreLikeThisHandler.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":359,"status":"N"}],"commitId":"5e7310c344b4d31903acda93c7638bce125b63cf","commitMessage":"@@@SOLR-15385 RawTypes Part IV.  solr-core (#195)\n\n","date":"2021-06-29 03:06:47","modifiedFileCount":"93","status":"M","submitter":"Mike Drob"}]
