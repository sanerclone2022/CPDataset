[{"authorTime":"2012-07-05 00:02:42","codes":[{"authorDate":"2012-05-09 01:00:33","commitOrder":17,"curCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<Integer,DocInfo>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2012-05-09 01:00:33","endLine":728,"groupId":"28906","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressGetRealtime","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9a/a52c3157b47389198337198d387734d8d7cb1e.src","preCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<Integer,DocInfo>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"NB"},{"authorDate":"2012-07-05 00:02:42","commitOrder":17,"curCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<Integer,DocInfo>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2012-07-05 00:02:42","endLine":278,"groupId":"41338","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testStressGetRealtimeVersions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cc/e28a24bd28baf85941f2b1d88d959b41ec0270.src","preCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<Integer,DocInfo>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressVersions.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"B"}],"commitId":"0327e7bf4c264a88f90678e6d55edb0f06e5e7e5","commitMessage":"@@@tests: refactor TestRealTimeGet\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1357324 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-07-05 00:02:42","modifiedFileCount":"1","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2014-03-12 22:39:17","codes":[{"authorDate":"2014-03-12 22:39:17","commitOrder":18,"curCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2014-03-12 22:39:17","endLine":686,"groupId":"28906","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressGetRealtime","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/15/81f64afcfa35d21f32a2bcf0845a5e6d84dbfc.src","preCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<Integer,DocInfo>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":402,"status":"M"},{"authorDate":"2014-03-12 22:39:17","commitOrder":18,"curCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2014-03-12 22:39:17","endLine":278,"groupId":"41338","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testStressGetRealtimeVersions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d9/1a2cc6a96fa9dd03511c3e55fda444fd373321.src","preCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<Thread>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<Integer,DocInfo>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressVersions.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"}],"commitId":"3b67b17493216f6b0c81a981073fd5f61eace6f4","commitMessage":"@@@LUCENE-5512: remove redundant typing (diamond operator) in trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1576755 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-03-12 22:39:17","modifiedFileCount":"1241","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-03-12 22:39:17","codes":[{"authorDate":"2015-12-24 07:16:13","commitOrder":19,"curCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2015-12-24 07:16:13","endLine":756,"groupId":"28906","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressGetRealtime","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c6/41c7431561542396b61cf560f829d1b227ce69.src","preCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":462,"status":"M"},{"authorDate":"2014-03-12 22:39:17","commitOrder":19,"curCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2014-03-12 22:39:17","endLine":278,"groupId":"41338","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testStressGetRealtimeVersions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d9/1a2cc6a96fa9dd03511c3e55fda444fd373321.src","preCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressVersions.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"N"}],"commitId":"c5e2b3508e829f75e75667595e884a143a294824","commitMessage":"@@@SOLR-8436: filters for realtime-get\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1721585 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-12-24 07:16:13","modifiedFileCount":"3","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2017-03-31 22:22:45","codes":[{"authorDate":"2017-03-31 22:22:45","commitOrder":20,"curCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2017-03-31 23:28:21","endLine":794,"groupId":"28906","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressGetRealtime","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/e4cb70afb256e5926da578b145f88cc637553b.src","preCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":500,"status":"M"},{"authorDate":"2017-03-31 22:22:45","commitOrder":20,"curCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2017-03-31 23:28:21","endLine":278,"groupId":"41338","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testStressGetRealtimeVersions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/15/b0c68737b6afef2bd026260a7227a791fac713.src","preCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressVersions.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"}],"commitId":"e80643e5a77297ba7ee29c7297e37af6ffb73ac2","commitMessage":"@@@LUCENE-7753: Make fields static when possible.\n","date":"2017-03-31 23:28:21","modifiedFileCount":"40","status":"M","submitter":"Adrien Grand"},{"authorTime":"2017-03-31 22:22:45","codes":[{"authorDate":"2018-11-03 05:12:41","commitOrder":21,"curCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get random version\",\n                        () -> deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get bad version\",\n                        () -> addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2018-11-03 22:48:16","endLine":754,"groupId":"22886","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressGetRealtime","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ec/1b422eef0600ddd8723c2f6004bba0518f157f.src","preCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    try {\n                      version = addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion)));\n                      fail();\n                    } catch (SolrException se) {\n                      assertEquals(409, se.code());\n                    }\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":466,"status":"M"},{"authorDate":"2017-03-31 22:22:45","commitOrder":21,"curCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2017-03-31 23:28:21","endLine":278,"groupId":"41338","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testStressGetRealtimeVersions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/15/b0c68737b6afef2bd026260a7227a791fac713.src","preCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressVersions.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"N"}],"commitId":"f669a1fb0e1ff974df93229c41cd397956cb1e9a","commitMessage":"@@@SOLR-12555: Use `expectThrows` for expected exceptions\n\nThis commit replaces the `try { doX(); fail(); }` pattern with the\n`expectThrows` test helper.  which was created for this purpose.\n\nThis commit makes these changes in the core package: `o.a.solr.search`.\n\nCloses #464\n","date":"2018-11-03 22:48:16","modifiedFileCount":"10","status":"M","submitter":"Jason Gerlowski"},{"authorTime":"2019-05-03 05:20:05","codes":[{"authorDate":"2019-05-03 05:20:05","commitOrder":22,"curCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get random version\",\n                        () -> deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get bad version\",\n                        () -> addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2019-05-03 05:20:05","endLine":754,"groupId":"22886","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressGetRealtime","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/40/aea9f0ac4e5db1b0eaa33888aa86643ef5b0f0.src","preCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get random version\",\n                        () -> deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get bad version\",\n                        () -> addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":466,"status":"M"},{"authorDate":"2019-05-03 05:20:05","commitOrder":22,"curCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2019-05-03 05:20:05","endLine":278,"groupId":"41338","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testStressGetRealtimeVersions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/fc/66846e894227ba607a0e2a20f931dba675b2bf.src","preCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressVersions.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"}],"commitId":"8908205b428f2ae68bcef0f22a944a62cfcd93d5","commitMessage":"@@@SOLR-13441: Refactor code to minimize direct use of noggit\n","date":"2019-05-03 05:20:05","modifiedFileCount":"58","status":"M","submitter":"noble"},{"authorTime":"2020-06-18 05:51:41","codes":[{"authorDate":"2020-06-18 05:51:41","commitOrder":23,"curCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get random version\",\n                        () -> deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get bad version\",\n                        () -> addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              @SuppressWarnings({\"rawtypes\"})\n              Map rsp = (Map) Utils.fromJSONString(response);\n              @SuppressWarnings({\"rawtypes\"})\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2020-06-18 05:51:41","endLine":756,"groupId":"103089","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressGetRealtime","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/30/cb450e17627101ce957f90b3bcb5ad9f46c43d.src","preCode":"  public void testStressGetRealtime() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    \r\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1+random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int filteredGetPercent = random().nextInt( random().nextInt(20)+1 );   \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n        \r\n    final int percentRealtimeQuery = 60;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n    verbose(\"commitPercent=\", commitPercent);\n    verbose(\"softCommitPercent=\",softCommitPercent);\n    verbose(\"deletePercent=\",deletePercent);\n    verbose(\"deleteByQueryPercent=\", deleteByQueryPercent);\n    verbose(\"ndocs=\", ndocs);\n    verbose(\"nWriteThreads=\", nWriteThreads);\n    verbose(\"nReadThreads=\", nReadThreads);\n    verbose(\"percentRealtimeQuery=\", percentRealtimeQuery);\n    verbose(\"maxConcurrentCommits=\", maxConcurrentCommits);\n    verbose(\"operations=\", operations);\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n          while (operations.get() > 0) {\n            int oper = rand.nextInt(100);\n\n            if (oper < commitPercent) {\n              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                Map<Integer,DocInfo> newCommittedModel;\n                long version;\n\n                synchronized(TestRealTimeGet.this) {\n                  newCommittedModel = new HashMap<>(model);  \r\n                  version = snapshotCount++;\n                  verbose(\"took snapshot version=\",version);\n                }\n\n                if (rand.nextInt(100) < softCommitPercent) {\n                  verbose(\"softCommit start\");\n                  assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                  verbose(\"softCommit end\");\n                } else {\n                  verbose(\"hardCommit start\");\n                  assertU(commit());\n                  verbose(\"hardCommit end\");\n                }\n\n                synchronized(TestRealTimeGet.this) {\n                  \r\n                  if (version >= committedModelClock) {\n                    if (VERBOSE) {\n                      verbose(\"installing new committedModel version=\"+committedModelClock);\n                    }\n                    committedModel = newCommittedModel;\n                    committedModelClock = version;\n                  }\n                }\n              }\n              numCommitting.decrementAndGet();\n              continue;\n            }\n\n\n            int id = rand.nextInt(ndocs);\n            Object sync = syncArr[id];\n\n            \r\n            \r\n            boolean before = rand.nextBoolean();\n            if (before) {\n              lastId = id;\n            }\n\n            \r\n            \r\n            \r\n            synchronized (sync) {\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"deleting id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"deleting id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                \r\n                Long version = null;\n\n                if (opt) {\n                  if (correct) {\n                    version = deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get random version\",\n                        () -> deleteAndGetVersion(Integer.toString(id), params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = deleteAndGetVersion(Integer.toString(id), null);\n                }\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, -nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n                }\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id \",id, \"val=\",nextVal);\n                }\n\n                assertU(\"<delete><query>id:\" + id + \"</query></delete>\");\n                model.put(id, new DocInfo(-1L, -nextVal));\n                if (VERBOSE) {\n                  verbose(\"deleteByQuery id\",id, \"val=\",nextVal,\"DONE\");\n                }\n              } else {\n                boolean opt = rand.nextInt() < optimisticPercent;\n                boolean correct = opt ? rand.nextInt() < optimisticCorrectPercent : false;\n                long badVersion = correct ? 0 : badVersion(rand, info.version);\n\n                if (VERBOSE) {\n                  if (!opt) {\n                    verbose(\"adding id\",id,\"val=\",nextVal);\n                  } else {\n                    verbose(\"adding id\",id,\"val=\",nextVal, \"existing_version=\",info.version,  (correct ? \"\" : (\" bad_version=\" + badVersion)));\n                  }\n                }\n\n                Long version = null;\n                SolrInputDocument sd = sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal));\n\n                if (opt) {\n                  if (correct) {\n                    version = addAndGetVersion(sd, params(\"_version_\", Long.toString(info.version)));\n                  } else {\n                    SolrException se = expectThrows(SolrException.class, \"should not get bad version\",\n                        () -> addAndGetVersion(sd, params(\"_version_\", Long.toString(badVersion))));\n                    assertEquals(409, se.code());\n                  }\n                } else {\n                  version = addAndGetVersion(sd, null);\n                }\n\n\n                if (version != null) {\n                  model.put(id, new DocInfo(version, nextVal));\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n            }   \r\n\n            if (!before) {\n              lastId = id;\n            }\n          }\n        } catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(TestRealTimeGet.this) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n\n              boolean filteredOut = false;\n              SolrQueryRequest sreq;\n              if (realTime) {\n                ModifiableSolrParams p = params(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n                if (rand.nextInt(100) < filteredGetPercent) {\n                  int idToFilter = rand.nextBoolean() ? id : rand.nextInt(ndocs);\n                  filteredOut = idToFilter != id;\n                  p.add(\"fq\", \"id:\"+idToFilter);\n                }\n                sreq = req(p);\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (filteredOut || foundVal < Math.abs(info.val)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          }\n        catch (Throwable e) {\n          operations.set(-1L);\n          throw new RuntimeException(e);\n        }\n      }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":466,"status":"M"},{"authorDate":"2020-06-18 05:51:41","commitOrder":23,"curCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              @SuppressWarnings({\"rawtypes\"})\n              Map rsp = (Map) Utils.fromJSONString(response);\n              @SuppressWarnings({\"rawtypes\"})\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2020-06-18 05:51:41","endLine":280,"groupId":"103089","id":14,"instanceNumber":2,"isCurCommit":1,"methodName":"testStressGetRealtimeVersions","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ff/3bf0c1b7a0cd28fd4b6bdd2ad68d6bd5d4aa49.src","preCode":"  public void testStressGetRealtimeVersions() throws Exception {\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(20);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = 1 + random().nextInt(5);\n    final int optimisticPercent = 1+random().nextInt(50);    \r\n    final int optimisticCorrectPercent = 25+random().nextInt(70);    \r\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 5 + random().nextInt(25);\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final AtomicLong operations = new AtomicLong(50000);  \r\n    int nReadThreads = 5 + random().nextInt(25);\n\n\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n    for (int i=0; i<nWriteThreads; i++) {\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              int oper = rand.nextInt(100);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  if (rand.nextInt(100) < softCommitPercent) {\n                    verbose(\"softCommit start\");\n                    assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                    verbose(\"softCommit end\");\n                  } else {\n                    verbose(\"hardCommit start\");\n                    assertU(commit());\n                    verbose(\"hardCommit end\");\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id = rand.nextInt(ndocs);\n              Object sync = syncArr[id];\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal);\n\n                Long version = deleteAndGetVersion(Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n                verbose(\"deleteByQyery id\",id,\"val=\",nextVal);\n\n                Long version = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), null);\n                assertTrue(version < 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQyery id\", id, \"val=\",nextVal,\"DONE\");\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal);\n\n                \r\n                Long version = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal)), null);\n                assertTrue(version > 0);\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.decrementAndGet() >= 0) {\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = model.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n              if (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressVersions.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"}],"commitId":"b01e249c9ec724b6df120a5d731020cfe4de3fce","commitMessage":"@@@SOLR-14574: Fix or suppress warnings in solr/core/src/test (part 1)\n","date":"2020-06-18 05:51:41","modifiedFileCount":"213","status":"M","submitter":"Erick Erickson"}]
