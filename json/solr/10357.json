[{"authorTime":"2015-11-12 12:37:37","codes":[{"authorDate":"2015-07-04 22:24:35","commitOrder":2,"curCode":"  public Metric constructMetric(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && Metric.class.isAssignableFrom(clazz)){\n        Metric metric = (Metric)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n        return metric;\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)\", expression, expression.getFunctionName()));\n  }\n","date":"2015-07-04 22:24:35","endLine":196,"groupId":"10683","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"constructMetric","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/96/01b234b3983f4b449f5fe2bdeb83a6077838bb.src","preCode":"  public Metric constructMetric(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && Metric.class.isAssignableFrom(clazz)){\n        Metric metric = (Metric)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n        return metric;\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":185,"status":"NB"},{"authorDate":"2015-11-12 12:37:37","commitOrder":2,"curCode":"  public StreamOperation constructOperation(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamOperation.class.isAssignableFrom(clazz)){\n        return (StreamOperation)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid operation expression %s - function '%s' is unknown (not mapped to a valid StreamOperation)\", expression, expression.getFunctionName()));\n  }\n","date":"2015-11-12 12:37:37","endLine":299,"groupId":"1633","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"constructOperation","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/42/5fe8a8c96f63cf221e767079640fe1d205d4da.src","preCode":"  public StreamOperation constructOperation(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamOperation.class.isAssignableFrom(clazz)){\n        return (StreamOperation)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid operation expression %s - function '%s' is unknown (not mapped to a valid StreamOperation)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":289,"status":"B"}],"commitId":"1161f2d018962780e36aa6278c923bd7b6c31876","commitMessage":"@@@SOLR-7669: Add SelectStream and Tuple Operations to the Streaming API and Streaming Expressions\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1713967 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-11-12 12:37:37","modifiedFileCount":"8","status":"M","submitter":"Dennis Gove"},{"authorTime":"2016-10-07 07:36:39","codes":[{"authorDate":"2016-10-07 07:36:39","commitOrder":3,"curCode":"  public Metric constructMetric(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && Metric.class.isAssignableFrom(clazz)){\n        return (Metric)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)\", expression, expression.getFunctionName()));\n  }\n","date":"2016-10-07 21:24:02","endLine":240,"groupId":"1633","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"constructMetric","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d2/e72dfc9ea841b8b8c4e00e09892bf88ccca9d7.src","preCode":"  public Metric constructMetric(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && Metric.class.isAssignableFrom(clazz)){\n        Metric metric = (Metric)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n        return metric;\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"},{"authorDate":"2016-10-07 07:36:39","commitOrder":3,"curCode":"  public StreamOperation constructOperation(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamOperation.class.isAssignableFrom(clazz)){\n        return (StreamOperation)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid operation expression %s - function '%s' is unknown (not mapped to a valid StreamOperation)\", expression, expression.getFunctionName()));\n  }\n","date":"2016-10-07 21:24:02","endLine":342,"groupId":"1633","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"constructOperation","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d2/e72dfc9ea841b8b8c4e00e09892bf88ccca9d7.src","preCode":"  public StreamOperation constructOperation(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamOperation.class.isAssignableFrom(clazz)){\n        return (StreamOperation)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid operation expression %s - function '%s' is unknown (not mapped to a valid StreamOperation)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":332,"status":"M"}],"commitId":"6aa28bd6558e47080166bf42b2b97aaa74ebf90b","commitMessage":"@@@SOLR-8385: Narrow StreamFactory.withFunctionName clazz parameter to prevent misconfiguration\n","date":"2016-10-07 21:24:02","modifiedFileCount":"3","status":"M","submitter":"Kevin Risden"},{"authorTime":"2019-12-23 12:20:26","codes":[{"authorDate":"2019-12-23 12:20:26","commitOrder":4,"curCode":"  public Metric constructMetric(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if(classSupplier != null){\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if(Expressible.class.isAssignableFrom(clazz) && Metric.class.isAssignableFrom(clazz)){\n        return (Metric)createInstance(clazz, new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)\", expression, expression.getFunctionName()));\n  }\n","date":"2019-12-23 12:20:26","endLine":280,"groupId":"6822","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"constructMetric","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/176dd212c3e82fd07c7479b3863fedaf18857d.src","preCode":"  public Metric constructMetric(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && Metric.class.isAssignableFrom(clazz)){\n        return (Metric)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":269,"status":"M"},{"authorDate":"2019-12-23 12:20:26","commitOrder":4,"curCode":"  public StreamOperation constructOperation(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (Expressible.class.isAssignableFrom(clazz) && StreamOperation.class.isAssignableFrom(clazz)) {\n        return (StreamOperation) createInstance(clazz, new Class[]{StreamExpression.class, StreamFactory.class}, new Object[]{expression, this});\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid operation expression %s - function '%s' is unknown (not mapped to a valid StreamOperation)\", expression, expression.getFunctionName()));\n  }\n","date":"2019-12-23 12:20:26","endLine":384,"groupId":"6822","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"constructOperation","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/176dd212c3e82fd07c7479b3863fedaf18857d.src","preCode":"  public StreamOperation constructOperation(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamOperation.class.isAssignableFrom(clazz)){\n        return (StreamOperation)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid operation expression %s - function '%s' is unknown (not mapped to a valid StreamOperation)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":373,"status":"M"}],"commitId":"ef15ae9805557685874c2a3269dae15ef7f58ccf","commitMessage":"@@@SOLR-14125 : Streaming expressions to be loadable from packages (#1108)\n\n SOLR-14125: Make <expressible> plugins work with packages","date":"2019-12-23 12:20:26","modifiedFileCount":"8","status":"M","submitter":"Noble Paul"},{"authorTime":"2021-06-03 06:17:26","codes":[{"authorDate":"2021-06-03 06:17:26","commitOrder":5,"curCode":"  public Metric constructMetric(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (Metric.class.isAssignableFrom(clazz)) {\n        return createInstance(clazz.asSubclass(Metric.class), new Class<?>[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT, \"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)\", expression, expression.getFunctionName()));\n  }\n","date":"2021-06-03 06:17:26","endLine":297,"groupId":"10357","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"constructMetric","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/83/81da1bf58fac3cb043b56e0583c74a16396806.src","preCode":"  public Metric constructMetric(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (Expressible.class.isAssignableFrom(clazz) && Metric.class.isAssignableFrom(clazz)) {\n        return (Metric)createInstance(clazz, new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT, \"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":286,"status":"M"},{"authorDate":"2021-06-03 06:17:26","commitOrder":5,"curCode":"  public StreamOperation constructOperation(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (StreamOperation.class.isAssignableFrom(clazz)) {\n        return createInstance(clazz.asSubclass(StreamOperation.class), new Class<?>[]{StreamExpression.class, StreamFactory.class}, new Object[]{expression, this});\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid operation expression %s - function '%s' is unknown (not mapped to a valid StreamOperation)\", expression, expression.getFunctionName()));\n  }\n","date":"2021-06-03 06:17:26","endLine":395,"groupId":"10357","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"constructOperation","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/83/81da1bf58fac3cb043b56e0583c74a16396806.src","preCode":"  public StreamOperation constructOperation(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (Expressible.class.isAssignableFrom(clazz) && StreamOperation.class.isAssignableFrom(clazz)) {\n        return (StreamOperation) createInstance(clazz, new Class[]{StreamExpression.class, StreamFactory.class}, new Object[]{expression, this});\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid operation expression %s - function '%s' is unknown (not mapped to a valid StreamOperation)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":384,"status":"M"}],"commitId":"c8e06a7298a2745c2b83102169073e2f8e8eceb5","commitMessage":"@@@SOLR-15385 Address many rawtypes warnings (#107)\n\nAddressed significant usage of raw types with Class.  Map.  and SolrRequest; removed over 400 SuppressWarning annotations.\n\nMap construction was replaced with Map.of when immutability was possible.  and Utils.makeMap when a mutable map was required.\n\nDiscovered a potential bug in the PackageStore tests where not all assertions were being verified - these tests will be fixed separately.\n\nCo-authored-by: David Smiley <dsmiley@salesforce.com>","date":"2021-06-03 06:17:26","modifiedFileCount":"244","status":"M","submitter":"Mike Drob"}]
