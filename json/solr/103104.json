[{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2011-07-10 07:01:53","commitOrder":1,"curCode":"  int doSetGen(int iter, Query q) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    long start = System.currentTimeMillis();\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocSet set = searcher.getDocSetNC(q, null);\n      ret += set.size();\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"ret=\"+ret+ \" time=\"+(end-start)+\" throughput=\"+iter*1000/(end-start+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","date":"2011-07-10 07:01:53","endLine":152,"groupId":"47537","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doSetGen","params":"(intiter@Queryq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b5/c41365341691434016e7a1fc54ec17f1df879b.src","preCode":"  int doSetGen(int iter, Query q) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    long start = System.currentTimeMillis();\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocSet set = searcher.getDocSetNC(q, null);\n      ret += set.size();\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"ret=\"+ret+ \" time=\"+(end-start)+\" throughput=\"+iter*1000/(end-start+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestSearchPerf.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"B"},{"authorDate":"2011-07-10 07:01:53","commitOrder":1,"curCode":"  int doListGen(int iter, Query q, List<Query> filt, boolean cacheQuery, boolean cacheFilt) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    long start = System.currentTimeMillis();\n\n    \r\n    int NO_CHECK_QCACHE       = 0x80000000;\n    int GET_DOCSET            = 0x40000000;\n    int NO_CHECK_FILTERCACHE  = 0x20000000;\n    int GET_SCORES            = 0x01;\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocList l = searcher.getDocList(q, filt, (Sort)null, 0, 10, (cacheQuery?0:NO_CHECK_QCACHE)|(cacheFilt?0:NO_CHECK_FILTERCACHE) );\n      ret += l.matches();\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"ret=\"+ret+ \" time=\"+(end-start)+\" throughput=\"+iter*1000/(end-start+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","date":"2011-07-10 07:01:53","endLine":179,"groupId":"55585","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doListGen","params":"(intiter@Queryq@List<Query>filt@booleancacheQuery@booleancacheFilt)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b5/c41365341691434016e7a1fc54ec17f1df879b.src","preCode":"  int doListGen(int iter, Query q, List<Query> filt, boolean cacheQuery, boolean cacheFilt) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    long start = System.currentTimeMillis();\n\n    \r\n    int NO_CHECK_QCACHE       = 0x80000000;\n    int GET_DOCSET            = 0x40000000;\n    int NO_CHECK_FILTERCACHE  = 0x20000000;\n    int GET_SCORES            = 0x01;\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocList l = searcher.getDocList(q, filt, (Sort)null, 0, 10, (cacheQuery?0:NO_CHECK_QCACHE)|(cacheFilt?0:NO_CHECK_FILTERCACHE) );\n      ret += l.matches();\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"ret=\"+ret+ \" time=\"+(end-start)+\" throughput=\"+iter*1000/(end-start+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestSearchPerf.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"B"}],"commitId":"429093b236e30940d69edc8869346819c337cd10","commitMessage":"@@@SOLR-2452: Rewrote Solr build system (tighter integration with the Lucene build system) and restructured Solr internal and contrib modules\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1144761 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2011-07-10 07:01:53","modifiedFileCount":"0","status":"B","submitter":"Steven Rowe"},{"authorTime":"2015-08-08 21:39:58","codes":[{"authorDate":"2015-08-08 21:39:58","commitOrder":2,"curCode":"  int doSetGen(int iter, Query q) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    final RTimer timer = new RTimer();\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocSet set = searcher.getDocSetNC(q, null);\n      ret += set.size();\n    }\n\n    double elapsed = timer.getTime();\n    System.out.println(\"ret=\"+ret+ \" time=\"+elapsed+\" throughput=\"+iter*1000/(elapsed+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","date":"2015-08-08 21:39:58","endLine":157,"groupId":"10401","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doSetGen","params":"(intiter@Queryq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2d/f7d6a7623cb9149edd3bb0ee07fd99b8b89278.src","preCode":"  int doSetGen(int iter, Query q) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    long start = System.currentTimeMillis();\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocSet set = searcher.getDocSetNC(q, null);\n      ret += set.size();\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"ret=\"+ret+ \" time=\"+(end-start)+\" throughput=\"+iter*1000/(end-start+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestSearchPerf.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":138,"status":"M"},{"authorDate":"2015-08-08 21:39:58","commitOrder":2,"curCode":"  int doListGen(int iter, Query q, List<Query> filt, boolean cacheQuery, boolean cacheFilt) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    final RTimer timer = new RTimer();\n\n    \r\n    int NO_CHECK_QCACHE       = 0x80000000;\n    int GET_DOCSET            = 0x40000000;\n    int NO_CHECK_FILTERCACHE  = 0x20000000;\n    int GET_SCORES            = 0x01;\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocList l = searcher.getDocList(q, filt, (Sort)null, 0, 10, (cacheQuery?0:NO_CHECK_QCACHE)|(cacheFilt?0:NO_CHECK_FILTERCACHE) );\n      ret += l.matches();\n    }\n\n    double elapsed = timer.getTime();\n    System.out.println(\"ret=\"+ret+ \" time=\"+elapsed+\" throughput=\"+iter*1000/(elapsed+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","date":"2015-08-08 21:39:58","endLine":184,"groupId":"0","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doListGen","params":"(intiter@Queryq@List<Query>filt@booleancacheQuery@booleancacheFilt)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2d/f7d6a7623cb9149edd3bb0ee07fd99b8b89278.src","preCode":"  int doListGen(int iter, Query q, List<Query> filt, boolean cacheQuery, boolean cacheFilt) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    long start = System.currentTimeMillis();\n\n    \r\n    int NO_CHECK_QCACHE       = 0x80000000;\n    int GET_DOCSET            = 0x40000000;\n    int NO_CHECK_FILTERCACHE  = 0x20000000;\n    int GET_SCORES            = 0x01;\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocList l = searcher.getDocList(q, filt, (Sort)null, 0, 10, (cacheQuery?0:NO_CHECK_QCACHE)|(cacheFilt?0:NO_CHECK_FILTERCACHE) );\n      ret += l.matches();\n    }\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"ret=\"+ret+ \" time=\"+(end-start)+\" throughput=\"+iter*1000/(end-start+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestSearchPerf.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"}],"commitId":"b4aafbb6060a5b865281f8403b1f87b05061db33","commitMessage":"@@@SOLR-7859: Clamp down on use of System.currentTimeMillis\n\n - Use RTimer where currentTimeMillis is used for timing\n - Abstract out a new class TimeOut for when currentTimeMillis/nanoTime\n   is used to timeout operations.\n - Used `new Date()` in some cases where that is the logical intent.\n - Deprecated a couple of APIs which were publicly exposing epoch time. \n   in favour of Date objects to make the intent clearer.\n - A couple of cases had currentTimeMillis in dead code.\n - In some cases where currentTimeMillis was used to just generate a name. \n   used nanoTime instead (really it should be some sequence/random number\n   in such a case).\n - In some other cases where stamps were used for SQL queries.  HTTP headers. \n   comparing against data in external files.  ZK etc..  used SuppressForbidden.\n - Also currently allow the use of currentTimeMillis in commit data. \n   this is then used in replication -- this is concerning since absolute\n   times are being compared.  but that can be dealt with separately.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1694798 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-08-08 21:39:58","modifiedFileCount":"89","status":"M","submitter":"Ramkumar Aiyengar"},{"authorTime":"2016-01-04 21:50:08","codes":[{"authorDate":"2015-08-08 21:39:58","commitOrder":3,"curCode":"  int doSetGen(int iter, Query q) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    final RTimer timer = new RTimer();\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocSet set = searcher.getDocSetNC(q, null);\n      ret += set.size();\n    }\n\n    double elapsed = timer.getTime();\n    System.out.println(\"ret=\"+ret+ \" time=\"+elapsed+\" throughput=\"+iter*1000/(elapsed+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","date":"2015-08-08 21:39:58","endLine":157,"groupId":"103104","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doSetGen","params":"(intiter@Queryq)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2d/f7d6a7623cb9149edd3bb0ee07fd99b8b89278.src","preCode":"  int doSetGen(int iter, Query q) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    final RTimer timer = new RTimer();\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocSet set = searcher.getDocSetNC(q, null);\n      ret += set.size();\n    }\n\n    double elapsed = timer.getTime();\n    System.out.println(\"ret=\"+ret+ \" time=\"+elapsed+\" throughput=\"+iter*1000/(elapsed+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestSearchPerf.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":138,"status":"N"},{"authorDate":"2016-01-04 21:50:08","commitOrder":3,"curCode":"  int doListGen(int iter, Query q, List<Query> filt, boolean cacheQuery, boolean cacheFilt) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    final RTimer timer = new RTimer();\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocList l = searcher.getDocList(q, filt, (Sort)null, 0, 10, (cacheQuery?0:SolrIndexSearcher.NO_CHECK_QCACHE)|(cacheFilt?0:SolrIndexSearcher.NO_CHECK_FILTERCACHE) );\n      ret += l.matches();\n    }\n\n    double elapsed = timer.getTime();\n    System.out.println(\"ret=\"+ret+ \" time=\"+elapsed+\" throughput=\"+iter*1000/(elapsed+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","date":"2016-01-04 21:50:08","endLine":178,"groupId":"103104","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"doListGen","params":"(intiter@Queryq@List<Query>filt@booleancacheQuery@booleancacheFilt)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/cf/db8a48dd0cf1196db75339f044aa212a254463.src","preCode":"  int doListGen(int iter, Query q, List<Query> filt, boolean cacheQuery, boolean cacheFilt) throws Exception {\n    SolrQueryRequest req = lrf.makeRequest();\n\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    final RTimer timer = new RTimer();\n\n    \r\n    int NO_CHECK_QCACHE       = 0x80000000;\n    int GET_DOCSET            = 0x40000000;\n    int NO_CHECK_FILTERCACHE  = 0x20000000;\n    int GET_SCORES            = 0x01;\n\n    int ret = 0;\n    for (int i=0; i<iter; i++) {\n      DocList l = searcher.getDocList(q, filt, (Sort)null, 0, 10, (cacheQuery?0:NO_CHECK_QCACHE)|(cacheFilt?0:NO_CHECK_FILTERCACHE) );\n      ret += l.matches();\n    }\n\n    double elapsed = timer.getTime();\n    System.out.println(\"ret=\"+ret+ \" time=\"+elapsed+\" throughput=\"+iter*1000/(elapsed+1));\n\n    req.close();\n    assertTrue(ret>0);  \r\n    return ret;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestSearchPerf.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"}],"commitId":"817fabc70caf191aed394294db63f33c38528498","commitMessage":"@@@SOLR-8481: TestSearchPerf no longer needs to duplicate SolrIndexSearcher.(NO_CHECK_QCACHE|NO_CHECK_FILTERCACHE)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1722869 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2016-01-04 21:50:08","modifiedFileCount":"1","status":"M","submitter":"Christine Poerschke"}]
