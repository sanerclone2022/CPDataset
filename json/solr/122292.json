[{"authorTime":"2020-02-15 13:08:21","codes":[{"authorDate":"2020-02-15 13:08:21","commitOrder":1,"curCode":"  public DocSet intersection(DocSet other) {\n    if (!(other instanceof SortedIntDocSet)) {\n      int icount = 0;\n      int arr[] = new int[docs.length];\n      for (int i=0; i<docs.length; i++) {\n        int doc = docs[i];\n        if (other.exists(doc)) arr[icount++] = doc;\n      }\n      return new SortedIntDocSet(arr,icount);\n    }\n\n    int[] otherDocs = ((SortedIntDocSet)other).docs;\n    int maxsz = Math.min(docs.length, otherDocs.length);\n    int[] arr = new int[maxsz];\n    int sz = intersection(docs, docs.length, otherDocs, otherDocs.length, arr);\n    return new SortedIntDocSet(arr,sz);\n  }\n","date":"2020-02-25 22:48:20","endLine":415,"groupId":"36800","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"intersection","params":"(DocSetother)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f6/5ee17e33d956ef414b60fb7ae68b2c44a5cc90.src","preCode":"  public DocSet intersection(DocSet other) {\n    if (!(other instanceof SortedIntDocSet)) {\n      int icount = 0;\n      int arr[] = new int[docs.length];\n      for (int i=0; i<docs.length; i++) {\n        int doc = docs[i];\n        if (other.exists(doc)) arr[icount++] = doc;\n      }\n      return new SortedIntDocSet(arr,icount);\n    }\n\n    int[] otherDocs = ((SortedIntDocSet)other).docs;\n    int maxsz = Math.min(docs.length, otherDocs.length);\n    int[] arr = new int[maxsz];\n    int sz = intersection(docs, docs.length, otherDocs, otherDocs.length, arr);\n    return new SortedIntDocSet(arr,sz);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SortedIntDocSet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":399,"status":"B"},{"authorDate":"2020-02-15 13:08:21","commitOrder":1,"curCode":"  public DocSet andNot(DocSet other) {\n    if (other.size()==0) return this;\n\n    if (!(other instanceof SortedIntDocSet)) {\n      int count = 0;\n      int arr[] = new int[docs.length];\n      for (int i=0; i<docs.length; i++) {\n        int doc = docs[i];\n        if (!other.exists(doc)) arr[count++] = doc;\n      }\n      return new SortedIntDocSet(arr,count);\n    }\n\n    int[] otherDocs = ((SortedIntDocSet)other).docs;\n    int[] arr = new int[docs.length];\n    int sz = andNot(docs, docs.length, otherDocs, otherDocs.length, arr);\n    return new SortedIntDocSet(arr,sz);\n  }\n","date":"2020-02-25 22:48:20","endLine":542,"groupId":"51874","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"andNot","params":"(DocSetother)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f6/5ee17e33d956ef414b60fb7ae68b2c44a5cc90.src","preCode":"  public DocSet andNot(DocSet other) {\n    if (other.size()==0) return this;\n\n    if (!(other instanceof SortedIntDocSet)) {\n      int count = 0;\n      int arr[] = new int[docs.length];\n      for (int i=0; i<docs.length; i++) {\n        int doc = docs[i];\n        if (!other.exists(doc)) arr[count++] = doc;\n      }\n      return new SortedIntDocSet(arr,count);\n    }\n\n    int[] otherDocs = ((SortedIntDocSet)other).docs;\n    int[] arr = new int[docs.length];\n    int sz = andNot(docs, docs.length, otherDocs, otherDocs.length, arr);\n    return new SortedIntDocSet(arr,sz);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SortedIntDocSet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":525,"status":"B"}],"commitId":"50a7075862af29c3710345808bed33e14ba6bd55","commitMessage":"@@@SOLR-14256: Remove HashDocSet; add DocSet.getBits.\n* DocSet is now fixed at two implementations.  read-only and doc ordered.\n* DocSetBase removed; not needed anymore.  DocSet is now an abstract class.\n","date":"2020-02-25 22:48:20","modifiedFileCount":"11","status":"B","submitter":"David Smiley"},{"authorTime":"2021-04-21 04:28:33","codes":[{"authorDate":"2021-04-21 04:28:33","commitOrder":2,"curCode":"  public DocSet intersection(DocSet other) {\n    if (!(other instanceof SortedIntDocSet)) {\n      int icount = 0;\n      int arr[] = new int[docs.length];\n      for (int i=0; i<docs.length; i++) {\n        int doc = docs[i];\n        if (other.exists(doc)) arr[icount++] = doc;\n      }\n      if (icount == docs.length) {\n        return this; \r\n      }\n      return new SortedIntDocSet(arr,icount);\n    }\n\n    int[] otherDocs = ((SortedIntDocSet)other).docs;\n    int maxsz = Math.min(docs.length, otherDocs.length);\n    int[] arr = new int[maxsz];\n    int sz = intersection(docs, docs.length, otherDocs, otherDocs.length, arr);\n    if (sz == docs.length) {\n      return this; \r\n    }\n    return new SortedIntDocSet(arr,sz);\n  }\n","date":"2021-04-21 04:28:33","endLine":424,"groupId":"122292","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"intersection","params":"(DocSetother)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/94/e3d6f52708e8e614dc8de6027844e223412be7.src","preCode":"  public DocSet intersection(DocSet other) {\n    if (!(other instanceof SortedIntDocSet)) {\n      int icount = 0;\n      int arr[] = new int[docs.length];\n      for (int i=0; i<docs.length; i++) {\n        int doc = docs[i];\n        if (other.exists(doc)) arr[icount++] = doc;\n      }\n      return new SortedIntDocSet(arr,icount);\n    }\n\n    int[] otherDocs = ((SortedIntDocSet)other).docs;\n    int maxsz = Math.min(docs.length, otherDocs.length);\n    int[] arr = new int[maxsz];\n    int sz = intersection(docs, docs.length, otherDocs, otherDocs.length, arr);\n    return new SortedIntDocSet(arr,sz);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SortedIntDocSet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":402,"status":"M"},{"authorDate":"2021-04-21 04:28:33","commitOrder":2,"curCode":"  public DocSet andNot(DocSet other) {\n    if (other.size()==0) return this;\n\n    if (!(other instanceof SortedIntDocSet)) {\n      int count = 0;\n      int arr[] = new int[docs.length];\n      for (int i=0; i<docs.length; i++) {\n        int doc = docs[i];\n        if (!other.exists(doc)) arr[count++] = doc;\n      }\n      if (count == docs.length) {\n        return this; \r\n      }\n      return new SortedIntDocSet(arr,count);\n    }\n\n    int[] otherDocs = ((SortedIntDocSet)other).docs;\n    int[] arr = new int[docs.length];\n    int sz = andNot(docs, docs.length, otherDocs, otherDocs.length, arr);\n    if (sz == docs.length) {\n      return this; \r\n    }\n    return new SortedIntDocSet(arr,sz);\n  }\n","date":"2021-04-21 04:28:33","endLine":557,"groupId":"122292","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"andNot","params":"(DocSetother)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/94/e3d6f52708e8e614dc8de6027844e223412be7.src","preCode":"  public DocSet andNot(DocSet other) {\n    if (other.size()==0) return this;\n\n    if (!(other instanceof SortedIntDocSet)) {\n      int count = 0;\n      int arr[] = new int[docs.length];\n      for (int i=0; i<docs.length; i++) {\n        int doc = docs[i];\n        if (!other.exists(doc)) arr[count++] = doc;\n      }\n      return new SortedIntDocSet(arr,count);\n    }\n\n    int[] otherDocs = ((SortedIntDocSet)other).docs;\n    int[] arr = new int[docs.length];\n    int sz = andNot(docs, docs.length, otherDocs, otherDocs.length, arr);\n    return new SortedIntDocSet(arr,sz);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/SortedIntDocSet.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":534,"status":"M"}],"commitId":"bec4ed890b026a23bb537190de7cdbe10b3b1081","commitMessage":"@@@SOLR-14185: introduce DocSet.iterator(LeafReaderContext).  replacing Filter where possible (#2)\n\n* fix some brittle code that effectively assumes non-null iterators\n* replace Filter with `DocSet.iterator(LeafReaderContext)` where possible\n* extend TestDocSet to cover equivalence of direct/getTopFilter DISIs\n* IntervalFacets was redundantly checking live bits; stop it\n\nSortedIntDocSet specifically:\n* report precise cost for the iterator; no need to approximate\n* cache per-segment offsets into the array\n* replaced an unnecessary custom binary search implementation with Arrays.binarySearch(...). \n* intersection size optimization; return \"this\" if unchanged\n\nCo-authored-by: David Smiley <dsmiley@salesforce.com>","date":"2021-04-21 04:28:33","modifiedFileCount":"15","status":"M","submitter":"Michael Gibney"}]
