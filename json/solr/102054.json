[{"authorTime":"2018-12-05 00:01:24","codes":[{"authorDate":"2019-04-10 15:02:59","commitOrder":16,"curCode":"  private long findVersionOnUpdate(UpdateCommand cmd) {\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n    return versionOnUpdate;\n  }\n","date":"2019-04-10 15:02:59","endLine":858,"groupId":"6599","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"findVersionOnUpdate","params":"(UpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private long findVersionOnUpdate(UpdateCommand cmd) {\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n    return versionOnUpdate;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":850,"status":"B"},{"authorDate":"2018-12-05 00:01:24","commitOrder":16,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2018-12-06 22:36:56","endLine":1916,"groupId":"6599","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6f/8564629ab1d176cf98ca68584ccb4eacf1ceaf.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1798,"status":"NB"}],"commitId":"8527ec11af8099f86953ffad1182ad43c752f95b","commitMessage":"@@@SOLR-12638: Partial/Atomic updates of nested docs.\nand [child] now works in RTG.\n","date":"2019-04-10 15:02:59","modifiedFileCount":"11","status":"M","submitter":"Moshe"},{"authorTime":"2019-05-01 04:31:06","codes":[{"authorDate":"2019-04-10 15:02:59","commitOrder":17,"curCode":"  private long findVersionOnUpdate(UpdateCommand cmd) {\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n    return versionOnUpdate;\n  }\n","date":"2019-04-10 15:02:59","endLine":858,"groupId":"102054","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"findVersionOnUpdate","params":"(UpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private long findVersionOnUpdate(UpdateCommand cmd) {\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n    return versionOnUpdate;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":850,"status":"N"},{"authorDate":"2019-05-01 04:31:06","commitOrder":17,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      long finalVersionOnUpdate = versionOnUpdate;\n      return bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doVersionDelete(cmd, finalVersionOnUpdate, signedVersionOnUpdate, isReplayOrPeersync, leaderLogic,\n          forwardedFromCollection, bucket));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2019-05-01 04:31:44","endLine":959,"groupId":"102054","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ed/48c758f47592c9980d29aab7abd4b35f61d414.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":916,"status":"M"}],"commitId":"70e090717d21a9713c45b8a52e35df940a4277df","commitMessage":"@@@SOLR-12833: Avoid unnecessary memory cost when DistributedUpdateProcessor timed-out lock is not used.\n","date":"2019-05-01 04:31:44","modifiedFileCount":"4","status":"M","submitter":"Andrzej Bialecki"}]
