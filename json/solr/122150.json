[{"authorTime":"2018-05-21 23:22:54","codes":[{"authorDate":"2018-05-21 23:22:54","commitOrder":2,"curCode":"  int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    if (0 == docs.size()) {\n      \r\n      \r\n      \r\n      if (accs != null) {\n        for (SlotAcc acc : accs) {\n          acc.collect(docs, slot, slotContext); \r\n        }\n      }\n      return count;\n    }\n    \n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            \r\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext);  \r\n    }\n    return count;\n  }\n","date":"2018-05-21 23:22:54","endLine":387,"groupId":"38876","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"collect","params":"(DocSetdocs@intslot@IntFunction<SlotContext>slotContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c0/625df70e85a54ab483d944c97c1ac85f678590.src","preCode":"  int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    if (0 == docs.size()) {\n      \r\n      \r\n      \r\n      if (accs != null) {\n        for (SlotAcc acc : accs) {\n          acc.collect(docs, slot, slotContext); \r\n        }\n      }\n      return count;\n    }\n    \n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            \r\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext);  \r\n    }\n    return count;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"MB"},{"authorDate":"2018-05-21 23:22:54","commitOrder":2,"curCode":"  public int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext();) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            \r\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext); \r\n    }\n    return count;\n  }\n","date":"2018-05-21 23:22:54","endLine":138,"groupId":"38876","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"collect","params":"(DocSetdocs@intslot@IntFunction<SlotContext>slotContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9c/12aff99ea4b25a2fedc4478af5a93a9aa63a01.src","preCode":"  public int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext();) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            \r\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext); \r\n    }\n    return count;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/facet/SlotAcc.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"B"}],"commitId":"669b9e7a5343c625e265a075c9dbf24fcbff7363","commitMessage":"@@@SOLR-9480: A new 'relatedness()' aggregate function for JSON Faceting to enable building Semantic Knowledge Graphs\n","date":"2018-05-21 23:22:54","modifiedFileCount":"26","status":"M","submitter":"Chris Hostetter"},{"authorTime":"2018-05-21 23:22:54","codes":[{"authorDate":"2020-04-10 21:46:54","commitOrder":3,"curCode":"  long collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    long count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    if (0 == docs.size()) {\n      \r\n      \r\n      \r\n      if (accs != null) {\n        for (SlotAcc acc : accs) {\n          acc.collect(docs, slot, slotContext); \r\n        }\n      }\n      return count;\n    }\n    \n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            \r\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext);  \r\n    }\n    return count;\n  }\n","date":"2020-04-10 22:00:20","endLine":377,"groupId":"122150","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"collect","params":"(DocSetdocs@intslot@IntFunction<SlotContext>slotContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b8/271f5961accd1489f641c64d5076391f7a8a22.src","preCode":"  int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    if (0 == docs.size()) {\n      \r\n      \r\n      \r\n      if (accs != null) {\n        for (SlotAcc acc : accs) {\n          acc.collect(docs, slot, slotContext); \r\n        }\n      }\n      return count;\n    }\n    \n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            \r\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext);  \r\n    }\n    return count;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":335,"status":"M"},{"authorDate":"2018-05-21 23:22:54","commitOrder":3,"curCode":"  public int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext();) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            \r\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext); \r\n    }\n    return count;\n  }\n","date":"2018-05-21 23:22:54","endLine":138,"groupId":"122150","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"collect","params":"(DocSetdocs@intslot@IntFunction<SlotContext>slotContext)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9c/12aff99ea4b25a2fedc4478af5a93a9aa63a01.src","preCode":"  public int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext();) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            \r\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext); \r\n    }\n    return count;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/facet/SlotAcc.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":108,"status":"N"}],"commitId":"36b280bd0a21952ea54c7567f037eb48dc93205a","commitMessage":"@@@SOLR-11775: return long val for facet count in json facet\n\n* Long value is returned for any count related to json facets\n  irrespective of number of shards\n","date":"2020-04-10 22:00:20","modifiedFileCount":"33","status":"M","submitter":"Munendra S N"}]
