[{"authorTime":"2018-08-12 02:17:18","codes":[{"authorDate":"2017-12-05 10:08:58","commitOrder":3,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"harmonicFit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    HarmonicCurveFitter curveFitter = HarmonicCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    HarmonicOscillator pf = new HarmonicOscillator(coef[0], coef[1], coef[2]);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","date":"2017-12-05 10:09:41","endLine":84,"groupId":"25701","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/93/2c113bf30599c073f79cadbe9eb510f6c0fef0.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"harmonicFit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    HarmonicCurveFitter curveFitter = HarmonicCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    HarmonicOscillator pf = new HarmonicOscillator(coef[0], coef[1], coef[2]);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/HarmonicFitEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":38,"status":"NB"},{"authorDate":"2018-08-12 02:17:18","commitOrder":3,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length >= 3) {\n      throw new IOException(\"gaussfit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n      \r\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    GaussianCurveFitter curveFitter = GaussianCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    List<WeightedObservedPoint> pointList = points.toList();\n\n    double[] guess = new GaussianCurveFitter.ParameterGuesser(pointList).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(pointList);\n    Gaussian gaussian = new Gaussian(coef[0], coef[1], coef[2]);\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= gaussian.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return new VectorFunction(gaussian, list);\n  }\n","date":"2018-08-12 02:17:44","endLine":90,"groupId":"33399","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a2/6c8d70d1f5db569da2c2db8daf9e6423c2157d.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length >= 3) {\n      throw new IOException(\"gaussfit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n      \r\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    GaussianCurveFitter curveFitter = GaussianCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    List<WeightedObservedPoint> pointList = points.toList();\n\n    double[] guess = new GaussianCurveFitter.ParameterGuesser(pointList).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(pointList);\n    Gaussian gaussian = new Gaussian(coef[0], coef[1], coef[2]);\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= gaussian.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return new VectorFunction(gaussian, list);\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/GaussFitEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"B"}],"commitId":"17eb8cd14d27d2680fe7c4b3871f3eb883542d34","commitMessage":"@@@SOLR-12634: Add gaussfit Stream Evaluator\n","date":"2018-08-12 02:17:44","modifiedFileCount":"3","status":"M","submitter":"Joel Bernstein"},{"authorTime":"2018-08-12 02:17:18","codes":[{"authorDate":"2018-10-04 00:24:48","commitOrder":4,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"harmonicFit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    HarmonicCurveFitter curveFitter = HarmonicCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] guess = new HarmonicCurveFitter.ParameterGuesser(points.toList()).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(points.toList());\n    HarmonicOscillator pf = new HarmonicOscillator(coef[0], coef[1], coef[2]);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    VectorFunction vectorFunction =  new VectorFunction(pf, list);\n    vectorFunction.addToContext(\"amplitude\", coef[0]);\n    vectorFunction.addToContext(\"angularFrequency\", coef[1]);\n    vectorFunction.addToContext(\"phase\", coef[2]);\n\n    return vectorFunction;\n\n  }\n","date":"2018-10-04 00:25:35","endLine":92,"groupId":"25701","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/7ac6ea9feefd18fe66fbc47797a3f7edf7ab4b.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"harmonicFit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    HarmonicCurveFitter curveFitter = HarmonicCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    HarmonicOscillator pf = new HarmonicOscillator(coef[0], coef[1], coef[2]);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/HarmonicFitEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":37,"status":"M"},{"authorDate":"2018-08-12 02:17:18","commitOrder":4,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length >= 3) {\n      throw new IOException(\"gaussfit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n      \r\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    GaussianCurveFitter curveFitter = GaussianCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    List<WeightedObservedPoint> pointList = points.toList();\n\n    double[] guess = new GaussianCurveFitter.ParameterGuesser(pointList).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(pointList);\n    Gaussian gaussian = new Gaussian(coef[0], coef[1], coef[2]);\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= gaussian.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return new VectorFunction(gaussian, list);\n  }\n","date":"2018-08-12 02:17:44","endLine":90,"groupId":"33399","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a2/6c8d70d1f5db569da2c2db8daf9e6423c2157d.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length >= 3) {\n      throw new IOException(\"gaussfit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n      \r\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    GaussianCurveFitter curveFitter = GaussianCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    List<WeightedObservedPoint> pointList = points.toList();\n\n    double[] guess = new GaussianCurveFitter.ParameterGuesser(pointList).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(pointList);\n    Gaussian gaussian = new Gaussian(coef[0], coef[1], coef[2]);\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= gaussian.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return new VectorFunction(gaussian, list);\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/GaussFitEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"N"}],"commitId":"751bf7db208d505ecb48779b432ee3e52f00fdfc","commitMessage":"@@@SOLR-12828: Add oscillate Stream Evaluator to support sine wave analysis\n","date":"2018-10-04 00:25:35","modifiedFileCount":"4","status":"M","submitter":"Joel Bernstein"},{"authorTime":"2018-08-12 02:17:18","codes":[{"authorDate":"2020-06-08 09:31:51","commitOrder":5,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"harmonicFit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    HarmonicCurveFitter curveFitter = HarmonicCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] guess = new HarmonicCurveFitter.ParameterGuesser(points.toList()).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(points.toList());\n    HarmonicOscillator pf = new HarmonicOscillator(coef[0], coef[1], coef[2]);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    VectorFunction vectorFunction =  new VectorFunction(pf, list);\n    vectorFunction.addToContext(\"amplitude\", coef[0]);\n    vectorFunction.addToContext(\"angularFrequency\", coef[1]);\n    vectorFunction.addToContext(\"phase\", coef[2]);\n\n    return vectorFunction;\n\n  }\n","date":"2020-06-08 09:31:51","endLine":95,"groupId":"25701","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f1/f36468ac2ae21be7a5e1058de6ce9a708a002d.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"harmonicFit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    HarmonicCurveFitter curveFitter = HarmonicCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] guess = new HarmonicCurveFitter.ParameterGuesser(points.toList()).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(points.toList());\n    HarmonicOscillator pf = new HarmonicOscillator(coef[0], coef[1], coef[2]);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    VectorFunction vectorFunction =  new VectorFunction(pf, list);\n    vectorFunction.addToContext(\"amplitude\", coef[0]);\n    vectorFunction.addToContext(\"angularFrequency\", coef[1]);\n    vectorFunction.addToContext(\"phase\", coef[2]);\n\n    return vectorFunction;\n\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/HarmonicFitEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":38,"status":"M"},{"authorDate":"2018-08-12 02:17:18","commitOrder":5,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length >= 3) {\n      throw new IOException(\"gaussfit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n      \r\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    GaussianCurveFitter curveFitter = GaussianCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    List<WeightedObservedPoint> pointList = points.toList();\n\n    double[] guess = new GaussianCurveFitter.ParameterGuesser(pointList).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(pointList);\n    Gaussian gaussian = new Gaussian(coef[0], coef[1], coef[2]);\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= gaussian.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return new VectorFunction(gaussian, list);\n  }\n","date":"2018-08-12 02:17:44","endLine":90,"groupId":"33399","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a2/6c8d70d1f5db569da2c2db8daf9e6423c2157d.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length >= 3) {\n      throw new IOException(\"gaussfit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n      \r\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    GaussianCurveFitter curveFitter = GaussianCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    List<WeightedObservedPoint> pointList = points.toList();\n\n    double[] guess = new GaussianCurveFitter.ParameterGuesser(pointList).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(pointList);\n    Gaussian gaussian = new Gaussian(coef[0], coef[1], coef[2]);\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= gaussian.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return new VectorFunction(gaussian, list);\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/GaussFitEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"N"}],"commitId":"7bf59a16bda85b19b68b639b395d143019a89fde","commitMessage":"@@@SOLR-14544: Fix or suppress warnings in solr/client/solrj/io/eval\n","date":"2020-06-08 09:31:51","modifiedFileCount":"110","status":"M","submitter":"Erick Erickson"},{"authorTime":"2021-06-22 00:19:37","codes":[{"authorDate":"2021-06-22 00:19:37","commitOrder":6,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"harmonicFit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n        \r\n        Object second = objects[1];\n        x = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List<?>) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    HarmonicCurveFitter curveFitter = HarmonicCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] guess = new HarmonicCurveFitter.ParameterGuesser(points.toList()).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(points.toList());\n    HarmonicOscillator pf = new HarmonicOscillator(coef[0], coef[1], coef[2]);\n\n    List<Number> list = new ArrayList<>();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    VectorFunction vectorFunction =  new VectorFunction(pf, list);\n    vectorFunction.addToContext(\"amplitude\", coef[0]);\n    vectorFunction.addToContext(\"angularFrequency\", coef[1]);\n    vectorFunction.addToContext(\"phase\", coef[2]);\n\n    return vectorFunction;\n\n  }\n","date":"2021-06-22 00:19:37","endLine":92,"groupId":"10165","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/09/37c39db095cc33feb5a98780989ac68e210b51.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"harmonicFit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n        \r\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    HarmonicCurveFitter curveFitter = HarmonicCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] guess = new HarmonicCurveFitter.ParameterGuesser(points.toList()).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(points.toList());\n    HarmonicOscillator pf = new HarmonicOscillator(coef[0], coef[1], coef[2]);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    VectorFunction vectorFunction =  new VectorFunction(pf, list);\n    vectorFunction.addToContext(\"amplitude\", coef[0]);\n    vectorFunction.addToContext(\"angularFrequency\", coef[1]);\n    vectorFunction.addToContext(\"phase\", coef[2]);\n\n    return vectorFunction;\n\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/HarmonicFitEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":37,"status":"M"},{"authorDate":"2021-06-22 00:19:37","commitOrder":6,"curCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length >= 3) {\n      throw new IOException(\"gaussfit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n      \r\n      Object second = objects[1];\n      x = ((List<?>) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List<?>) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    GaussianCurveFitter curveFitter = GaussianCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    List<WeightedObservedPoint> pointList = points.toList();\n\n    double[] guess = new GaussianCurveFitter.ParameterGuesser(pointList).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(pointList);\n    Gaussian gaussian = new Gaussian(coef[0], coef[1], coef[2]);\n    List<Double> list = new ArrayList<>();\n    for(double xvalue : x) {\n      double yvalue= gaussian.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return new VectorFunction(gaussian, list);\n  }\n","date":"2021-06-22 00:19:37","endLine":90,"groupId":"10165","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"doWork","params":"(Object...objects)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/40/d314434be172d3604c49c4c804b65ce704496f.src","preCode":"  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length >= 3) {\n      throw new IOException(\"gaussfit function takes a maximum of 2 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n\n    if(objects.length == 1) {\n      \r\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 2) {\n      \r\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n\n\n    }\n\n    GaussianCurveFitter curveFitter = GaussianCurveFitter.create();\n\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    List<WeightedObservedPoint> pointList = points.toList();\n\n    double[] guess = new GaussianCurveFitter.ParameterGuesser(pointList).guess();\n    curveFitter = curveFitter.withStartPoint(guess);\n\n    double[] coef = curveFitter.fit(pointList);\n    Gaussian gaussian = new Gaussian(coef[0], coef[1], coef[2]);\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= gaussian.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return new VectorFunction(gaussian, list);\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/GaussFitEvaluator.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":40,"status":"M"}],"commitId":"1725e778ac86d88e2deff8f7339d45bb4e50a719","commitMessage":"@@@SOLR-15385 RawTypes Part III.  contrib and solrj (#169)\n\n* SOLR-15385 RawTypes Part III.  contrib and solrj\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>","date":"2021-06-22 00:19:37","modifiedFileCount":"216","status":"M","submitter":"Mike Drob"}]
