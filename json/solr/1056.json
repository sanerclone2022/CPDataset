[{"authorTime":"2015-09-04 03:42:38","codes":[{"authorDate":"2012-01-28 03:01:06","commitOrder":2,"curCode":"  public static int UTF16toUTF8(CharSequence s, int offset, int len, byte[] result, int resultOffset) {\n    final int end = offset + len;\n\n    int upto = resultOffset;\n    for(int i=offset;i<end;i++) {\n      final int code = (int) s.charAt(i);\n\n      if (code < 0x80)\n        result[upto++] = (byte) code;\n      else if (code < 0x800) {\n        result[upto++] = (byte) (0xC0 | (code >> 6));\n        result[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else if (code < 0xD800 || code > 0xDFFF) {\n        result[upto++] = (byte)(0xE0 | (code >> 12));\n        result[upto++] = (byte)(0x80 | ((code >> 6) & 0x3F));\n        result[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else {\n        \r\n        \r\n        if (code < 0xDC00 && (i < end-1)) {\n          int utf32 = (int) s.charAt(i+1);\n          \r\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) {\n            utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n            i++;\n            result[upto++] = (byte)(0xF0 | (utf32 >> 18));\n            result[upto++] = (byte)(0x80 | ((utf32 >> 12) & 0x3F));\n            result[upto++] = (byte)(0x80 | ((utf32 >> 6) & 0x3F));\n            result[upto++] = (byte)(0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        \r\n        \r\n        result[upto++] = (byte) 0xEF;\n        result[upto++] = (byte) 0xBF;\n        result[upto++] = (byte) 0xBD;\n      }\n    }\n\n    return upto - resultOffset;\n  }\n","date":"2012-01-28 03:01:06","endLine":122,"groupId":"1175","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"UTF16toUTF8","params":"(CharSequences@intoffset@intlen@byte[]result@intresultOffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b0/0bba19169a5252b448060487c6e98cd5124fdf.src","preCode":"  public static int UTF16toUTF8(CharSequence s, int offset, int len, byte[] result, int resultOffset) {\n    final int end = offset + len;\n\n    int upto = resultOffset;\n    for(int i=offset;i<end;i++) {\n      final int code = (int) s.charAt(i);\n\n      if (code < 0x80)\n        result[upto++] = (byte) code;\n      else if (code < 0x800) {\n        result[upto++] = (byte) (0xC0 | (code >> 6));\n        result[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else if (code < 0xD800 || code > 0xDFFF) {\n        result[upto++] = (byte)(0xE0 | (code >> 12));\n        result[upto++] = (byte)(0x80 | ((code >> 6) & 0x3F));\n        result[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else {\n        \r\n        \r\n        if (code < 0xDC00 && (i < end-1)) {\n          int utf32 = (int) s.charAt(i+1);\n          \r\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) {\n            utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n            i++;\n            result[upto++] = (byte)(0xF0 | (utf32 >> 18));\n            result[upto++] = (byte)(0x80 | ((utf32 >> 12) & 0x3F));\n            result[upto++] = (byte)(0x80 | ((utf32 >> 6) & 0x3F));\n            result[upto++] = (byte)(0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        \r\n        \r\n        result[upto++] = (byte) 0xEF;\n        result[upto++] = (byte) 0xBF;\n        result[upto++] = (byte) 0xBD;\n      }\n    }\n\n    return upto - resultOffset;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/util/ByteUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"NB"},{"authorDate":"2015-09-04 03:42:38","commitOrder":2,"curCode":"  public static int writeUTF16toUTF8(CharSequence s, int offset, int len, OutputStream fos, byte[] scratch) throws IOException {\n    final int end = offset + len;\n\n    int upto = 0, totalBytes = 0;\n    for(int i=offset;i<end;i++) {\n      final int code = (int) s.charAt(i);\n\n      if (upto > scratch.length - 4)  {\n        \r\n        totalBytes += upto;\n        fos.write(scratch, 0, upto);\n        upto = 0;\n      }\n\n      if (code < 0x80)\n        scratch[upto++] = (byte) code;\n      else if (code < 0x800) {\n        scratch[upto++] = (byte) (0xC0 | (code >> 6));\n        scratch[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else if (code < 0xD800 || code > 0xDFFF) {\n        scratch[upto++] = (byte)(0xE0 | (code >> 12));\n        scratch[upto++] = (byte)(0x80 | ((code >> 6) & 0x3F));\n        scratch[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else {\n        \r\n        \r\n        if (code < 0xDC00 && (i < end-1)) {\n          int utf32 = (int) s.charAt(i+1);\n          \r\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) {\n            utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n            i++;\n            scratch[upto++] = (byte)(0xF0 | (utf32 >> 18));\n            scratch[upto++] = (byte)(0x80 | ((utf32 >> 12) & 0x3F));\n            scratch[upto++] = (byte)(0x80 | ((utf32 >> 6) & 0x3F));\n            scratch[upto++] = (byte)(0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        \r\n        \r\n        scratch[upto++] = (byte) 0xEF;\n        scratch[upto++] = (byte) 0xBF;\n        scratch[upto++] = (byte) 0xBD;\n      }\n    }\n\n    totalBytes += upto;\n    fos.write(scratch, 0, upto);\n\n    return totalBytes;\n  }\n","date":"2015-09-04 03:42:38","endLine":187,"groupId":"1175","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"writeUTF16toUTF8","params":"(CharSequences@intoffset@intlen@OutputStreamfos@byte[]scratch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e2/4f793eb86953af87469b4e50a7a58846971535.src","preCode":"  public static int writeUTF16toUTF8(CharSequence s, int offset, int len, OutputStream fos, byte[] scratch) throws IOException {\n    final int end = offset + len;\n\n    int upto = 0, totalBytes = 0;\n    for(int i=offset;i<end;i++) {\n      final int code = (int) s.charAt(i);\n\n      if (upto > scratch.length - 4)  {\n        \r\n        totalBytes += upto;\n        fos.write(scratch, 0, upto);\n        upto = 0;\n      }\n\n      if (code < 0x80)\n        scratch[upto++] = (byte) code;\n      else if (code < 0x800) {\n        scratch[upto++] = (byte) (0xC0 | (code >> 6));\n        scratch[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else if (code < 0xD800 || code > 0xDFFF) {\n        scratch[upto++] = (byte)(0xE0 | (code >> 12));\n        scratch[upto++] = (byte)(0x80 | ((code >> 6) & 0x3F));\n        scratch[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else {\n        \r\n        \r\n        if (code < 0xDC00 && (i < end-1)) {\n          int utf32 = (int) s.charAt(i+1);\n          \r\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) {\n            utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n            i++;\n            scratch[upto++] = (byte)(0xF0 | (utf32 >> 18));\n            scratch[upto++] = (byte)(0x80 | ((utf32 >> 12) & 0x3F));\n            scratch[upto++] = (byte)(0x80 | ((utf32 >> 6) & 0x3F));\n            scratch[upto++] = (byte)(0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        \r\n        \r\n        scratch[upto++] = (byte) 0xEF;\n        scratch[upto++] = (byte) 0xBF;\n        scratch[upto++] = (byte) 0xBD;\n      }\n    }\n\n    totalBytes += upto;\n    fos.write(scratch, 0, upto);\n\n    return totalBytes;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/util/ByteUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"B"}],"commitId":"05a9c3bed883ce870878f74c837a5b646853bb30","commitMessage":"@@@SOLR-7971: JavaBinCodec now uses a double pass approach to write strings larger than 64KB to avoid allocating buffer memory equal to string's UTF8 size\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1701115 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-09-04 03:42:38","modifiedFileCount":"2","status":"M","submitter":"Shalin Shekhar Mangar"},{"authorTime":"2018-11-20 11:58:32","codes":[{"authorDate":"2012-01-28 03:01:06","commitOrder":3,"curCode":"  public static int UTF16toUTF8(CharSequence s, int offset, int len, byte[] result, int resultOffset) {\n    final int end = offset + len;\n\n    int upto = resultOffset;\n    for(int i=offset;i<end;i++) {\n      final int code = (int) s.charAt(i);\n\n      if (code < 0x80)\n        result[upto++] = (byte) code;\n      else if (code < 0x800) {\n        result[upto++] = (byte) (0xC0 | (code >> 6));\n        result[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else if (code < 0xD800 || code > 0xDFFF) {\n        result[upto++] = (byte)(0xE0 | (code >> 12));\n        result[upto++] = (byte)(0x80 | ((code >> 6) & 0x3F));\n        result[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else {\n        \r\n        \r\n        if (code < 0xDC00 && (i < end-1)) {\n          int utf32 = (int) s.charAt(i+1);\n          \r\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) {\n            utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n            i++;\n            result[upto++] = (byte)(0xF0 | (utf32 >> 18));\n            result[upto++] = (byte)(0x80 | ((utf32 >> 12) & 0x3F));\n            result[upto++] = (byte)(0x80 | ((utf32 >> 6) & 0x3F));\n            result[upto++] = (byte)(0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        \r\n        \r\n        result[upto++] = (byte) 0xEF;\n        result[upto++] = (byte) 0xBF;\n        result[upto++] = (byte) 0xBD;\n      }\n    }\n\n    return upto - resultOffset;\n  }\n","date":"2012-01-28 03:01:06","endLine":122,"groupId":"1056","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"UTF16toUTF8","params":"(CharSequences@intoffset@intlen@byte[]result@intresultOffset)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b0/0bba19169a5252b448060487c6e98cd5124fdf.src","preCode":"  public static int UTF16toUTF8(CharSequence s, int offset, int len, byte[] result, int resultOffset) {\n    final int end = offset + len;\n\n    int upto = resultOffset;\n    for(int i=offset;i<end;i++) {\n      final int code = (int) s.charAt(i);\n\n      if (code < 0x80)\n        result[upto++] = (byte) code;\n      else if (code < 0x800) {\n        result[upto++] = (byte) (0xC0 | (code >> 6));\n        result[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else if (code < 0xD800 || code > 0xDFFF) {\n        result[upto++] = (byte)(0xE0 | (code >> 12));\n        result[upto++] = (byte)(0x80 | ((code >> 6) & 0x3F));\n        result[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else {\n        \r\n        \r\n        if (code < 0xDC00 && (i < end-1)) {\n          int utf32 = (int) s.charAt(i+1);\n          \r\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) {\n            utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n            i++;\n            result[upto++] = (byte)(0xF0 | (utf32 >> 18));\n            result[upto++] = (byte)(0x80 | ((utf32 >> 12) & 0x3F));\n            result[upto++] = (byte)(0x80 | ((utf32 >> 6) & 0x3F));\n            result[upto++] = (byte)(0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        \r\n        \r\n        result[upto++] = (byte) 0xEF;\n        result[upto++] = (byte) 0xBF;\n        result[upto++] = (byte) 0xBD;\n      }\n    }\n\n    return upto - resultOffset;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/util/ByteUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"N"},{"authorDate":"2018-11-20 11:58:32","commitOrder":3,"curCode":"  public static int writeUTF16toUTF8(CharSequence s, int offset, int len, OutputStream fos, byte[] scratch) throws IOException {\n    final int end = offset + len;\n\n    int upto = 0, totalBytes = 0;\n    for(int i=offset;i<end;i++) {\n      final int code = (int) s.charAt(i);\n\n      if (upto > scratch.length - 4)  {\n        \r\n        totalBytes += upto;\n        if(fos == null) throw new IOException(\"buffer over flow\");\n        fos.write(scratch, 0, upto);\n        upto = 0;\n      }\n\n      if (code < 0x80)\n        scratch[upto++] = (byte) code;\n      else if (code < 0x800) {\n        scratch[upto++] = (byte) (0xC0 | (code >> 6));\n        scratch[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else if (code < 0xD800 || code > 0xDFFF) {\n        scratch[upto++] = (byte)(0xE0 | (code >> 12));\n        scratch[upto++] = (byte)(0x80 | ((code >> 6) & 0x3F));\n        scratch[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else {\n        \r\n        \r\n        if (code < 0xDC00 && (i < end-1)) {\n          int utf32 = (int) s.charAt(i+1);\n          \r\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) {\n            utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n            i++;\n            scratch[upto++] = (byte)(0xF0 | (utf32 >> 18));\n            scratch[upto++] = (byte)(0x80 | ((utf32 >> 12) & 0x3F));\n            scratch[upto++] = (byte)(0x80 | ((utf32 >> 6) & 0x3F));\n            scratch[upto++] = (byte)(0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        \r\n        \r\n        scratch[upto++] = (byte) 0xEF;\n        scratch[upto++] = (byte) 0xBF;\n        scratch[upto++] = (byte) 0xBD;\n      }\n    }\n\n    totalBytes += upto;\n    if(fos != null) fos.write(scratch, 0, upto);\n\n    return totalBytes;\n  }\n","date":"2018-11-20 11:58:32","endLine":187,"groupId":"1056","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"writeUTF16toUTF8","params":"(CharSequences@intoffset@intlen@OutputStreamfos@byte[]scratch)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ec/4acdb68715eebbe60a6f8350a01cdf909cce3c.src","preCode":"  public static int writeUTF16toUTF8(CharSequence s, int offset, int len, OutputStream fos, byte[] scratch) throws IOException {\n    final int end = offset + len;\n\n    int upto = 0, totalBytes = 0;\n    for(int i=offset;i<end;i++) {\n      final int code = (int) s.charAt(i);\n\n      if (upto > scratch.length - 4)  {\n        \r\n        totalBytes += upto;\n        fos.write(scratch, 0, upto);\n        upto = 0;\n      }\n\n      if (code < 0x80)\n        scratch[upto++] = (byte) code;\n      else if (code < 0x800) {\n        scratch[upto++] = (byte) (0xC0 | (code >> 6));\n        scratch[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else if (code < 0xD800 || code > 0xDFFF) {\n        scratch[upto++] = (byte)(0xE0 | (code >> 12));\n        scratch[upto++] = (byte)(0x80 | ((code >> 6) & 0x3F));\n        scratch[upto++] = (byte)(0x80 | (code & 0x3F));\n      } else {\n        \r\n        \r\n        if (code < 0xDC00 && (i < end-1)) {\n          int utf32 = (int) s.charAt(i+1);\n          \r\n          if (utf32 >= 0xDC00 && utf32 <= 0xDFFF) {\n            utf32 = ((code - 0xD7C0) << 10) + (utf32 & 0x3FF);\n            i++;\n            scratch[upto++] = (byte)(0xF0 | (utf32 >> 18));\n            scratch[upto++] = (byte)(0x80 | ((utf32 >> 12) & 0x3F));\n            scratch[upto++] = (byte)(0x80 | ((utf32 >> 6) & 0x3F));\n            scratch[upto++] = (byte)(0x80 | (utf32 & 0x3F));\n            continue;\n          }\n        }\n        \r\n        \r\n        scratch[upto++] = (byte) 0xEF;\n        scratch[upto++] = (byte) 0xBF;\n        scratch[upto++] = (byte) 0xBD;\n      }\n    }\n\n    totalBytes += upto;\n    fos.write(scratch, 0, upto);\n\n    return totalBytes;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/common/util/ByteUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"M"}],"commitId":"25bca6f16513fda0bdd2ab670633bac26dbf5d6e","commitMessage":"@@@SOLR-12992: When using binary format.  ExportWriter to directly copy BytesRef instead of creating new String\n","date":"2018-11-20 11:58:32","modifiedFileCount":"7","status":"M","submitter":"Noble Paul"}]
