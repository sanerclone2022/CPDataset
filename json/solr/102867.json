[{"authorTime":"2017-08-01 15:49:57","codes":[{"authorDate":"2017-05-23 10:44:01","commitOrder":4,"curCode":"  private void reorderedDBQsUsingUpdatedValueFromADroppedUpdate() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n    \n    float inplace_updatable_float = 1F;\n    buildRandomIndex(inplace_updatable_float, Collections.singletonList(1));\n\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(regularUpdateRequest(\"id\", 1, \"id_i\", 1, \"inplace_updatable_float\", 12, \"title_s\", \"mytitle\"));\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1))); \r\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1)));\n    updates.add(regularDeleteByQueryRequest(\"inplace_updatable_float:14\"));\n\n    \r\n    \r\n    shardToJetty.get(SHARD1).get(1).jetty.getDebugFilter().addDelay(\n        \"Waiting for dependant update to timeout\", 2, 8000);\n\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    for (UpdateRequest update : updates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, cloudClient,\n                                                                         random().nextLong());\n      threadpool.submit(task);\n\n      \r\n      \r\n      Thread.sleep(100); \n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 12 secs\", threadpool.awaitTermination(12, TimeUnit.SECONDS));\n\n    commit();\n\n    \r\n    \r\n    for (int i=0; i<100; i++) {\n      Thread.sleep(10);\n      cloudClient.getZkStateReader().forceUpdateCollection(DEFAULT_COLLECTION);\n      ClusterState state = cloudClient.getZkStateReader().getClusterState();\n\n      int numActiveReplicas = 0;\n      for (Replica rep: state.getCollection(DEFAULT_COLLECTION).getSlice(SHARD1).getReplicas())\n        if (rep.getState().equals(Replica.State.ACTIVE))\n          numActiveReplicas++;\n\n      assertEquals(\"The replica receiving reordered updates must not have gone down\", 3, numActiveReplicas);\n    }\n\n    for (SolrClient client : clients) {\n      log.info(\"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): \" + ((HttpSolrClient)client).getBaseURL());\n      log.info(\"Version at \" + ((HttpSolrClient)client).getBaseURL() + \" is: \" + getReplicaValue(client, 1, \"_version_\"));\n\n      assertNull(client.getById(\"1\", params(\"distrib\", \"false\")));\n    }\n\n    log.info(\"reorderedDBQsUsingUpdatedValueFromADroppedUpdate: This test passed fine...\");\n  }\n","date":"2017-05-23 10:58:51","endLine":1208,"groupId":"24544","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"reorderedDBQsUsingUpdatedValueFromADroppedUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/44/b4a4ed010be39b6f403aed3fe9a59c1ca82606.src","preCode":"  private void reorderedDBQsUsingUpdatedValueFromADroppedUpdate() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n    \n    float inplace_updatable_float = 1F;\n    buildRandomIndex(inplace_updatable_float, Collections.singletonList(1));\n\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(regularUpdateRequest(\"id\", 1, \"id_i\", 1, \"inplace_updatable_float\", 12, \"title_s\", \"mytitle\"));\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1))); \r\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1)));\n    updates.add(regularDeleteByQueryRequest(\"inplace_updatable_float:14\"));\n\n    \r\n    \r\n    shardToJetty.get(SHARD1).get(1).jetty.getDebugFilter().addDelay(\n        \"Waiting for dependant update to timeout\", 2, 8000);\n\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    for (UpdateRequest update : updates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, cloudClient,\n                                                                         random().nextLong());\n      threadpool.submit(task);\n\n      \r\n      \r\n      Thread.sleep(100); \n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 12 secs\", threadpool.awaitTermination(12, TimeUnit.SECONDS));\n\n    commit();\n\n    \r\n    \r\n    for (int i=0; i<100; i++) {\n      Thread.sleep(10);\n      cloudClient.getZkStateReader().forceUpdateCollection(DEFAULT_COLLECTION);\n      ClusterState state = cloudClient.getZkStateReader().getClusterState();\n\n      int numActiveReplicas = 0;\n      for (Replica rep: state.getCollection(DEFAULT_COLLECTION).getSlice(SHARD1).getReplicas())\n        if (rep.getState().equals(Replica.State.ACTIVE))\n          numActiveReplicas++;\n\n      assertEquals(\"The replica receiving reordered updates must not have gone down\", 3, numActiveReplicas);\n    }\n\n    for (SolrClient client : clients) {\n      log.info(\"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): \" + ((HttpSolrClient)client).getBaseURL());\n      log.info(\"Version at \" + ((HttpSolrClient)client).getBaseURL() + \" is: \" + getReplicaValue(client, 1, \"_version_\"));\n\n      assertNull(client.getById(\"1\", params(\"distrib\", \"false\")));\n    }\n\n    log.info(\"reorderedDBQsUsingUpdatedValueFromADroppedUpdate: This test passed fine...\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1146,"status":"NB"},{"authorDate":"2017-08-01 15:49:57","commitOrder":4,"curCode":"  protected int getNumberOfActiveReplicas(ClusterState clusterState, String collection, String sliceId) {\n    int numActiveReplicas = 0;\n    \r\n    for (Replica rep : clusterState.getCollection(collection).getSlice(sliceId).getReplicas()) {\n      if (rep.getState().equals(State.ACTIVE)) {\n        numActiveReplicas++;\n      }\n    }\n    return numActiveReplicas;\n  }\n","date":"2017-08-01 15:55:00","endLine":432,"groupId":"32267","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getNumberOfActiveReplicas","params":"(ClusterStateclusterState@Stringcollection@StringsliceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/74/9abdf804d224f7fba11e504871df9cb1a99c2f.src","preCode":"  protected int getNumberOfActiveReplicas(ClusterState clusterState, String collection, String sliceId) {\n    int numActiveReplicas = 0;\n    \r\n    for (Replica rep : clusterState.getCollection(collection).getSlice(sliceId).getReplicas()) {\n      if (rep.getState().equals(State.ACTIVE)) {\n        numActiveReplicas++;\n      }\n    }\n    return numActiveReplicas;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":423,"status":"B"}],"commitId":"93ed4770ac82eb732c7409f82d02009e0fabe390","commitMessage":"@@@SOLR-9321: Remove deprecated methods of ClusterState\n","date":"2017-08-01 15:55:00","modifiedFileCount":"45","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2018-04-04 04:41:57","codes":[{"authorDate":"2017-05-23 10:44:01","commitOrder":5,"curCode":"  private void reorderedDBQsUsingUpdatedValueFromADroppedUpdate() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n    \n    float inplace_updatable_float = 1F;\n    buildRandomIndex(inplace_updatable_float, Collections.singletonList(1));\n\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(regularUpdateRequest(\"id\", 1, \"id_i\", 1, \"inplace_updatable_float\", 12, \"title_s\", \"mytitle\"));\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1))); \r\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1)));\n    updates.add(regularDeleteByQueryRequest(\"inplace_updatable_float:14\"));\n\n    \r\n    \r\n    shardToJetty.get(SHARD1).get(1).jetty.getDebugFilter().addDelay(\n        \"Waiting for dependant update to timeout\", 2, 8000);\n\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    for (UpdateRequest update : updates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, cloudClient,\n                                                                         random().nextLong());\n      threadpool.submit(task);\n\n      \r\n      \r\n      Thread.sleep(100); \n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 12 secs\", threadpool.awaitTermination(12, TimeUnit.SECONDS));\n\n    commit();\n\n    \r\n    \r\n    for (int i=0; i<100; i++) {\n      Thread.sleep(10);\n      cloudClient.getZkStateReader().forceUpdateCollection(DEFAULT_COLLECTION);\n      ClusterState state = cloudClient.getZkStateReader().getClusterState();\n\n      int numActiveReplicas = 0;\n      for (Replica rep: state.getCollection(DEFAULT_COLLECTION).getSlice(SHARD1).getReplicas())\n        if (rep.getState().equals(Replica.State.ACTIVE))\n          numActiveReplicas++;\n\n      assertEquals(\"The replica receiving reordered updates must not have gone down\", 3, numActiveReplicas);\n    }\n\n    for (SolrClient client : clients) {\n      log.info(\"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): \" + ((HttpSolrClient)client).getBaseURL());\n      log.info(\"Version at \" + ((HttpSolrClient)client).getBaseURL() + \" is: \" + getReplicaValue(client, 1, \"_version_\"));\n\n      assertNull(client.getById(\"1\", params(\"distrib\", \"false\")));\n    }\n\n    log.info(\"reorderedDBQsUsingUpdatedValueFromADroppedUpdate: This test passed fine...\");\n  }\n","date":"2017-05-23 10:58:51","endLine":1208,"groupId":"24544","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"reorderedDBQsUsingUpdatedValueFromADroppedUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/44/b4a4ed010be39b6f403aed3fe9a59c1ca82606.src","preCode":"  private void reorderedDBQsUsingUpdatedValueFromADroppedUpdate() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n    \n    float inplace_updatable_float = 1F;\n    buildRandomIndex(inplace_updatable_float, Collections.singletonList(1));\n\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(regularUpdateRequest(\"id\", 1, \"id_i\", 1, \"inplace_updatable_float\", 12, \"title_s\", \"mytitle\"));\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1))); \r\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1)));\n    updates.add(regularDeleteByQueryRequest(\"inplace_updatable_float:14\"));\n\n    \r\n    \r\n    shardToJetty.get(SHARD1).get(1).jetty.getDebugFilter().addDelay(\n        \"Waiting for dependant update to timeout\", 2, 8000);\n\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    for (UpdateRequest update : updates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, cloudClient,\n                                                                         random().nextLong());\n      threadpool.submit(task);\n\n      \r\n      \r\n      Thread.sleep(100); \n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 12 secs\", threadpool.awaitTermination(12, TimeUnit.SECONDS));\n\n    commit();\n\n    \r\n    \r\n    for (int i=0; i<100; i++) {\n      Thread.sleep(10);\n      cloudClient.getZkStateReader().forceUpdateCollection(DEFAULT_COLLECTION);\n      ClusterState state = cloudClient.getZkStateReader().getClusterState();\n\n      int numActiveReplicas = 0;\n      for (Replica rep: state.getCollection(DEFAULT_COLLECTION).getSlice(SHARD1).getReplicas())\n        if (rep.getState().equals(Replica.State.ACTIVE))\n          numActiveReplicas++;\n\n      assertEquals(\"The replica receiving reordered updates must not have gone down\", 3, numActiveReplicas);\n    }\n\n    for (SolrClient client : clients) {\n      log.info(\"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): \" + ((HttpSolrClient)client).getBaseURL());\n      log.info(\"Version at \" + ((HttpSolrClient)client).getBaseURL() + \" is: \" + getReplicaValue(client, 1, \"_version_\"));\n\n      assertNull(client.getById(\"1\", params(\"distrib\", \"false\")));\n    }\n\n    log.info(\"reorderedDBQsUsingUpdatedValueFromADroppedUpdate: This test passed fine...\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1146,"status":"N"},{"authorDate":"2018-04-04 04:41:57","commitOrder":5,"curCode":"  private int getNumberOfActiveReplicas(ClusterState clusterState, String collection, String sliceId) {\n    int numActiveReplicas = 0;\n    \r\n    for (Replica rep : clusterState.getCollection(collection).getSlice(sliceId).getReplicas()) {\n      if (rep.getState().equals(State.ACTIVE)) {\n        numActiveReplicas++;\n      }\n    }\n    return numActiveReplicas;\n  }\n","date":"2018-04-04 04:41:57","endLine":529,"groupId":"32267","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getNumberOfActiveReplicas","params":"(ClusterStateclusterState@Stringcollection@StringsliceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/be/aeb2465e095d5299a6c3e1c95c6eec31c9db2c.src","preCode":"  protected int getNumberOfActiveReplicas(ClusterState clusterState, String collection, String sliceId) {\n    int numActiveReplicas = 0;\n    \r\n    for (Replica rep : clusterState.getCollection(collection).getSlice(sliceId).getReplicas()) {\n      if (rep.getState().equals(State.ACTIVE)) {\n        numActiveReplicas++;\n      }\n    }\n    return numActiveReplicas;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":520,"status":"M"}],"commitId":"34b83ed86993d71ba3bb9ae58a3df8ce4351a045","commitMessage":"@@@SOLR-12176: Improve FORCELEADER to handle the case when a replica win the election but does not present in clusterstate\n","date":"2018-04-04 04:41:57","modifiedFileCount":"2","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2018-04-04 04:41:57","codes":[{"authorDate":"2020-04-13 10:46:35","commitOrder":6,"curCode":"  private void reorderedDBQsUsingUpdatedValueFromADroppedUpdate() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n    \n    float inplace_updatable_float = 1F;\n    buildRandomIndex(inplace_updatable_float, Collections.singletonList(1));\n\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(regularUpdateRequest(\"id\", 1, \"id_i\", 1, \"inplace_updatable_float\", 12, \"title_s\", \"mytitle\"));\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1))); \r\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1)));\n    updates.add(regularDeleteByQueryRequest(\"inplace_updatable_float:14\"));\n\n    \r\n    \r\n    shardToJetty.get(SHARD1).get(1).jetty.getDebugFilter().addDelay(\n        \"Waiting for dependant update to timeout\", 2, 8000);\n\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n    for (UpdateRequest update : updates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, cloudClient,\n                                                                         random().nextLong());\n      threadpool.submit(task);\n\n      \r\n      \r\n      Thread.sleep(100); \n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 12 secs\", threadpool.awaitTermination(12, TimeUnit.SECONDS));\n\n    commit();\n\n    \r\n    \r\n    for (int i=0; i<100; i++) {\n      Thread.sleep(10);\n      cloudClient.getZkStateReader().forceUpdateCollection(DEFAULT_COLLECTION);\n      ClusterState state = cloudClient.getZkStateReader().getClusterState();\n\n      int numActiveReplicas = 0;\n      for (Replica rep: state.getCollection(DEFAULT_COLLECTION).getSlice(SHARD1).getReplicas())\n        if (rep.getState().equals(Replica.State.ACTIVE))\n          numActiveReplicas++;\n\n      assertEquals(\"The replica receiving reordered updates must not have gone down\", 3, numActiveReplicas);\n    }\n\n    for (SolrClient client : clients) {\n      log.info(\"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): \" + ((HttpSolrClient)client).getBaseURL());\n      log.info(\"Version at \" + ((HttpSolrClient)client).getBaseURL() + \" is: \" + getReplicaValue(client, 1, \"_version_\"));\n\n      assertNull(client.getById(\"1\", params(\"distrib\", \"false\")));\n    }\n\n    log.info(\"reorderedDBQsUsingUpdatedValueFromADroppedUpdate: This test passed fine...\");\n  }\n","date":"2020-04-13 10:46:35","endLine":1340,"groupId":"24544","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"reorderedDBQsUsingUpdatedValueFromADroppedUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/41/8aead206df58684b813f6d7d9833c7bc744f3f.src","preCode":"  private void reorderedDBQsUsingUpdatedValueFromADroppedUpdate() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n    \n    float inplace_updatable_float = 1F;\n    buildRandomIndex(inplace_updatable_float, Collections.singletonList(1));\n\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(regularUpdateRequest(\"id\", 1, \"id_i\", 1, \"inplace_updatable_float\", 12, \"title_s\", \"mytitle\"));\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1))); \r\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1)));\n    updates.add(regularDeleteByQueryRequest(\"inplace_updatable_float:14\"));\n\n    \r\n    \r\n    shardToJetty.get(SHARD1).get(1).jetty.getDebugFilter().addDelay(\n        \"Waiting for dependant update to timeout\", 2, 8000);\n\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n    for (UpdateRequest update : updates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, cloudClient,\n                                                                         random().nextLong());\n      threadpool.submit(task);\n\n      \r\n      \r\n      Thread.sleep(100); \n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 12 secs\", threadpool.awaitTermination(12, TimeUnit.SECONDS));\n\n    commit();\n\n    \r\n    \r\n    for (int i=0; i<100; i++) {\n      Thread.sleep(10);\n      cloudClient.getZkStateReader().forceUpdateCollection(DEFAULT_COLLECTION);\n      ClusterState state = cloudClient.getZkStateReader().getClusterState();\n\n      int numActiveReplicas = 0;\n      for (Replica rep: state.getCollection(DEFAULT_COLLECTION).getSlice(SHARD1).getReplicas())\n        if (rep.getState().equals(Replica.State.ACTIVE))\n          numActiveReplicas++;\n\n      assertEquals(\"The replica receiving reordered updates must not have gone down\", 3, numActiveReplicas);\n    }\n\n    for (SolrClient client : clients) {\n      log.info(\"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): \" + ((HttpSolrClient)client).getBaseURL());\n      log.info(\"Version at \" + ((HttpSolrClient)client).getBaseURL() + \" is: \" + getReplicaValue(client, 1, \"_version_\"));\n\n      assertNull(client.getById(\"1\", params(\"distrib\", \"false\")));\n    }\n\n    log.info(\"reorderedDBQsUsingUpdatedValueFromADroppedUpdate: This test passed fine...\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1278,"status":"M"},{"authorDate":"2018-04-04 04:41:57","commitOrder":6,"curCode":"  private int getNumberOfActiveReplicas(ClusterState clusterState, String collection, String sliceId) {\n    int numActiveReplicas = 0;\n    \r\n    for (Replica rep : clusterState.getCollection(collection).getSlice(sliceId).getReplicas()) {\n      if (rep.getState().equals(State.ACTIVE)) {\n        numActiveReplicas++;\n      }\n    }\n    return numActiveReplicas;\n  }\n","date":"2018-04-04 04:41:57","endLine":529,"groupId":"32267","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"getNumberOfActiveReplicas","params":"(ClusterStateclusterState@Stringcollection@StringsliceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/be/aeb2465e095d5299a6c3e1c95c6eec31c9db2c.src","preCode":"  private int getNumberOfActiveReplicas(ClusterState clusterState, String collection, String sliceId) {\n    int numActiveReplicas = 0;\n    \r\n    for (Replica rep : clusterState.getCollection(collection).getSlice(sliceId).getReplicas()) {\n      if (rep.getState().equals(State.ACTIVE)) {\n        numActiveReplicas++;\n      }\n    }\n    return numActiveReplicas;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":520,"status":"N"}],"commitId":"13f19f65559290a860df84fa1b5ac2db903b27ec","commitMessage":"@@@SOLR-9906: SolrjNamedThreadFactory is deprecated in favor of SolrNamedThreadFactory. DefaultSolrThreadFactory is removed from solr-core in favor of SolrNamedThreadFactory in solrj package and all solr-core classes now use SolrNamedThreadFactory\n","date":"2020-04-13 10:46:35","modifiedFileCount":"83","status":"M","submitter":"Shalin Shekhar Mangar"},{"authorTime":"2018-04-04 04:41:57","codes":[{"authorDate":"2020-05-01 07:50:31","commitOrder":7,"curCode":"  private void reorderedDBQsUsingUpdatedValueFromADroppedUpdate() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n    \n    float inplace_updatable_float = 1F;\n    buildRandomIndex(inplace_updatable_float, Collections.singletonList(1));\n\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(regularUpdateRequest(\"id\", 1, \"id_i\", 1, \"inplace_updatable_float\", 12, \"title_s\", \"mytitle\"));\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1))); \r\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1)));\n    updates.add(regularDeleteByQueryRequest(\"inplace_updatable_float:14\"));\n\n    \r\n    \r\n    shardToJetty.get(SHARD1).get(1).jetty.getDebugFilter().addDelay(\n        \"Waiting for dependant update to timeout\", 2, 8000);\n\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n    for (UpdateRequest update : updates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, cloudClient,\n                                                                         random().nextLong());\n      threadpool.submit(task);\n\n      \r\n      \r\n      Thread.sleep(100); \n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 12 secs\", threadpool.awaitTermination(12, TimeUnit.SECONDS));\n\n    commit();\n\n    \r\n    \r\n    for (int i=0; i<100; i++) {\n      Thread.sleep(10);\n      cloudClient.getZkStateReader().forceUpdateCollection(DEFAULT_COLLECTION);\n      ClusterState state = cloudClient.getZkStateReader().getClusterState();\n\n      int numActiveReplicas = 0;\n      for (Replica rep: state.getCollection(DEFAULT_COLLECTION).getSlice(SHARD1).getReplicas())\n        if (rep.getState().equals(Replica.State.ACTIVE))\n          numActiveReplicas++;\n\n      assertEquals(\"The replica receiving reordered updates must not have gone down\", 3, numActiveReplicas);\n    }\n\n    for (SolrClient client : clients) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): {}\", ((HttpSolrClient) client).getBaseURL());\n        log.info(\"Version at {} is: {}\", ((HttpSolrClient) client).getBaseURL(),\n            getReplicaValue(client, 1, \"_version_\")); \r\n      }\n      assertNull(client.getById(\"1\", params(\"distrib\", \"false\")));\n    }\n\n    log.info(\"reorderedDBQsUsingUpdatedValueFromADroppedUpdate: This test passed fine...\");\n  }\n","date":"2020-05-01 07:50:31","endLine":1355,"groupId":"102867","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"reorderedDBQsUsingUpdatedValueFromADroppedUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/38/31100e885a3fb07d8a51c2e82d65328357ddf3.src","preCode":"  private void reorderedDBQsUsingUpdatedValueFromADroppedUpdate() throws Exception {\n    if (onlyLeaderIndexes) {\n      log.info(\"RTG with DBQs are not working in tlog replicas\");\n      return;\n    }\n    clearIndex();\n    commit();\n    \n    float inplace_updatable_float = 1F;\n    buildRandomIndex(inplace_updatable_float, Collections.singletonList(1));\n\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(regularUpdateRequest(\"id\", 1, \"id_i\", 1, \"inplace_updatable_float\", 12, \"title_s\", \"mytitle\"));\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1))); \r\n    updates.add(regularUpdateRequest(\"id\", 1, \"inplace_updatable_float\", map(\"inc\", 1)));\n    updates.add(regularDeleteByQueryRequest(\"inplace_updatable_float:14\"));\n\n    \r\n    \r\n    shardToJetty.get(SHARD1).get(1).jetty.getDebugFilter().addDelay(\n        \"Waiting for dependant update to timeout\", 2, 8000);\n\n    ExecutorService threadpool =\n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n    for (UpdateRequest update : updates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, cloudClient,\n                                                                         random().nextLong());\n      threadpool.submit(task);\n\n      \r\n      \r\n      Thread.sleep(100); \n    }\n\n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 12 secs\", threadpool.awaitTermination(12, TimeUnit.SECONDS));\n\n    commit();\n\n    \r\n    \r\n    for (int i=0; i<100; i++) {\n      Thread.sleep(10);\n      cloudClient.getZkStateReader().forceUpdateCollection(DEFAULT_COLLECTION);\n      ClusterState state = cloudClient.getZkStateReader().getClusterState();\n\n      int numActiveReplicas = 0;\n      for (Replica rep: state.getCollection(DEFAULT_COLLECTION).getSlice(SHARD1).getReplicas())\n        if (rep.getState().equals(Replica.State.ACTIVE))\n          numActiveReplicas++;\n\n      assertEquals(\"The replica receiving reordered updates must not have gone down\", 3, numActiveReplicas);\n    }\n\n    for (SolrClient client : clients) {\n      log.info(\"Testing client (testDBQUsingUpdatedFieldFromDroppedUpdate): \" + ((HttpSolrClient)client).getBaseURL());\n      log.info(\"Version at \" + ((HttpSolrClient)client).getBaseURL() + \" is: \" + getReplicaValue(client, 1, \"_version_\"));\n\n      assertNull(client.getById(\"1\", params(\"distrib\", \"false\")));\n    }\n\n    log.info(\"reorderedDBQsUsingUpdatedValueFromADroppedUpdate: This test passed fine...\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1291,"status":"M"},{"authorDate":"2018-04-04 04:41:57","commitOrder":7,"curCode":"  private int getNumberOfActiveReplicas(ClusterState clusterState, String collection, String sliceId) {\n    int numActiveReplicas = 0;\n    \r\n    for (Replica rep : clusterState.getCollection(collection).getSlice(sliceId).getReplicas()) {\n      if (rep.getState().equals(State.ACTIVE)) {\n        numActiveReplicas++;\n      }\n    }\n    return numActiveReplicas;\n  }\n","date":"2018-04-04 04:41:57","endLine":529,"groupId":"102867","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"getNumberOfActiveReplicas","params":"(ClusterStateclusterState@Stringcollection@StringsliceId)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/be/aeb2465e095d5299a6c3e1c95c6eec31c9db2c.src","preCode":"  private int getNumberOfActiveReplicas(ClusterState clusterState, String collection, String sliceId) {\n    int numActiveReplicas = 0;\n    \r\n    for (Replica rep : clusterState.getCollection(collection).getSlice(sliceId).getReplicas()) {\n      if (rep.getState().equals(State.ACTIVE)) {\n        numActiveReplicas++;\n      }\n    }\n    return numActiveReplicas;\n  }\n","realPath":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":520,"status":"N"}],"commitId":"9ae05e9b4f318dc0bbb352a6a65573614d0be26d","commitMessage":"@@@LUCENE-7788: fail precommit on unparameterised log messages and examine for wasted work/objects\n","date":"2020-05-01 07:50:31","modifiedFileCount":"170","status":"M","submitter":"Erick Erickson"}]
