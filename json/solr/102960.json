[{"authorTime":"2019-04-10 15:02:59","codes":[{"authorDate":"2019-04-10 15:02:59","commitOrder":1,"curCode":"  public void testBlockAtomicInplaceUpdates() throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"string_s\", \"root\");\n    assertU(adoc(doc));\n\n    assertU(commit());\n\n    assertQ(req(\"q\", \"id:1\", \"fl\", \"*\"),\n        \"//*[@numFound='1']\",\n        \"//doc[1]/str[@name='id']=1\"\n    );\n\n    List<SolrInputDocument> docs = IntStream.range(10, 20).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\",\n        \"child\", \"inplace_updatable_int\", \"0\")).collect(Collectors.toList());\n    doc = sdoc(\"id\", \"1\", \"children\", Collections.singletonMap(\"add\", docs));\n    addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n\n    assertU(commit());\n\n\n    assertQ(req(\"q\", \"_root_:1\", \"fl\", \"*\", \"rows\", \"11\"),\n        \"//*[@numFound='11']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\"\n    );\n\n    for(int i = 10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    for(int i = 10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    \r\n    for(int i = 10; i < 20; ++i) {\n      docs = IntStream.range(i * 10, (i * 10) + 5).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"grandChild\")).collect(Collectors.toList());\n      doc = sdoc(\"id\", String.valueOf(i), \"grandChildren\", Collections.singletonMap(\"add\", docs));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    for(int i =10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    assertQ(req(\"q\", \"-_root_:*\", \"fl\", \"*\"),\n        \"//*[@numFound='0']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:grandChild\", \"fl\", \"*\", \"rows\", \"50\"),\n        \"//*[@numFound='50']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\");\n\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*,[child limit=-1]\"),\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/children/[0]/id=='10'\",\n        \"/response/docs/[0]/children/[0]/inplace_updatable_int==3\",\n        \"/response/docs/[0]/children/[0]/grandChildren/[0]/id=='100'\",\n        \"/response/docs/[0]/children/[0]/grandChildren/[4]/id=='104'\",\n        \"/response/docs/[0]/children/[9]/id=='19'\"\n    );\n\n  }\n","date":"2019-04-10 15:02:59","endLine":151,"groupId":"50479","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testBlockAtomicInplaceUpdates","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e5/2176f74a561f162e7efceeb5679a5036a2223c.src","preCode":"  public void testBlockAtomicInplaceUpdates() throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"string_s\", \"root\");\n    assertU(adoc(doc));\n\n    assertU(commit());\n\n    assertQ(req(\"q\", \"id:1\", \"fl\", \"*\"),\n        \"//*[@numFound='1']\",\n        \"//doc[1]/str[@name='id']=1\"\n    );\n\n    List<SolrInputDocument> docs = IntStream.range(10, 20).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\",\n        \"child\", \"inplace_updatable_int\", \"0\")).collect(Collectors.toList());\n    doc = sdoc(\"id\", \"1\", \"children\", Collections.singletonMap(\"add\", docs));\n    addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n\n    assertU(commit());\n\n\n    assertQ(req(\"q\", \"_root_:1\", \"fl\", \"*\", \"rows\", \"11\"),\n        \"//*[@numFound='11']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\"\n    );\n\n    for(int i = 10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    for(int i = 10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    \r\n    for(int i = 10; i < 20; ++i) {\n      docs = IntStream.range(i * 10, (i * 10) + 5).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"grandChild\")).collect(Collectors.toList());\n      doc = sdoc(\"id\", String.valueOf(i), \"grandChildren\", Collections.singletonMap(\"add\", docs));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    for(int i =10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    assertQ(req(\"q\", \"-_root_:*\", \"fl\", \"*\"),\n        \"//*[@numFound='0']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:grandChild\", \"fl\", \"*\", \"rows\", \"50\"),\n        \"//*[@numFound='50']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\");\n\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*,[child limit=-1]\"),\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/children/[0]/id=='10'\",\n        \"/response/docs/[0]/children/[0]/inplace_updatable_int==3\",\n        \"/response/docs/[0]/children/[0]/grandChildren/[0]/id=='100'\",\n        \"/response/docs/[0]/children/[0]/grandChildren/[4]/id=='104'\",\n        \"/response/docs/[0]/children/[9]/id=='19'\"\n    );\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"B"},{"authorDate":"2019-04-10 15:02:59","commitOrder":1,"curCode":"  public void testBlockAtomicQuantities() throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"string_s\", \"root\");\n    assertU(adoc(doc));\n\n    assertU(commit());\n\n    assertQ(req(\"q\", \"id:1\", \"fl\", \"*\"),\n        \"//*[@numFound='1']\",\n        \"//doc[1]/str[@name='id']=1\"\n    );\n\n    List<SolrInputDocument> docs = IntStream.range(10, 20).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"child\")).collect(Collectors.toList());\n    doc = sdoc(\"id\", \"1\", \"children\", Collections.singletonMap(\"add\", docs));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertU(commit());\n\n\n    assertQ(req(\"q\", \"_root_:1\", \"fl\", \"*\", \"rows\", \"11\"),\n        \"//*[@numFound='11']\",\n        \"*[count(//str[@name='_root_'][.='1'])=11]\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\"\n    );\n\n    \r\n    for(int i = 10; i < 20; ++i) {\n      docs = IntStream.range(i * 10, (i * 10) + 5).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"grandChild\")).collect(Collectors.toList());\n      doc = sdoc(\"id\", String.valueOf(i), \"grandChildren\", Collections.singletonMap(\"add\", docs));\n      addAndGetVersion(doc, params(\"wt\", \"json\"));\n      assertU(commit());\n    }\n\n    assertQ(req(\"q\", \"string_s:grandChild\", \"fl\", \"*\", \"rows\", \"50\"),\n        \"//*[@numFound='50']\",\n        \"*[count(//str[@name='string_s'][.='grandChild'])=50]\");\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\");\n  }\n","date":"2019-04-10 15:02:59","endLine":197,"groupId":"6131","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testBlockAtomicQuantities","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e5/2176f74a561f162e7efceeb5679a5036a2223c.src","preCode":"  public void testBlockAtomicQuantities() throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"string_s\", \"root\");\n    assertU(adoc(doc));\n\n    assertU(commit());\n\n    assertQ(req(\"q\", \"id:1\", \"fl\", \"*\"),\n        \"//*[@numFound='1']\",\n        \"//doc[1]/str[@name='id']=1\"\n    );\n\n    List<SolrInputDocument> docs = IntStream.range(10, 20).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"child\")).collect(Collectors.toList());\n    doc = sdoc(\"id\", \"1\", \"children\", Collections.singletonMap(\"add\", docs));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertU(commit());\n\n\n    assertQ(req(\"q\", \"_root_:1\", \"fl\", \"*\", \"rows\", \"11\"),\n        \"//*[@numFound='11']\",\n        \"*[count(//str[@name='_root_'][.='1'])=11]\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\"\n    );\n\n    \r\n    for(int i = 10; i < 20; ++i) {\n      docs = IntStream.range(i * 10, (i * 10) + 5).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"grandChild\")).collect(Collectors.toList());\n      doc = sdoc(\"id\", String.valueOf(i), \"grandChildren\", Collections.singletonMap(\"add\", docs));\n      addAndGetVersion(doc, params(\"wt\", \"json\"));\n      assertU(commit());\n    }\n\n    assertQ(req(\"q\", \"string_s:grandChild\", \"fl\", \"*\", \"rows\", \"50\"),\n        \"//*[@numFound='50']\",\n        \"*[count(//str[@name='string_s'][.='grandChild'])=50]\");\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"B"}],"commitId":"8527ec11af8099f86953ffad1182ad43c752f95b","commitMessage":"@@@SOLR-12638: Partial/Atomic updates of nested docs.\nand [child] now works in RTG.\n","date":"2019-04-10 15:02:59","modifiedFileCount":"11","status":"B","submitter":"Moshe"},{"authorTime":"2021-01-08 12:23:20","codes":[{"authorDate":"2019-04-10 15:02:59","commitOrder":2,"curCode":"  public void testBlockAtomicInplaceUpdates() throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"string_s\", \"root\");\n    assertU(adoc(doc));\n\n    assertU(commit());\n\n    assertQ(req(\"q\", \"id:1\", \"fl\", \"*\"),\n        \"//*[@numFound='1']\",\n        \"//doc[1]/str[@name='id']=1\"\n    );\n\n    List<SolrInputDocument> docs = IntStream.range(10, 20).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\",\n        \"child\", \"inplace_updatable_int\", \"0\")).collect(Collectors.toList());\n    doc = sdoc(\"id\", \"1\", \"children\", Collections.singletonMap(\"add\", docs));\n    addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n\n    assertU(commit());\n\n\n    assertQ(req(\"q\", \"_root_:1\", \"fl\", \"*\", \"rows\", \"11\"),\n        \"//*[@numFound='11']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\"\n    );\n\n    for(int i = 10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    for(int i = 10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    \r\n    for(int i = 10; i < 20; ++i) {\n      docs = IntStream.range(i * 10, (i * 10) + 5).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"grandChild\")).collect(Collectors.toList());\n      doc = sdoc(\"id\", String.valueOf(i), \"grandChildren\", Collections.singletonMap(\"add\", docs));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    for(int i =10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    assertQ(req(\"q\", \"-_root_:*\", \"fl\", \"*\"),\n        \"//*[@numFound='0']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:grandChild\", \"fl\", \"*\", \"rows\", \"50\"),\n        \"//*[@numFound='50']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\");\n\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*,[child limit=-1]\"),\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/children/[0]/id=='10'\",\n        \"/response/docs/[0]/children/[0]/inplace_updatable_int==3\",\n        \"/response/docs/[0]/children/[0]/grandChildren/[0]/id=='100'\",\n        \"/response/docs/[0]/children/[0]/grandChildren/[4]/id=='104'\",\n        \"/response/docs/[0]/children/[9]/id=='19'\"\n    );\n\n  }\n","date":"2019-04-10 15:02:59","endLine":151,"groupId":"102960","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testBlockAtomicInplaceUpdates","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e5/2176f74a561f162e7efceeb5679a5036a2223c.src","preCode":"  public void testBlockAtomicInplaceUpdates() throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"string_s\", \"root\");\n    assertU(adoc(doc));\n\n    assertU(commit());\n\n    assertQ(req(\"q\", \"id:1\", \"fl\", \"*\"),\n        \"//*[@numFound='1']\",\n        \"//doc[1]/str[@name='id']=1\"\n    );\n\n    List<SolrInputDocument> docs = IntStream.range(10, 20).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\",\n        \"child\", \"inplace_updatable_int\", \"0\")).collect(Collectors.toList());\n    doc = sdoc(\"id\", \"1\", \"children\", Collections.singletonMap(\"add\", docs));\n    addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n\n    assertU(commit());\n\n\n    assertQ(req(\"q\", \"_root_:1\", \"fl\", \"*\", \"rows\", \"11\"),\n        \"//*[@numFound='11']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\"\n    );\n\n    for(int i = 10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    for(int i = 10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    \r\n    for(int i = 10; i < 20; ++i) {\n      docs = IntStream.range(i * 10, (i * 10) + 5).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"grandChild\")).collect(Collectors.toList());\n      doc = sdoc(\"id\", String.valueOf(i), \"grandChildren\", Collections.singletonMap(\"add\", docs));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    for(int i =10; i < 20; ++i) {\n      doc = sdoc(\"id\", String.valueOf(i), \"inplace_updatable_int\", Collections.singletonMap(\"inc\", \"1\"));\n      addAndGetVersion(doc, params(\"wt\", \"json\", \"_route_\", \"1\"));\n      assertU(commit());\n    }\n\n    assertQ(req(\"q\", \"-_root_:*\", \"fl\", \"*\"),\n        \"//*[@numFound='0']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:grandChild\", \"fl\", \"*\", \"rows\", \"50\"),\n        \"//*[@numFound='50']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\");\n\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*,[child limit=-1]\"),\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/children/[0]/id=='10'\",\n        \"/response/docs/[0]/children/[0]/inplace_updatable_int==3\",\n        \"/response/docs/[0]/children/[0]/grandChildren/[0]/id=='100'\",\n        \"/response/docs/[0]/children/[0]/grandChildren/[4]/id=='104'\",\n        \"/response/docs/[0]/children/[9]/id=='19'\"\n    );\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":76,"status":"N"},{"authorDate":"2021-01-08 12:23:20","commitOrder":2,"curCode":"  public void testBlockAtomicQuantities() throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"string_s\", \"root\");\n    assertU(adoc(doc));\n\n    assertU(commit());\n\n    assertQ(req(\"q\", \"id:1\", \"fl\", \"*\"),\n        \"//*[@numFound='1']\",\n        \"//doc[1]/str[@name='id']=1\"\n    );\n\n    List<SolrInputDocument> docs = IntStream.range(10, 20).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"child\")).collect(Collectors.toList());\n    doc = sdoc(\"id\", \"1\", \"children\", Collections.singletonMap(\"add\", docs));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertU(commit());\n\n\n    assertQ(req(\"q\", \"_root_:1\", \"fl\", \"*\", \"rows\", \"11\"),\n        \"//*[@numFound='11']\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\"\n    );\n\n    \r\n    for(int i = 10; i < 20; ++i) {\n      docs = IntStream.range(i * 10, (i * 10) + 5).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"grandChild\")).collect(Collectors.toList());\n      doc =\n          sdoc(\n              \"id\",\n              String.valueOf(i),\n              \"_root_\", \r\n              \"1\",\n              \"grandChildren\",\n              Collections.singletonMap(\"add\", docs));\n      addAndGetVersion(doc, params(\"wt\", \"json\")); \r\n      assertU(commit());\n    }\n\n    assertQ(req(\"q\", \"string_s:grandChild\", \"fl\", \"*\", \"rows\", \"50\"),\n        \"//*[@numFound='50']\",\n        \"*[count(//str[@name='string_s'][.='grandChild'])=50]\");\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\");\n  }\n","date":"2021-01-08 12:23:20","endLine":208,"groupId":"102960","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testBlockAtomicQuantities","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/85/3cb78ca4ff03fc8fa36ca4e4f0c3cba084ab06.src","preCode":"  public void testBlockAtomicQuantities() throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"string_s\", \"root\");\n    assertU(adoc(doc));\n\n    assertU(commit());\n\n    assertQ(req(\"q\", \"id:1\", \"fl\", \"*\"),\n        \"//*[@numFound='1']\",\n        \"//doc[1]/str[@name='id']=1\"\n    );\n\n    List<SolrInputDocument> docs = IntStream.range(10, 20).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"child\")).collect(Collectors.toList());\n    doc = sdoc(\"id\", \"1\", \"children\", Collections.singletonMap(\"add\", docs));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertU(commit());\n\n\n    assertQ(req(\"q\", \"_root_:1\", \"fl\", \"*\", \"rows\", \"11\"),\n        \"//*[@numFound='11']\",\n        \"*[count(//str[@name='_root_'][.='1'])=11]\"\n    );\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\"\n    );\n\n    \r\n    for(int i = 10; i < 20; ++i) {\n      docs = IntStream.range(i * 10, (i * 10) + 5).mapToObj(x -> sdoc(\"id\", String.valueOf(x), \"string_s\", \"grandChild\")).collect(Collectors.toList());\n      doc = sdoc(\"id\", String.valueOf(i), \"grandChildren\", Collections.singletonMap(\"add\", docs));\n      addAndGetVersion(doc, params(\"wt\", \"json\"));\n      assertU(commit());\n    }\n\n    assertQ(req(\"q\", \"string_s:grandChild\", \"fl\", \"*\", \"rows\", \"50\"),\n        \"//*[@numFound='50']\",\n        \"*[count(//str[@name='string_s'][.='grandChild'])=50]\");\n\n    assertQ(req(\"q\", \"string_s:child\", \"fl\", \"*\"),\n        \"//*[@numFound='10']\",\n        \"*[count(//str[@name='string_s'][.='child'])=10]\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":159,"status":"M"}],"commitId":"4cb3ad4a1c40b4326aec64577a7e60018f7f1a5e","commitMessage":"@@@* SOLR-14923: Nested docs indexing perf & robustness (#2159)\n\n* When the schema defines _root_.  and you want to do atomic/partial updates...\n** _root_ needn't be stored or have docValues any more\n** _nest_path_ field isn't needed for this any more\n** Simplified internal logic\n* Allow (and recommend.  eventually insist) that the _root_ field be passed for atomic/partial updates to child docs.\n** In the absence of _root_.  assume the _route_ param is equivalent to ameliorate back-compat scope.  This is a temporary hack; remove in SOLR-15064.\n** One of the two is required; you'll get an exception if the assumption is false.  THIS IS A BACK-COMPAT CHANGE\n* Ensure that the update log contains the _root_ field if it's defined in the schema; in some cases it wasn't.  It's important for robustness of atomic/partial updates to child docs.  Caveat: the buffer replay scenario is not tested with child docs.\n* Limited the cases when a realtime searcher is re-opened.  It was being applied to any update that included child docs but now only some narrow subset: only for atomic/partial updates.  and when the update log contains an in-place update for the same nest because it's complicated to resolve those log entries.\n* Internal improvements to RealTimeGetComponent to aid clarity & robustness & probably performance...\n** Use SolrDocumentFetcher.solrDoc(docID.  ReturnFields) instead of more manual loading.  Will do more with this in another PR.\n** Clarify when only root doc IDs are expected.\n** Use Resolution enum more.  add PARTIAL.  remove DOC_WITH_CHILDREN; enhance docs.\n** When have ReturnFields.  a Set of \"onlyTheseFields\" becomes redundant.  Add a child doc resolution via a transformer when needed.\n** Clarified where copy-field targets are removed\n* NestPathField should default to single valued.  instead of inheriting the schema default.  which for ancient schemas was multi-valued.\n* AddUpdateCommand.getLuceneDocument(s) methods are very internal; made package visible and refactored a bit for clarity\n* DocumentBuilder: when in-place update.  skip id and _root_ here.  thus also simplifying further logic\n* NestedShardedAtomicUpdateTest no longer extends AbstractFullDistribZkTestBase because it wasn't really leveraging the \"control client\" checking.  and it added too much complexity to debug failures.","date":"2021-01-08 12:23:20","modifiedFileCount":"19","status":"M","submitter":"David Smiley"}]
