[{"authorTime":"2016-12-31 08:54:00","codes":[{"authorDate":"2018-11-28 00:21:42","commitOrder":5,"curCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    HashSet fieldSet = null;\n\n    if(fl != null) {\n      fieldSet = new HashSet();\n      String[] fls = fl.split(\",\");\n      for (String f : fls) {\n        fieldSet.add(f.trim()); \r\n      }\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(fieldSet != null && !fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","date":"2018-11-28 00:22:02","endLine":268,"groupId":"58983","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"parseComp","params":"(Stringsort@Stringfl)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2e/eeb78e77102275782cfc3100eb927a0a6db439.src","preCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    HashSet fieldSet = null;\n\n    if(fl != null) {\n      fieldSet = new HashSet();\n      String[] fls = fl.split(\",\");\n      for (String f : fls) {\n        fieldSet.add(f.trim()); \r\n      }\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(fieldSet != null && !fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SearchStream.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"B"},{"authorDate":"2016-12-31 08:54:00","commitOrder":5,"curCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    String[] fls = fl.split(\",\");\n    HashSet fieldSet = new HashSet();\n    for(String f : fls) {\n      fieldSet.add(f.trim()); \r\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n      \n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n      \n      if(!fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n      \n      \r\n      if(null != fieldMappings && fieldMappings.containsKey(fieldName)){\n        fieldName = fieldMappings.get(fieldName);\n      }\n      \n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","date":"2016-12-31 08:55:31","endLine":359,"groupId":"52729","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"parseComp","params":"(Stringsort@Stringfl)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f1/77585e2a35a104d293d8eb4481219124a7916c.src","preCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    String[] fls = fl.split(\",\");\n    HashSet fieldSet = new HashSet();\n    for(String f : fls) {\n      fieldSet.add(f.trim()); \r\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n      \n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n      \n      if(!fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n      \n      \r\n      if(null != fieldMappings && fieldMappings.containsKey(fieldName)){\n        fieldName = fieldMappings.get(fieldName);\n      }\n      \n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":320,"status":"NB"}],"commitId":"c2cac887702f9efc0a6bf75cd9f1e78f730c2c4f","commitMessage":"@@@SOLR-12984: The search Streaming Expression should properly support and push down paging when using the /select handler\n","date":"2018-11-28 00:22:02","modifiedFileCount":"8","status":"M","submitter":"Joel Bernstein"},{"authorTime":"2020-06-10 07:16:14","codes":[{"authorDate":"2018-11-28 00:21:42","commitOrder":6,"curCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    HashSet fieldSet = null;\n\n    if(fl != null) {\n      fieldSet = new HashSet();\n      String[] fls = fl.split(\",\");\n      for (String f : fls) {\n        fieldSet.add(f.trim()); \r\n      }\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(fieldSet != null && !fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","date":"2018-11-28 00:22:02","endLine":268,"groupId":"58983","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"parseComp","params":"(Stringsort@Stringfl)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2e/eeb78e77102275782cfc3100eb927a0a6db439.src","preCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    HashSet fieldSet = null;\n\n    if(fl != null) {\n      fieldSet = new HashSet();\n      String[] fls = fl.split(\",\");\n      for (String f : fls) {\n        fieldSet.add(f.trim()); \r\n      }\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(fieldSet != null && !fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SearchStream.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"N"},{"authorDate":"2020-06-10 07:16:14","commitOrder":6,"curCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    String[] fls = fl.split(\",\");\n    @SuppressWarnings({\"rawtypes\"})\n    HashSet fieldSet = new HashSet();\n    for(String f : fls) {\n      fieldSet.add(f.trim()); \r\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(!fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      \r\n      if(null != fieldMappings && fieldMappings.containsKey(fieldName)){\n        fieldName = fieldMappings.get(fieldName);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","date":"2020-06-10 07:21:36","endLine":332,"groupId":"52729","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"parseComp","params":"(Stringsort@Stringfl)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c2/a87000bd42388f84e4fd13664859986f885dc7.src","preCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    String[] fls = fl.split(\",\");\n    HashSet fieldSet = new HashSet();\n    for(String f : fls) {\n      fieldSet.add(f.trim()); \r\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(!fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      \r\n      if(null != fieldMappings && fieldMappings.containsKey(fieldName)){\n        fieldName = fieldMappings.get(fieldName);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":292,"status":"M"}],"commitId":"c8f48d470108e5bbb356a9dbc8d040b75214c7dc","commitMessage":"@@@SOLR-14547: Fix or suppress warnings in solr/client/solrj/io/stream\n","date":"2020-06-10 07:21:36","modifiedFileCount":"43","status":"M","submitter":"Erick Erickson"},{"authorTime":"2021-06-22 00:19:37","codes":[{"authorDate":"2021-06-22 00:19:37","commitOrder":7,"curCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    HashSet<String> fieldSet = null;\n\n    if(fl != null) {\n      fieldSet = new HashSet<>();\n      String[] fls = fl.split(\",\");\n      for (String f : fls) {\n        fieldSet.add(f.trim()); \r\n      }\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(fieldSet != null && !fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","date":"2021-06-22 00:19:37","endLine":268,"groupId":"10298","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"parseComp","params":"(Stringsort@Stringfl)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9f/225ad277ca8f6abca839aa42bfea5929f60a60.src","preCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    HashSet fieldSet = null;\n\n    if(fl != null) {\n      fieldSet = new HashSet();\n      String[] fls = fl.split(\",\");\n      for (String f : fls) {\n        fieldSet.add(f.trim()); \r\n      }\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(fieldSet != null && !fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SearchStream.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":230,"status":"M"},{"authorDate":"2021-06-22 00:19:37","commitOrder":7,"curCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    String[] fls = fl.split(\",\");\n    HashSet<String> fieldSet = new HashSet<>();\n    for(String f : fls) {\n      fieldSet.add(f.trim()); \r\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(!fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      \r\n      if(null != fieldMappings && fieldMappings.containsKey(fieldName)){\n        fieldName = fieldMappings.get(fieldName);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","date":"2021-06-22 00:19:37","endLine":326,"groupId":"10298","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"parseComp","params":"(Stringsort@Stringfl)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e3/a79eafa121e1556989bbe1ed01375bd3558d1d.src","preCode":"  private StreamComparator parseComp(String sort, String fl) throws IOException {\n\n    String[] fls = fl.split(\",\");\n    @SuppressWarnings({\"rawtypes\"})\n    HashSet fieldSet = new HashSet();\n    for(String f : fls) {\n      fieldSet.add(f.trim()); \r\n    }\n\n    String[] sorts = sort.split(\",\");\n    StreamComparator[] comps = new StreamComparator[sorts.length];\n    for(int i=0; i<sorts.length; i++) {\n      String s = sorts[i];\n\n      String[] spec = s.trim().split(\"\\\\s+\"); \r\n\n      if (spec.length != 2) {\n        throw new IOException(\"Invalid sort spec:\" + s);\n      }\n\n      String fieldName = spec[0].trim();\n      String order = spec[1].trim();\n\n      if(!fieldSet.contains(spec[0])) {\n        throw new IOException(\"Fields in the sort spec must be included in the field list:\"+spec[0]);\n      }\n\n      \r\n      if(null != fieldMappings && fieldMappings.containsKey(fieldName)){\n        fieldName = fieldMappings.get(fieldName);\n      }\n\n      comps[i] = new FieldComparator(fieldName, order.equalsIgnoreCase(\"asc\") ? ComparatorOrder.ASCENDING : ComparatorOrder.DESCENDING);\n    }\n\n    if(comps.length > 1) {\n      return new MultipleFieldComparator(comps);\n    } else {\n      return comps[0];\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/CloudSolrStream.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":287,"status":"M"}],"commitId":"1725e778ac86d88e2deff8f7339d45bb4e50a719","commitMessage":"@@@SOLR-15385 RawTypes Part III.  contrib and solrj (#169)\n\n* SOLR-15385 RawTypes Part III.  contrib and solrj\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>","date":"2021-06-22 00:19:37","modifiedFileCount":"216","status":"M","submitter":"Mike Drob"}]
