[{"authorTime":"2014-02-09 13:18:05","codes":[{"authorDate":"2013-11-23 21:46:12","commitOrder":3,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2013-11-23 21:46:12","endLine":94,"groupId":"55185","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e8/196413cc6211012aae351dd30d0b128cb8a2ef.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":65,"status":"NB"},{"authorDate":"2014-02-09 13:18:05","commitOrder":3,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars, blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-02-09 13:18:05","endLine":101,"groupId":"55185","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/16/62913c694b4b0a906dff7c5fc8d25b6bc53028.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars, blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":66,"status":"B"}],"commitId":"450e6204f43176c5bbb7a5bf88a5be565d5402ba","commitMessage":"@@@SOLR-5695: Add support for Lucene's BlendedInfixSuggester\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1566222 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-02-09 13:18:05","modifiedFileCount":"2","status":"M","submitter":"Areek Zillur"},{"authorTime":"2014-03-07 20:45:11","codes":[{"authorDate":"2014-03-07 20:45:11","commitOrder":4,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-03-07 20:45:11","endLine":99,"groupId":"55185","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a1/1d6d223616494c82fab0168fb77293d9597ae4.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"M"},{"authorDate":"2014-03-07 20:45:11","commitOrder":4,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-03-07 20:45:11","endLine":104,"groupId":"55185","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/7c/20b5645a536c853f2c6ca4c1b2cd10f81d7a80.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars, blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"M"}],"commitId":"2c116862af0cc8e921c039a19b3aec7cca80ef3f","commitMessage":"@@@LUCENE-5493: cut over index sorting to use Sort api for specifying the order\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1575248 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-03-07 20:45:11","modifiedFileCount":"16","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-05-03 06:34:25","codes":[{"authorDate":"2014-05-03 06:34:25","commitOrder":5,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-05-03 06:34:25","endLine":98,"groupId":"55185","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/07/0fb839ceef144cd473c9372c3f76413f9ae69f.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"},{"authorDate":"2014-05-03 06:34:25","commitOrder":5,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-05-03 06:34:25","endLine":104,"groupId":"55185","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b8/95ff0de72da34b050064d39b3aeabc525bc4a5.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"M"}],"commitId":"ad37014a3ac6dcd53de14680ddb63b99c25b1f86","commitMessage":"@@@SOLR-6022: Rename getAnalyzer() to getIndexAnalyzer()\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1592076 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-05-03 06:34:25","modifiedFileCount":"31","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2014-05-22 14:15:26","codes":[{"authorDate":"2014-05-22 14:15:26","commitOrder":6,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-05-22 14:15:26","endLine":101,"groupId":"5119","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1e/31716ba28a8c10d8894c78f9d998f100155c27.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"},{"authorDate":"2014-05-22 14:15:26","commitOrder":6,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-05-22 14:15:26","endLine":107,"groupId":"4547","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/12/9a8e27d3e86e914e3441e207be8a20d164b2ee.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"M"}],"commitId":"cf5a0caeb61c701d7c57d63f0e747913976b3940","commitMessage":"@@@LUCENE-5650: Enforce read-only access to any path outside the temporary folder via security manager\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1596767 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-05-22 14:15:26","modifiedFileCount":"32","status":"M","submitter":"Dawid Weiss"},{"authorTime":"2014-08-22 08:07:15","codes":[{"authorDate":"2014-08-22 08:07:15","commitOrder":7,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-08-22 08:07:15","endLine":101,"groupId":"5119","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/23/27d785960ef814ef32cca157917de008636703.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"},{"authorDate":"2014-08-22 08:07:15","commitOrder":7,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-08-22 08:07:15","endLine":107,"groupId":"4547","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/82/daeab31d73ae005012db5a96a3db69aee7847d.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"M"}],"commitId":"4a485d68771e5e123139cc12e9ea2733a922baea","commitMessage":"@@@LUCENE-5889: add commit method to AnalyzingInfixSuggester\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1619635 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-08-22 08:07:15","modifiedFileCount":"6","status":"M","submitter":"Michael McCandless"},{"authorTime":"2014-09-14 05:46:29","codes":[{"authorDate":"2014-09-14 05:46:29","commitOrder":8,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-09-14 05:46:29","endLine":101,"groupId":"5119","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/5e/30fb1cfbae79957d4c248d3b31c61268c65ae4.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":68,"status":"M"},{"authorDate":"2014-09-14 05:46:29","commitOrder":8,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-09-14 05:46:29","endLine":107,"groupId":"4547","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/48/bdf983b27bbddbfec5100305e0fc2a50aca90a.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":67,"status":"M"}],"commitId":"3eb66fb19ca2aa3d9dce53661f3233b6c9d3f974","commitMessage":"@@@LUCENE-5945: Full cutover to Path api from java.io.File\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1624784 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-09-14 05:46:29","modifiedFileCount":"293","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-11-15 06:04:05","codes":[{"authorDate":"2014-11-15 06:04:05","commitOrder":9,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-11-15 06:04:05","endLine":123,"groupId":"5119","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/41/ce876f9e67225c1262f1dae0737ab9d46706bc.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2014-11-15 06:04:05","commitOrder":9,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-11-15 06:04:05","endLine":129,"groupId":"4547","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/14/55465ffa8454364f890fe2b4ab7a169811840d.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"}],"commitId":"fdeb3232439060d4f06a43c5b3239db540eed9a9","commitMessage":"@@@LUCENE-6004: don't highlight LookupResult.key from AnalyzingInfixSuggester\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1639798 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-15 06:04:05","modifiedFileCount":"5","status":"M","submitter":"Michael McCandless"},{"authorTime":"2014-11-29 07:05:14","codes":[{"authorDate":"2014-11-29 07:05:14","commitOrder":10,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-11-29 07:05:14","endLine":122,"groupId":"5119","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d6/1eb5491f95ad119e214567715d6807319882bd.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":72,"status":"M"},{"authorDate":"2014-11-29 07:05:14","commitOrder":10,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2014-11-29 07:05:14","endLine":128,"groupId":"4547","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/de/f6cc554df3f9b924fc124f1f2fd764f2380caa.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"}],"commitId":"46e8f846c5a5304e8d1c6ab56d24ac548a68231f","commitMessage":"@@@LUCENE-6080: remove some deprecations from trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1642374 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-29 07:05:14","modifiedFileCount":"20","status":"M","submitter":"Robert Muir"},{"authorTime":"2015-02-06 02:24:01","codes":[{"authorDate":"2015-02-06 02:24:01","commitOrder":11,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2015-02-06 02:24:01","endLine":140,"groupId":"5119","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c3/7219b79d3de6d9b75d30e5fc437cee6de48c77.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"},{"authorDate":"2015-02-06 02:24:01","commitOrder":11,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2015-02-06 02:24:01","endLine":137,"groupId":"1607","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b7/c6bf42850b41a519b059fdcac74ad5f60b61dd.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"}],"commitId":"b96f012f2e75a9b9fb59253f6d133cd05ecaf670","commitMessage":"@@@SOLR-6648: Add support for highlight and allTermsRequired configuration in AnalyzingInfix and BlendedInfix Solr suggesters\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1657655 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-02-06 02:24:01","modifiedFileCount":"3","status":"M","submitter":"Tomas Eduardo Fernandez Lobbe"},{"authorTime":"2015-03-26 01:41:51","codes":[{"authorDate":"2015-02-06 02:24:01","commitOrder":12,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","date":"2015-02-06 02:24:01","endLine":140,"groupId":"5119","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c3/7219b79d3de6d9b75d30e5fc437cee6de48c77.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"N"},{"authorDate":"2015-03-26 01:41:51","commitOrder":12,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2015-03-26 01:41:51","endLine":137,"groupId":"1607","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1b/92d1828c90e2196f4859226f8b0567c5374d3e.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"M"}],"commitId":"29c1de0fa8958b5cd6ada921ddbaaeb68c95c481","commitMessage":"@@@SOLR-7305: BlendedInfixLookupFactory swallows root IOException when it occurs. This closes #137\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1669180 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-03-26 01:41:51","modifiedFileCount":"1","status":"M","submitter":"Shalin Shekhar Mangar"},{"authorTime":"2015-03-26 01:41:51","codes":[{"authorDate":"2015-04-01 03:54:37","commitOrder":13,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2015-04-01 03:54:37","endLine":140,"groupId":"5119","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/49/edb6068fd125d7db970564c961eea37594a867.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"M"},{"authorDate":"2015-03-26 01:41:51","commitOrder":13,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2015-03-26 01:41:51","endLine":137,"groupId":"1607","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1b/92d1828c90e2196f4859226f8b0567c5374d3e.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":71,"status":"N"}],"commitId":"02b89071249adc5c2ae34292888e6e080c77ca5f","commitMessage":"@@@LUCENE-6378: Fix all RuntimeExceptions to throw the underlying root cause\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1670453 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-04-01 03:54:37","modifiedFileCount":"12","status":"M","submitter":"Varun Thacker"},{"authorTime":"2015-12-22 18:26:38","codes":[{"authorDate":"2015-04-01 03:54:37","commitOrder":14,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2015-04-01 03:54:37","endLine":140,"groupId":"5119","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/49/edb6068fd125d7db970564c961eea37594a867.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":81,"status":"N"},{"authorDate":"2015-12-22 18:26:38","commitOrder":14,"curCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n\n    Double exponent = params.get(EXPONENT) == null ? null : Double.valueOf(params.get(EXPONENT).toString());\n\n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, exponent, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2015-12-22 18:26:38","endLine":142,"groupId":"1607","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a5/be664ac1b093ee4e21d85f4198f4ca0c1d6201.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":74,"status":"M"}],"commitId":"fabc3b903dbc8fed2007890292640b533dc4678a","commitMessage":"@@@LUCENE-6939: add exponential reciprocal scoring mode to BlendedInfixSuggester\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1721330 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-12-22 18:26:38","modifiedFileCount":"4","status":"M","submitter":"Michael McCandless"},{"authorTime":"2020-06-13 23:00:58","codes":[{"authorDate":"2020-06-13 23:00:58","commitOrder":15,"curCode":"  public Lookup create(@SuppressWarnings({\"rawtypes\"})NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2020-06-13 23:00:58","endLine":144,"groupId":"5119","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"create","params":"(@SuppressWarnings({\"rawtypes\"})NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1c/e2206ba1b2caaebd5a689a1f6ff2098f187e29.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2020-06-13 23:00:58","commitOrder":15,"curCode":"  public Lookup create(@SuppressWarnings({\"rawtypes\"})NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n\n    Double exponent = params.get(EXPONENT) == null ? null : Double.valueOf(params.get(EXPONENT).toString());\n\n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, exponent, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2020-06-13 23:00:58","endLine":141,"groupId":"1607","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"create","params":"(@SuppressWarnings({\"rawtypes\"})NamedListparams@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/27197e913f4601b444a9a5b510888b312a60a2.src","preCode":"  public Lookup create(NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n\n    Double exponent = params.get(EXPONENT) == null ? null : Double.valueOf(params.get(EXPONENT).toString());\n\n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, exponent, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"}],"commitId":"a41aa20b0afaadf47ec6e58476a947c6936c1921","commitMessage":"@@@SOLR-14564: Fix or suppress remaining warnings in solr/core\n","date":"2020-06-13 23:00:58","modifiedFileCount":"91","status":"M","submitter":"Erick Erickson"},{"authorTime":"2021-07-08 04:15:36","codes":[{"authorDate":"2021-07-08 04:15:36","commitOrder":16,"curCode":"  public Lookup create(NamedList<?> params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2021-07-08 04:15:36","endLine":144,"groupId":"102582","id":27,"instanceNumber":1,"isCurCommit":1,"methodName":"create","params":"(NamedList<?>params@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ad/aa36b2b2f1d18ee3cce10d8e1ab0184391d24b.src","preCode":"  public Lookup create(@SuppressWarnings({\"rawtypes\"})NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":85,"status":"M"},{"authorDate":"2021-07-08 04:15:36","commitOrder":16,"curCode":"  public Lookup create(NamedList<?> params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n\n    Double exponent = params.get(EXPONENT) == null ? null : Double.valueOf(params.get(EXPONENT).toString());\n\n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, exponent, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","date":"2021-07-08 04:15:36","endLine":141,"groupId":"102582","id":28,"instanceNumber":2,"isCurCommit":1,"methodName":"create","params":"(NamedList<?>params@SolrCorecore)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1f/16178be64f5b328b86e13059b70cd51fba8676.src","preCode":"  public Lookup create(@SuppressWarnings({\"rawtypes\"})NamedList params, SolrCore core) {\n    \r\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    \r\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n\n    Double exponent = params.get(EXPONENT) == null ? null : Double.valueOf(params.get(EXPONENT).toString());\n\n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, exponent, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"}],"commitId":"201d56b350fa1b4e5f8361618f898a2155240c72","commitMessage":"@@@SOLR-15385 RawTypes Part V (#196)\n\n","date":"2021-07-08 04:15:36","modifiedFileCount":"88","status":"M","submitter":"Mike Drob"}]
