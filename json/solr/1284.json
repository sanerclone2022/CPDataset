[{"authorTime":"2017-07-04 12:44:18","codes":[{"authorDate":"2018-12-17 00:58:20","commitOrder":3,"curCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","date":"2018-12-17 00:58:20","endLine":162,"groupId":"14606","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"ConcurrentUpdateHttp2SolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ac/7449b65054af6f2ed91807ede3091664826b8c.src","preCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":145,"status":"B"},{"authorDate":"2017-07-04 12:44:18","commitOrder":3,"curCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","date":"2017-07-04 12:44:18","endLine":149,"groupId":"41953","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"ConcurrentUpdateSolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2d/9bfb105f512fe6d8a793d69864b535330b8465.src","preCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":122,"status":"NB"}],"commitId":"f80e8e11672d31c6e12069d2bd12a28b92e5a336","commitMessage":"@@@Merge jira/http2 branch to master\n","date":"2018-12-17 00:58:20","modifiedFileCount":"47","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2019-12-11 04:45:43","codes":[{"authorDate":"2019-12-11 04:45:43","commitOrder":4,"curCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","date":"2019-12-11 04:45:43","endLine":164,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"ConcurrentUpdateHttp2SolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bb/0c5822f6ec10743fcadef6d9198373adcb3ebf.src","preCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"},{"authorDate":"2019-12-11 04:45:43","commitOrder":4,"curCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","date":"2019-12-11 04:45:43","endLine":153,"groupId":"42750","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"ConcurrentUpdateSolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d9/21cb2114af37456fe372f44f3bed753cc789a3.src","preCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    \n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"}],"commitId":"c4f0c3363828c088eefa2b99783178848c2f1f7a","commitMessage":"@@@SOLR-13975.  SOLR-13896: ConcurrentUpdateSolrClient connection stall prevention.\n","date":"2019-12-11 04:45:43","modifiedFileCount":"8","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2019-12-13 02:04:23","codes":[{"authorDate":"2019-12-13 02:04:23","commitOrder":5,"curCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","date":"2019-12-13 02:58:03","endLine":167,"groupId":"42360","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"ConcurrentUpdateHttp2SolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0e/224a1b85b2105e72d1d415c6fb7345f4118c83.src","preCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"},{"authorDate":"2019-12-13 02:04:23","commitOrder":5,"curCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","date":"2019-12-13 02:58:03","endLine":155,"groupId":"42750","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"ConcurrentUpdateSolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ed/c8270cfc324c25d78baac6c43684c87e6026ae.src","preCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"}],"commitId":"e155649026a62e684667e657175d0f722601c05b","commitMessage":"@@@SOLR-13975: Make sure the stall time is adjusted up when an unusually long\npoll time is configured.\n","date":"2019-12-13 02:58:03","modifiedFileCount":"2","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2020-02-20 20:29:20","codes":[{"authorDate":"2019-12-13 02:04:23","commitOrder":6,"curCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","date":"2019-12-13 02:58:03","endLine":167,"groupId":"42360","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"ConcurrentUpdateHttp2SolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0e/224a1b85b2105e72d1d415c6fb7345f4118c83.src","preCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"N"},{"authorDate":"2020-02-20 20:29:20","commitOrder":6,"curCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .withConnectionTimeout(builder.connectionTimeoutMillis)\n        .withSocketTimeout(builder.socketTimeoutMillis)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","date":"2020-02-20 20:29:20","endLine":157,"groupId":"42750","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"ConcurrentUpdateSolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c7/74e03367132882aca0fc7bd6950af3c6082922.src","preCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"}],"commitId":"051133c13f982e72aabf914350c65e3dd8aa961d","commitMessage":"@@@SOLR-12550: ConcurrentUpdateSolrClient doesn't respect timeouts for commits and optimize (#417)\n\nConcurrentUpdateSolrClient now propagates its connection and read timeouts to the private HttpSolrClient used to commit and optimize.","date":"2020-02-20 20:29:20","modifiedFileCount":"2","status":"M","submitter":"Marc A. Morissette"},{"authorTime":"2020-04-13 10:46:35","codes":[{"authorDate":"2020-04-13 10:46:35","commitOrder":7,"curCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","date":"2020-04-13 10:46:35","endLine":167,"groupId":"1284","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"ConcurrentUpdateHttp2SolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/36/aafa05daa8bfe7c7ea440a7ccedd8cdbc01b5b.src","preCode":"  protected ConcurrentUpdateHttp2SolrClient(Builder builder) {\n    this.client = builder.client;\n    this.shutdownClient = builder.closeHttp2Client;\n    this.threadCount = builder.threadCount;\n    this.queue = new CustomBlockingQueue<>(builder.queueSize, threadCount, END_UPDATE);\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.basePath = builder.baseSolrUrl;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":146,"status":"M"},{"authorDate":"2020-04-13 10:46:35","commitOrder":7,"curCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .withConnectionTimeout(builder.connectionTimeoutMillis)\n        .withSocketTimeout(builder.socketTimeoutMillis)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","date":"2020-04-13 10:46:35","endLine":157,"groupId":"1284","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"ConcurrentUpdateSolrClient","params":"(Builderbuilder)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/22/c797002022e925cde0804c9a89329bb461b8c4.src","preCode":"  protected ConcurrentUpdateSolrClient(Builder builder) {\n    this.internalHttpClient = (builder.httpClient == null);\n    this.client = new HttpSolrClient.Builder(builder.baseSolrUrl)\n        .withHttpClient(builder.httpClient)\n        .withConnectionTimeout(builder.connectionTimeoutMillis)\n        .withSocketTimeout(builder.socketTimeoutMillis)\n        .build();\n    this.client.setFollowRedirects(false);\n    this.queue = new LinkedBlockingQueue<>(builder.queueSize);\n    this.threadCount = builder.threadCount;\n    this.runners = new LinkedList<>();\n    this.streamDeletes = builder.streamDeletes;\n    this.connectionTimeout = builder.connectionTimeoutMillis;\n    this.soTimeout = builder.socketTimeoutMillis;\n    this.stallTime = Integer.getInteger(\"solr.cloud.client.stallTime\", 15000);\n    if (stallTime < pollQueueTime * 2) {\n      throw new RuntimeException(\"Invalid stallTime: \" + stallTime + \"ms, must be 2x > pollQueueTime \" + pollQueueTime);\n    }\n\n    if (builder.executorService != null) {\n      this.scheduler = builder.executorService;\n      this.shutdownExecutor = false;\n    } else {\n      this.scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"concurrentUpdateScheduler\"));\n      this.shutdownExecutor = true;\n    }\n    \n    if (log.isDebugEnabled()) {\n      this.pollInterrupts = new AtomicInteger();\n      this.pollExits = new AtomicInteger();\n      this.blockLoops = new AtomicInteger();\n      this.emptyQueueLoops = new AtomicInteger();\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"}],"commitId":"13f19f65559290a860df84fa1b5ac2db903b27ec","commitMessage":"@@@SOLR-9906: SolrjNamedThreadFactory is deprecated in favor of SolrNamedThreadFactory. DefaultSolrThreadFactory is removed from solr-core in favor of SolrNamedThreadFactory in solrj package and all solr-core classes now use SolrNamedThreadFactory\n","date":"2020-04-13 10:46:35","modifiedFileCount":"83","status":"M","submitter":"Shalin Shekhar Mangar"}]
