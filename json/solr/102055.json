[{"authorTime":"2019-04-10 15:02:59","codes":[{"authorDate":"2019-05-01 04:31:06","commitOrder":2,"curCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","date":"2019-05-01 04:31:44","endLine":499,"groupId":"43106","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doVersionAdd","params":"(AddUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync@booleanleaderLogic@booleanforwardedFromCollection@VersionBucketbucket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ed/48c758f47592c9980d29aab7abd4b35f61d414.src","preCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":343,"status":"B"},{"authorDate":"2019-04-10 15:02:59","commitOrder":2,"curCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":887,"groupId":"6599","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"doLocalDeleteByQuery","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"NB"}],"commitId":"70e090717d21a9713c45b8a52e35df940a4277df","commitMessage":"@@@SOLR-12833: Avoid unnecessary memory cost when DistributedUpdateProcessor timed-out lock is not used.\n","date":"2019-05-01 04:31:44","modifiedFileCount":"4","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2019-04-10 15:02:59","codes":[{"authorDate":"2019-05-07 13:20:02","commitOrder":3,"curCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","date":"2019-05-07 13:20:02","endLine":503,"groupId":"43106","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doVersionAdd","params":"(AddUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync@booleanleaderLogic@booleanforwardedFromCollection@VersionBucketbucket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1b/7c81b9e12e35d234493d10fab600ee345f7489.src","preCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":343,"status":"M"},{"authorDate":"2019-04-10 15:02:59","commitOrder":3,"curCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":887,"groupId":"6599","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"doLocalDeleteByQuery","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"N"}],"commitId":"733b071564ac310b537166f15f74dde19f29a488","commitMessage":"@@@SOLR-13320 : add an update param failOnVersionConflicts=false to updates not fail when there is a version conflict\n","date":"2019-05-07 13:20:02","modifiedFileCount":"5","status":"M","submitter":"noble"},{"authorTime":"2019-04-10 15:02:59","codes":[{"authorDate":"2020-04-21 09:08:15","commitOrder":4,"curCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getPrintableId());\n            }\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getPrintableId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                }\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                if (log.isInfoEnabled()) {\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n                }\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: {}, but last version I have is: {}. Dropping current update\"\n                    , prev, lastVersion);\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                }\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","date":"2020-04-21 09:08:15","endLine":514,"groupId":"43106","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"doVersionAdd","params":"(AddUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync@booleanleaderLogic@booleanforwardedFromCollection@VersionBucketbucket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4f/b5107d6c2e919070ec5dd04a6a02ae83bf6c15.src","preCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                    + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                log.info(\n                    \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                    idBytes.utf8ToString(), fetchedFromLeader);\n\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                    + \". Dropping current update.\");\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"M"},{"authorDate":"2019-04-10 15:02:59","commitOrder":4,"curCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":887,"groupId":"6599","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"doLocalDeleteByQuery","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"N"}],"commitId":"c94770c2b9c00ccdc2d617d595d62f85a332dc0c","commitMessage":"@@@LUCENE-7788: fail precommit on unparameterised log messages and examine for wasted work/objects\n","date":"2020-04-21 09:08:15","modifiedFileCount":"38","status":"M","submitter":"Erick Erickson"},{"authorTime":"2019-04-10 15:02:59","codes":[{"authorDate":"2020-04-23 10:32:49","commitOrder":5,"curCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getPrintableId());\n            }\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getPrintableId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document was deleted at the leader subsequently.\"\n                      , idBytes.utf8ToString());\n                }\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                if (log.isInfoEnabled()) {\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n                }\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: {}, but last version I have is: {}. Dropping current update\"\n                    , prev, lastVersion);\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                }\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","date":"2020-04-23 10:32:49","endLine":514,"groupId":"43106","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"doVersionAdd","params":"(AddUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync@booleanleaderLogic@booleanforwardedFromCollection@VersionBucketbucket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/70/366b69781e73a6f4daef6a290ac3b848d7301c.src","preCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getPrintableId());\n            }\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getPrintableId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                }\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                if (log.isInfoEnabled()) {\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n                }\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: {}, but last version I have is: {}. Dropping current update\"\n                    , prev, lastVersion);\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                }\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"M"},{"authorDate":"2019-04-10 15:02:59","commitOrder":5,"curCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":887,"groupId":"6599","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"doLocalDeleteByQuery","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"N"}],"commitId":"e43b17962a116111af4348cf7548ee2e7a2375b8","commitMessage":"@@@LUCENE-7788: fail precommit on unparameterised log messages and examine for wasted work/objects\n","date":"2020-04-23 10:32:49","modifiedFileCount":"102","status":"M","submitter":"Erick Erickson"},{"authorTime":"2019-04-10 15:02:59","codes":[{"authorDate":"2021-01-08 12:23:20","commitOrder":6,"curCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getPrintableId());\n            }\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getPrintableId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document was deleted at the leader subsequently.\"\n                      , idBytes.utf8ToString());\n                }\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                if (log.isInfoEnabled()) {\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n                }\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: {}, but last version I have is: {}. Dropping current update\"\n                    , prev, lastVersion);\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                }\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","date":"2021-01-08 12:23:20","endLine":504,"groupId":"102055","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"doVersionAdd","params":"(AddUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync@booleanleaderLogic@booleanforwardedFromCollection@VersionBucketbucket)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/5b/7800c1e3ccc5c13e377bd60734a7f834359f01.src","preCode":"  private boolean doVersionAdd(AddUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync,\n      boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket) throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      bucket.signalAll();\n      \r\n      \r\n      \r\n\n      \r\n      \r\n      \r\n      \r\n      \r\n\n      if (versionsStored) {\n\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            \r\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getPrintableId());\n            }\n            cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n            versionOnUpdate = 0;\n          }\n\n          getUpdatedDocument(cmd, versionOnUpdate);\n\n          \r\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && isReplayOrPeersync == false) {\n            \r\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getPrintableId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (versionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                || (versionOnUpdate == 1 && foundVersion > 0)) {\n              \r\n              \r\n            } else {\n              if(cmd.getReq().getParams().getBool(CommonParams.FAIL_ON_VERSION_CONFLICTS, true) == false) {\n                return true;\n              }\n\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                  + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(version);\n          cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n          bucket.updateHighest(version);\n        } else {\n          \r\n          cmd.setVersion(versionOnUpdate);\n\n          if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n            \r\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.add(cmd);\n            return true;\n          }\n\n          if (cmd.isInPlaceUpdate()) {\n            long prev = cmd.prevVersion;\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion == null || Math.abs(lastVersion) < prev) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n              if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document was deleted at the leader subsequently.\"\n                      , idBytes.utf8ToString());\n                }\n                versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                return true;\n              } else {\n                assert fetchedFromLeader instanceof AddUpdateCommand;\n                \r\n                \r\n                if (log.isInfoEnabled()) {\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n                }\n                \r\n                \r\n                cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                cmd.prevVersion = -1;\n                cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                assert cmd.isInPlaceUpdate() == false;\n              }\n            } else {\n              if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                \r\n                \r\n                log.info(\"Update was applied on version: {}, but last version I have is: {}. Dropping current update\"\n                    , prev, lastVersion);\n                return true;\n              } else {\n                \r\n                if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                  bucket.updateHighest(versionOnUpdate);\n                }\n              }\n            }\n          } else {\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                }\n                return true;\n              }\n            }\n          }\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n      \r\n      doLocalAdd(cmd);\n\n      \r\n      \r\n      \r\n      if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n        ulog.openRealtimeSearcher();\n      }\n\n      if (clonedDoc != null) {\n        cmd.solrDoc = clonedDoc;\n      }\n    } finally {\n      bucket.unlock();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":342,"status":"M"},{"authorDate":"2019-04-10 15:02:59","commitOrder":6,"curCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":887,"groupId":"102055","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"doLocalDeleteByQuery","params":"(DeleteUpdateCommandcmd@longversionOnUpdate@booleanisReplayOrPeersync)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private void doLocalDeleteByQuery(DeleteUpdateCommand cmd, long versionOnUpdate, boolean isReplayOrPeersync) throws IOException {\n    if (versionsStored) {\n      final boolean leaderLogic = isLeader & !isReplayOrPeersync;\n      if (leaderLogic) {\n        long version = vinfo.getNewClock();\n        cmd.setVersion(-version);\n        \r\n\n        doLocalDelete(cmd);\n\n      } else {\n        cmd.setVersion(-versionOnUpdate);\n\n        if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n          ulog.deleteByQuery(cmd);\n          return;\n        }\n\n        if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n          \r\n          cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n        }\n        doLocalDelete(cmd);\n      }\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":860,"status":"N"}],"commitId":"4cb3ad4a1c40b4326aec64577a7e60018f7f1a5e","commitMessage":"@@@* SOLR-14923: Nested docs indexing perf & robustness (#2159)\n\n* When the schema defines _root_.  and you want to do atomic/partial updates...\n** _root_ needn't be stored or have docValues any more\n** _nest_path_ field isn't needed for this any more\n** Simplified internal logic\n* Allow (and recommend.  eventually insist) that the _root_ field be passed for atomic/partial updates to child docs.\n** In the absence of _root_.  assume the _route_ param is equivalent to ameliorate back-compat scope.  This is a temporary hack; remove in SOLR-15064.\n** One of the two is required; you'll get an exception if the assumption is false.  THIS IS A BACK-COMPAT CHANGE\n* Ensure that the update log contains the _root_ field if it's defined in the schema; in some cases it wasn't.  It's important for robustness of atomic/partial updates to child docs.  Caveat: the buffer replay scenario is not tested with child docs.\n* Limited the cases when a realtime searcher is re-opened.  It was being applied to any update that included child docs but now only some narrow subset: only for atomic/partial updates.  and when the update log contains an in-place update for the same nest because it's complicated to resolve those log entries.\n* Internal improvements to RealTimeGetComponent to aid clarity & robustness & probably performance...\n** Use SolrDocumentFetcher.solrDoc(docID.  ReturnFields) instead of more manual loading.  Will do more with this in another PR.\n** Clarify when only root doc IDs are expected.\n** Use Resolution enum more.  add PARTIAL.  remove DOC_WITH_CHILDREN; enhance docs.\n** When have ReturnFields.  a Set of \"onlyTheseFields\" becomes redundant.  Add a child doc resolution via a transformer when needed.\n** Clarified where copy-field targets are removed\n* NestPathField should default to single valued.  instead of inheriting the schema default.  which for ancient schemas was multi-valued.\n* AddUpdateCommand.getLuceneDocument(s) methods are very internal; made package visible and refactored a bit for clarity\n* DocumentBuilder: when in-place update.  skip id and _root_ here.  thus also simplifying further logic\n* NestedShardedAtomicUpdateTest no longer extends AbstractFullDistribZkTestBase because it wasn't really leveraging the \"control client\" checking.  and it added too much complexity to debug failures.","date":"2021-01-08 12:23:20","modifiedFileCount":"19","status":"M","submitter":"David Smiley"}]
