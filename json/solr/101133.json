[{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2011-03-30 00:37:39","commitOrder":2,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \r\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","date":"2011-03-30 00:37:39","endLine":138,"groupId":"14352","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/db/bbfc08aaa41e9df2841c472b59ef8753b03037.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \r\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","realPath":"solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":87,"status":"NB"},{"authorDate":"2011-07-10 07:01:53","commitOrder":2,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \r\n    analyzer = new CollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","date":"2011-07-10 07:01:53","endLine":144,"groupId":"38290","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/7f/915a4724a7fd79e91f8da00608630040679a50.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \r\n    analyzer = new CollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/CollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"B"}],"commitId":"429093b236e30940d69edc8869346819c337cd10","commitMessage":"@@@SOLR-2452: Rewrote Solr build system (tighter integration with the Lucene build system) and restructured Solr internal and contrib modules\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1144761 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2011-07-10 07:01:53","modifiedFileCount":"0","status":"M","submitter":"Steven Rowe"},{"authorTime":"2011-07-10 07:01:53","codes":[{"authorDate":"2011-11-28 19:03:24","commitOrder":3,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    \r\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","date":"2011-11-28 19:03:24","endLine":184,"groupId":"14352","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9c/da6048d05f1f3b6e0a55f035cf1f44ac8bf1bc.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \r\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","realPath":"solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"},{"authorDate":"2011-07-10 07:01:53","commitOrder":3,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \r\n    analyzer = new CollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","date":"2011-07-10 07:01:53","endLine":144,"groupId":"38290","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/7f/915a4724a7fd79e91f8da00608630040679a50.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \r\n    analyzer = new CollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/CollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":90,"status":"N"}],"commitId":"4dd6b5fbedfcd6420550674f93c31a1339b33576","commitMessage":"@@@SOLR-2919: Localized rangequery support for icu/jdk collation filters.  parametric tailoring for icu collators\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1207070 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2011-11-28 19:03:24","modifiedFileCount":"4","status":"M","submitter":"Robert Muir"},{"authorTime":"2013-12-10 06:53:38","codes":[{"authorDate":"2013-12-10 06:53:38","commitOrder":4,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_CURRENT, collator);\n  }\n","date":"2013-12-10 06:53:38","endLine":191,"groupId":"14352","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c1/b2ce7c09d74540c4c3c3e2c95b6790650de20e.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    \r\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","realPath":"solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"},{"authorDate":"2013-12-10 06:53:38","commitOrder":4,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    analyzer = new CollationKeyAnalyzer(Version.LUCENE_CURRENT, collator);\n  }\n","date":"2013-12-10 06:53:38","endLine":151,"groupId":"38290","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/89/1e673613919f2c4a0c8b608923450794515b7f.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \r\n    analyzer = new CollationKeyAnalyzer(Version.LUCENE_40, collator);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/CollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"}],"commitId":"a1461ad9b12fe4d9a62fc7a4aff2c7361584dedc","commitMessage":"@@@LUCENE-5364: Replace hard-coded Version.LUCENE_XY that doesn't have to be hard-coded (because of back-compat testing or version dependent behavior.  or demo code that should exemplify pinning versions in user code).  with Version.LUCENE_CURRENT in non-test code.  or with LuceneTestCase.TEST_VERSION_CURRENT in test code; upgrade hard-coded Version.LUCENE_XY constants that should track the next release version to the next release version if they aren't already there.  and put a token near them so that they can be found and upgraded when the next release version changes: ':Post-Release-Update-Version.LUCENE_XY:'\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1549701 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-12-10 06:53:38","modifiedFileCount":"28","status":"M","submitter":"Steven Rowe"},{"authorTime":"2014-08-09 06:42:48","codes":[{"authorDate":"2013-12-10 06:53:38","commitOrder":5,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_CURRENT, collator);\n  }\n","date":"2013-12-10 06:53:38","endLine":191,"groupId":"14352","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c1/b2ce7c09d74540c4c3c3e2c95b6790650de20e.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_CURRENT, collator);\n  }\n","realPath":"solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"N"},{"authorDate":"2014-08-09 06:42:48","commitOrder":5,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    analyzer = new CollationKeyAnalyzer(collator);\n  }\n","date":"2014-08-09 06:42:48","endLine":151,"groupId":"38290","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/19/bf9db57ac8f5163ce93a956b1707cc36b6522d.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    analyzer = new CollationKeyAnalyzer(Version.LUCENE_CURRENT, collator);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/CollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"M"}],"commitId":"9938a39a872d4f232f718b2672d0245cae658e0b","commitMessage":"@@@LUCENE-5859: Remove Version from Analyzer constructors\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1616901 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-08-09 06:42:48","modifiedFileCount":"284","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2014-08-09 06:42:48","codes":[{"authorDate":"2014-08-16 03:15:17","commitOrder":6,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    analyzer = new ICUCollationKeyAnalyzer(Version.LATEST, collator);\n  }\n","date":"2014-08-16 03:15:17","endLine":191,"groupId":"14352","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d7/2d38b55fa5256b694bdfcf064a07d18075fd55.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_CURRENT, collator);\n  }\n","realPath":"solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"},{"authorDate":"2014-08-09 06:42:48","commitOrder":6,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    analyzer = new CollationKeyAnalyzer(collator);\n  }\n","date":"2014-08-09 06:42:48","endLine":151,"groupId":"38290","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/19/bf9db57ac8f5163ce93a956b1707cc36b6522d.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    analyzer = new CollationKeyAnalyzer(collator);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/CollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"N"}],"commitId":"73bb9c91d9da485b07b09cdfcb8efe0180282fe8","commitMessage":"@@@LUCENE-5850: Made Version handling more robust and extensible\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1618263 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-08-16 03:15:17","modifiedFileCount":"52","status":"M","submitter":"Ryan Ernst"},{"authorTime":"2014-08-09 06:42:48","codes":[{"authorDate":"2014-11-29 07:05:14","commitOrder":7,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    analyzer = new ICUCollationKeyAnalyzer(collator);\n  }\n","date":"2014-11-29 07:05:14","endLine":191,"groupId":"101133","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/83/be3170881f7e6be1f20282542fec06416f5261.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String localeID = args.remove(\"locale\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    String alternate = args.remove(\"alternate\");\n    String caseLevel = args.remove(\"caseLevel\");\n    String caseFirst = args.remove(\"caseFirst\");\n    String numeric = args.remove(\"numeric\");\n    String variableTop = args.remove(\"variableTop\");\n\n    if (custom == null && localeID == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or locale is required.\");\n    \n    if (custom != null && localeID != null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both locale and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    final Collator collator;\n    \n    if (localeID != null) { \n      \r\n      collator = createFromLocale(localeID);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"quaternary\"))\n        collator.setStrength(Collator.QUATERNARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    \n    \r\n    RuleBasedCollator rbc = (RuleBasedCollator) collator;\n    if (alternate != null) {\n      if (alternate.equalsIgnoreCase(\"shifted\")) {\n        rbc.setAlternateHandlingShifted(true);\n      } else if (alternate.equalsIgnoreCase(\"non-ignorable\")) {\n        rbc.setAlternateHandlingShifted(false);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid alternate: \" + alternate);\n      }\n    }\n    if (caseLevel != null) {\n      rbc.setCaseLevel(Boolean.parseBoolean(caseLevel));\n    }\n    if (caseFirst != null) {\n      if (caseFirst.equalsIgnoreCase(\"lower\")) {\n        rbc.setLowerCaseFirst(true);\n      } else if (caseFirst.equalsIgnoreCase(\"upper\")) {\n        rbc.setUpperCaseFirst(true);\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid caseFirst: \" + caseFirst);\n      }\n    }\n    if (numeric != null) {\n      rbc.setNumericCollation(Boolean.parseBoolean(numeric));\n    }\n    if (variableTop != null) {\n      rbc.setVariableTop(variableTop);\n    }\n\n    analyzer = new ICUCollationKeyAnalyzer(Version.LATEST, collator);\n  }\n","realPath":"solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":104,"status":"M"},{"authorDate":"2014-08-09 06:42:48","commitOrder":7,"curCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    analyzer = new CollationKeyAnalyzer(collator);\n  }\n","date":"2014-08-09 06:42:48","endLine":151,"groupId":"101133","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"setup","params":"(ResourceLoaderloader@Map<String@String>args)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/19/bf9db57ac8f5163ce93a956b1707cc36b6522d.src","preCode":"  private void setup(ResourceLoader loader, Map<String,String> args) {\n    String custom = args.remove(\"custom\");\n    String language = args.remove(\"language\");\n    String country = args.remove(\"country\");\n    String variant = args.remove(\"variant\");\n    String strength = args.remove(\"strength\");\n    String decomposition = args.remove(\"decomposition\");\n    \n    final Collator collator;\n\n    if (custom == null && language == null)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Either custom or language is required.\");\n    \n    if (custom != null && \n        (language != null || country != null || variant != null))\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Cannot specify both language and custom. \"\n          + \"To tailor rules for a built-in language, see the javadocs for RuleBasedCollator. \"\n          + \"Then save the entire customized ruleset to a file, and use with the custom parameter\");\n    \n    if (language != null) { \n      \r\n      collator = createFromLocale(language, country, variant);\n    } else { \n      \r\n      collator = createFromRules(custom, loader);\n    }\n    \n    \r\n    if (strength != null) {\n      if (strength.equalsIgnoreCase(\"primary\"))\n        collator.setStrength(Collator.PRIMARY);\n      else if (strength.equalsIgnoreCase(\"secondary\"))\n        collator.setStrength(Collator.SECONDARY);\n      else if (strength.equalsIgnoreCase(\"tertiary\"))\n        collator.setStrength(Collator.TERTIARY);\n      else if (strength.equalsIgnoreCase(\"identical\"))\n        collator.setStrength(Collator.IDENTICAL);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid strength: \" + strength);\n    }\n    \n    \r\n    if (decomposition != null) {\n      if (decomposition.equalsIgnoreCase(\"no\"))\n        collator.setDecomposition(Collator.NO_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"canonical\"))\n        collator.setDecomposition(Collator.CANONICAL_DECOMPOSITION);\n      else if (decomposition.equalsIgnoreCase(\"full\"))\n        collator.setDecomposition(Collator.FULL_DECOMPOSITION);\n      else\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Invalid decomposition: \" + decomposition);\n    }\n    analyzer = new CollationKeyAnalyzer(collator);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/CollationField.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":98,"status":"N"}],"commitId":"46e8f846c5a5304e8d1c6ab56d24ac548a68231f","commitMessage":"@@@LUCENE-6080: remove some deprecations from trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1642374 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-11-29 07:05:14","modifiedFileCount":"20","status":"M","submitter":"Robert Muir"}]
