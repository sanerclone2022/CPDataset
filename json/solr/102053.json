[{"authorTime":"2012-01-26 03:49:26","codes":[{"authorDate":"2012-01-26 03:49:26","commitOrder":1,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2012-01-26 03:49:26","endLine":416,"groupId":"37095","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/fd/ea6d20db5f3f1e82cd6bf652d6fe9befcdafd4.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":326,"status":"B"},{"authorDate":"2012-01-26 03:49:26","commitOrder":1,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2012-01-26 03:49:26","endLine":571,"groupId":"37102","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/fd/ea6d20db5f3f1e82cd6bf652d6fe9befcdafd4.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":494,"status":"B"}],"commitId":"9fed484fb108e53cd6026133f660b3fd270e2025","commitMessage":"@@@SOLR-2358: merge in solrcloud branch (watch out hudson!)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1235888 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-01-26 03:49:26","modifiedFileCount":"88","status":"B","submitter":"Mark Robert Miller"},{"authorTime":"2012-05-09 01:00:33","codes":[{"authorDate":"2012-05-09 01:00:33","commitOrder":2,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  \r\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2012-05-09 01:00:33","endLine":481,"groupId":"37095","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/62/2776597a19de83aab019b7d83cf5d38d1554fa.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":373,"status":"M"},{"authorDate":"2012-05-09 01:00:33","commitOrder":2,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2012-05-09 01:00:33","endLine":849,"groupId":"354","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/62/2776597a19de83aab019b7d83cf5d38d1554fa.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"M"}],"commitId":"e35df0b58f397ce53d73841edc919f5a4e44f009","commitMessage":"@@@SOLR-139 SOLR-3178 : Updateable documents.  optimistic locking\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1335642 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-05-09 01:00:33","modifiedFileCount":"13","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2012-05-09 01:00:33","codes":[{"authorDate":"2012-07-03 23:05:30","commitOrder":3,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  \r\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2012-07-03 23:05:30","endLine":515,"groupId":"37095","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b4/0b3211ffd41ff44bb4aeff2b97b75987f85be3.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  \r\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":399,"status":"M"},{"authorDate":"2012-05-09 01:00:33","commitOrder":3,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2012-05-09 01:00:33","endLine":849,"groupId":"354","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/62/2776597a19de83aab019b7d83cf5d38d1554fa.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"N"}],"commitId":"0f808c6bcdfcb11ce1398fe3c79c9b28c851aa1c","commitMessage":"@@@SOLR-3559: DBQ reorder support\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1356778 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-07-03 23:05:30","modifiedFileCount":"8","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2012-05-09 01:00:33","codes":[{"authorDate":"2012-07-14 01:10:36","commitOrder":4,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2012-07-14 01:10:36","endLine":512,"groupId":"8482","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/42/6d580ca05ce4a939fec3c0caa671b6bccc674f.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  \r\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":399,"status":"M"},{"authorDate":"2012-05-09 01:00:33","commitOrder":4,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2012-05-09 01:00:33","endLine":849,"groupId":"354","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/62/2776597a19de83aab019b7d83cf5d38d1554fa.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"N"}],"commitId":"732ad20130da9d04c7537b0533e98f4a62cf970e","commitMessage":"@@@SOLR-139: update doc - create if it doesn't exist by default\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1361301 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-07-14 01:10:36","modifiedFileCount":"2","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2012-05-09 01:00:33","codes":[{"authorDate":"2012-07-19 00:52:42","commitOrder":5,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd, SolrInputDocument cloneDoc) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            cloneDoc.setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2012-07-19 00:52:42","endLine":517,"groupId":"348","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd@SolrInputDocumentcloneDoc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f7/323c9f5ff729282060405fd7f58eea64f39a27.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":403,"status":"M"},{"authorDate":"2012-05-09 01:00:33","commitOrder":5,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2012-05-09 01:00:33","endLine":849,"groupId":"354","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/62/2776597a19de83aab019b7d83cf5d38d1554fa.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"N"}],"commitId":"83e07fec099c12e31f0fe7abe8b77cd3839085dd","commitMessage":"@@@SOLR-3215: Clone SolrInputDocument when distrib indexing so that update processors after the distrib update process do not process the document twice.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1363013 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-07-19 00:52:42","modifiedFileCount":"3","status":"M","submitter":"Mark Robert Miller"},{"authorTime":"2012-05-09 01:00:33","codes":[{"authorDate":"2012-09-16 01:39:28","commitOrder":6,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2012-09-16 01:39:28","endLine":568,"groupId":"8482","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/33/eaa0f3141816465e6092a0ab07641fe8a8b481.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd, SolrInputDocument cloneDoc) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            cloneDoc.setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":444,"status":"M"},{"authorDate":"2012-05-09 01:00:33","commitOrder":6,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2012-05-09 01:00:33","endLine":849,"groupId":"354","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/62/2776597a19de83aab019b7d83cf5d38d1554fa.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"N"}],"commitId":"eb275c2b436a72bf8f13b8f5946e79ef886363f4","commitMessage":"@@@SOLR-3831: Atomic updates do not distribute correctly to other nodes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1385136 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-09-16 01:39:28","modifiedFileCount":"6","status":"M","submitter":"Mark Robert Miller"},{"authorTime":"2012-05-09 01:00:33","codes":[{"authorDate":"2012-12-12 01:25:02","commitOrder":7,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2012-12-12 01:25:02","endLine":592,"groupId":"8482","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/44/cfbbfefcadc3b2dcaf7a07272b9336778996cf.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":457,"status":"M"},{"authorDate":"2012-05-09 01:00:33","commitOrder":7,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2012-05-09 01:00:33","endLine":849,"groupId":"354","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/62/2776597a19de83aab019b7d83cf5d38d1554fa.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":759,"status":"N"}],"commitId":"0b3a7900fc251ce3d1911adf3de6d40a1c41690b","commitMessage":"@@@SOLR-4127: Added explicit error message if users attempt Atomic document updates with either updateLog or DistribUpdateProcessor\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1420297 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-12-12 01:25:02","modifiedFileCount":"2","status":"M","submitter":"Chris M. Hostetter"},{"authorTime":"2013-01-04 08:01:16","codes":[{"authorDate":"2013-01-04 08:01:16","commitOrder":8,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2013-01-04 08:01:16","endLine":602,"groupId":"50291","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4b/9461f7d523c94be6edeb648c3f63a34ff35b4b.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":467,"status":"M"},{"authorDate":"2013-01-04 08:01:16","commitOrder":8,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2013-01-04 08:01:16","endLine":1043,"groupId":"16816","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4b/9461f7d523c94be6edeb648c3f63a34ff35b4b.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":953,"status":"M"}],"commitId":"c7d885205182263ff9918ee7401f5168488887df","commitMessage":"@@@SOLR-4257: PeerSync updates and Log Replay updates should not wait for ZK connection\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1428677 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-01-04 08:01:16","modifiedFileCount":"2","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2013-05-30 00:40:28","codes":[{"authorDate":"2013-05-30 00:40:28","commitOrder":9,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2013-05-30 00:40:28","endLine":656,"groupId":"25824","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bc/cc97eb134087f1d56437f3aabb2c0d7fcce7ea.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":521,"status":"M"},{"authorDate":"2013-05-30 00:40:28","commitOrder":9,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2013-05-30 00:40:28","endLine":1098,"groupId":"16816","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bc/cc97eb134087f1d56437f3aabb2c0d7fcce7ea.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1008,"status":"M"}],"commitId":"f9a5dc2c88f1282b7820dfc8b3b7fc16b047d3a8","commitMessage":"@@@SOLR-4855: DistributedUpdateProcessor doesn't check for peer sync requests\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1487538 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-05-30 00:40:28","modifiedFileCount":"1","status":"M","submitter":"Shalin Shekhar Mangar"},{"authorTime":"2013-11-14 13:58:22","codes":[{"authorDate":"2013-11-14 13:58:22","commitOrder":10,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2013-11-14 13:58:22","endLine":858,"groupId":"25824","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/34/5b3fd827b8c7776e15df993eecc8100fc62743.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":705,"status":"M"},{"authorDate":"2013-11-14 13:58:22","commitOrder":10,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2013-11-14 13:58:22","endLine":1418,"groupId":"12958","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/34/5b3fd827b8c7776e15df993eecc8100fc62743.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1310,"status":"M"}],"commitId":"5d2d0e70f37d7bd83477046065b3e40dcb883e43","commitMessage":"@@@SOLR-5308: A new 'migrate' collection API to split all documents with a route key into another collection\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1541832 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-11-14 13:58:22","modifiedFileCount":"10","status":"M","submitter":"Shalin Shekhar Mangar"},{"authorTime":"2013-11-18 22:31:18","codes":[{"authorDate":"2013-11-18 22:31:18","commitOrder":11,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2013-11-18 22:31:18","endLine":844,"groupId":"57737","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/61/20337e1cf1097d8c2249a61479834d3ac587e7.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":691,"status":"M"},{"authorDate":"2013-11-18 22:31:18","commitOrder":11,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2013-11-18 22:31:18","endLine":1404,"groupId":"12958","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/61/20337e1cf1097d8c2249a61479834d3ac587e7.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1296,"status":"M"}],"commitId":"4f1a857977a50f09ad7bd8a08b9f77d5e048e011","commitMessage":"@@@SOLR-5452: Do not attempt to proxy internal update requests.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1543037 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-11-18 22:31:18","modifiedFileCount":"2","status":"M","submitter":"Mark Robert Miller"},{"authorTime":"2013-11-18 22:31:18","codes":[{"authorDate":"2015-01-18 04:04:27","commitOrder":12,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2015-01-18 04:04:27","endLine":1100,"groupId":"57737","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/5b/156613c1ac7e76365a027261a55dcb1f68e986.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":947,"status":"M"},{"authorDate":"2013-11-18 22:31:18","commitOrder":12,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2013-11-18 22:31:18","endLine":1404,"groupId":"12958","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/61/20337e1cf1097d8c2249a61479834d3ac587e7.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1296,"status":"N"}],"commitId":"5fa8807541fa86a2885ff78824186fc5740db7ff","commitMessage":"@@@SOLR-6909: Extract atomic update handling logic into AtomicUpdateDocumentMerger\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1652660 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-01-18 04:04:27","modifiedFileCount":"3","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2015-03-24 11:19:37","codes":[{"authorDate":"2015-03-24 11:19:37","commitOrder":13,"curCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2015-03-24 11:19:37","endLine":1113,"groupId":"57737","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b4/7c4ace6551ebebbe91edfc82f5feed20314898.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":959,"status":"M"},{"authorDate":"2015-03-24 11:19:37","commitOrder":13,"curCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2015-03-24 11:19:37","endLine":1586,"groupId":"12958","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b4/7c4ace6551ebebbe91edfc82f5feed20314898.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1477,"status":"M"}],"commitId":"57b47fed018c1e77cabd3d31a0fc7965a3badf16","commitMessage":"@@@SOLR-7134: Replication can still cause index corruption.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1668779 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-03-24 11:19:37","modifiedFileCount":"15","status":"M","submitter":"Mark Robert Miller"},{"authorTime":"2015-05-23 02:58:29","codes":[{"authorDate":"2015-05-23 02:58:29","commitOrder":14,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2015-05-23 02:58:29","endLine":1121,"groupId":"57737","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b4/08a5f67186344f321a830c5aacb4cf319593e5.src","preCode":"  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":967,"status":"M"},{"authorDate":"2015-05-23 02:58:29","commitOrder":14,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2015-05-23 02:58:29","endLine":1601,"groupId":"12958","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b4/08a5f67186344f321a830c5aacb4cf319593e5.src","preCode":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1492,"status":"M"}],"commitId":"375899fdbd3512fc33c5c872c88c244cdf3f7541","commitMessage":"@@@SOLR-6273: Cross Data Center Replication\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1681186 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-05-23 02:58:29","modifiedFileCount":"9","status":"M","submitter":"Erick Erickson"},{"authorTime":"2016-08-26 06:10:16","codes":[{"authorDate":"2016-08-26 06:10:16","commitOrder":15,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2016-08-26 06:10:16","endLine":1105,"groupId":"57737","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f1/9352dc63b9f18c78653d5b0d46693c39c2ed14.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":951,"status":"M"},{"authorDate":"2016-08-26 06:10:16","commitOrder":15,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2016-08-26 06:10:16","endLine":1602,"groupId":"6599","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f1/9352dc63b9f18c78653d5b0d46693c39c2ed14.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1493,"status":"M"}],"commitId":"8683da80ed2befd4abe0a7028ae95aefd4b3eb21","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2016-08-26 06:10:16","modifiedFileCount":"51","status":"M","submitter":"Karl Wright"},{"authorTime":"2016-08-26 06:10:16","codes":[{"authorDate":"2016-10-03 03:18:22","commitOrder":16,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2016-10-03 03:18:22","endLine":1123,"groupId":"57737","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b8/bdd16cfb4da2de0c00f3a3539b71478c7b6686.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":969,"status":"M"},{"authorDate":"2016-08-26 06:10:16","commitOrder":16,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2016-08-26 06:10:16","endLine":1602,"groupId":"6599","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f1/9352dc63b9f18c78653d5b0d46693c39c2ed14.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1493,"status":"N"}],"commitId":"3182cd9872af3cb73a1f73e36de68b8d76646e59","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2016-10-03 03:18:22","modifiedFileCount":"570","status":"M","submitter":"Karl Wright"},{"authorTime":"2016-08-26 06:10:16","codes":[{"authorDate":"2017-01-26 09:23:13","commitOrder":17,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1; \r\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), (fetchedFromLeader == null? null: ((AddUpdateCommand)fetchedFromLeader).solrDoc));\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2017-01-26 09:23:13","endLine":1195,"groupId":"15693","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/8f/5d90993d154923ec3275e099e6f57e8c226ebe.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              \r\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":983,"status":"M"},{"authorDate":"2016-08-26 06:10:16","commitOrder":17,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2016-08-26 06:10:16","endLine":1602,"groupId":"6599","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f1/9352dc63b9f18c78653d5b0d46693c39c2ed14.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1493,"status":"N"}],"commitId":"5375410807aecf3cc67f82ca1e9ee591f39d0ac7","commitMessage":"@@@SOLR-5944: In-place updates of Numeric DocValues\n","date":"2017-01-26 09:23:13","modifiedFileCount":"22","status":"M","submitter":"Ishan Chattopadhyaya"},{"authorTime":"2016-08-26 06:10:16","codes":[{"authorDate":"2017-02-19 11:51:35","commitOrder":18,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2017-02-19 11:51:35","endLine":1204,"groupId":"15693","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c6/ccb710a340689823a0e412da5746f77f18eb02.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1; \r\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), (fetchedFromLeader == null? null: ((AddUpdateCommand)fetchedFromLeader).solrDoc));\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":992,"status":"M"},{"authorDate":"2016-08-26 06:10:16","commitOrder":18,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2016-08-26 06:10:16","endLine":1602,"groupId":"6599","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f1/9352dc63b9f18c78653d5b0d46693c39c2ed14.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1493,"status":"N"}],"commitId":"6358afbea66239436a6c0c52e088eeecebac1f65","commitMessage":"@@@SOLR-5944: Cleanup comments and logging.  use NoMergePolicy instead of LogDocMergePolicy\n","date":"2017-02-19 11:51:35","modifiedFileCount":"4","status":"M","submitter":"Ishan Chattopadhyaya"},{"authorTime":"2017-03-14 15:37:47","codes":[{"authorDate":"2017-03-14 15:37:47","commitOrder":19,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2017-03-14 15:37:47","endLine":1219,"groupId":"15693","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/08/ede7242694d51e4db905f68a16ffacf3e5ca1c.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1004,"status":"M"},{"authorDate":"2017-03-14 15:37:47","commitOrder":19,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2017-03-14 15:37:47","endLine":1874,"groupId":"6599","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/08/ede7242694d51e4db905f68a16ffacf3e5ca1c.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1761,"status":"M"}],"commitId":"7830462d4b7da3acefff6353419e71cde62d5fee","commitMessage":"@@@SOLR-9835: Create another replication mode for SolrCloud\n","date":"2017-03-14 15:37:47","modifiedFileCount":"35","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2017-03-23 09:15:50","codes":[{"authorDate":"2017-03-23 09:15:50","commitOrder":20,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2017-03-23 09:15:50","endLine":1218,"groupId":"45600","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/fe/71b0b805fddffe4a35f4ba6ada300a586643d3.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1003,"status":"M"},{"authorDate":"2017-03-23 09:15:50","commitOrder":20,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2017-03-23 09:15:50","endLine":1873,"groupId":"6599","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/fe/71b0b805fddffe4a35f4ba6ada300a586643d3.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1760,"status":"M"}],"commitId":"eb587772ddecaea371b20feb955a197e80699f22","commitMessage":"@@@SOLR-6615: use constants for 'id'.  '_route_'.  '_version_'\n","date":"2017-03-23 09:15:50","modifiedFileCount":"48","status":"M","submitter":"Noble Paul"},{"authorTime":"2017-05-23 10:44:01","codes":[{"authorDate":"2017-05-23 10:44:01","commitOrder":21,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2017-05-23 10:58:51","endLine":1217,"groupId":"45600","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/52/69ecb71444b71292f014f74c807f54e4e1b1a7.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1002,"status":"M"},{"authorDate":"2017-05-23 10:44:01","commitOrder":21,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2017-05-23 10:58:51","endLine":1873,"groupId":"6599","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/52/69ecb71444b71292f014f74c807f54e4e1b1a7.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1760,"status":"M"}],"commitId":"2fc41d565a4a0408a09856a37d3be7d87414ba3f","commitMessage":"@@@SOLR-10233: Add support for replica types\n","date":"2017-05-23 10:58:51","modifiedFileCount":"69","status":"M","submitter":"Tomas Fernandez Lobbe"},{"authorTime":"2017-05-23 10:44:01","codes":[{"authorDate":"2017-11-01 07:21:58","commitOrder":22,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2017-11-01 07:21:58","endLine":1128,"groupId":"45600","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/5f/4fcdd5a2a2793447bd844348f801aa1c46911c.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                \r\n                checkDeleteByQueries = true;\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":918,"status":"M"},{"authorDate":"2017-05-23 10:44:01","commitOrder":22,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2017-05-23 10:58:51","endLine":1873,"groupId":"6599","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/52/69ecb71444b71292f014f74c807f54e4e1b1a7.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1760,"status":"N"}],"commitId":"148d81c1e9578221e61cbc2acbf2a7a2082d9fc0","commitMessage":"@@@SOLR-11438: Solr should return rf when min_rf is specified for deletes as well as adds\n","date":"2017-11-01 07:21:58","modifiedFileCount":"3","status":"M","submitter":"Erick Erickson"},{"authorTime":"2018-05-30 12:05:48","codes":[{"authorDate":"2018-05-30 12:05:48","commitOrder":23,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2018-05-30 12:05:48","endLine":1179,"groupId":"45600","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/8f/87510e9d196867d27c2d7355caa8d70f8a61bb.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":969,"status":"M"},{"authorDate":"2018-05-30 12:05:48","commitOrder":23,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2018-05-30 12:05:48","endLine":1856,"groupId":"6599","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/8f/87510e9d196867d27c2d7355caa8d70f8a61bb.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1743,"status":"M"}],"commitId":"6084da559c5466551af68c114b7310356c989dec","commitMessage":"@@@SOLR-12338: Replay buffering tlog in parallel\n","date":"2018-05-30 12:05:48","modifiedFileCount":"8","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2018-05-30 12:05:48","codes":[{"authorDate":"2018-07-23 10:33:28","commitOrder":24,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2018-07-23 10:33:28","endLine":1178,"groupId":"45600","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/8d/715a6731a07b32f30ca0180bec7d88b8e5b82f.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":970,"status":"M"},{"authorDate":"2018-05-30 12:05:48","commitOrder":24,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2018-05-30 12:05:48","endLine":1856,"groupId":"6599","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/8f/87510e9d196867d27c2d7355caa8d70f8a61bb.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1743,"status":"N"}],"commitId":"8c06dec16dd711c097f4f8eaa7d9df041e0cb563","commitMessage":"@@@SOLR-12305: When a replica is applying updates.  some kind of updates can skip buffering for faster recovery\n","date":"2018-07-23 10:33:28","modifiedFileCount":"1","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2018-08-02 10:54:32","codes":[{"authorDate":"2018-08-02 10:54:32","commitOrder":25,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","date":"2018-08-02 10:54:32","endLine":1178,"groupId":"45600","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a2/1d906776c2b4e1e07807002cfad6a6dd59fb0c.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":970,"status":"M"},{"authorDate":"2018-08-02 10:54:32","commitOrder":25,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2018-08-02 10:54:32","endLine":1867,"groupId":"6599","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a2/1d906776c2b4e1e07807002cfad6a6dd59fb0c.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1754,"status":"M"}],"commitId":"259bc2baf7ce58aa0143fa6a8d43da417506cd63","commitMessage":"@@@SOLR-12607: Fixed two separate bugs in shard splits which can cause data loss. The first case is when using TLOG replicas only.  the updates forwarded from parent shard leader to the sub-shard leader are written only in tlog and not the index. If this happens after the buffered updates have been replayed then the updates can never be executed even though they remain the transaction log. The second case is when synchronously forwarding updates to sub-shard leader fails and the underlying errors are not propagated to the client\n","date":"2018-08-02 10:54:32","modifiedFileCount":"5","status":"M","submitter":"Shalin Shekhar Mangar"},{"authorTime":"2018-12-05 00:01:24","codes":[{"authorDate":"2018-12-05 00:01:24","commitOrder":26,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n\n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2018-12-06 22:36:56","endLine":1222,"groupId":"41183","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6f/8564629ab1d176cf98ca68584ccb4eacf1ceaf.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  \r\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1003,"status":"M"},{"authorDate":"2018-12-05 00:01:24","commitOrder":26,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2018-12-06 22:36:56","endLine":1916,"groupId":"6599","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6f/8564629ab1d176cf98ca68584ccb4eacf1ceaf.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  \r\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1798,"status":"M"}],"commitId":"b9a966e5f75b77944f61e88a30c002dbc22c504e","commitMessage":"@@@SOLR-12833: Add configurable timeout to VersionBucket lock.\n","date":"2018-12-06 22:36:56","modifiedFileCount":"3","status":"M","submitter":"markrmiller"},{"authorTime":"2018-12-05 00:01:24","codes":[{"authorDate":"2019-01-26 10:17:32","commitOrder":27,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n\n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2019-02-07 03:31:55","endLine":1228,"groupId":"43106","id":53,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c8/ddeb95bb1a29921fba5547637f7ac6d8d20895.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n\n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1009,"status":"M"},{"authorDate":"2018-12-05 00:01:24","commitOrder":27,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2018-12-06 22:36:56","endLine":1916,"groupId":"6599","id":54,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6f/8564629ab1d176cf98ca68584ccb4eacf1ceaf.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1798,"status":"N"}],"commitId":"0add3bb0ac6d7c3a2bd1ad8dde57f8b24f8bb121","commitMessage":"@@@Removed some unused variables from DistributedUpdateProcessor\n","date":"2019-02-07 03:31:55","modifiedFileCount":"1","status":"M","submitter":"Tomas Fernandez Lobbe"},{"authorTime":"2018-12-05 00:01:24","codes":[{"authorDate":"2019-03-20 01:26:31","commitOrder":28,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        \r\n        doLocalAdd(cmd);\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2019-03-20 01:26:31","endLine":487,"groupId":"43106","id":55,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/50/660cba684800142c6ab37d93133e7da42843cc.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n\n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        \r\n        doLocalAdd(cmd);\n\n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":273,"status":"M"},{"authorDate":"2018-12-05 00:01:24","commitOrder":28,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2018-12-06 22:36:56","endLine":1916,"groupId":"6599","id":56,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6f/8564629ab1d176cf98ca68584ccb4eacf1ceaf.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1798,"status":"N"}],"commitId":"5b7866b0851eff66cb7e929beef5249e3c72ac36","commitMessage":"@@@SOLR-12955: Refactored DistributedUpdateProcessor to put SolrCloud specifics into a subclass\nCloses #528\n","date":"2019-03-20 01:26:31","modifiedFileCount":"8","status":"M","submitter":"Bar Rotstein"},{"authorTime":"2018-12-05 00:01:24","codes":[{"authorDate":"2019-04-10 15:02:59","commitOrder":29,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        \r\n        doLocalAdd(cmd);\n\n        \r\n        \r\n        \r\n        if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n          ulog.openRealtimeSearcher();\n        }\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":494,"groupId":"43106","id":57,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        \r\n        doLocalAdd(cmd);\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"M"},{"authorDate":"2018-12-05 00:01:24","commitOrder":29,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2018-12-06 22:36:56","endLine":1916,"groupId":"6599","id":58,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6f/8564629ab1d176cf98ca68584ccb4eacf1ceaf.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1798,"status":"N"}],"commitId":"8527ec11af8099f86953ffad1182ad43c752f95b","commitMessage":"@@@SOLR-12638: Partial/Atomic updates of nested docs.\nand [child] now works in RTG.\n","date":"2019-04-10 15:02:59","modifiedFileCount":"11","status":"M","submitter":"Moshe"},{"authorTime":"2019-05-01 04:31:06","codes":[{"authorDate":"2019-05-01 04:31:06","commitOrder":30,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      long finalVersionOnUpdate = versionOnUpdate;\n      return bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doVersionAdd(cmd, finalVersionOnUpdate, isReplayOrPeersync, leaderLogic, forwardedFromCollection, bucket));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2019-05-01 04:31:44","endLine":341,"groupId":"102053","id":59,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ed/48c758f47592c9980d29aab7abd4b35f61d414.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        \r\n        doLocalAdd(cmd);\n\n        \r\n        \r\n        \r\n        if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n          ulog.openRealtimeSearcher();\n        }\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":276,"status":"M"},{"authorDate":"2019-05-01 04:31:06","commitOrder":30,"curCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      long finalVersionOnUpdate = versionOnUpdate;\n      return bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doVersionDelete(cmd, finalVersionOnUpdate, signedVersionOnUpdate, isReplayOrPeersync, leaderLogic,\n          forwardedFromCollection, bucket));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2019-05-01 04:31:44","endLine":959,"groupId":"102053","id":60,"instanceNumber":2,"isCurCommit":0,"methodName":"versionDelete","params":"(DeleteUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ed/48c758f47592c9980d29aab7abd4b35f61d414.src","preCode":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); \r\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            \r\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              \r\n              \r\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              \r\n              \r\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                \r\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":916,"status":"M"}],"commitId":"70e090717d21a9713c45b8a52e35df940a4277df","commitMessage":"@@@SOLR-12833: Avoid unnecessary memory cost when DistributedUpdateProcessor timed-out lock is not used.\n","date":"2019-05-01 04:31:44","modifiedFileCount":"4","status":"M","submitter":"Andrzej Bialecki"}]
