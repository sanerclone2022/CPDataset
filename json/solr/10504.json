[{"authorTime":"2019-03-04 17:41:45","codes":[{"authorDate":"2018-04-12 18:39:56","commitOrder":2,"curCode":"  private void queryWithPreferReplicaTypes(CloudSolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<String, String>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n  }\n","date":"2018-04-12 18:39:56","endLine":960,"groupId":"39722","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"queryWithPreferReplicaTypes","params":"(CloudSolrClientcloudClient@StringpreferReplicaTypes@booleanpreferLocalShards@StringcollectionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bc/4bd8ca68da8bbb4162960626ed3acbe7b32770.src","preCode":"  private void queryWithPreferReplicaTypes(CloudSolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<String, String>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n  }\n","realPath":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":892,"status":"NB"},{"authorDate":"2019-03-04 17:41:45","commitOrder":2,"curCode":"  private void queryWithPreferReplicaTypes(CloudHttp2SolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n  }\n","date":"2019-03-04 17:41:45","endLine":976,"groupId":"35883","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"queryWithPreferReplicaTypes","params":"(CloudHttp2SolrClientcloudClient@StringpreferReplicaTypes@booleanpreferLocalShards@StringcollectionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/de/8c311c361e11acc2dea2be8a49e95e17467bdd.src","preCode":"  private void queryWithPreferReplicaTypes(CloudHttp2SolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n  }\n","realPath":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":908,"status":"B"}],"commitId":"e99934b240cbb197331edc5e1889203e60b3d5d9","commitMessage":"@@@SOLR-13276: Adding Http2 equivalent classes of CloudSolrClient and HttpClusterStateProvider\n","date":"2019-03-04 17:41:45","modifiedFileCount":"7","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2020-04-28 08:45:57","codes":[{"authorDate":"2020-04-28 08:45:57","commitOrder":3,"curCode":"  private void queryWithPreferReplicaTypes(CloudSolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<String, String>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray())); \r\n    }\n  }\n","date":"2020-04-28 08:45:57","endLine":1040,"groupId":"39722","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"queryWithPreferReplicaTypes","params":"(CloudSolrClientcloudClient@StringpreferReplicaTypes@booleanpreferLocalShards@StringcollectionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e0/2f501762afe1a4ef52a5ddd99c8fe34bad8a58.src","preCode":"  private void queryWithPreferReplicaTypes(CloudSolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<String, String>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n  }\n","realPath":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":970,"status":"M"},{"authorDate":"2020-04-28 08:45:57","commitOrder":3,"curCode":"  private void queryWithPreferReplicaTypes(CloudHttp2SolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray())); \r\n    }\n  }\n","date":"2020-04-28 08:45:57","endLine":1068,"groupId":"35883","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"queryWithPreferReplicaTypes","params":"(CloudHttp2SolrClientcloudClient@StringpreferReplicaTypes@booleanpreferLocalShards@StringcollectionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c4/08b2eefa61290f0791255a109d1854bc4eb3fa.src","preCode":"  private void queryWithPreferReplicaTypes(CloudHttp2SolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    log.info(\"Shards giving the response: \" + Arrays.toString(shardAddresses.toArray()));\n  }\n","realPath":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":998,"status":"M"}],"commitId":"960610a615a2893062b1df3ab1595d8fef6bcdb4","commitMessage":"@@@LUCENE-7788: fail precommit on unparameterised log messages and examine for wasted work/objects\n","date":"2020-04-28 08:45:57","modifiedFileCount":"39","status":"M","submitter":"Erick Erickson"},{"authorTime":"2020-06-17 01:27:53","codes":[{"authorDate":"2020-06-17 01:27:53","commitOrder":4,"curCode":"  private void queryWithPreferReplicaTypes(CloudSolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<String, String>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    @SuppressWarnings({\"unchecked\"})\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray()));\n    }\n  }\n","date":"2020-06-17 01:27:53","endLine":1046,"groupId":"32506","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"queryWithPreferReplicaTypes","params":"(CloudSolrClientcloudClient@StringpreferReplicaTypes@booleanpreferLocalShards@StringcollectionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/fb/363589300707a5ba887ca8307c8502d1a624b8.src","preCode":"  private void queryWithPreferReplicaTypes(CloudSolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<String, String>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray()));\n    }\n  }\n","realPath":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":975,"status":"M"},{"authorDate":"2020-06-17 01:27:53","commitOrder":4,"curCode":"  private void queryWithPreferReplicaTypes(CloudHttp2SolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    @SuppressWarnings({\"unchecked\"})\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray()));\n    }\n  }\n","date":"2020-06-17 01:27:53","endLine":1078,"groupId":"32506","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"queryWithPreferReplicaTypes","params":"(CloudHttp2SolrClientcloudClient@StringpreferReplicaTypes@booleanpreferLocalShards@StringcollectionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/df/76cb83739b589a06e3faeacfdcbb4a3b836016.src","preCode":"  private void queryWithPreferReplicaTypes(CloudHttp2SolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray()));\n    }\n  }\n","realPath":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1007,"status":"M"}],"commitId":"6357b3bdaaa0e2c2b1acfe838e55db3a83e38e73","commitMessage":"@@@SOLR-14573: Fix or suppress warnings in solrj/src/test\n","date":"2020-06-17 01:27:53","modifiedFileCount":"65","status":"M","submitter":"Erick Erickson"},{"authorTime":"2020-11-20 01:57:47","codes":[{"authorDate":"2020-11-20 01:57:47","commitOrder":5,"curCode":"  private void queryWithPreferReplicaTypes(CloudSolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<String, String>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    @SuppressWarnings({\"unchecked\"})\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray()));\n    }\n  }\n","date":"2020-11-20 01:57:47","endLine":1021,"groupId":"10504","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"queryWithPreferReplicaTypes","params":"(CloudSolrClientcloudClient@StringpreferReplicaTypes@StringcollectionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/81/80358e3865d292d6acbecea7380da445f2b636.src","preCode":"  private void queryWithPreferReplicaTypes(CloudSolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<String, String>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    @SuppressWarnings({\"unchecked\"})\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray()));\n    }\n  }\n","realPath":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":958,"status":"M"},{"authorDate":"2020-11-20 01:57:47","commitOrder":5,"curCode":"  private void queryWithPreferReplicaTypes(CloudHttp2SolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    @SuppressWarnings({\"unchecked\"})\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray()));\n    }\n  }\n","date":"2020-11-20 01:57:47","endLine":1054,"groupId":"10504","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"queryWithPreferReplicaTypes","params":"(CloudHttp2SolrClientcloudClient@StringpreferReplicaTypes@StringcollectionName)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/81/85e46c99b3801265c876c72fcfb178e31d889b.src","preCode":"  private void queryWithPreferReplicaTypes(CloudHttp2SolrClient cloudClient,\n                                           String preferReplicaTypes,\n                                           boolean preferLocalShards,\n                                           String collectionName)\n      throws Exception\n  {\n    SolrQuery qRequest = new SolrQuery(\"*:*\");\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n\n    final List<String> preferredTypes = Arrays.asList(preferReplicaTypes.split(\"\\\\|\"));\n    StringBuilder rule = new StringBuilder();\n    preferredTypes.forEach(type -> {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_TYPE);\n      rule.append(':');\n      rule.append(type);\n    });\n    if (preferLocalShards) {\n      if (rule.length() != 0) {\n        rule.append(',');\n      }\n      rule.append(ShardParams.SHARDS_PREFERENCE_REPLICA_LOCATION);\n      rule.append(\":local\");\n    }\n    qParams.add(ShardParams.SHARDS_PREFERENCE, rule.toString());  \n    qParams.add(ShardParams.SHARDS_INFO, \"true\");\n    qRequest.add(qParams);\n\n    \r\n    \r\n    \r\n    \r\n    QueryResponse qResponse = cloudClient.query(collectionName, qRequest);\n\n    Object shardsInfo = qResponse.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"Unable to obtain \"+ShardParams.SHARDS_INFO, shardsInfo);\n\n    Map<String, String> replicaTypeMap = new HashMap<>();\n    DocCollection collection = getCollectionState(collectionName);\n    for (Slice slice : collection.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String coreUrl = replica.getCoreUrl();\n        \r\n        \r\n        if (coreUrl.endsWith(\"/\")) {\n          coreUrl = coreUrl.substring(0, coreUrl.length() - 1);\n        }\n        replicaTypeMap.put(coreUrl, replica.getType().toString());\n      }\n    }\n\n    \r\n    SimpleOrderedMap<?> shardsInfoMap = (SimpleOrderedMap<?>)shardsInfo;\n    @SuppressWarnings({\"unchecked\"})\n    Iterator<Map.Entry<String, ?>> itr = shardsInfoMap.asMap(100).entrySet().iterator();\n    List<String> shardAddresses = new ArrayList<String>();\n    while (itr.hasNext()) {\n      Map.Entry<String, ?> e = itr.next();\n      assertTrue(\"Did not find map-type value in \"+ShardParams.SHARDS_INFO, e.getValue() instanceof Map);\n      String shardAddress = (String)((Map)e.getValue()).get(\"shardAddress\");\n      assertNotNull(ShardParams.SHARDS_INFO+\" did not return 'shardAddress' parameter\", shardAddress);\n      assertTrue(replicaTypeMap.containsKey(shardAddress));\n      assertTrue(preferredTypes.indexOf(replicaTypeMap.get(shardAddress)) == 0);\n      shardAddresses.add(shardAddress);\n    }\n    assertTrue(\"No responses\", shardAddresses.size() > 0);\n    if (log.isInfoEnabled()) {\n      log.info(\"Shards giving the response: {}\", Arrays.toString(shardAddresses.toArray()));\n    }\n  }\n","realPath":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudHttp2SolrClientTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":990,"status":"M"}],"commitId":"c4d4767bca196ad358b72156889effd27fdfcc9b","commitMessage":"@@@SOLR-14035: Remove deprecated preferLocalShards=true support in favour of the shards.preference=replica.location:local alternative.\n(Alex Bulygin via Christine Poerschke)\n","date":"2020-11-20 01:57:47","modifiedFileCount":"5","status":"M","submitter":"Christine Poerschke"}]
