[{"authorTime":"2017-04-28 04:30:46","codes":[{"authorDate":"2017-02-10 13:39:06","commitOrder":2,"curCode":"  public StreamEvaluator constructEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return (StreamEvaluator)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid evaluator expression %s - function '%s' is unknown (not mapped to a valid StreamEvaluator)\", expression, expression.getFunctionName()));\n  }\n","date":"2017-02-10 13:39:51","endLine":378,"groupId":"1632","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"constructEvaluator","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f5/7319d36a4797356f1044aad0d4b56feb961a3b.src","preCode":"  public StreamEvaluator constructEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return (StreamEvaluator)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid evaluator expression %s - function '%s' is unknown (not mapped to a valid StreamEvaluator)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":368,"status":"NB"},{"authorDate":"2017-04-28 04:30:46","commitOrder":2,"curCode":"  public boolean isEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return true;\n      }\n    }\n\n    return false;\n  }\n","date":"2017-04-28 05:03:29","endLine":390,"groupId":"1632","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"isEvaluator","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f0/3bf489c8b461258de7472f5617e51755ff7aba.src","preCode":"  public boolean isEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return true;\n      }\n    }\n\n    return false;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":380,"status":"B"}],"commitId":"e57fab17c0d440cfa9e54d87001bc9691e8ed53d","commitMessage":"@@@SOLR-10559: Cleaner syntax\n","date":"2017-04-28 05:03:29","modifiedFileCount":"8","status":"M","submitter":"Joel Bernstein"},{"authorTime":"2017-04-28 04:30:46","codes":[{"authorDate":"2017-08-26 17:07:19","commitOrder":3,"curCode":"  public org.apache.solr.client.solrj.io.eval.StreamEvaluator constructEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return (org.apache.solr.client.solrj.io.eval.StreamEvaluator)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid evaluator expression %s - function '%s' is unknown (not mapped to a valid StreamEvaluator)\", expression, expression.getFunctionName()));\n  }\n","date":"2017-08-26 17:07:19","endLine":378,"groupId":"1632","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"constructEvaluator","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f4/c9b580808b897b502a7db8ed31a59cd2bb0391.src","preCode":"  public StreamEvaluator constructEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return (StreamEvaluator)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid evaluator expression %s - function '%s' is unknown (not mapped to a valid StreamEvaluator)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":368,"status":"M"},{"authorDate":"2017-04-28 04:30:46","commitOrder":3,"curCode":"  public boolean isEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return true;\n      }\n    }\n\n    return false;\n  }\n","date":"2017-04-28 05:03:29","endLine":390,"groupId":"1632","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"isEvaluator","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f0/3bf489c8b461258de7472f5617e51755ff7aba.src","preCode":"  public boolean isEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return true;\n      }\n    }\n\n    return false;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":380,"status":"N"}],"commitId":"ddcb98e9c3e0d5f6acf59f872e8324e7ad144506","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2017-08-26 17:07:19","modifiedFileCount":"90","status":"M","submitter":"Karl Wright"},{"authorTime":"2019-12-23 12:20:26","codes":[{"authorDate":"2019-12-23 12:20:26","commitOrder":4,"curCode":"  public org.apache.solr.client.solrj.io.eval.StreamEvaluator constructEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n\n    if(classSupplier != null){\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return (org.apache.solr.client.solrj.io.eval.StreamEvaluator)createInstance(clazz, new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid evaluator expression %s - function '%s' is unknown (not mapped to a valid StreamEvaluator)\", expression, expression.getFunctionName()));\n  }\n","date":"2019-12-23 12:20:26","endLine":401,"groupId":"23006","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"constructEvaluator","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/176dd212c3e82fd07c7479b3863fedaf18857d.src","preCode":"  public org.apache.solr.client.solrj.io.eval.StreamEvaluator constructEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return (org.apache.solr.client.solrj.io.eval.StreamEvaluator)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT,\"Invalid evaluator expression %s - function '%s' is unknown (not mapped to a valid StreamEvaluator)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":389,"status":"M"},{"authorDate":"2019-12-23 12:20:26","commitOrder":4,"curCode":"  public boolean isEvaluator(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n","date":"2019-12-23 12:20:26","endLine":427,"groupId":"23006","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"isEvaluator","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/176dd212c3e82fd07c7479b3863fedaf18857d.src","preCode":"  public boolean isEvaluator(StreamExpression expression) throws IOException{\n    String function = expression.getFunctionName();\n    if(functionNames.containsKey(function)){\n      Class<? extends Expressible> clazz = functionNames.get(function);\n      if(Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)){\n        return true;\n      }\n    }\n\n    return false;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"M"}],"commitId":"ef15ae9805557685874c2a3269dae15ef7f58ccf","commitMessage":"@@@SOLR-14125 : Streaming expressions to be loadable from packages (#1108)\n\n SOLR-14125: Make <expressible> plugins work with packages","date":"2019-12-23 12:20:26","modifiedFileCount":"8","status":"M","submitter":"Noble Paul"},{"authorTime":"2019-12-23 12:20:26","codes":[{"authorDate":"2021-06-03 06:17:26","commitOrder":5,"curCode":"  public StreamEvaluator constructEvaluator(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (StreamEvaluator.class.isAssignableFrom(clazz)) {\n        return createInstance(clazz.asSubclass(StreamEvaluator.class), new Class<?>[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT, \"Invalid evaluator expression %s - function '%s' is unknown (not mapped to a valid StreamEvaluator)\", expression, expression.getFunctionName()));\n  }\n","date":"2021-06-03 06:17:26","endLine":413,"groupId":"10360","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"constructEvaluator","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/83/81da1bf58fac3cb043b56e0583c74a16396806.src","preCode":"  public org.apache.solr.client.solrj.io.eval.StreamEvaluator constructEvaluator(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)) {\n        return (org.apache.solr.client.solrj.io.eval.StreamEvaluator)createInstance(clazz, new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});\n      }\n    }\n    \n    throw new IOException(String.format(Locale.ROOT, \"Invalid evaluator expression %s - function '%s' is unknown (not mapped to a valid StreamEvaluator)\", expression, expression.getFunctionName()));\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":401,"status":"M"},{"authorDate":"2019-12-23 12:20:26","commitOrder":5,"curCode":"  public boolean isEvaluator(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n","date":"2019-12-23 12:20:26","endLine":427,"groupId":"10360","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"isEvaluator","params":"(StreamExpressionexpression)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/176dd212c3e82fd07c7479b3863fedaf18857d.src","preCode":"  public boolean isEvaluator(StreamExpression expression) throws IOException {\n    String function = expression.getFunctionName();\n    Supplier<Class<? extends Expressible>> classSupplier = functionNames.get(function);\n    if (classSupplier != null) {\n      Class<? extends Expressible> clazz = classSupplier.get();\n      if (Expressible.class.isAssignableFrom(clazz) && StreamEvaluator.class.isAssignableFrom(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":416,"status":"N"}],"commitId":"c8e06a7298a2745c2b83102169073e2f8e8eceb5","commitMessage":"@@@SOLR-15385 Address many rawtypes warnings (#107)\n\nAddressed significant usage of raw types with Class.  Map.  and SolrRequest; removed over 400 SuppressWarning annotations.\n\nMap construction was replaced with Map.of when immutability was possible.  and Utils.makeMap when a mutable map was required.\n\nDiscovered a potential bug in the PackageStore tests where not all assertions were being verified - these tests will be fixed separately.\n\nCo-authored-by: David Smiley <dsmiley@salesforce.com>","date":"2021-06-03 06:17:26","modifiedFileCount":"244","status":"M","submitter":"Mike Drob"}]
