[{"authorTime":"2018-11-30 01:58:18","codes":[{"authorDate":"2018-11-30 01:58:18","commitOrder":5,"curCode":"  protected static void waitForState(String message, String collection, CollectionStatePredicate predicate, int timeout, TimeUnit timeUnit) {\n    AtomicReference<DocCollection> state = new AtomicReference<>();\n    AtomicReference<Set<String>> liveNodesLastSeen = new AtomicReference<>();\n    try {\n      cluster.getSolrClient().waitForState(collection, timeout, timeUnit, (n, c) -> {\n        state.set(c);\n        liveNodesLastSeen.set(n);\n        return predicate.matches(n, c);\n      });\n    } catch (Exception e) {\n      fail(message + \"\\n\" + e.getMessage() + \"\\nLive Nodes: \" + Arrays.toString(liveNodesLastSeen.get().toArray()) + \"\\nLast available state: \" + state.get());\n    }\n  }\n","date":"2018-11-30 01:58:51","endLine":291,"groupId":"10752","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"waitForState","params":"(Stringmessage@Stringcollection@CollectionStatePredicatepredicate@inttimeout@TimeUnittimeUnit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6e/2f780276b1ded9e429090c96f85b801bbe77f8.src","preCode":"  protected static void waitForState(String message, String collection, CollectionStatePredicate predicate, int timeout, TimeUnit timeUnit) {\n    AtomicReference<DocCollection> state = new AtomicReference<>();\n    AtomicReference<Set<String>> liveNodesLastSeen = new AtomicReference<>();\n    try {\n      cluster.getSolrClient().waitForState(collection, timeout, timeUnit, (n, c) -> {\n        state.set(c);\n        liveNodesLastSeen.set(n);\n        return predicate.matches(n, c);\n      });\n    } catch (Exception e) {\n      fail(message + \"\\n\" + e.getMessage() + \"\\nLive Nodes: \" + Arrays.toString(liveNodesLastSeen.get().toArray()) + \"\\nLast available state: \" + state.get());\n    }\n  }\n","realPath":"solr/test-framework/src/java/org/apache/solr/cloud/SolrCloudTestCase.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":279,"status":"MB"},{"authorDate":"2018-11-30 01:58:18","commitOrder":5,"curCode":"  public void waitForActiveCollection(String collection, long wait, TimeUnit unit, int shards, int totalReplicas) {\n    CollectionStatePredicate predicate = expectedShardsAndActiveReplicas(shards, totalReplicas);\n\n    AtomicReference<DocCollection> state = new AtomicReference<>();\n    AtomicReference<Set<String>> liveNodesLastSeen = new AtomicReference<>();\n    try {\n      getSolrClient().waitForState(collection, wait, unit, (n, c) -> {\n        state.set(c);\n        liveNodesLastSeen.set(n);\n\n        return predicate.matches(n, c);\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      throw new RuntimeException(\"Failed while waiting for active collection\" + \"\\n\" + e.getMessage() + \"\\nLive Nodes: \" + Arrays.toString(liveNodesLastSeen.get().toArray())\n          + \"\\nLast available state: \" + state.get());\n    }\n\n  }\n","date":"2018-11-30 01:58:51","endLine":739,"groupId":"16246","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"waitForActiveCollection","params":"(Stringcollection@longwait@TimeUnitunit@intshards@inttotalReplicas)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9b/52b802fa40c62926486109466e0e4b7929accf.src","preCode":"  public void waitForActiveCollection(String collection, long wait, TimeUnit unit, int shards, int totalReplicas) {\n    CollectionStatePredicate predicate = expectedShardsAndActiveReplicas(shards, totalReplicas);\n\n    AtomicReference<DocCollection> state = new AtomicReference<>();\n    AtomicReference<Set<String>> liveNodesLastSeen = new AtomicReference<>();\n    try {\n      getSolrClient().waitForState(collection, wait, unit, (n, c) -> {\n        state.set(c);\n        liveNodesLastSeen.set(n);\n\n        return predicate.matches(n, c);\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      throw new RuntimeException(\"Failed while waiting for active collection\" + \"\\n\" + e.getMessage() + \"\\nLive Nodes: \" + Arrays.toString(liveNodesLastSeen.get().toArray())\n          + \"\\nLast available state: \" + state.get());\n    }\n\n  }\n","realPath":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":722,"status":"B"}],"commitId":"75b183196798232aa6f2dcaaaab117f309119053","commitMessage":"@@@SOLR-12801: Make massive improvements to the tests.\n\nSOLR-12804: Remove static modifier from Overseer queue access.\n\nSOLR-12896: Introduce more checks for shutdown and closed to improve clean close and shutdown. (Partial)\n\nSOLR-12897: Introduce AlreadyClosedException to clean up silly close / shutdown logging. (Partial)\n\nSOLR-12898: Replace cluster state polling with ZkStateReader#waitFor. (Partial)\n\nSOLR-12923: The new AutoScaling tests are way too flaky and need special attention. (Partial)\n\nSOLR-12932: ant test (without badapples=false) should pass easily for developers. (Partial)\n\nSOLR-12933: Fix SolrCloud distributed commit.\n","date":"2018-11-30 01:58:51","modifiedFileCount":"339","status":"M","submitter":"markrmiller"},{"authorTime":"2019-08-22 04:13:40","codes":[{"authorDate":"2019-08-22 04:13:40","commitOrder":6,"curCode":"  protected static void waitForState(String message, String collection, CollectionStatePredicate predicate, int timeout, TimeUnit timeUnit) {\n    log.info(\"waitForState ({}): {}\", collection, message);\n    AtomicReference<DocCollection> state = new AtomicReference<>();\n    AtomicReference<Set<String>> liveNodesLastSeen = new AtomicReference<>();\n    try {\n      cluster.getSolrClient().waitForState(collection, timeout, timeUnit, (n, c) -> {\n        state.set(c);\n        liveNodesLastSeen.set(n);\n        return predicate.matches(n, c);\n      });\n    } catch (Exception e) {\n      fail(message + \"\\n\" + e.getMessage() + \"\\nLive Nodes: \" + Arrays.toString(liveNodesLastSeen.get().toArray()) + \"\\nLast available state: \" + state.get());\n    }\n  }\n","date":"2019-08-22 04:13:40","endLine":331,"groupId":"121894","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"waitForState","params":"(Stringmessage@Stringcollection@CollectionStatePredicatepredicate@inttimeout@TimeUnittimeUnit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/5f/30f212e2fe5dc645740f50b925b622ea72fc56.src","preCode":"  protected static void waitForState(String message, String collection, CollectionStatePredicate predicate, int timeout, TimeUnit timeUnit) {\n    AtomicReference<DocCollection> state = new AtomicReference<>();\n    AtomicReference<Set<String>> liveNodesLastSeen = new AtomicReference<>();\n    try {\n      cluster.getSolrClient().waitForState(collection, timeout, timeUnit, (n, c) -> {\n        state.set(c);\n        liveNodesLastSeen.set(n);\n        return predicate.matches(n, c);\n      });\n    } catch (Exception e) {\n      fail(message + \"\\n\" + e.getMessage() + \"\\nLive Nodes: \" + Arrays.toString(liveNodesLastSeen.get().toArray()) + \"\\nLast available state: \" + state.get());\n    }\n  }\n","realPath":"solr/test-framework/src/java/org/apache/solr/cloud/SolrCloudTestCase.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":318,"status":"M"},{"authorDate":"2019-08-22 04:13:40","commitOrder":6,"curCode":"  public void waitForActiveCollection(String collection, long wait, TimeUnit unit, int shards, int totalReplicas) {\n    log.info(\"waitForActiveCollection: {}\", collection);\n    CollectionStatePredicate predicate = expectedShardsAndActiveReplicas(shards, totalReplicas);\n\n    AtomicReference<DocCollection> state = new AtomicReference<>();\n    AtomicReference<Set<String>> liveNodesLastSeen = new AtomicReference<>();\n    try {\n      getSolrClient().waitForState(collection, wait, unit, (n, c) -> {\n        state.set(c);\n        liveNodesLastSeen.set(n);\n\n        return predicate.matches(n, c);\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      throw new RuntimeException(\"Failed while waiting for active collection\" + \"\\n\" + e.getMessage() + \"\\nLive Nodes: \" + Arrays.toString(liveNodesLastSeen.get().toArray())\n          + \"\\nLast available state: \" + state.get());\n    }\n\n  }\n","date":"2019-08-22 04:13:40","endLine":764,"groupId":"121894","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"waitForActiveCollection","params":"(Stringcollection@longwait@TimeUnitunit@intshards@inttotalReplicas)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ec/a5235654bd2873ec2b91df4a25b96972e17703.src","preCode":"  public void waitForActiveCollection(String collection, long wait, TimeUnit unit, int shards, int totalReplicas) {\n    CollectionStatePredicate predicate = expectedShardsAndActiveReplicas(shards, totalReplicas);\n\n    AtomicReference<DocCollection> state = new AtomicReference<>();\n    AtomicReference<Set<String>> liveNodesLastSeen = new AtomicReference<>();\n    try {\n      getSolrClient().waitForState(collection, wait, unit, (n, c) -> {\n        state.set(c);\n        liveNodesLastSeen.set(n);\n\n        return predicate.matches(n, c);\n      });\n    } catch (TimeoutException | InterruptedException e) {\n      throw new RuntimeException(\"Failed while waiting for active collection\" + \"\\n\" + e.getMessage() + \"\\nLive Nodes: \" + Arrays.toString(liveNodesLastSeen.get().toArray())\n          + \"\\nLast available state: \" + state.get());\n    }\n\n  }\n","realPath":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":746,"status":"M"}],"commitId":"2fdc882bc473627744c1fd184848dfabeab3648d","commitMessage":"@@@Additional logging in test framework methods that 'waitFor' something to better trace order of operations when failures occur\n","date":"2019-08-22 04:13:40","modifiedFileCount":"6","status":"M","submitter":"Chris Hostetter"}]
