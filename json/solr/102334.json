[{"authorTime":"2018-12-31 19:05:31","codes":[{"authorDate":"2018-09-04 20:24:32","commitOrder":20,"curCode":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    \r\n    \r\n    \r\n    \r\n    \r\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); \r\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        \r\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      \r\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; \r\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      \r\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        \r\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              \r\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  \r\n          leafComparator.setScorer(new ScoreAndDoc(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n","date":"2018-09-07 18:41:47","endLine":482,"groupId":"9950","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"doFieldSortValues","params":"(ResponseBuilderrb@SolrIndexSearchersearcher)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e9/373702897c112e3f16ad7de6359dd73959d8c0.src","preCode":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    \r\n    \r\n    \r\n    \r\n    \r\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); \r\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        \r\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      \r\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; \r\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      \r\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        \r\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              \r\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  \r\n          leafComparator.setScorer(new ScoreAndDoc(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":376,"status":"NB"},{"authorDate":"2018-12-31 19:05:31","commitOrder":20,"curCode":"    public void handleMergeFields(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException {\n      SolrQueryRequest req = rb.req;\n      SolrQueryResponse rsp = rb.rsp;\n      \r\n      \r\n      \r\n      \r\n      \r\n      boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n      if(fsv){\n        NamedList<Object[]> sortVals = new NamedList<>(); \r\n        IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n        List<LeafReaderContext> leaves = topReaderContext.leaves();\n        LeafReaderContext currentLeaf = null;\n        if (leaves.size()==1) {\n          \r\n          currentLeaf = leaves.get(0);\n          leaves=null;\n        }\n\n        DocList docList = rb.getResults().docList;\n\n        \r\n        int nDocs = docList.size();\n        final long[] sortedIds = new long[nDocs];\n        final float[] scores = new float[nDocs]; \r\n        DocList docs = rb.getResults().docList;\n        DocIterator it = docs.iterator();\n        for (int i=0; i<nDocs; i++) {\n          sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n          scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n        }\n\n        \r\n        new InPlaceMergeSorter() {\n          @Override\n          protected void swap(int i, int j) {\n            long tmpId = sortedIds[i];\n            float tmpScore = scores[i];\n            sortedIds[i] = sortedIds[j];\n            scores[i] = scores[j];\n            sortedIds[j] = tmpId;\n            scores[j] = tmpScore;\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            return Long.compare(sortedIds[i], sortedIds[j]);\n          }\n        }.sort(0, sortedIds.length);\n\n        SortSpec sortSpec = rb.getSortSpec();\n        Sort sort = searcher.weightSort(sortSpec.getSort());\n        SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n        List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n        for (int fld = 0; fld < schemaFields.size(); fld++) {\n          SchemaField schemaField = schemaFields.get(fld);\n          FieldType ft = null == schemaField? null : schemaField.getType();\n          SortField sortField = sortFields[fld];\n\n          SortField.Type type = sortField.getType();\n          \r\n          if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n          FieldComparator<?> comparator = null;\n          LeafFieldComparator leafComparator = null;\n          Object[] vals = new Object[nDocs];\n\n          int lastIdx = -1;\n          int idx = 0;\n\n          for (int i = 0; i < sortedIds.length; ++i) {\n            long idAndPos = sortedIds[i];\n            float score = scores[i];\n            int doc = (int)(idAndPos >>> 32);\n            int position = (int)idAndPos;\n\n            if (leaves != null) {\n              idx = ReaderUtil.subIndex(doc, leaves);\n              currentLeaf = leaves.get(idx);\n              if (idx != lastIdx) {\n                \r\n                comparator = null;\n              }\n            }\n\n            if (comparator == null) {\n              comparator = sortField.getComparator(1,0);\n              leafComparator = comparator.getLeafComparator(currentLeaf);\n            }\n\n            doc -= currentLeaf.docBase;  \r\n            leafComparator.setScorer(new ScoreAndDoc(doc, score));\n            leafComparator.copy(0, doc);\n            Object val = comparator.value(0);\n            if (null != ft) val = ft.marshalSortValue(val);\n            vals[position] = val;\n          }\n\n          sortVals.add(sortField.getField(), vals);\n        }\n\n        rsp.add(\"merge_values\", sortVals);\n      }\n    }\n","date":"2018-12-31 19:05:31","endLine":434,"groupId":"52384","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"handleMergeFields","params":"(ResponseBuilderrb@SolrIndexSearchersearcher)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bc/3839771bc3a6b3138cd6daee9a86497bd799f5.src","preCode":"    public void handleMergeFields(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException {\n      SolrQueryRequest req = rb.req;\n      SolrQueryResponse rsp = rb.rsp;\n      \r\n      \r\n      \r\n      \r\n      \r\n      boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n      if(fsv){\n        NamedList<Object[]> sortVals = new NamedList<>(); \r\n        IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n        List<LeafReaderContext> leaves = topReaderContext.leaves();\n        LeafReaderContext currentLeaf = null;\n        if (leaves.size()==1) {\n          \r\n          currentLeaf = leaves.get(0);\n          leaves=null;\n        }\n\n        DocList docList = rb.getResults().docList;\n\n        \r\n        int nDocs = docList.size();\n        final long[] sortedIds = new long[nDocs];\n        final float[] scores = new float[nDocs]; \r\n        DocList docs = rb.getResults().docList;\n        DocIterator it = docs.iterator();\n        for (int i=0; i<nDocs; i++) {\n          sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n          scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n        }\n\n        \r\n        new InPlaceMergeSorter() {\n          @Override\n          protected void swap(int i, int j) {\n            long tmpId = sortedIds[i];\n            float tmpScore = scores[i];\n            sortedIds[i] = sortedIds[j];\n            scores[i] = scores[j];\n            sortedIds[j] = tmpId;\n            scores[j] = tmpScore;\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            return Long.compare(sortedIds[i], sortedIds[j]);\n          }\n        }.sort(0, sortedIds.length);\n\n        SortSpec sortSpec = rb.getSortSpec();\n        Sort sort = searcher.weightSort(sortSpec.getSort());\n        SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n        List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n        for (int fld = 0; fld < schemaFields.size(); fld++) {\n          SchemaField schemaField = schemaFields.get(fld);\n          FieldType ft = null == schemaField? null : schemaField.getType();\n          SortField sortField = sortFields[fld];\n\n          SortField.Type type = sortField.getType();\n          \r\n          if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n          FieldComparator<?> comparator = null;\n          LeafFieldComparator leafComparator = null;\n          Object[] vals = new Object[nDocs];\n\n          int lastIdx = -1;\n          int idx = 0;\n\n          for (int i = 0; i < sortedIds.length; ++i) {\n            long idAndPos = sortedIds[i];\n            float score = scores[i];\n            int doc = (int)(idAndPos >>> 32);\n            int position = (int)idAndPos;\n\n            if (leaves != null) {\n              idx = ReaderUtil.subIndex(doc, leaves);\n              currentLeaf = leaves.get(idx);\n              if (idx != lastIdx) {\n                \r\n                comparator = null;\n              }\n            }\n\n            if (comparator == null) {\n              comparator = sortField.getComparator(1,0);\n              leafComparator = comparator.getLeafComparator(currentLeaf);\n            }\n\n            doc -= currentLeaf.docBase;  \r\n            leafComparator.setScorer(new ScoreAndDoc(doc, score));\n            leafComparator.copy(0, doc);\n            Object val = comparator.value(0);\n            if (null != ft) val = ft.marshalSortValue(val);\n            vals[position] = val;\n          }\n\n          sortVals.add(sortField.getField(), vals);\n        }\n\n        rsp.add(\"merge_values\", sortVals);\n      }\n    }\n","realPath":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":329,"status":"B"}],"commitId":"6a2de771bfc8a40738e1ce0645f8b2c8ae8f9e09","commitMessage":"@@@SOLR-13096: rename TestRankQueryPlugin to RankQueryTestPlugin\n","date":"2018-12-31 19:05:31","modifiedFileCount":"0","status":"M","submitter":"Christine Poerschke"},{"authorTime":"2018-12-31 19:05:31","codes":[{"authorDate":"2019-02-20 21:24:52","commitOrder":21,"curCode":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    \r\n    \r\n    \r\n    \r\n    \r\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      try {\n      NamedList<Object[]> sortVals = new NamedList<>(); \r\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        \r\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      final DocList docs = rb.getResults().docList;\n\n      \r\n      int nDocs = docs.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; \r\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      \r\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        \r\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              \r\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  \r\n          leafComparator.setScorer(new ScoreAndDoc(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n      rsp.add(\"sort_values\", sortVals);\n    }catch(ExitableDirectoryReader.ExitingReaderException x) {\n      \r\n      \r\n      rsp.add(\"sort_values\",new NamedList<>() );\n      throw x;\n    }\n    }\n  }\n","date":"2019-03-04 22:41:57","endLine":488,"groupId":"102334","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"doFieldSortValues","params":"(ResponseBuilderrb@SolrIndexSearchersearcher)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4d/ab304b5f34bf507897feb0b3565933c160d9fe.src","preCode":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    \r\n    \r\n    \r\n    \r\n    \r\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); \r\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        \r\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      \r\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; \r\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      \r\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        \r\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              \r\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  \r\n          leafComparator.setScorer(new ScoreAndDoc(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":377,"status":"M"},{"authorDate":"2018-12-31 19:05:31","commitOrder":21,"curCode":"    public void handleMergeFields(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException {\n      SolrQueryRequest req = rb.req;\n      SolrQueryResponse rsp = rb.rsp;\n      \r\n      \r\n      \r\n      \r\n      \r\n      boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n      if(fsv){\n        NamedList<Object[]> sortVals = new NamedList<>(); \r\n        IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n        List<LeafReaderContext> leaves = topReaderContext.leaves();\n        LeafReaderContext currentLeaf = null;\n        if (leaves.size()==1) {\n          \r\n          currentLeaf = leaves.get(0);\n          leaves=null;\n        }\n\n        DocList docList = rb.getResults().docList;\n\n        \r\n        int nDocs = docList.size();\n        final long[] sortedIds = new long[nDocs];\n        final float[] scores = new float[nDocs]; \r\n        DocList docs = rb.getResults().docList;\n        DocIterator it = docs.iterator();\n        for (int i=0; i<nDocs; i++) {\n          sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n          scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n        }\n\n        \r\n        new InPlaceMergeSorter() {\n          @Override\n          protected void swap(int i, int j) {\n            long tmpId = sortedIds[i];\n            float tmpScore = scores[i];\n            sortedIds[i] = sortedIds[j];\n            scores[i] = scores[j];\n            sortedIds[j] = tmpId;\n            scores[j] = tmpScore;\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            return Long.compare(sortedIds[i], sortedIds[j]);\n          }\n        }.sort(0, sortedIds.length);\n\n        SortSpec sortSpec = rb.getSortSpec();\n        Sort sort = searcher.weightSort(sortSpec.getSort());\n        SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n        List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n        for (int fld = 0; fld < schemaFields.size(); fld++) {\n          SchemaField schemaField = schemaFields.get(fld);\n          FieldType ft = null == schemaField? null : schemaField.getType();\n          SortField sortField = sortFields[fld];\n\n          SortField.Type type = sortField.getType();\n          \r\n          if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n          FieldComparator<?> comparator = null;\n          LeafFieldComparator leafComparator = null;\n          Object[] vals = new Object[nDocs];\n\n          int lastIdx = -1;\n          int idx = 0;\n\n          for (int i = 0; i < sortedIds.length; ++i) {\n            long idAndPos = sortedIds[i];\n            float score = scores[i];\n            int doc = (int)(idAndPos >>> 32);\n            int position = (int)idAndPos;\n\n            if (leaves != null) {\n              idx = ReaderUtil.subIndex(doc, leaves);\n              currentLeaf = leaves.get(idx);\n              if (idx != lastIdx) {\n                \r\n                comparator = null;\n              }\n            }\n\n            if (comparator == null) {\n              comparator = sortField.getComparator(1,0);\n              leafComparator = comparator.getLeafComparator(currentLeaf);\n            }\n\n            doc -= currentLeaf.docBase;  \r\n            leafComparator.setScorer(new ScoreAndDoc(doc, score));\n            leafComparator.copy(0, doc);\n            Object val = comparator.value(0);\n            if (null != ft) val = ft.marshalSortValue(val);\n            vals[position] = val;\n          }\n\n          sortVals.add(sortField.getField(), vals);\n        }\n\n        rsp.add(\"merge_values\", sortVals);\n      }\n    }\n","date":"2018-12-31 19:05:31","endLine":434,"groupId":"102334","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"handleMergeFields","params":"(ResponseBuilderrb@SolrIndexSearchersearcher)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bc/3839771bc3a6b3138cd6daee9a86497bd799f5.src","preCode":"    public void handleMergeFields(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException {\n      SolrQueryRequest req = rb.req;\n      SolrQueryResponse rsp = rb.rsp;\n      \r\n      \r\n      \r\n      \r\n      \r\n      boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n      if(fsv){\n        NamedList<Object[]> sortVals = new NamedList<>(); \r\n        IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n        List<LeafReaderContext> leaves = topReaderContext.leaves();\n        LeafReaderContext currentLeaf = null;\n        if (leaves.size()==1) {\n          \r\n          currentLeaf = leaves.get(0);\n          leaves=null;\n        }\n\n        DocList docList = rb.getResults().docList;\n\n        \r\n        int nDocs = docList.size();\n        final long[] sortedIds = new long[nDocs];\n        final float[] scores = new float[nDocs]; \r\n        DocList docs = rb.getResults().docList;\n        DocIterator it = docs.iterator();\n        for (int i=0; i<nDocs; i++) {\n          sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n          scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n        }\n\n        \r\n        new InPlaceMergeSorter() {\n          @Override\n          protected void swap(int i, int j) {\n            long tmpId = sortedIds[i];\n            float tmpScore = scores[i];\n            sortedIds[i] = sortedIds[j];\n            scores[i] = scores[j];\n            sortedIds[j] = tmpId;\n            scores[j] = tmpScore;\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            return Long.compare(sortedIds[i], sortedIds[j]);\n          }\n        }.sort(0, sortedIds.length);\n\n        SortSpec sortSpec = rb.getSortSpec();\n        Sort sort = searcher.weightSort(sortSpec.getSort());\n        SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n        List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n        for (int fld = 0; fld < schemaFields.size(); fld++) {\n          SchemaField schemaField = schemaFields.get(fld);\n          FieldType ft = null == schemaField? null : schemaField.getType();\n          SortField sortField = sortFields[fld];\n\n          SortField.Type type = sortField.getType();\n          \r\n          if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n          FieldComparator<?> comparator = null;\n          LeafFieldComparator leafComparator = null;\n          Object[] vals = new Object[nDocs];\n\n          int lastIdx = -1;\n          int idx = 0;\n\n          for (int i = 0; i < sortedIds.length; ++i) {\n            long idAndPos = sortedIds[i];\n            float score = scores[i];\n            int doc = (int)(idAndPos >>> 32);\n            int position = (int)idAndPos;\n\n            if (leaves != null) {\n              idx = ReaderUtil.subIndex(doc, leaves);\n              currentLeaf = leaves.get(idx);\n              if (idx != lastIdx) {\n                \r\n                comparator = null;\n              }\n            }\n\n            if (comparator == null) {\n              comparator = sortField.getComparator(1,0);\n              leafComparator = comparator.getLeafComparator(currentLeaf);\n            }\n\n            doc -= currentLeaf.docBase;  \r\n            leafComparator.setScorer(new ScoreAndDoc(doc, score));\n            leafComparator.copy(0, doc);\n            Object val = comparator.value(0);\n            if (null != ft) val = ft.marshalSortValue(val);\n            vals[position] = val;\n          }\n\n          sortVals.add(sortField.getField(), vals);\n        }\n\n        rsp.add(\"merge_values\", sortVals);\n      }\n    }\n","realPath":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":329,"status":"N"}],"commitId":"b8d569aff0c4417b0f9cd52d54455ab9b66236a1","commitMessage":"@@@SOLR-9882: reporting timeAllowed breach as partialResults instead of 500 error\n","date":"2019-03-04 22:41:57","modifiedFileCount":"16","status":"M","submitter":"Mikhail Khludnev"}]
