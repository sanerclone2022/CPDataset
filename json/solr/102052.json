[{"authorTime":"2019-04-10 15:02:59","codes":[{"authorDate":"2019-04-10 15:02:59","commitOrder":29,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        \r\n        doLocalAdd(cmd);\n\n        \r\n        \r\n        \r\n        if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n          ulog.openRealtimeSearcher();\n        }\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","date":"2019-04-10 15:02:59","endLine":494,"groupId":"43106","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        \r\n        doLocalAdd(cmd);\n\n        \r\n        \r\n        \r\n        if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n          ulog.openRealtimeSearcher();\n        }\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":275,"status":"MB"},{"authorDate":"2019-04-10 15:02:59","commitOrder":29,"curCode":"  private long findVersionOnUpdate(UpdateCommand cmd) {\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n    return versionOnUpdate;\n  }\n","date":"2019-04-10 15:02:59","endLine":858,"groupId":"6599","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"findVersionOnUpdate","params":"(UpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private long findVersionOnUpdate(UpdateCommand cmd) {\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n    return versionOnUpdate;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":850,"status":"B"}],"commitId":"8527ec11af8099f86953ffad1182ad43c752f95b","commitMessage":"@@@SOLR-12638: Partial/Atomic updates of nested docs.\nand [child] now works in RTG.\n","date":"2019-04-10 15:02:59","modifiedFileCount":"11","status":"M","submitter":"Moshe"},{"authorTime":"2019-04-10 15:02:59","codes":[{"authorDate":"2019-05-01 04:31:06","commitOrder":30,"curCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      long finalVersionOnUpdate = versionOnUpdate;\n      return bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doVersionAdd(cmd, finalVersionOnUpdate, isReplayOrPeersync, leaderLogic, forwardedFromCollection, bucket));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n","date":"2019-05-01 04:31:44","endLine":341,"groupId":"102052","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"versionAdd","params":"(AddUpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ed/48c758f47592c9980d29aab7abd4b35f61d414.src","preCode":"  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    \r\n    \r\n    int bucketHash = bucketHash(idBytes);\n\n    \r\n    \r\n\n    \r\n    \r\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        \r\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    \r\n    \r\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        \r\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        \r\n        \r\n        \r\n\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              \r\n              \r\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            \r\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              \r\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                \r\n                \r\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            \r\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              \r\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                \r\n                \r\n                \r\n                \r\n                \r\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  \r\n                  \r\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  \r\n                  \r\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  \r\n                  \r\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  \r\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              \r\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                \r\n                \r\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                \r\n                \r\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  \r\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        \r\n        doLocalAdd(cmd);\n\n        \r\n        \r\n        \r\n        if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n          ulog.openRealtimeSearcher();\n        }\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":276,"status":"M"},{"authorDate":"2019-04-10 15:02:59","commitOrder":30,"curCode":"  private long findVersionOnUpdate(UpdateCommand cmd) {\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n    return versionOnUpdate;\n  }\n","date":"2019-04-10 15:02:59","endLine":858,"groupId":"102052","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"findVersionOnUpdate","params":"(UpdateCommandcmd)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bf/1255a35148c17c90e8b95f82208656c27e21a5.src","preCode":"  private long findVersionOnUpdate(UpdateCommand cmd) {\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  \r\n    return versionOnUpdate;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":850,"status":"N"}],"commitId":"70e090717d21a9713c45b8a52e35df940a4277df","commitMessage":"@@@SOLR-12833: Avoid unnecessary memory cost when DistributedUpdateProcessor timed-out lock is not used.\n","date":"2019-05-01 04:31:44","modifiedFileCount":"4","status":"M","submitter":"Andrzej Bialecki"}]
