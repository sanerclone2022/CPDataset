[{"authorTime":"2020-05-28 00:06:29","codes":[{"authorDate":"2020-05-28 00:06:29","commitOrder":1,"curCode":"  public void cancelElection() throws InterruptedException, KeeperException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core != null) {\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n      }\n    }\n\n    super.cancelElection();\n  }\n","date":"2020-05-28 00:06:29","endLine":84,"groupId":"49992","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"cancelElection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f6/c96caf2052b8512692877534a6cdb32cf20207.src","preCode":"  public void cancelElection() throws InterruptedException, KeeperException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core != null) {\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n      }\n    }\n\n    super.cancelElection();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"B"},{"authorDate":"2020-05-28 00:06:29","commitOrder":1,"curCode":"  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        \r\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        \r\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        \r\n        \r\n        \r\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        \r\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            \r\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        \r\n        \r\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          \r\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            \r\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            \r\n            \r\n            \r\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        \r\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            \r\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          \r\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          \r\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, cc.getLoadedCoreNames());\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            \r\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n","date":"2020-05-28 00:06:29","endLine":313,"groupId":"3350","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"runLeaderProcess","params":"(booleanweAreReplacement@intpauseBeforeStart)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f6/c96caf2052b8512692877534a6cdb32cf20207.src","preCode":"  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        \r\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        \r\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        \r\n        \r\n        \r\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        \r\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            \r\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        \r\n        \r\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          \r\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            \r\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            \r\n            \r\n            \r\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        \r\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            \r\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          \r\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          \r\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, cc.getLoadedCoreNames());\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            \r\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"B"}],"commitId":"07a9b5d1b0eb06adbb6993de2ee615a09609ac90","commitMessage":"@@@SOLR-14474: Fix remaining auxilliary class warnings in Solr\n","date":"2020-05-28 00:06:29","modifiedFileCount":"17","status":"B","submitter":"Erick Erickson"},{"authorTime":"2020-11-07 00:18:08","codes":[{"authorDate":"2020-05-28 00:06:29","commitOrder":2,"curCode":"  public void cancelElection() throws InterruptedException, KeeperException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core != null) {\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n      }\n    }\n\n    super.cancelElection();\n  }\n","date":"2020-05-28 00:06:29","endLine":84,"groupId":"49992","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"cancelElection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f6/c96caf2052b8512692877534a6cdb32cf20207.src","preCode":"  public void cancelElection() throws InterruptedException, KeeperException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core != null) {\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n      }\n    }\n\n    super.cancelElection();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"N"},{"authorDate":"2020-11-07 00:18:08","commitOrder":2,"curCode":"  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        \r\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        \r\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        \r\n        \r\n        \r\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        \r\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            \r\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        \r\n        \r\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          \r\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            \r\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            \r\n            \r\n            \r\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        \r\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            \r\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          \r\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          \r\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, CloudUtil.getLoadedCoreNamesAsString(cc));\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            \r\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n","date":"2020-11-11 18:37:45","endLine":313,"groupId":"3350","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"runLeaderProcess","params":"(booleanweAreReplacement@intpauseBeforeStart)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/69/ccf75c4efcef1ad1eb545ec52923670ee32ee6.src","preCode":"  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        \r\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        \r\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        \r\n        \r\n        \r\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        \r\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            \r\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        \r\n        \r\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          \r\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            \r\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            \r\n            \r\n            \r\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        \r\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            \r\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          \r\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          \r\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, cc.getLoadedCoreNames());\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            \r\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"}],"commitId":"67f9245ce30bb21d3976c05548856c81cf7ee8a1","commitMessage":"@@@SOLR-14975: Optimize CoreContainer.getAllCoreNames and getLoadedCoreNames.\nAlso optimize getCoreDescriptors.\n","date":"2020-11-11 18:37:45","modifiedFileCount":"14","status":"M","submitter":"Bruno Roustant"},{"authorTime":"2020-12-05 07:19:49","codes":[{"authorDate":"2020-05-28 00:06:29","commitOrder":3,"curCode":"  public void cancelElection() throws InterruptedException, KeeperException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core != null) {\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n      }\n    }\n\n    super.cancelElection();\n  }\n","date":"2020-05-28 00:06:29","endLine":84,"groupId":"49992","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"cancelElection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f6/c96caf2052b8512692877534a6cdb32cf20207.src","preCode":"  public void cancelElection() throws InterruptedException, KeeperException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core != null) {\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n      }\n    }\n\n    super.cancelElection();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"N"},{"authorDate":"2020-12-05 07:19:49","commitOrder":3,"curCode":"  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        \r\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        \r\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        \r\n        \r\n        \r\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        \r\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            \r\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        \r\n        \r\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          \r\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            \r\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            \r\n            \r\n            \r\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        \r\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            \r\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          \r\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          \r\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, CloudUtil.getLoadedCoreNamesAsString(cc));\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            \r\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n","date":"2020-12-16 05:54:40","endLine":309,"groupId":"3350","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"runLeaderProcess","params":"(booleanweAreReplacement@intpauseBeforeStart)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/68/b062ed876e202954919840495652baffb160c0.src","preCode":"  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        \r\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        \r\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        \r\n        \r\n        \r\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        \r\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            \r\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        \r\n        \r\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          \r\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            \r\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            \r\n            \r\n            \r\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        \r\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            \r\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          \r\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          \r\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, CloudUtil.getLoadedCoreNamesAsString(cc));\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            \r\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":94,"status":"M"}],"commitId":"bf7b438f12d65904b461e595594fc9a64cfcc899","commitMessage":"@@@SOLR-15029 Trigger leader election on index writer tragedy\n\nSOLR-13027 Use TestInjection so that we always have a Tragic Event\n\nWhen we encounter a tragic error in the index writer.  we can trigger a\nleader election instead of queing up a delete and re-add of the node in\nquestion. This should result in a more graceful transition.  and the\nprevious leader will eventually be put into recovery by a new leader.\n\ncloses #2120\n","date":"2020-12-16 05:54:40","modifiedFileCount":"15","status":"M","submitter":"Mike Drob"},{"authorTime":"2021-02-13 09:42:18","codes":[{"authorDate":"2020-05-28 00:06:29","commitOrder":4,"curCode":"  public void cancelElection() throws InterruptedException, KeeperException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core != null) {\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n      }\n    }\n\n    super.cancelElection();\n  }\n","date":"2020-05-28 00:06:29","endLine":84,"groupId":"102453","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"cancelElection","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f6/c96caf2052b8512692877534a6cdb32cf20207.src","preCode":"  public void cancelElection() throws InterruptedException, KeeperException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core != null) {\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n      }\n    }\n\n    super.cancelElection();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":75,"status":"N"},{"authorDate":"2021-02-13 09:42:18","commitOrder":4,"curCode":"  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        \r\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        \r\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n\n        if (distributedClusterStateUpdater.isDistributedStateUpdate()) {\n          distributedClusterStateUpdater.doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceSetShardLeader, m,\n              zkController.getSolrCloudManager(), zkStateReader);\n        } else {\n          zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n        }\n      }\n\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        \r\n        \r\n        \r\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        \r\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            \r\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        \r\n        \r\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          \r\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            \r\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            \r\n            \r\n            \r\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        \r\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            \r\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          \r\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          \r\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, CloudUtil.getLoadedCoreNamesAsString(cc));\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            \r\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n","date":"2021-02-13 09:42:18","endLine":316,"groupId":"102453","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"runLeaderProcess","params":"(booleanweAreReplacement@intpauseBeforeStart)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/98/5619850ec22effc42b2c56e72af642ecc6c7db.src","preCode":"  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        \r\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        \r\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        \r\n        \r\n        \r\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        \r\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            \r\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        \r\n        \r\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          \r\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            \r\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            \r\n            \r\n            \r\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        \r\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            \r\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          \r\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          \r\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, CloudUtil.getLoadedCoreNamesAsString(cc));\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            \r\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":95,"status":"M"}],"commitId":"23755ddfdd36a9613010cb9e6201127df55be744","commitMessage":"@@@SOLR-14928: allow cluster state updates to be done in a distributed way and not through Overseer (#2364)\n\n","date":"2021-02-13 09:42:18","modifiedFileCount":"42","status":"M","submitter":"Ilan Ginzburg"}]
