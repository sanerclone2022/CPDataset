[{"authorTime":"2017-07-11 07:58:23","codes":[{"authorDate":"2017-07-11 07:58:23","commitOrder":1,"curCode":"  public void testIntPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_i_dv\";\n    String nonDocValuesField = \"number_p_i\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Integer> values;\n    List<Integer> sortedValues;\n    int max;\n    do {\n      values = getRandomInts(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    int min = sortedValues.get(0);\n    int gap = (int)(((long)(max + numValues) - (long)min) / (long)numBuckets);\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    int minBucketVal = min;\n    for (Integer value : sortedValues) {\n      while (((long)value - (long)minBucketVal) >= (long)gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","date":"2017-07-11 07:58:23","endLine":265,"groupId":"6150","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testIntPointFieldRangeFacet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3d/ac18c2bdfac96349fcaebb19bf76a023cca188.src","preCode":"  public void testIntPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_i_dv\";\n    String nonDocValuesField = \"number_p_i\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Integer> values;\n    List<Integer> sortedValues;\n    int max;\n    do {\n      values = getRandomInts(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    int min = sortedValues.get(0);\n    int gap = (int)(((long)(max + numValues) - (long)min) / (long)numBuckets);\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    int minBucketVal = min;\n    for (Integer value : sortedValues) {\n      while (((long)value - (long)minBucketVal) >= (long)gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","realPath":"solr/core/src/test/org/apache/solr/schema/TestPointFields.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"B"},{"authorDate":"2017-07-11 07:58:23","commitOrder":1,"curCode":"  public void testLongPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_l_dv\";\n    String nonDocValuesField = \"number_p_l\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Long> values;\n    List<Long> sortedValues;\n    long max;\n    do {\n      values = getRandomLongs(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    long min = sortedValues.get(0);\n    long gap = BigInteger.valueOf(max + numValues).subtract(BigInteger.valueOf(min))\n        .divide(BigInteger.valueOf(numBuckets)).longValueExact();\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    long minBucketVal = min;\n    for (Long value : sortedValues) {\n      while (value - minBucketVal >= gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","date":"2017-07-11 07:58:23","endLine":1239,"groupId":"6150","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongPointFieldRangeFacet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3d/ac18c2bdfac96349fcaebb19bf76a023cca188.src","preCode":"  public void testLongPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_l_dv\";\n    String nonDocValuesField = \"number_p_l\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Long> values;\n    List<Long> sortedValues;\n    long max;\n    do {\n      values = getRandomLongs(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    long min = sortedValues.get(0);\n    long gap = BigInteger.valueOf(max + numValues).subtract(BigInteger.valueOf(min))\n        .divide(BigInteger.valueOf(numBuckets)).longValueExact();\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    long minBucketVal = min;\n    for (Long value : sortedValues) {\n      while (value - minBucketVal >= gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","realPath":"solr/core/src/test/org/apache/solr/schema/TestPointFields.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1177,"status":"B"}],"commitId":"5bb09e08528552c310d30fc627dc823a86aa6880","commitMessage":"@@@SOLR-10796: TestPointFields: increase randomized testing of non-trivial values\n","date":"2017-07-11 07:58:23","modifiedFileCount":"1","status":"B","submitter":"Steve Rowe"},{"authorTime":"2017-07-12 15:07:43","codes":[{"authorDate":"2017-07-11 07:58:23","commitOrder":2,"curCode":"  public void testIntPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_i_dv\";\n    String nonDocValuesField = \"number_p_i\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Integer> values;\n    List<Integer> sortedValues;\n    int max;\n    do {\n      values = getRandomInts(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    int min = sortedValues.get(0);\n    int gap = (int)(((long)(max + numValues) - (long)min) / (long)numBuckets);\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    int minBucketVal = min;\n    for (Integer value : sortedValues) {\n      while (((long)value - (long)minBucketVal) >= (long)gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","date":"2017-07-11 07:58:23","endLine":265,"groupId":"6150","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testIntPointFieldRangeFacet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3d/ac18c2bdfac96349fcaebb19bf76a023cca188.src","preCode":"  public void testIntPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_i_dv\";\n    String nonDocValuesField = \"number_p_i\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Integer> values;\n    List<Integer> sortedValues;\n    int max;\n    do {\n      values = getRandomInts(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    int min = sortedValues.get(0);\n    int gap = (int)(((long)(max + numValues) - (long)min) / (long)numBuckets);\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    int minBucketVal = min;\n    for (Integer value : sortedValues) {\n      while (((long)value - (long)minBucketVal) >= (long)gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","realPath":"solr/core/src/test/org/apache/solr/schema/TestPointFields.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"N"},{"authorDate":"2017-07-12 15:07:43","commitOrder":2,"curCode":"  public void testLongPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_l_dv\";\n    String nonDocValuesField = \"number_p_l\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Long> values;\n    List<Long> sortedValues;\n    long max;\n    do {\n      values = getRandomLongs(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Long.MAX_VALUE - numValues); \r\n    long min = sortedValues.get(0);\n    long gap = BigInteger.valueOf(max + numValues).subtract(BigInteger.valueOf(min))\n        .divide(BigInteger.valueOf(numBuckets)).longValueExact();\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    long minBucketVal = min;\n    for (Long value : sortedValues) {\n      while (value - minBucketVal >= gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","date":"2017-07-12 15:07:43","endLine":1239,"groupId":"6150","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongPointFieldRangeFacet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b6/e00b2e166ac477dc7e652a85255584a4c8c7d2.src","preCode":"  public void testLongPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_l_dv\";\n    String nonDocValuesField = \"number_p_l\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Long> values;\n    List<Long> sortedValues;\n    long max;\n    do {\n      values = getRandomLongs(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    long min = sortedValues.get(0);\n    long gap = BigInteger.valueOf(max + numValues).subtract(BigInteger.valueOf(min))\n        .divide(BigInteger.valueOf(numBuckets)).longValueExact();\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    long minBucketVal = min;\n    for (Long value : sortedValues) {\n      while (value - minBucketVal >= gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","realPath":"solr/core/src/test/org/apache/solr/schema/TestPointFields.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1177,"status":"M"}],"commitId":"61c612efd76c71a09f9cf911b73eb52ae22e144b","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2017-07-12 15:07:43","modifiedFileCount":"1","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2017-07-12 23:55:50","codes":[{"authorDate":"2017-07-11 07:58:23","commitOrder":3,"curCode":"  public void testIntPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_i_dv\";\n    String nonDocValuesField = \"number_p_i\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Integer> values;\n    List<Integer> sortedValues;\n    int max;\n    do {\n      values = getRandomInts(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    int min = sortedValues.get(0);\n    int gap = (int)(((long)(max + numValues) - (long)min) / (long)numBuckets);\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    int minBucketVal = min;\n    for (Integer value : sortedValues) {\n      while (((long)value - (long)minBucketVal) >= (long)gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","date":"2017-07-11 07:58:23","endLine":265,"groupId":"6150","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testIntPointFieldRangeFacet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3d/ac18c2bdfac96349fcaebb19bf76a023cca188.src","preCode":"  public void testIntPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_i_dv\";\n    String nonDocValuesField = \"number_p_i\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Integer> values;\n    List<Integer> sortedValues;\n    int max;\n    do {\n      values = getRandomInts(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    int min = sortedValues.get(0);\n    int gap = (int)(((long)(max + numValues) - (long)min) / (long)numBuckets);\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    int minBucketVal = min;\n    for (Integer value : sortedValues) {\n      while (((long)value - (long)minBucketVal) >= (long)gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","realPath":"solr/core/src/test/org/apache/solr/schema/TestPointFields.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"N"},{"authorDate":"2017-07-12 23:55:50","commitOrder":3,"curCode":"  public void testLongPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_l_dv\";\n    String nonDocValuesField = \"number_p_l\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Long> values;\n    List<Long> sortedValues;\n    long max;\n    do {\n      values = getRandomLongs(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Long.MAX_VALUE - numValues); \r\n    long min = sortedValues.get(0);\n    BigInteger bigIntGap =  BigInteger.valueOf(max + numValues).subtract(BigInteger.valueOf(min))\n        .divide(BigInteger.valueOf(numBuckets));\n    long gap = bigIntGap.longValueExact();\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    long minBucketVal = min;\n    System.err.println(\"min:\" + min + \"   max: \" + max + \"   gap: \" + gap);\n    System.err.println(\"bucketNum: \" + bucketNum + \"   minBucketVal: \" + minBucketVal);\n    for (Long value : sortedValues) {\n      System.err.println(\"value: \" + value);\n      while (BigInteger.valueOf(value).subtract(BigInteger.valueOf(minBucketVal)).compareTo(bigIntGap) > 0) {\n        ++bucketNum;\n        minBucketVal += gap;\n        System.err.println(\"bucketNum: \" + bucketNum + \"   minBucketVal: \" + minBucketVal);\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","date":"2017-07-12 23:56:21","endLine":1244,"groupId":"6150","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongPointFieldRangeFacet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/83/eaebd37779e86336543b18ab64760df89e1c67.src","preCode":"  public void testLongPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_l_dv\";\n    String nonDocValuesField = \"number_p_l\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Long> values;\n    List<Long> sortedValues;\n    long max;\n    do {\n      values = getRandomLongs(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Long.MAX_VALUE - numValues); \r\n    long min = sortedValues.get(0);\n    long gap = BigInteger.valueOf(max + numValues).subtract(BigInteger.valueOf(min))\n        .divide(BigInteger.valueOf(numBuckets)).longValueExact();\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    long minBucketVal = min;\n    for (Long value : sortedValues) {\n      while (value - minBucketVal >= gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","realPath":"solr/core/src/test/org/apache/solr/schema/TestPointFields.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1177,"status":"M"}],"commitId":"6188c8ce389d187e49453668bc194074cac72842","commitMessage":"@@@SOLR-10796: fix long overflow in testLongPointFieldRangeFacet()\n","date":"2017-07-12 23:56:21","modifiedFileCount":"1","status":"M","submitter":"Steve Rowe"},{"authorTime":"2017-07-12 23:59:15","codes":[{"authorDate":"2017-07-11 07:58:23","commitOrder":4,"curCode":"  public void testIntPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_i_dv\";\n    String nonDocValuesField = \"number_p_i\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Integer> values;\n    List<Integer> sortedValues;\n    int max;\n    do {\n      values = getRandomInts(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    int min = sortedValues.get(0);\n    int gap = (int)(((long)(max + numValues) - (long)min) / (long)numBuckets);\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    int minBucketVal = min;\n    for (Integer value : sortedValues) {\n      while (((long)value - (long)minBucketVal) >= (long)gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","date":"2017-07-11 07:58:23","endLine":265,"groupId":"102657","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testIntPointFieldRangeFacet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/3d/ac18c2bdfac96349fcaebb19bf76a023cca188.src","preCode":"  public void testIntPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_i_dv\";\n    String nonDocValuesField = \"number_p_i\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Integer> values;\n    List<Integer> sortedValues;\n    int max;\n    do {\n      values = getRandomInts(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Integer.MAX_VALUE - numValues); \r\n    int min = sortedValues.get(0);\n    int gap = (int)(((long)(max + numValues) - (long)min) / (long)numBuckets);\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    int minBucketVal = min;\n    for (Integer value : sortedValues) {\n      while (((long)value - (long)minBucketVal) >= (long)gap) {\n        ++bucketNum;\n        minBucketVal += gap;\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","realPath":"solr/core/src/test/org/apache/solr/schema/TestPointFields.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"N"},{"authorDate":"2017-07-12 23:59:15","commitOrder":4,"curCode":"  public void testLongPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_l_dv\";\n    String nonDocValuesField = \"number_p_l\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Long> values;\n    List<Long> sortedValues;\n    long max;\n    do {\n      values = getRandomLongs(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Long.MAX_VALUE - numValues); \r\n    long min = sortedValues.get(0);\n    BigInteger bigIntGap =  BigInteger.valueOf(max + numValues).subtract(BigInteger.valueOf(min))\n        .divide(BigInteger.valueOf(numBuckets));\n    long gap = bigIntGap.longValueExact();\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    long minBucketVal = min;\n    \r\n    \r\n    for (Long value : sortedValues) {\n      \r\n      while (BigInteger.valueOf(value).subtract(BigInteger.valueOf(minBucketVal)).compareTo(bigIntGap) > 0) {\n        ++bucketNum;\n        minBucketVal += gap;\n        \r\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","date":"2017-07-12 23:59:15","endLine":1244,"groupId":"102657","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongPointFieldRangeFacet","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4c/8ff69b09d33c1da9c9c782a2057d98630ebadc.src","preCode":"  public void testLongPointFieldRangeFacet() throws Exception {\n    String docValuesField = \"number_p_l_dv\";\n    String nonDocValuesField = \"number_p_l\";\n    int numValues = 10 * RANDOM_MULTIPLIER;\n    int numBuckets = numValues / 2;\n    List<Long> values;\n    List<Long> sortedValues;\n    long max;\n    do {\n      values = getRandomLongs(numValues, false);\n      sortedValues = values.stream().sorted().collect(Collectors.toList());\n    } while ((max = sortedValues.get(sortedValues.size() - 1)) >= Long.MAX_VALUE - numValues); \r\n    long min = sortedValues.get(0);\n    BigInteger bigIntGap =  BigInteger.valueOf(max + numValues).subtract(BigInteger.valueOf(min))\n        .divide(BigInteger.valueOf(numBuckets));\n    long gap = bigIntGap.longValueExact();\n    int[] bucketCount = new int[numBuckets];\n    int bucketNum = 0;\n    long minBucketVal = min;\n    System.err.println(\"min:\" + min + \"   max: \" + max + \"   gap: \" + gap);\n    System.err.println(\"bucketNum: \" + bucketNum + \"   minBucketVal: \" + minBucketVal);\n    for (Long value : sortedValues) {\n      System.err.println(\"value: \" + value);\n      while (BigInteger.valueOf(value).subtract(BigInteger.valueOf(minBucketVal)).compareTo(bigIntGap) > 0) {\n        ++bucketNum;\n        minBucketVal += gap;\n        System.err.println(\"bucketNum: \" + bucketNum + \"   minBucketVal: \" + minBucketVal);\n      }\n      ++bucketCount[bucketNum];\n    }\n\n    for (int i = 0 ; i < numValues ; i++) {\n      assertU(adoc(\"id\", String.valueOf(i), docValuesField, String.valueOf(values.get(i)), nonDocValuesField, String.valueOf(values.get(i))));\n    }\n    assertU(commit());\n\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(docValuesField).getType() instanceof PointField);\n    String[] testStrings = new String[numBuckets + 1];\n    testStrings[numBuckets] = \"//*[@numFound='\" + numValues + \"']\";\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + docValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap)),\n        testStrings);\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", docValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n\n    assertFalse(h.getCore().getLatestSchema().getField(nonDocValuesField).hasDocValues());\n    assertTrue(h.getCore().getLatestSchema().getField(nonDocValuesField).getType() instanceof PointField);\n    minBucketVal = min;\n    for (int i = 0 ; i < numBuckets ; minBucketVal += gap, ++i) {\n      testStrings[i] = \"//lst[@name='facet_counts']/lst[@name='facet_ranges']/lst[@name='\" + nonDocValuesField\n          + \"']/lst[@name='counts']/int[@name='\" + minBucketVal + \"'][.='\" + bucketCount[i] + \"']\";\n    }\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"filter\"),\n        testStrings);\n    \r\n    assertQ(req(\"q\", \"*:*\", \"facet\", \"true\", \"facet.range\", nonDocValuesField, \"facet.range.start\", String.valueOf(min),\n        \"facet.range.end\", String.valueOf(max), \"facet.range.gap\", String.valueOf(gap), \"facet.range.method\", \"dv\"),\n        testStrings);\n  }\n","realPath":"solr/core/src/test/org/apache/solr/schema/TestPointFields.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1177,"status":"M"}],"commitId":"00b5930cc9066ec14cc16aa665f01dc0996e9f1f","commitMessage":"@@@SOLR-10796: comment out debug printing\n","date":"2017-07-12 23:59:15","modifiedFileCount":"1","status":"M","submitter":"Steve Rowe"}]
