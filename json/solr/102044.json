[{"authorTime":"2014-01-14 01:26:38","codes":[{"authorDate":"2015-12-24 07:16:13","commitOrder":4,"curCode":"  public void openRealtimeSearcher() {\n    synchronized (this) {\n      \r\n      \r\n      try {\n        RefCounted<SolrIndexSearcher> holder = uhandler.core.openNewSearcher(true, true);\n        holder.decref();\n      } catch (Exception e) {\n        SolrException.log(log, \"Error opening realtime searcher\", e);\n        return;\n      }\n\n      if (map != null) map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n    }\n  }\n","date":"2015-12-24 07:16:13","endLine":526,"groupId":"58172","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"openRealtimeSearcher","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/32/d2d2b244cb8f87aa5f66887c986c2428fe6394.src","preCode":"  public void openRealtimeSearcher() {\n    synchronized (this) {\n      \r\n      \r\n      try {\n        RefCounted<SolrIndexSearcher> holder = uhandler.core.openNewSearcher(true, true);\n        holder.decref();\n      } catch (Exception e) {\n        SolrException.log(log, \"Error opening realtime searcher\", e);\n        return;\n      }\n\n      if (map != null) map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/UpdateLog.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":510,"status":"B"},{"authorDate":"2014-01-14 01:26:38","commitOrder":4,"curCode":"  public void deleteAll() {\n    synchronized (this) {\n\n      try {\n        RefCounted<SolrIndexSearcher> holder = uhandler.core.openNewSearcher(true, true);\n        holder.decref();\n      } catch (Exception e) {\n        SolrException.log(log, \"Error opening realtime searcher for deleteByQuery\", e);\n      }\n\n      if (map != null) map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n    }\n  }\n","date":"2014-01-14 01:26:38","endLine":526,"groupId":"5163","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteAll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/73/53bfa3e7494a972ab3afcdae2e9794940c82c4.src","preCode":"  public void deleteAll() {\n    synchronized (this) {\n\n      try {\n        RefCounted<SolrIndexSearcher> holder = uhandler.core.openNewSearcher(true, true);\n        holder.decref();\n      } catch (Exception e) {\n        SolrException.log(log, \"Error opening realtime searcher for deleteByQuery\", e);\n      }\n\n      if (map != null) map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/UpdateLog.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"NB"}],"commitId":"c5e2b3508e829f75e75667595e884a143a294824","commitMessage":"@@@SOLR-8436: filters for realtime-get\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1721585 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-12-24 07:16:13","modifiedFileCount":"3","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2014-01-14 01:26:38","codes":[{"authorDate":"2021-01-08 12:23:20","commitOrder":5,"curCode":"  public void openRealtimeSearcher() {\n    log.debug(\"openRealtimeSearcher\");\n    synchronized (this) {\n      \r\n      \r\n      try {\n        RefCounted<SolrIndexSearcher> holder = uhandler.core.openNewSearcher(true, true);\n        holder.decref();\n      } catch (Exception e) {\n        SolrException.log(log, \"Error opening realtime searcher\", e);\n        return;\n      }\n\n      if (map != null) map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n    }\n  }\n","date":"2021-01-08 12:23:20","endLine":715,"groupId":"102044","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"openRealtimeSearcher","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2b/021f386ff9a5cf333f446a05411b9811fa670f.src","preCode":"  public void openRealtimeSearcher() {\n    synchronized (this) {\n      \r\n      \r\n      try {\n        RefCounted<SolrIndexSearcher> holder = uhandler.core.openNewSearcher(true, true);\n        holder.decref();\n      } catch (Exception e) {\n        SolrException.log(log, \"Error opening realtime searcher\", e);\n        return;\n      }\n\n      if (map != null) map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/UpdateLog.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":698,"status":"M"},{"authorDate":"2014-01-14 01:26:38","commitOrder":5,"curCode":"  public void deleteAll() {\n    synchronized (this) {\n\n      try {\n        RefCounted<SolrIndexSearcher> holder = uhandler.core.openNewSearcher(true, true);\n        holder.decref();\n      } catch (Exception e) {\n        SolrException.log(log, \"Error opening realtime searcher for deleteByQuery\", e);\n      }\n\n      if (map != null) map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n    }\n  }\n","date":"2014-01-14 01:26:38","endLine":526,"groupId":"102044","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteAll","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/73/53bfa3e7494a972ab3afcdae2e9794940c82c4.src","preCode":"  public void deleteAll() {\n    synchronized (this) {\n\n      try {\n        RefCounted<SolrIndexSearcher> holder = uhandler.core.openNewSearcher(true, true);\n        holder.decref();\n      } catch (Exception e) {\n        SolrException.log(log, \"Error opening realtime searcher for deleteByQuery\", e);\n      }\n\n      if (map != null) map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/update/UpdateLog.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":509,"status":"N"}],"commitId":"4cb3ad4a1c40b4326aec64577a7e60018f7f1a5e","commitMessage":"@@@* SOLR-14923: Nested docs indexing perf & robustness (#2159)\n\n* When the schema defines _root_.  and you want to do atomic/partial updates...\n** _root_ needn't be stored or have docValues any more\n** _nest_path_ field isn't needed for this any more\n** Simplified internal logic\n* Allow (and recommend.  eventually insist) that the _root_ field be passed for atomic/partial updates to child docs.\n** In the absence of _root_.  assume the _route_ param is equivalent to ameliorate back-compat scope.  This is a temporary hack; remove in SOLR-15064.\n** One of the two is required; you'll get an exception if the assumption is false.  THIS IS A BACK-COMPAT CHANGE\n* Ensure that the update log contains the _root_ field if it's defined in the schema; in some cases it wasn't.  It's important for robustness of atomic/partial updates to child docs.  Caveat: the buffer replay scenario is not tested with child docs.\n* Limited the cases when a realtime searcher is re-opened.  It was being applied to any update that included child docs but now only some narrow subset: only for atomic/partial updates.  and when the update log contains an in-place update for the same nest because it's complicated to resolve those log entries.\n* Internal improvements to RealTimeGetComponent to aid clarity & robustness & probably performance...\n** Use SolrDocumentFetcher.solrDoc(docID.  ReturnFields) instead of more manual loading.  Will do more with this in another PR.\n** Clarify when only root doc IDs are expected.\n** Use Resolution enum more.  add PARTIAL.  remove DOC_WITH_CHILDREN; enhance docs.\n** When have ReturnFields.  a Set of \"onlyTheseFields\" becomes redundant.  Add a child doc resolution via a transformer when needed.\n** Clarified where copy-field targets are removed\n* NestPathField should default to single valued.  instead of inheriting the schema default.  which for ancient schemas was multi-valued.\n* AddUpdateCommand.getLuceneDocument(s) methods are very internal; made package visible and refactored a bit for clarity\n* DocumentBuilder: when in-place update.  skip id and _root_ here.  thus also simplifying further logic\n* NestedShardedAtomicUpdateTest no longer extends AbstractFullDistribZkTestBase because it wasn't really leveraging the \"control client\" checking.  and it added too much complexity to debug failures.","date":"2021-01-08 12:23:20","modifiedFileCount":"19","status":"M","submitter":"David Smiley"}]
