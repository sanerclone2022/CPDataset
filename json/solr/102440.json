[{"authorTime":"2021-02-19 21:40:23","codes":[{"authorDate":"2021-02-19 21:40:23","commitOrder":12,"curCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","date":"2021-02-19 21:40:23","endLine":380,"groupId":"17205","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"migrateKey","params":"(ClusterStateclusterState@DocCollectionsourceCollection@SlicesourceSlice@DocCollectiontargetCollection@SlicetargetSlice@StringsplitKey@inttimeout@@SuppressWarnings({\"rawtypes\"})NamedListresults@StringasyncId@ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0b/832ca11d767d1ecec43b35b3cbed9a640bd442.src","preCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"MB"},{"authorDate":"2021-02-19 21:40:23","commitOrder":12,"curCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","date":"2021-02-19 21:40:23","endLine":260,"groupId":"17205","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCollection","params":"(StringcollectionName@@SuppressWarnings({\"rawtypes\"})NamedListresults@CollectionCommandContextccc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/43/9d7c7d6907172cf1dc79e896bd41e04ca888f6.src","preCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CollectionHandlingUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":254,"status":"B"}],"commitId":"e7c80f6445a04cb3d1b49d85d773fde283c916fe","commitMessage":"@@@SOLR-15157: refactor Collection API to separate from Overseer and message handling abstractions (#2390)\n\nNo functional changes. In preparation of distributing the Collection API command execution.","date":"2021-02-19 21:40:23","modifiedFileCount":"42","status":"M","submitter":"Ilan Ginzburg"},{"authorTime":"2021-02-19 21:40:23","codes":[{"authorDate":"2021-04-08 18:51:04","commitOrder":13,"curCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.newShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","date":"2021-04-08 18:51:04","endLine":380,"groupId":"17205","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"migrateKey","params":"(ClusterStateclusterState@DocCollectionsourceCollection@SlicesourceSlice@DocCollectiontargetCollection@SlicetargetSlice@StringsplitKey@inttimeout@@SuppressWarnings({\"rawtypes\"})NamedListresults@StringasyncId@ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/80/818a8cf49f386c7932f2ceda848c3c160a1c72.src","preCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":136,"status":"M"},{"authorDate":"2021-02-19 21:40:23","commitOrder":13,"curCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","date":"2021-02-19 21:40:23","endLine":260,"groupId":"17205","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCollection","params":"(StringcollectionName@@SuppressWarnings({\"rawtypes\"})NamedListresults@CollectionCommandContextccc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/43/9d7c7d6907172cf1dc79e896bd41e04ca888f6.src","preCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CollectionHandlingUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":254,"status":"N"}],"commitId":"51e749d40486815d70b249ef1a02ce1cd3a644c1","commitMessage":"@@@SOLR-15157: rename getShardHandler into newShardHandler in CollectionCommandContext (#62)\n\n","date":"2021-04-08 18:51:04","modifiedFileCount":"13","status":"M","submitter":"Ilan Ginzburg"},{"authorTime":"2021-06-03 06:17:26","codes":[{"authorDate":"2021-06-03 06:17:26","commitOrder":14,"curCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.newShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = Utils.makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","date":"2021-06-03 06:17:26","endLine":379,"groupId":"37391","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"migrateKey","params":"(ClusterStateclusterState@DocCollectionsourceCollection@SlicesourceSlice@DocCollectiontargetCollection@SlicetargetSlice@StringsplitKey@inttimeout@@SuppressWarnings({\"rawtypes\"})NamedListresults@StringasyncId@ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d1/7f28fa81ec47316c353f3987f1dd8bbe0f6b7a.src","preCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.newShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"M"},{"authorDate":"2021-06-03 06:17:26","commitOrder":14,"curCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = Map.of(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","date":"2021-06-03 06:17:26","endLine":260,"groupId":"35290","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCollection","params":"(StringcollectionName@@SuppressWarnings({\"rawtypes\"})NamedListresults@CollectionCommandContextccc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f5/6c9aad3715481e877a558ea493d58697e9531e.src","preCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CollectionHandlingUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":254,"status":"M"}],"commitId":"c8e06a7298a2745c2b83102169073e2f8e8eceb5","commitMessage":"@@@SOLR-15385 Address many rawtypes warnings (#107)\n\nAddressed significant usage of raw types with Class.  Map.  and SolrRequest; removed over 400 SuppressWarning annotations.\n\nMap construction was replaced with Map.of when immutability was possible.  and Utils.makeMap when a mutable map was required.\n\nDiscovered a potential bug in the PackageStore tests where not all assertions were being verified - these tests will be fixed separately.\n\nCo-authored-by: David Smiley <dsmiley@salesforce.com>","date":"2021-06-03 06:17:26","modifiedFileCount":"244","status":"M","submitter":"Mike Drob"},{"authorTime":"2021-06-03 06:17:26","codes":[{"authorDate":"2021-06-25 13:22:29","commitOrder":15,"curCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.newShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = sourceCollection.getConfigName();\n    Map<String, Object> props = Utils.makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","date":"2021-06-25 13:22:29","endLine":379,"groupId":"37391","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"migrateKey","params":"(ClusterStateclusterState@DocCollectionsourceCollection@SlicesourceSlice@DocCollectiontargetCollection@SlicetargetSlice@StringsplitKey@inttimeout@@SuppressWarnings({\"rawtypes\"})NamedListresults@StringasyncId@ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/74/6488fcba9efda70ec853fa061c8bf2ca5f03f1.src","preCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.newShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = Utils.makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"M"},{"authorDate":"2021-06-03 06:17:26","commitOrder":15,"curCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = Map.of(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","date":"2021-06-03 06:17:26","endLine":260,"groupId":"35290","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"cleanupCollection","params":"(StringcollectionName@@SuppressWarnings({\"rawtypes\"})NamedListresults@CollectionCommandContextccc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f5/6c9aad3715481e877a558ea493d58697e9531e.src","preCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = Map.of(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CollectionHandlingUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":254,"status":"N"}],"commitId":"caca8279586ffecf9e6a6e80515d3fd531d06c85","commitMessage":"@@@SOLR-14341: Move configName into DocCollection (state.json) (#17)\n\nSolrCloud: move the reference a collection has to a configSet in ZooKeeper from the\n  collections/collectionName into its state.json.  For many-collection clusters.  this is an\n  optimization when the cluster status is fetched.\n\nCo-authored-by: Nazerke Seidan <nseidan@salesforce.com>\nCo-authored-by: David Smiley <dsmiley@salesforce.com>","date":"2021-06-25 13:22:29","modifiedFileCount":"34","status":"M","submitter":"Nazerke Seidan"},{"authorTime":"2021-07-08 04:15:36","codes":[{"authorDate":"2021-07-08 04:15:36","commitOrder":16,"curCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList<Object> results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.newShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = sourceCollection.getConfigName();\n    Map<String, Object> props = Utils.makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","date":"2021-07-08 04:15:36","endLine":378,"groupId":"102440","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"migrateKey","params":"(ClusterStateclusterState@DocCollectionsourceCollection@SlicesourceSlice@DocCollectiontargetCollection@SlicetargetSlice@StringsplitKey@inttimeout@NamedList<Object>results@StringasyncId@ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/59/4c49b1f174ceca61e1743bddfd3aba5ca963b8.src","preCode":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ccc.getZkStateReader();\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandler shardHandler = ccc.newShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    \r\n    \r\n    DocRouter.Range splitRange = intersect(targetSlice.getRange(), intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceAddRoutingRule, m,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      ccc.offerStateUpdate(Utils.toJSON(m));\n    }\n\n    \r\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, ccc.getSolrCloudManager().getTimeSource());\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    \r\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    \r\n    String configName = sourceCollection.getConfigName();\n    Map<String, Object> props = Utils.makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        CollectionHandlingUtils.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        CollectionHandlingUtils.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    new CreateCollectionCmd(ccc).call(clusterState, new ZkNodeProps(props), results);\n    \r\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      \r\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ccc.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    \r\n    for (String key : message.keySet()) {\n      if (key.startsWith(CollectionAdminParams.PROPERTY_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    \r\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    new AddReplicaCmd(ccc).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = CollectionHandlingUtils.syncRequestTracker(ccc);\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = CollectionHandlingUtils.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2, ccc.getZkStateReader());\n    \r\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n      shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = CollectionHandlingUtils.asyncRequestTracker(asyncId, ccc);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = Map.of(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      new DeleteCollectionCmd(ccc).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":134,"status":"M"},{"authorDate":"2021-07-08 04:15:36","commitOrder":16,"curCode":"  static void cleanupCollection(String collectionName, NamedList<Object> results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = Map.of(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","date":"2021-07-08 04:15:36","endLine":254,"groupId":"102440","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"cleanupCollection","params":"(StringcollectionName@NamedList<Object>results@CollectionCommandContextccc)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/80/34817554376e47cdfacbfa6cb7c60ecd2e2755.src","preCode":"  static void cleanupCollection(String collectionName, @SuppressWarnings({\"rawtypes\"})NamedList results, CollectionCommandContext ccc) throws Exception {\n    log.error(\"Cleaning up collection [{}].\", collectionName);\n    Map<String, Object> props = Map.of(\n        Overseer.QUEUE_OPERATION, DELETE.toLower(),\n        NAME, collectionName);\n    new DeleteCollectionCmd(ccc).call(ccc.getZkStateReader().getClusterState(), new ZkNodeProps(props), results);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CollectionHandlingUtils.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":248,"status":"M"}],"commitId":"201d56b350fa1b4e5f8361618f898a2155240c72","commitMessage":"@@@SOLR-15385 RawTypes Part V (#196)\n\n","date":"2021-07-08 04:15:36","modifiedFileCount":"88","status":"M","submitter":"Mike Drob"}]
