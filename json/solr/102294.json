[{"authorTime":"2018-02-10 00:47:36","codes":[{"authorDate":"2018-03-05 12:50:54","commitOrder":5,"curCode":"  private Collection<?> excludeSet(@SuppressWarnings(\"rawtypes\") \n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          \r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    return excludeSet.keySet();\n  }\n","date":"2018-03-11 13:25:05","endLine":183,"groupId":"52005","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"excludeSet","params":"(@SuppressWarnings(\"rawtypes\")MaptagMap@Set<String>tagsToExclude)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6c/2172eccb71d030ec9e6ae456cc77e624110c08.src","preCode":"  private Collection<?> excludeSet(@SuppressWarnings(\"rawtypes\") \n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          \r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    return excludeSet.keySet();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/join/FiltersQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"B"},{"authorDate":"2018-02-10 00:47:36","commitOrder":5,"curCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","date":"2018-02-10 00:50:28","endLine":277,"groupId":"52381","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"computeDocSet","params":"(DocSetbaseDocSet@List<String>excludeTagList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0b/5a08227d96edb9c777984355d38ddbbecc1df9.src","preCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/request/SimpleFacets.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":223,"status":"NB"}],"commitId":"fa55f0c2f2c4af8bca2cd53a76ee6c3142d72ce8","commitMessage":"@@@SOLR-9510: introducting {!filter param=$fq excludeTags=t. q}foo:bar.  also adding\nfilters and excludeTags local params into {!parent} and {!child}\n","date":"2018-03-11 13:25:05","modifiedFileCount":"6","status":"M","submitter":"Mikhail Khludnev"},{"authorTime":"2019-07-03 21:49:12","codes":[{"authorDate":"2018-03-05 12:50:54","commitOrder":6,"curCode":"  private Collection<?> excludeSet(@SuppressWarnings(\"rawtypes\") \n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          \r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    return excludeSet.keySet();\n  }\n","date":"2018-03-11 13:25:05","endLine":183,"groupId":"52005","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"excludeSet","params":"(@SuppressWarnings(\"rawtypes\")MaptagMap@Set<String>tagsToExclude)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6c/2172eccb71d030ec9e6ae456cc77e624110c08.src","preCode":"  private Collection<?> excludeSet(@SuppressWarnings(\"rawtypes\") \n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          \r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    return excludeSet.keySet();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/join/FiltersQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"N"},{"authorDate":"2019-07-03 21:49:12","commitOrder":6,"curCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","date":"2019-07-03 22:03:08","endLine":278,"groupId":"6867","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"computeDocSet","params":"(DocSetbaseDocSet@List<String>excludeTagList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/92/f9a66dea0034abcd00fa2a3d8068536a4a577d.src","preCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/request/SimpleFacets.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":224,"status":"M"}],"commitId":"e3d247f288f2bbfc8f73858fa35481a611bb16cf","commitMessage":"@@@SOLR-13603: remove deprecated groupSpec methods usage\n\nThis is precursor to removing deprecated methods\n","date":"2019-07-03 22:03:08","modifiedFileCount":"8","status":"M","submitter":"Munendra S N"},{"authorTime":"2020-06-13 23:00:58","codes":[{"authorDate":"2018-03-05 12:50:54","commitOrder":7,"curCode":"  private Collection<?> excludeSet(@SuppressWarnings(\"rawtypes\") \n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          \r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    return excludeSet.keySet();\n  }\n","date":"2018-03-11 13:25:05","endLine":183,"groupId":"52005","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"excludeSet","params":"(@SuppressWarnings(\"rawtypes\")MaptagMap@Set<String>tagsToExclude)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/6c/2172eccb71d030ec9e6ae456cc77e624110c08.src","preCode":"  private Collection<?> excludeSet(@SuppressWarnings(\"rawtypes\") \n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          \r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    return excludeSet.keySet();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/join/FiltersQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":163,"status":"N"},{"authorDate":"2020-06-13 23:00:58","commitOrder":7,"curCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","date":"2020-06-13 23:00:58","endLine":277,"groupId":"6867","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"computeDocSet","params":"(DocSetbaseDocSet@List<String>excludeTagList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/fc/462ddcc9aee3805ffc4e1bb71ebb2f8258d726.src","preCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/request/SimpleFacets.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"}],"commitId":"a41aa20b0afaadf47ec6e58476a947c6936c1921","commitMessage":"@@@SOLR-14564: Fix or suppress remaining warnings in solr/core\n","date":"2020-06-13 23:00:58","modifiedFileCount":"91","status":"M","submitter":"Erick Erickson"},{"authorTime":"2020-06-13 23:00:58","codes":[{"authorDate":"2020-06-28 21:29:24","commitOrder":8,"curCode":"  private Collection<QParser> excludeSet(@SuppressWarnings(\"rawtypes\")\n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<QParser,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp, Boolean.TRUE);\n      }\n    }\n    return excludeSet.keySet();\n  }\n","date":"2020-06-30 23:55:07","endLine":132,"groupId":"52005","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"excludeSet","params":"(@SuppressWarnings(\"rawtypes\")MaptagMap@Set<String>tagsToExclude)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/85/1f48b803440b31dbb8b282fd21dcae6b9d19d9.src","preCode":"  private Collection<?> excludeSet(@SuppressWarnings(\"rawtypes\") \n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        try {\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        } catch (SyntaxError syntaxError) {\n          \r\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, syntaxError);\n        }\n      }\n    }\n    return excludeSet.keySet();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/join/FiltersQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"M"},{"authorDate":"2020-06-13 23:00:58","commitOrder":8,"curCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","date":"2020-06-13 23:00:58","endLine":277,"groupId":"6867","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"computeDocSet","params":"(DocSetbaseDocSet@List<String>excludeTagList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/fc/462ddcc9aee3805ffc4e1bb71ebb2f8258d726.src","preCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/request/SimpleFacets.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"N"}],"commitId":"f647400e31c0fb238744cece8d3943bc15253ec7","commitMessage":"@@@SOLR-14539: Introducing {!bool excludeTags=foo. bar}\n","date":"2020-06-30 23:55:07","modifiedFileCount":"3","status":"M","submitter":"Mikhail Khludnev"},{"authorTime":"2021-07-08 04:15:36","codes":[{"authorDate":"2020-06-28 21:29:24","commitOrder":9,"curCode":"  private Collection<QParser> excludeSet(@SuppressWarnings(\"rawtypes\")\n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<QParser,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp, Boolean.TRUE);\n      }\n    }\n    return excludeSet.keySet();\n  }\n","date":"2020-06-30 23:55:07","endLine":132,"groupId":"52005","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"excludeSet","params":"(@SuppressWarnings(\"rawtypes\")MaptagMap@Set<String>tagsToExclude)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/85/1f48b803440b31dbb8b282fd21dcae6b9d19d9.src","preCode":"  private Collection<QParser> excludeSet(@SuppressWarnings(\"rawtypes\")\n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<QParser,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp, Boolean.TRUE);\n      }\n    }\n    return excludeSet.keySet();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/join/FiltersQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":117,"status":"N"},{"authorDate":"2021-07-08 04:15:36","commitOrder":9,"curCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector<?> allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","date":"2021-07-08 04:15:36","endLine":276,"groupId":"6867","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"computeDocSet","params":"(DocSetbaseDocSet@List<String>excludeTagList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/48/e9425860b632f0051ca270ddc3de4b9996676c.src","preCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      AllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/request/SimpleFacets.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"}],"commitId":"201d56b350fa1b4e5f8361618f898a2155240c72","commitMessage":"@@@SOLR-15385 RawTypes Part V (#196)\n\n","date":"2021-07-08 04:15:36","modifiedFileCount":"88","status":"M","submitter":"Mike Drob"},{"authorTime":"2021-07-08 04:15:36","codes":[{"authorDate":"2021-07-13 23:49:56","commitOrder":10,"curCode":"  private Collection<QParser> excludeSet(Map<?, ?> tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<QParser,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp, Boolean.TRUE);\n      }\n    }\n    return excludeSet.keySet();\n  }\n","date":"2021-07-13 23:49:56","endLine":130,"groupId":"102294","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"excludeSet","params":"(Map<?@?>tagMap@Set<String>tagsToExclude)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c7/d9befaeaa8c71dd36b4c3bc66cdcbbbc9fd615.src","preCode":"  private Collection<QParser> excludeSet(@SuppressWarnings(\"rawtypes\")\n                                     Map tagMap, Set<String> tagsToExclude) {\n\n    IdentityHashMap<QParser,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : tagsToExclude) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp, Boolean.TRUE);\n      }\n    }\n    return excludeSet.keySet();\n  }\n","realPath":"solr/core/src/java/org/apache/solr/search/join/FiltersQParser.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":116,"status":"M"},{"authorDate":"2021-07-08 04:15:36","commitOrder":10,"curCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector<?> allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","date":"2021-07-08 04:15:36","endLine":276,"groupId":"102294","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"computeDocSet","params":"(DocSetbaseDocSet@List<String>excludeTagList)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/48/e9425860b632f0051ca270ddc3de4b9996676c.src","preCode":"  protected DocSet computeDocSet(DocSet baseDocSet, List<String> excludeTagList) throws SyntaxError, IOException {\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    \r\n    if (tagMap == null || rb == null) {\n      return baseDocSet;\n    }\n\n    IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n    for (String excludeTag : excludeTagList) {\n      Object olst = tagMap.get(excludeTag);\n      \r\n      if (!(olst instanceof Collection)) continue;\n      for (Object o : (Collection<?>)olst) {\n        if (!(o instanceof QParser)) continue;\n        QParser qp = (QParser)o;\n        excludeSet.put(qp.getQuery(), Boolean.TRUE);\n      }\n    }\n    if (excludeSet.size() == 0) return baseDocSet;\n\n    List<Query> qlist = new ArrayList<>();\n\n    \r\n    if (!excludeSet.containsKey(rb.getQuery())) {\n      qlist.add(rb.getQuery());\n    }\n\n    \r\n    if (rb.getFilters() != null) {\n      for (Query q : rb.getFilters()) {\n        if (!excludeSet.containsKey(q)) {\n          qlist.add(q);\n        }\n      }\n    }\n\n    \r\n    DocSet base = searcher.getDocSet(qlist);\n    if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n      Grouping grouping = new Grouping(searcher, null, rb.createQueryCommand(), false, 0, false);\n      grouping.setWithinGroupSort(rb.getGroupingSpec().getWithinGroupSortSpec().getSort());\n      if (rb.getGroupingSpec().getFields().length > 0) {\n        grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n      } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n        grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n      } else {\n        return base;\n      }\n      AllGroupHeadsCollector<?> allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n      searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n      return new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n    } else {\n      return base;\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/request/SimpleFacets.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"N"}],"commitId":"09986130545fabfb2cc76ced85a0da6ba536acf0","commitMessage":"@@@SOLR-15385 RawTypes Part VI (#207)\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>","date":"2021-07-13 23:49:56","modifiedFileCount":"185","status":"M","submitter":"Mike Drob"}]
