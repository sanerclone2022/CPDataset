[{"authorTime":"2012-02-19 22:13:45","codes":[{"authorDate":"2012-01-26 03:49:26","commitOrder":2,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n      h.close();\n\n      String[] files = UpdateLog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, UpdateLog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<Long>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, UpdateLog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = UpdateLog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2012-01-26 03:49:26","endLine":567,"groupId":"51802","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/26/13bc062c23d91fdea05ba0fed985348d6bff9e.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n      h.close();\n\n      String[] files = UpdateLog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, UpdateLog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<Long>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, UpdateLog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = UpdateLog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":460,"status":"NB"},{"authorDate":"2012-02-19 22:13:45","commitOrder":2,"curCode":"  void deleteLogs() throws Exception {\n    File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n    h.close();\n\n    String[] files = UpdateLog.getLogList(logDir);\n    for (String file : files) {\n      new File(logDir, file).delete();\n    }\n\n    assertEquals(0, UpdateLog.getLogList(logDir).length);\n    createCore();\n  }\n","date":"2012-02-19 22:13:45","endLine":714,"groupId":"51802","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/97/342d1e0dd8d0966bf508459191053d1c352ba6.src","preCode":"  void deleteLogs() throws Exception {\n    File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n    h.close();\n\n    String[] files = UpdateLog.getLogList(logDir);\n    for (String file : files) {\n      new File(logDir, file).delete();\n    }\n\n    assertEquals(0, UpdateLog.getLogList(logDir).length);\n    createCore();\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":702,"status":"B"}],"commitId":"2e07171d1fd48651ae5a995039fbbaba6009604c","commitMessage":"@@@SOLR-3126: test changes to handle deletes surviving restart\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1291003 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-02-19 22:13:45","modifiedFileCount":"1","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2012-09-15 06:40:41","codes":[{"authorDate":"2012-01-26 03:49:26","commitOrder":3,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n      h.close();\n\n      String[] files = UpdateLog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, UpdateLog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<Long>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, UpdateLog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = UpdateLog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2012-01-26 03:49:26","endLine":567,"groupId":"51802","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/26/13bc062c23d91fdea05ba0fed985348d6bff9e.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n      h.close();\n\n      String[] files = UpdateLog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, UpdateLog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<Long>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, UpdateLog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = UpdateLog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":460,"status":"N"},{"authorDate":"2012-09-15 06:40:41","commitOrder":3,"curCode":"  void deleteLogs() throws Exception {\n    File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n    h.close();\n\n    try {\n      String[] files = UpdateLog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, UpdateLog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","date":"2012-09-15 06:40:41","endLine":1057,"groupId":"51803","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/55/1769ef11a03c1cbbe88d44c91af70375fbf02b.src","preCode":"  void deleteLogs() throws Exception {\n    File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n    h.close();\n\n    String[] files = UpdateLog.getLogList(logDir);\n    for (String file : files) {\n      new File(logDir, file).delete();\n    }\n\n    assertEquals(0, UpdateLog.getLogList(logDir).length);\n    createCore();\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1039,"status":"M"}],"commitId":"3c95aa47d0ddee07070f04534d33f91fa044b445","commitMessage":"@@@tlog: ensure tlog so corrupted that constructor can't complete is closed so windows can remove the file after\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1384958 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-09-15 06:40:41","modifiedFileCount":"3","status":"M","submitter":"Yonik Seeley"},{"authorTime":"2013-06-27 04:18:33","codes":[{"authorDate":"2013-06-27 04:18:33","commitOrder":4,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<Long>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, ulog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2013-06-27 04:18:33","endLine":837,"groupId":"51802","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4b/5ed59259d23ff0e4b0d5a613afd05a1b639a8c.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n      h.close();\n\n      String[] files = UpdateLog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, UpdateLog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<Long>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, UpdateLog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, UpdateLog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = UpdateLog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":729,"status":"M"},{"authorDate":"2013-06-27 04:18:33","commitOrder":4,"curCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","date":"2013-06-27 04:18:33","endLine":1106,"groupId":"51803","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4b/5ed59259d23ff0e4b0d5a613afd05a1b639a8c.src","preCode":"  void deleteLogs() throws Exception {\n    File logDir = h.getCore().getUpdateHandler().getUpdateLog().getLogDir();\n\n    h.close();\n\n    try {\n      String[] files = UpdateLog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, UpdateLog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1087,"status":"M"}],"commitId":"b9e1537a7e12e6c15622452e48d8ca8c23aa98c4","commitMessage":"@@@SOLR-4916: Add support to write and read Solr index files and transaction log files to and from HDFS.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1497072 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-06-27 04:18:33","modifiedFileCount":"42","status":"M","submitter":"Mark Robert Miller"},{"authorTime":"2013-06-27 04:18:33","codes":[{"authorDate":"2014-03-12 22:39:17","commitOrder":5,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, ulog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2014-03-12 22:39:17","endLine":837,"groupId":"51802","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1b/8bc633cd9e90f94f77b0ad52d2a6db02a4f5b8.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<Long>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, ulog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":729,"status":"M"},{"authorDate":"2013-06-27 04:18:33","commitOrder":5,"curCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","date":"2013-06-27 04:18:33","endLine":1106,"groupId":"51803","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4b/5ed59259d23ff0e4b0d5a613afd05a1b639a8c.src","preCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1087,"status":"N"}],"commitId":"3b67b17493216f6b0c81a981073fd5f61eace6f4","commitMessage":"@@@LUCENE-5512: remove redundant typing (diamond operator) in trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1576755 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-03-12 22:39:17","modifiedFileCount":"1241","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-09-04 23:56:25","codes":[{"authorDate":"2014-09-04 23:56:25","commitOrder":6,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, ulog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2014-09-04 23:56:25","endLine":839,"groupId":"51802","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/87/0eb3bfd605a96c3ff17409f6032502fc12dfed.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, ulog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":731,"status":"M"},{"authorDate":"2014-09-04 23:56:25","commitOrder":6,"curCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","date":"2014-09-04 23:56:25","endLine":1108,"groupId":"12300","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/87/0eb3bfd605a96c3ff17409f6032502fc12dfed.src","preCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        new File(logDir, file).delete();\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1089,"status":"M"}],"commitId":"3604769c3abad5b41a84fdd390ec3493b5804abc","commitMessage":"@@@LUCENE-5906: Use Files.delete everywhere instead of File.delete\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1622506 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-09-04 23:56:25","modifiedFileCount":"72","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-09-04 23:56:25","codes":[{"authorDate":"2015-03-07 19:40:37","commitOrder":7,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int numIndexed = 0;\n      int maxReq = 200;\n\n      LinkedList<Long> versions = new LinkedList<>();\n\n      int docsPerBatch = 3;\n      \r\n      int expectedToRetain = ulog.getMaxNumLogsToKeep() * docsPerBatch;\n      int versExpected;\n\n      for (int i = 1; i <= ulog.getMaxNumLogsToKeep() + 2; i ++) {\n        addDocs(docsPerBatch, numIndexed, versions); numIndexed += docsPerBatch;\n        versExpected = Math.min(numIndexed, expectedToRetain + docsPerBatch); \r\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertU(commit());\n        versExpected = Math.min(numIndexed, expectedToRetain);\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertEquals(Math.min(i, ulog.getMaxNumLogsToKeep()), ulog.getLogList(logDir).length);\n      }\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, numIndexed, versions);  numIndexed+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, numIndexed, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2015-03-07 19:40:37","endLine":845,"groupId":"49691","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/5d/6ced464c192fc7828ba57ab3222d7d0b4eda72.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int start = 0;\n      int maxReq = 50;\n\n      LinkedList<Long> versions = new LinkedList<>();\n      addDocs(10, start, versions); start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(10, start, versions);  start+=10;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      assertEquals(2, ulog.getLogList(logDir).length);\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, start, versions);  start+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      addDocs(105, start, versions);  start+=105;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n      assertU(commit());\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,start)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, start, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, start)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":720,"status":"M"},{"authorDate":"2014-09-04 23:56:25","commitOrder":7,"curCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","date":"2014-09-04 23:56:25","endLine":1108,"groupId":"12300","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/87/0eb3bfd605a96c3ff17409f6032502fc12dfed.src","preCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1089,"status":"N"}],"commitId":"65b033712b921f24ea01c4cf4971d5d3f6e4349e","commitMessage":"@@@SOLR-6359: Allow customization of the number of records and logs kept by UpdateLog\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1664825 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-03-07 19:40:37","modifiedFileCount":"6","status":"M","submitter":"Ramkumar Aiyengar"},{"authorTime":"2014-09-04 23:56:25","codes":[{"authorDate":"2016-03-04 21:23:47","commitOrder":8,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = () -> {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int numIndexed = 0;\n      int maxReq = 200;\n\n      LinkedList<Long> versions = new LinkedList<>();\n\n      int docsPerBatch = 3;\n      \r\n      int expectedToRetain = ulog.getMaxNumLogsToKeep() * docsPerBatch;\n      int versExpected;\n\n      for (int i = 1; i <= ulog.getMaxNumLogsToKeep() + 2; i ++) {\n        addDocs(docsPerBatch, numIndexed, versions); numIndexed += docsPerBatch;\n        versExpected = Math.min(numIndexed, expectedToRetain + docsPerBatch); \r\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertU(commit());\n        versExpected = Math.min(numIndexed, expectedToRetain);\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertEquals(Math.min(i, ulog.getMaxNumLogsToKeep()), ulog.getLogList(logDir).length);\n      }\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, numIndexed, versions);  numIndexed+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, numIndexed, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2016-03-04 21:23:47","endLine":901,"groupId":"49691","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/30/7492f53b602d299d6e1c3dfd2f814145a8aa99.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = new Runnable() {\n        @Override\n        public void run() {\n          try {\n            assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = new Runnable() {\n        @Override\n        public void run() {\n          logReplayFinish.release();\n        }\n      };\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int numIndexed = 0;\n      int maxReq = 200;\n\n      LinkedList<Long> versions = new LinkedList<>();\n\n      int docsPerBatch = 3;\n      \r\n      int expectedToRetain = ulog.getMaxNumLogsToKeep() * docsPerBatch;\n      int versExpected;\n\n      for (int i = 1; i <= ulog.getMaxNumLogsToKeep() + 2; i ++) {\n        addDocs(docsPerBatch, numIndexed, versions); numIndexed += docsPerBatch;\n        versExpected = Math.min(numIndexed, expectedToRetain + docsPerBatch); \r\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertU(commit());\n        versExpected = Math.min(numIndexed, expectedToRetain);\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertEquals(Math.min(i, ulog.getMaxNumLogsToKeep()), ulog.getLogList(logDir).length);\n      }\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, numIndexed, versions);  numIndexed+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, numIndexed, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":784,"status":"M"},{"authorDate":"2014-09-04 23:56:25","commitOrder":8,"curCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","date":"2014-09-04 23:56:25","endLine":1108,"groupId":"12300","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/87/0eb3bfd605a96c3ff17409f6032502fc12dfed.src","preCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1089,"status":"N"}],"commitId":"c27dd8e03866082686ab3d17f7350f91975a8efc","commitMessage":"@@@SOLR-8750 : Use lambdas in code where SAM type interfaces are used\n","date":"2016-03-04 21:23:47","modifiedFileCount":"45","status":"M","submitter":"Noble Paul"},{"authorTime":"2014-09-04 23:56:25","codes":[{"authorDate":"2019-08-10 16:21:11","commitOrder":9,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = () -> {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int numIndexed = 0;\n      int maxReq = 200;\n\n      LinkedList<Long> versions = new LinkedList<>();\n\n      int docsPerBatch = 3;\n      \r\n      int expectedToRetain = ulog.getMaxNumLogsToKeep() * docsPerBatch;\n      int versExpected;\n\n      for (int i = 1; i <= ulog.getMaxNumLogsToKeep() + 2; i ++) {\n        addDocs(docsPerBatch, numIndexed, versions); numIndexed += docsPerBatch;\n        versExpected = Math.min(numIndexed, expectedToRetain + docsPerBatch); \r\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertU(commit());\n        versExpected = Math.min(numIndexed, expectedToRetain);\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertEquals(Math.min(i, ulog.getMaxNumLogsToKeep()), ulog.getLogList(logDir).length);\n      }\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, numIndexed, versions);  numIndexed+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, numIndexed, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      try (RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length - 1]), \"rw\")) {\n        raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      }\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2019-08-10 16:21:11","endLine":1304,"groupId":"49691","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/09/b9b2f15e2a9f50a5444c2d978ce6378500e0f5.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = () -> {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int numIndexed = 0;\n      int maxReq = 200;\n\n      LinkedList<Long> versions = new LinkedList<>();\n\n      int docsPerBatch = 3;\n      \r\n      int expectedToRetain = ulog.getMaxNumLogsToKeep() * docsPerBatch;\n      int versExpected;\n\n      for (int i = 1; i <= ulog.getMaxNumLogsToKeep() + 2; i ++) {\n        addDocs(docsPerBatch, numIndexed, versions); numIndexed += docsPerBatch;\n        versExpected = Math.min(numIndexed, expectedToRetain + docsPerBatch); \r\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertU(commit());\n        versExpected = Math.min(numIndexed, expectedToRetain);\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertEquals(Math.min(i, ulog.getMaxNumLogsToKeep()), ulog.getLogList(logDir).length);\n      }\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, numIndexed, versions);  numIndexed+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, numIndexed, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length-1]), \"rw\");\n      raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      raf.close();\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1187,"status":"M"},{"authorDate":"2014-09-04 23:56:25","commitOrder":9,"curCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","date":"2014-09-04 23:56:25","endLine":1108,"groupId":"12300","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/87/0eb3bfd605a96c3ff17409f6032502fc12dfed.src","preCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1089,"status":"N"}],"commitId":"9546d8612ca050021db894fc8001134a6fdbf654","commitMessage":"@@@SOLR-13680: use try-with-resource to close closeable resources\n\ncloses #822\n","date":"2019-08-10 16:21:11","modifiedFileCount":"11","status":"M","submitter":"Munendra S N"},{"authorTime":"2014-09-04 23:56:25","codes":[{"authorDate":"2020-01-17 02:47:06","commitOrder":10,"curCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      TestInjection.skipIndexWriterCommitOnClose = true;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = () -> {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int numIndexed = 0;\n      int maxReq = 200;\n\n      LinkedList<Long> versions = new LinkedList<>();\n\n      int docsPerBatch = 3;\n      \r\n      int expectedToRetain = ulog.getMaxNumLogsToKeep() * docsPerBatch;\n      int versExpected;\n\n      for (int i = 1; i <= ulog.getMaxNumLogsToKeep() + 2; i ++) {\n        addDocs(docsPerBatch, numIndexed, versions); numIndexed += docsPerBatch;\n        versExpected = Math.min(numIndexed, expectedToRetain + docsPerBatch); \r\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertU(commit());\n        versExpected = Math.min(numIndexed, expectedToRetain);\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertEquals(Math.min(i, ulog.getMaxNumLogsToKeep()), ulog.getLogList(logDir).length);\n      }\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, numIndexed, versions);  numIndexed+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, numIndexed, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      try (RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length - 1]), \"rw\")) {\n        raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      }\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n      resetExceptionIgnores();\n\n    } finally {\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","date":"2020-01-17 02:47:06","endLine":1294,"groupId":"103123","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"testRemoveOldLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f4/df24c94837119d590d125caf3ff7e4ac72a719.src","preCode":"  public void testRemoveOldLogs() throws Exception {\n    try {\n      DirectUpdateHandler2.commitOnClose = false;\n      final Semaphore logReplay = new Semaphore(0);\n      final Semaphore logReplayFinish = new Semaphore(0);\n\n      UpdateLog.testing_logReplayHook = () -> {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      };\n\n      UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n      clearIndex();\n      assertU(commit());\n\n      UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n      File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n      h.close();\n\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n\n      createCore();\n\n      int numIndexed = 0;\n      int maxReq = 200;\n\n      LinkedList<Long> versions = new LinkedList<>();\n\n      int docsPerBatch = 3;\n      \r\n      int expectedToRetain = ulog.getMaxNumLogsToKeep() * docsPerBatch;\n      int versExpected;\n\n      for (int i = 1; i <= ulog.getMaxNumLogsToKeep() + 2; i ++) {\n        addDocs(docsPerBatch, numIndexed, versions); numIndexed += docsPerBatch;\n        versExpected = Math.min(numIndexed, expectedToRetain + docsPerBatch); \r\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertU(commit());\n        versExpected = Math.min(numIndexed, expectedToRetain);\n        assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n        assertEquals(Math.min(i, ulog.getMaxNumLogsToKeep()), ulog.getLogList(logDir).length);\n      }\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      versExpected = Math.min(numIndexed, expectedToRetain);\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, versExpected)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      addDocs(1, numIndexed, versions);  numIndexed+=1;\n      h.close();\n      createCore();      \r\n\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n\n      logReplay.release(1000);\n      assertTrue(logReplayFinish.tryAcquire(timeout, TimeUnit.SECONDS));\n\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      docsPerBatch = ulog.getNumRecordsToKeep() + 20;\n      \r\n      expectedToRetain = ulog.getNumRecordsToKeep();\n\n      addDocs(docsPerBatch, numIndexed, versions);  numIndexed+=docsPerBatch;\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n      assertU(commit());\n      expectedToRetain = expectedToRetain - 1; \r\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"\"+maxReq), \"/versions==\" + versions.subList(0,Math.min(maxReq,expectedToRetain)));\n\n      \r\n      assertEquals(1, ulog.getLogList(logDir).length);\n\n      \r\n      \r\n      \r\n      addDocs(1, numIndexed, new LinkedList<Long>()); \r\n      h.close();\n      files = ulog.getLogList(logDir);\n      Arrays.sort(files);\n      try (RandomAccessFile raf = new RandomAccessFile(new File(logDir, files[files.length - 1]), \"rw\")) {\n        raf.writeChars(\"This is a trashed log file that really shouldn't work at all, but we'll see...\");\n      }\n\n      ignoreException(\"Failure to open existing\");\n      createCore();\n      \r\n      assertJQ(req(\"qt\", \"/get\", \"getVersions\", \"\" + maxReq), \"/versions==\" + versions.subList(0, Math.min(maxReq, expectedToRetain)));\n      resetExceptionIgnores();\n\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1178,"status":"M"},{"authorDate":"2014-09-04 23:56:25","commitOrder":10,"curCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","date":"2014-09-04 23:56:25","endLine":1108,"groupId":"103123","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteLogs","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/87/0eb3bfd605a96c3ff17409f6032502fc12dfed.src","preCode":"  void deleteLogs() throws Exception {\n    UpdateLog ulog = h.getCore().getUpdateHandler().getUpdateLog();\n    File logDir = new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());\n\n    h.close();\n\n    try {\n      String[] files = ulog.getLogList(logDir);\n      for (String file : files) {\n        Files.delete(new File(logDir, file).toPath());\n      }\n\n      assertEquals(0, ulog.getLogList(logDir).length);\n    } finally {\n      \r\n      \r\n      createCore();\n      assertJQ(req(\"q\",\"*:*\") ,\"/response/numFound==\");   \r\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1089,"status":"N"}],"commitId":"5f2d7c4855987670489d68884c787e4cfb377fa9","commitMessage":"@@@SOLR-14184: Internal 'test' variable DirectUpdateHandler2.commitOnClose has been removed and replaced with TestInjection.skipIndexWriterCommitOnClose\n","date":"2020-01-17 02:47:06","modifiedFileCount":"13","status":"M","submitter":"Chris Hostetter"}]
