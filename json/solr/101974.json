[{"authorTime":"2015-03-17 13:13:36","codes":[{"authorDate":"2015-03-17 13:13:36","commitOrder":1,"curCode":"  public ManagedIndexSchema deleteDynamicFields(Collection<String> fieldNamePatterns) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      newSchema = shallowCopy(true);\n\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n\n      for (String fieldNamePattern : fieldNamePatterns) {\n        DynamicField dynamicField = null;\n        int dfPos = 0;\n        for ( ; dfPos < newSchema.dynamicFields.length ; ++dfPos) {\n          DynamicField df = newSchema.dynamicFields[dfPos];\n          if (df.getRegex().equals(fieldNamePattern)) {\n            dynamicField = df;\n            break;\n          }\n        }\n        if (null == dynamicField) {\n          String msg = \"The dynamic field '\" + fieldNamePattern\n              + \"' is not present in this schema, and so cannot be deleted.\";\n          throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n        }          \n        for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n          DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n          DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if ((null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n              || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))\n              || dynamicField.matches(dynamicCopy.getRegex())\n              || dynamicField.matches(dynamicCopy.getDestFieldName())) {\n            dynamicCopyFieldsToRebuild.add(dynamicCopy);\n            newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n            \r\n          } else {\n            newDynamicCopyFields.add(dynamicCopy);\n          }\n        }\n        if (newSchema.dynamicFields.length > 1) {\n          DynamicField[] temp = new DynamicField[newSchema.dynamicFields.length - 1];\n          System.arraycopy(newSchema.dynamicFields, 0, temp, 0, dfPos);\n          \r\n          System.arraycopy(newSchema.dynamicFields, dfPos + 1, temp, dfPos, newSchema.dynamicFields.length - dfPos - 1);\n          newSchema.dynamicFields = temp;\n        } else {\n          newSchema.dynamicFields = new DynamicField[0];\n        }\n      }\n      \r\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      \r\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-03-17 13:13:36","endLine":684,"groupId":"27353","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"deleteDynamicFields","params":"(Collection<String>fieldNamePatterns)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f9/6a89fc0c2f45c79f0f4cf9a721b2a3740e8ddd.src","preCode":"  public ManagedIndexSchema deleteDynamicFields(Collection<String> fieldNamePatterns) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      newSchema = shallowCopy(true);\n\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n\n      for (String fieldNamePattern : fieldNamePatterns) {\n        DynamicField dynamicField = null;\n        int dfPos = 0;\n        for ( ; dfPos < newSchema.dynamicFields.length ; ++dfPos) {\n          DynamicField df = newSchema.dynamicFields[dfPos];\n          if (df.getRegex().equals(fieldNamePattern)) {\n            dynamicField = df;\n            break;\n          }\n        }\n        if (null == dynamicField) {\n          String msg = \"The dynamic field '\" + fieldNamePattern\n              + \"' is not present in this schema, and so cannot be deleted.\";\n          throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n        }          \n        for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n          DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n          DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if ((null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n              || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))\n              || dynamicField.matches(dynamicCopy.getRegex())\n              || dynamicField.matches(dynamicCopy.getDestFieldName())) {\n            dynamicCopyFieldsToRebuild.add(dynamicCopy);\n            newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n            \r\n          } else {\n            newDynamicCopyFields.add(dynamicCopy);\n          }\n        }\n        if (newSchema.dynamicFields.length > 1) {\n          DynamicField[] temp = new DynamicField[newSchema.dynamicFields.length - 1];\n          System.arraycopy(newSchema.dynamicFields, 0, temp, 0, dfPos);\n          \r\n          System.arraycopy(newSchema.dynamicFields, dfPos + 1, temp, dfPos, newSchema.dynamicFields.length - dfPos - 1);\n          newSchema.dynamicFields = temp;\n        } else {\n          newSchema.dynamicFields = new DynamicField[0];\n        }\n      }\n      \r\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      \r\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":613,"status":"B"},{"authorDate":"2015-03-17 13:13:36","commitOrder":1,"curCode":"  public ManagedIndexSchema replaceDynamicField\n    (String fieldNamePattern, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      DynamicField oldDynamicField = null;\n      int dfPos = 0;\n      for ( ; dfPos < dynamicFields.length ; ++dfPos) {\n        DynamicField dynamicField = dynamicFields[dfPos];\n        if (dynamicField.getRegex().equals(fieldNamePattern)) {\n          oldDynamicField = dynamicField;\n          break;\n        }\n      }\n      if (null == oldDynamicField) {\n        String msg = \"The dynamic field '\" + fieldNamePattern \n            + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n\n      newSchema = shallowCopy(true);\n\n      \r\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      SchemaField prototype = SchemaField.create(fieldNamePattern, replacementFieldType, replacementArgs);\n      newSchema.dynamicFields[dfPos] = new DynamicField(prototype);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        if (fieldNamePattern.equals(dynamicCopy.getRegex())\n            || fieldNamePattern.equals(dynamicCopy.getDestFieldName())\n            || (null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n            || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-03-17 13:13:36","endLine":754,"groupId":"21312","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"replaceDynamicField","params":"(StringfieldNamePattern@FieldTypereplacementFieldType@Map<String@?>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f9/6a89fc0c2f45c79f0f4cf9a721b2a3740e8ddd.src","preCode":"  public ManagedIndexSchema replaceDynamicField\n    (String fieldNamePattern, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      DynamicField oldDynamicField = null;\n      int dfPos = 0;\n      for ( ; dfPos < dynamicFields.length ; ++dfPos) {\n        DynamicField dynamicField = dynamicFields[dfPos];\n        if (dynamicField.getRegex().equals(fieldNamePattern)) {\n          oldDynamicField = dynamicField;\n          break;\n        }\n      }\n      if (null == oldDynamicField) {\n        String msg = \"The dynamic field '\" + fieldNamePattern \n            + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n\n      newSchema = shallowCopy(true);\n\n      \r\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      SchemaField prototype = SchemaField.create(fieldNamePattern, replacementFieldType, replacementArgs);\n      newSchema.dynamicFields[dfPos] = new DynamicField(prototype);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        if (fieldNamePattern.equals(dynamicCopy.getRegex())\n            || fieldNamePattern.equals(dynamicCopy.getDestFieldName())\n            || (null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n            || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":687,"status":"B"}],"commitId":"ff83497b27c56dd86a94f64e081c2694772bd571","commitMessage":"@@@SOLR-6141: Schema API: Remove fields.  dynamic fields.  field types and copy fields; and replace fields.  dynamic fields and field types\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1667175 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-03-17 13:13:36","modifiedFileCount":"11","status":"B","submitter":"Steven Rowe"},{"authorTime":"2015-04-09 12:42:30","codes":[{"authorDate":"2015-04-09 12:42:30","commitOrder":2,"curCode":"  public ManagedIndexSchema deleteDynamicFields(Collection<String> fieldNamePatterns) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      newSchema = shallowCopy(true);\n\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n\n      for (String fieldNamePattern : fieldNamePatterns) {\n        DynamicField dynamicField = null;\n        int dfPos = 0;\n        for ( ; dfPos < newSchema.dynamicFields.length ; ++dfPos) {\n          DynamicField df = newSchema.dynamicFields[dfPos];\n          if (df.getRegex().equals(fieldNamePattern)) {\n            dynamicField = df;\n            break;\n          }\n        }\n        if (null == dynamicField) {\n          String msg = \"The dynamic field '\" + fieldNamePattern\n              + \"' is not present in this schema, and so cannot be deleted.\";\n          throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n        }          \n        for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n          DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n          DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if ((null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n              || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))\n              || dynamicField.matches(dynamicCopy.getRegex())\n              || dynamicField.matches(dynamicCopy.getDestFieldName())) {\n            dynamicCopyFieldsToRebuild.add(dynamicCopy);\n            newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n            \r\n          } else {\n            newDynamicCopyFields.add(dynamicCopy);\n          }\n        }\n        if (newSchema.dynamicFields.length > 1) {\n          DynamicField[] temp = new DynamicField[newSchema.dynamicFields.length - 1];\n          System.arraycopy(newSchema.dynamicFields, 0, temp, 0, dfPos);\n          \r\n          System.arraycopy(newSchema.dynamicFields, dfPos + 1, temp, dfPos, newSchema.dynamicFields.length - dfPos - 1);\n          newSchema.dynamicFields = temp;\n        } else {\n          newSchema.dynamicFields = new DynamicField[0];\n        }\n      }\n      \r\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-04-09 12:42:30","endLine":672,"groupId":"27353","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"deleteDynamicFields","params":"(Collection<String>fieldNamePatterns)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/66/6d6bc65b8edc75fb83961e5399755eea21c27c.src","preCode":"  public ManagedIndexSchema deleteDynamicFields(Collection<String> fieldNamePatterns) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      newSchema = shallowCopy(true);\n\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n\n      for (String fieldNamePattern : fieldNamePatterns) {\n        DynamicField dynamicField = null;\n        int dfPos = 0;\n        for ( ; dfPos < newSchema.dynamicFields.length ; ++dfPos) {\n          DynamicField df = newSchema.dynamicFields[dfPos];\n          if (df.getRegex().equals(fieldNamePattern)) {\n            dynamicField = df;\n            break;\n          }\n        }\n        if (null == dynamicField) {\n          String msg = \"The dynamic field '\" + fieldNamePattern\n              + \"' is not present in this schema, and so cannot be deleted.\";\n          throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n        }          \n        for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n          DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n          DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if ((null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n              || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))\n              || dynamicField.matches(dynamicCopy.getRegex())\n              || dynamicField.matches(dynamicCopy.getDestFieldName())) {\n            dynamicCopyFieldsToRebuild.add(dynamicCopy);\n            newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n            \r\n          } else {\n            newDynamicCopyFields.add(dynamicCopy);\n          }\n        }\n        if (newSchema.dynamicFields.length > 1) {\n          DynamicField[] temp = new DynamicField[newSchema.dynamicFields.length - 1];\n          System.arraycopy(newSchema.dynamicFields, 0, temp, 0, dfPos);\n          \r\n          System.arraycopy(newSchema.dynamicFields, dfPos + 1, temp, dfPos, newSchema.dynamicFields.length - dfPos - 1);\n          newSchema.dynamicFields = temp;\n        } else {\n          newSchema.dynamicFields = new DynamicField[0];\n        }\n      }\n      \r\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      \r\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":604,"status":"M"},{"authorDate":"2015-04-09 12:42:30","commitOrder":2,"curCode":"  public ManagedIndexSchema replaceDynamicField\n    (String fieldNamePattern, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      DynamicField oldDynamicField = null;\n      int dfPos = 0;\n      for ( ; dfPos < dynamicFields.length ; ++dfPos) {\n        DynamicField dynamicField = dynamicFields[dfPos];\n        if (dynamicField.getRegex().equals(fieldNamePattern)) {\n          oldDynamicField = dynamicField;\n          break;\n        }\n      }\n      if (null == oldDynamicField) {\n        String msg = \"The dynamic field '\" + fieldNamePattern \n            + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n\n      newSchema = shallowCopy(true);\n\n      \r\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      SchemaField prototype = SchemaField.create(fieldNamePattern, replacementFieldType, replacementArgs);\n      newSchema.dynamicFields[dfPos] = new DynamicField(prototype);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        if (fieldNamePattern.equals(dynamicCopy.getRegex())\n            || fieldNamePattern.equals(dynamicCopy.getDestFieldName())\n            || (null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n            || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-04-09 12:42:30","endLine":740,"groupId":"21312","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"replaceDynamicField","params":"(StringfieldNamePattern@FieldTypereplacementFieldType@Map<String@?>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/66/6d6bc65b8edc75fb83961e5399755eea21c27c.src","preCode":"  public ManagedIndexSchema replaceDynamicField\n    (String fieldNamePattern, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      DynamicField oldDynamicField = null;\n      int dfPos = 0;\n      for ( ; dfPos < dynamicFields.length ; ++dfPos) {\n        DynamicField dynamicField = dynamicFields[dfPos];\n        if (dynamicField.getRegex().equals(fieldNamePattern)) {\n          oldDynamicField = dynamicField;\n          break;\n        }\n      }\n      if (null == oldDynamicField) {\n        String msg = \"The dynamic field '\" + fieldNamePattern \n            + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n\n      newSchema = shallowCopy(true);\n\n      \r\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      SchemaField prototype = SchemaField.create(fieldNamePattern, replacementFieldType, replacementArgs);\n      newSchema.dynamicFields[dfPos] = new DynamicField(prototype);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        if (fieldNamePattern.equals(dynamicCopy.getRegex())\n            || fieldNamePattern.equals(dynamicCopy.getDestFieldName())\n            || (null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n            || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":675,"status":"M"}],"commitId":"4c83c2200c9b2097cad09e5dd0f97033254620df","commitMessage":"@@@SOLR-7366: fix regression in ManagedIndexSchema's handling of ResourceLoaderAware objects used by field types.  causing example XML docs to not be indexable via bin/post; add a test indexing example docs that fails without the patch and succeeds with it\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1672238 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-04-09 12:42:30","modifiedFileCount":"2","status":"M","submitter":"Steven Rowe"},{"authorTime":"2015-04-09 12:42:30","codes":[{"authorDate":"2019-10-05 01:05:01","commitOrder":3,"curCode":"  public ManagedIndexSchema deleteDynamicFields(Collection<String> fieldNamePatterns) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      newSchema = shallowCopy(true);\n\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n\n      for (String fieldNamePattern : fieldNamePatterns) {\n        DynamicField dynamicField = null;\n        int dfPos = 0;\n        for ( ; dfPos < newSchema.dynamicFields.length ; ++dfPos) {\n          DynamicField df = newSchema.dynamicFields[dfPos];\n          if (df.getRegex().equals(fieldNamePattern)) {\n            dynamicField = df;\n            break;\n          }\n        }\n        if (null == dynamicField) {\n          String msg = \"The dynamic field '\" + fieldNamePattern\n              + \"' is not present in this schema, and so cannot be deleted.\";\n          throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n        }          \n        for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n          DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n          DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if ((null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n              || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))\n              || dynamicField.matches(dynamicCopy.getRegex())\n              || dynamicField.matches(dynamicCopy.getDestFieldName())) {\n            dynamicCopyFieldsToRebuild.add(dynamicCopy);\n            newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n            \r\n          } else {\n            newDynamicCopyFields.add(dynamicCopy);\n          }\n        }\n        if (newSchema.dynamicFields.length > 1) {\n          DynamicField[] temp = new DynamicField[newSchema.dynamicFields.length - 1];\n          System.arraycopy(newSchema.dynamicFields, 0, temp, 0, dfPos);\n          \r\n          System.arraycopy(newSchema.dynamicFields, dfPos + 1, temp, dfPos, newSchema.dynamicFields.length - dfPos - 1);\n          newSchema.dynamicFields = temp;\n        } else {\n          newSchema.dynamicFields = new DynamicField[] {};\n        }\n      }\n      \r\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2019-10-05 01:05:01","endLine":677,"groupId":"101974","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"deleteDynamicFields","params":"(Collection<String>fieldNamePatterns)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/57/b0c90e90bb12a9f71c79531103e1b401274333.src","preCode":"  public ManagedIndexSchema deleteDynamicFields(Collection<String> fieldNamePatterns) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      newSchema = shallowCopy(true);\n\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n\n      for (String fieldNamePattern : fieldNamePatterns) {\n        DynamicField dynamicField = null;\n        int dfPos = 0;\n        for ( ; dfPos < newSchema.dynamicFields.length ; ++dfPos) {\n          DynamicField df = newSchema.dynamicFields[dfPos];\n          if (df.getRegex().equals(fieldNamePattern)) {\n            dynamicField = df;\n            break;\n          }\n        }\n        if (null == dynamicField) {\n          String msg = \"The dynamic field '\" + fieldNamePattern\n              + \"' is not present in this schema, and so cannot be deleted.\";\n          throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n        }          \n        for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n          DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n          DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if ((null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n              || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))\n              || dynamicField.matches(dynamicCopy.getRegex())\n              || dynamicField.matches(dynamicCopy.getDestFieldName())) {\n            dynamicCopyFieldsToRebuild.add(dynamicCopy);\n            newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n            \r\n          } else {\n            newDynamicCopyFields.add(dynamicCopy);\n          }\n        }\n        if (newSchema.dynamicFields.length > 1) {\n          DynamicField[] temp = new DynamicField[newSchema.dynamicFields.length - 1];\n          System.arraycopy(newSchema.dynamicFields, 0, temp, 0, dfPos);\n          \r\n          System.arraycopy(newSchema.dynamicFields, dfPos + 1, temp, dfPos, newSchema.dynamicFields.length - dfPos - 1);\n          newSchema.dynamicFields = temp;\n        } else {\n          newSchema.dynamicFields = new DynamicField[0];\n        }\n      }\n      \r\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":609,"status":"M"},{"authorDate":"2015-04-09 12:42:30","commitOrder":3,"curCode":"  public ManagedIndexSchema replaceDynamicField\n    (String fieldNamePattern, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      DynamicField oldDynamicField = null;\n      int dfPos = 0;\n      for ( ; dfPos < dynamicFields.length ; ++dfPos) {\n        DynamicField dynamicField = dynamicFields[dfPos];\n        if (dynamicField.getRegex().equals(fieldNamePattern)) {\n          oldDynamicField = dynamicField;\n          break;\n        }\n      }\n      if (null == oldDynamicField) {\n        String msg = \"The dynamic field '\" + fieldNamePattern \n            + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n\n      newSchema = shallowCopy(true);\n\n      \r\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      SchemaField prototype = SchemaField.create(fieldNamePattern, replacementFieldType, replacementArgs);\n      newSchema.dynamicFields[dfPos] = new DynamicField(prototype);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        if (fieldNamePattern.equals(dynamicCopy.getRegex())\n            || fieldNamePattern.equals(dynamicCopy.getDestFieldName())\n            || (null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n            || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-04-09 12:42:30","endLine":740,"groupId":"101974","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"replaceDynamicField","params":"(StringfieldNamePattern@FieldTypereplacementFieldType@Map<String@?>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/66/6d6bc65b8edc75fb83961e5399755eea21c27c.src","preCode":"  public ManagedIndexSchema replaceDynamicField\n    (String fieldNamePattern, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      DynamicField oldDynamicField = null;\n      int dfPos = 0;\n      for ( ; dfPos < dynamicFields.length ; ++dfPos) {\n        DynamicField dynamicField = dynamicFields[dfPos];\n        if (dynamicField.getRegex().equals(fieldNamePattern)) {\n          oldDynamicField = dynamicField;\n          break;\n        }\n      }\n      if (null == oldDynamicField) {\n        String msg = \"The dynamic field '\" + fieldNamePattern \n            + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n\n      newSchema = shallowCopy(true);\n\n      \r\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      SchemaField prototype = SchemaField.create(fieldNamePattern, replacementFieldType, replacementArgs);\n      newSchema.dynamicFields[dfPos] = new DynamicField(prototype);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        if (fieldNamePattern.equals(dynamicCopy.getRegex())\n            || fieldNamePattern.equals(dynamicCopy.getDestFieldName())\n            || (null != destDynamicBase && fieldNamePattern.equals(destDynamicBase.getRegex()))\n            || (null != sourceDynamicBase && fieldNamePattern.equals(sourceDynamicBase.getRegex()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(dynamicCopy.getDestination().getPrototype());\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":675,"status":"N"}],"commitId":"22e96697de1d9bc710f6e68e94885460106528bc","commitMessage":"@@@SOLR-13795: Managed schema should do a core reload in standalone mode.\nFixes #902\n","date":"2019-10-05 01:05:01","modifiedFileCount":"5","status":"M","submitter":"Thomas W?ckinger"}]
