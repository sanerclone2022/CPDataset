[{"authorTime":"2015-08-09 11:38:08","codes":[{"authorDate":"2014-03-12 22:39:17","commitOrder":3,"curCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            \r\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2014-03-12 22:39:17","endLine":410,"groupId":"60637","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressRecovery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/41/2908d0a5f57362c8b48284c652bec716a2f008.src","preCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;   \r\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            \r\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"NB"},{"authorDate":"2015-08-09 11:38:08","commitOrder":3,"curCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","date":"2015-08-09 11:38:08","endLine":215,"groupId":"9206","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"addDoc","params":"(intid@longnextVal@longversion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/02/e1deb7a35f146f2adb4ec6a33f0106b8a3e53e.src","preCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"B"}],"commitId":"2676aa61b98c11b9ba3dc5c3f9f19ab556d73495","commitMessage":"@@@SOLR-7836: Possible deadlock when closing refcounted index writers\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1694854 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-08-09 11:38:08","modifiedFileCount":"2","status":"M","submitter":"Erick Erickson"},{"authorTime":"2017-03-31 22:22:45","codes":[{"authorDate":"2017-03-31 22:22:45","commitOrder":4,"curCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            \r\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2017-03-31 23:28:21","endLine":410,"groupId":"60637","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressRecovery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/93/3700d91b74b272911afa885e0dcd141c603db4.src","preCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(field));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            \r\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":61,"status":"M"},{"authorDate":"2017-03-31 22:22:45","commitOrder":4,"curCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","date":"2017-03-31 23:28:21","endLine":215,"groupId":"9206","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"addDoc","params":"(intid@longnextVal@longversion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/32/c91db29bfce360c8a9adebd101efc539f4af18.src","preCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), field, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"M"}],"commitId":"e80643e5a77297ba7ee29c7297e37af6ffb73ac2","commitMessage":"@@@LUCENE-7753: Make fields static when possible.\n","date":"2017-03-31 23:28:21","modifiedFileCount":"40","status":"M","submitter":"Adrien Grand"},{"authorTime":"2017-03-31 22:22:45","codes":[{"authorDate":"2018-11-30 01:58:18","commitOrder":5,"curCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            \r\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2018-11-30 01:58:51","endLine":426,"groupId":"60637","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressRecovery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/61/d808f781cd0127a05889cb064b631e32b9398b.src","preCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n    clearIndex();\n    assertU(commit());\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(100));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        while (recInfo == null) {\n          try {\n            \r\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n        }\n\n        bufferedAddsApplied += recInfo.adds;\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"},{"authorDate":"2017-03-31 22:22:45","commitOrder":5,"curCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","date":"2017-03-31 23:28:21","endLine":215,"groupId":"9206","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"addDoc","params":"(intid@longnextVal@longversion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/32/c91db29bfce360c8a9adebd101efc539f4af18.src","preCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"N"}],"commitId":"75b183196798232aa6f2dcaaaab117f309119053","commitMessage":"@@@SOLR-12801: Make massive improvements to the tests.\n\nSOLR-12804: Remove static modifier from Overseer queue access.\n\nSOLR-12896: Introduce more checks for shutdown and closed to improve clean close and shutdown. (Partial)\n\nSOLR-12897: Introduce AlreadyClosedException to clean up silly close / shutdown logging. (Partial)\n\nSOLR-12898: Replace cluster state polling with ZkStateReader#waitFor. (Partial)\n\nSOLR-12923: The new AutoScaling tests are way too flaky and need special attention. (Partial)\n\nSOLR-12932: ant test (without badapples=false) should pass easily for developers. (Partial)\n\nSOLR-12933: Fix SolrCloud distributed commit.\n","date":"2018-11-30 01:58:51","modifiedFileCount":"339","status":"M","submitter":"markrmiller"},{"authorTime":"2017-03-31 22:22:45","codes":[{"authorDate":"2019-05-03 05:20:05","commitOrder":6,"curCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            \r\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2019-05-03 05:20:05","endLine":426,"groupId":"60637","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressRecovery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2e/d7f5c87d09b2daebfe3811a98730319dca3894.src","preCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map)ObjectBuilder.fromJSON(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            \r\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"},{"authorDate":"2017-03-31 22:22:45","commitOrder":6,"curCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","date":"2017-03-31 23:28:21","endLine":215,"groupId":"9206","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"addDoc","params":"(intid@longnextVal@longversion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/32/c91db29bfce360c8a9adebd101efc539f4af18.src","preCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"N"}],"commitId":"8908205b428f2ae68bcef0f22a944a62cfcd93d5","commitMessage":"@@@SOLR-13441: Refactor code to minimize direct use of noggit\n","date":"2019-05-03 05:20:05","modifiedFileCount":"58","status":"M","submitter":"noble"},{"authorTime":"2017-03-31 22:22:45","codes":[{"authorDate":"2020-06-18 05:51:41","commitOrder":7,"curCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              @SuppressWarnings({\"rawtypes\"})\n              Map rsp = (Map) Utils.fromJSONString(response);\n              @SuppressWarnings({\"rawtypes\"})\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            \r\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","date":"2020-06-18 05:51:41","endLine":428,"groupId":"103100","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testStressRecovery","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/7e/20c79782ab5d18b1a87414f5f7b1d2bfdc1f9a.src","preCode":"  public void testStressRecovery() throws Exception {\n    assumeFalse(\"FIXME: This test is horribly slow sometimes on Windows!\", Constants.WINDOWS);\n\n    final int commitPercent = 5 + random().nextInt(10);\n    final int softCommitPercent = 30+random().nextInt(75); \r\n    final int deletePercent = 4+random().nextInt(25);\n    final int deleteByQueryPercent = random().nextInt(5);\n    final int ndocs = 5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));\n    int nWriteThreads = 2 + random().nextInt(10);  \r\n\n    final int maxConcurrentCommits = nWriteThreads;\n\n    \r\n    final int percentRealtimeQuery = 75;\n    final int percentGetLatestVersions = random().nextInt(4);\n    final AtomicLong operations = new AtomicLong(atLeast(35));  \r\n    int nReadThreads = 2 + random().nextInt(10);  \r\n\n    initModel(ndocs);\n\n    final AtomicInteger numCommitting = new AtomicInteger();\n\n    List<Thread> threads = new ArrayList<>();\n\n\n    final AtomicLong testVersion = new AtomicLong(0);\n\n\n    final UpdateHandler uHandler = h.getCore().getUpdateHandler();\n    final UpdateLog uLog = uHandler.getUpdateLog();\n    final VersionInfo vInfo = uLog.getVersionInfo();\n    final Object stateChangeLock = new Object();\n    this.visibleModel = model;\n    final Semaphore[] writePermissions = new Semaphore[nWriteThreads];\n    for (int i=0; i<nWriteThreads; i++) writePermissions[i] = new Semaphore(Integer.MAX_VALUE, false);\n\n    final Semaphore readPermission = new Semaphore(Integer.MAX_VALUE, false);\n\n    for (int i=0; i<nWriteThreads; i++) {\n      final int threadNum = i;\n\n      Thread thread = new Thread(\"WRITER\"+i) {\n        Random rand = new Random(random().nextInt());\n        Semaphore writePermission = writePermissions[threadNum];\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              writePermission.acquire();\n\n              int oper = rand.nextInt(10);\n\n              if (oper < commitPercent) {\n                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {\n                  Map<Integer,DocInfo> newCommittedModel;\n                  long version;\n\n                  synchronized(globalLock) {\n                    newCommittedModel = new HashMap<>(model);  \r\n                    version = snapshotCount++;\n                  }\n\n                  synchronized (stateChangeLock) {\n                    \r\n                    \r\n                    if (uLog.getState() != UpdateLog.State.ACTIVE) version = -1;\n                    if (rand.nextInt(100) < softCommitPercent) {\n                      verbose(\"softCommit start\");\n                      assertU(TestHarness.commit(\"softCommit\",\"true\"));\n                      verbose(\"softCommit end\");\n                    } else {\n                      verbose(\"hardCommit start\");\n                      assertU(commit());\n                      verbose(\"hardCommit end\");\n                    }\n                  }\n\n                  synchronized(globalLock) {\n                    \r\n                    \r\n                    if (version >= committedModelClock) {\n                      if (VERBOSE) {\n                        verbose(\"installing new committedModel version=\"+committedModelClock);\n                      }\n                      committedModel = newCommittedModel;\n                      committedModelClock = version;\n                    }\n                  }\n                }\n                numCommitting.decrementAndGet();\n                continue;\n              }\n\n\n              int id;\n\n              if (rand.nextBoolean()) {\n                id = rand.nextInt(ndocs);\n              } else {\n                id = lastId;  \r\n              }\n\n              \r\n              \r\n              boolean before = rand.nextBoolean();\n              if (before) {\n                lastId = id;\n              }\n\n              DocInfo info = model.get(id);\n\n              long val = info.val;\n              long nextVal = Math.abs(val)+1;\n\n              \r\n              \r\n              \r\n              long version = testVersion.incrementAndGet();\n\n              \r\n              if (rand.nextBoolean()) Thread.yield();\n\n              if (oper < commitPercent + deletePercent) {\n                verbose(\"deleting id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteAndGetVersion(Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleting id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {\n\n                verbose(\"deleteByQuery id\",id,\"val=\",nextVal,\"version\",version);\n\n                Long returnedVersion = deleteByQueryAndGetVersion(\"id:\"+Integer.toString(id), params(\"_version_\",Long.toString(-version), DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n                \r\n                \r\n                if (returnedVersion != null) {\n                  assertEquals(-version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (Math.abs(version) > Math.abs(currInfo.version)) {\n                    model.put(id, new DocInfo(version, -nextVal));\n                  }\n                }\n\n                verbose(\"deleteByQuery id\", id, \"val=\",nextVal,\"version\",version,\"DONE\");\n\n              } else {\n                verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version);\n\n                Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal), \"_version_\",Long.toString(version)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n                if (returnedVersion != null) {\n                  assertEquals(version, returnedVersion.longValue());\n                }\n\n                \r\n                synchronized (model) {\n                  DocInfo currInfo = model.get(id);\n                  if (version > currInfo.version) {\n                    model.put(id, new DocInfo(version, nextVal));\n                  }\n                }\n\n                if (VERBOSE) {\n                  verbose(\"adding id\", id, \"val=\", nextVal,\"version\",version,\"DONE\");\n                }\n\n              }\n              \r\n\n              if (!before) {\n                lastId = id;\n              }\n            }\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (int i=0; i<nReadThreads; i++) {\n      Thread thread = new Thread(\"READER\"+i) {\n        Random rand = new Random(random().nextInt());\n\n        @Override\n        public void run() {\n          try {\n            while (operations.get() > 0) {\n              \r\n              readPermission.tryAcquire(10, TimeUnit.MILLISECONDS);\n\n\n              \r\n              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);\n\n              \r\n              \r\n\n              boolean realTime = rand.nextInt(100) < percentRealtimeQuery;\n              DocInfo info;\n\n              if (realTime) {\n                info = visibleModel.get(id);\n              } else {\n                synchronized(globalLock) {\n                  info = committedModel.get(id);\n                }\n              }\n\n\n              if  (VERBOSE) {\n                verbose(\"querying id\", id);\n              }\n              SolrQueryRequest sreq;\n              if (realTime) {\n                sreq = req(\"wt\",\"json\", \"qt\",\"/get\", \"ids\",Integer.toString(id));\n              } else {\n                sreq = req(\"wt\",\"json\", \"q\",\"id:\"+Integer.toString(id), \"omitHeader\",\"true\");\n              }\n\n              String response = h.query(sreq);\n              Map rsp = (Map) Utils.fromJSONString(response);\n              List doclist = (List)(((Map)rsp.get(\"response\")).get(\"docs\"));\n              if (doclist.size() == 0) {\n                \r\n              } else {\n                assertEquals(1, doclist.size());\n                long foundVal = (Long)(((Map)doclist.get(0)).get(FIELD));\n                long foundVer = (Long)(((Map)doclist.get(0)).get(\"_version_\"));\n                if (foundVer < Math.abs(info.version)\n                    || (foundVer == info.version && foundVal != info.val) ) {    \r\n                  verbose(\"ERROR, id=\", id, \"found=\",response,\"model\",info);\n                  assertTrue(false);\n                }\n              }\n            }\n\n\n            if (rand.nextInt(100) < percentGetLatestVersions) {\n              getLatestVersions();\n              \r\n            }\n\n          } catch (Throwable e) {\n            operations.set(-1L);\n            throw new RuntimeException(e);\n          }\n        }\n      };\n\n      threads.add(thread);\n    }\n\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    int bufferedAddsApplied = 0;\n    do {\n      assertTrue(uLog.getState() == UpdateLog.State.ACTIVE);\n\n      \r\n      \r\n\n      visibleModel = new ConcurrentHashMap<>(model);\n\n      synchronized (stateChangeLock) {\n        uLog.bufferUpdates();\n      }\n\n      assertTrue(uLog.getState() == UpdateLog.State.BUFFERING);\n\n      \r\n      if (random().nextBoolean()) Thread.sleep(random().nextInt(10)+1);\n\n      Future<UpdateLog.RecoveryInfo> recoveryInfoF = uLog.applyBufferedUpdates();\n      if (recoveryInfoF != null) {\n        UpdateLog.RecoveryInfo recInfo = null;\n\n        int writeThreadNumber = 0;\n        int cnt = 5000;\n        while (recInfo == null) {\n          try {\n            \r\n            cnt--;\n            recInfo = recoveryInfoF.get(random().nextInt(100/nWriteThreads), TimeUnit.MILLISECONDS);\n          } catch (TimeoutException e) {\n            \r\n            verbose(\"Operation\",operations.get(),\"Draining permits for write thread\",writeThreadNumber);\n            writePermissions[writeThreadNumber++].drainPermits();\n            if (writeThreadNumber >= nWriteThreads) {\n              \r\n              writeThreadNumber--;\n              writePermissions[writeThreadNumber].release(random().nextInt(2) + 1);\n            }\n\n            \r\n            readPermission.drainPermits();\n          }\n          if (cnt == 0) {\n            break;\n          }\n        }\n        if (recInfo != null) {\n          bufferedAddsApplied += recInfo.adds;\n        }\n      }\n\n      \r\n      for (Semaphore writePerm : writePermissions) {\n        \r\n        int neededPermits = Integer.MAX_VALUE - writePerm.availablePermits();\n        if (neededPermits > 0) writePerm.release( neededPermits );\n      }\n\n      \r\n      visibleModel = model;\n      int neededPermits = Integer.MAX_VALUE - readPermission.availablePermits();\n      if (neededPermits > 0) readPermission.release( neededPermits );\n\n      verbose(\"ROUND=\",operations.get());\n    } while (operations.decrementAndGet() > 0);\n\n    verbose(\"bufferedAddsApplied=\",bufferedAddsApplied);\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestStressRecovery.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":73,"status":"M"},{"authorDate":"2017-03-31 22:22:45","commitOrder":7,"curCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","date":"2017-03-31 23:28:21","endLine":215,"groupId":"103100","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"addDoc","params":"(intid@longnextVal@longversion)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/32/c91db29bfce360c8a9adebd101efc539f4af18.src","preCode":"  private void addDoc(int id, long nextVal, long version) throws Exception {\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version);\n\n    Long returnedVersion = addAndGetVersion(sdoc(\"id\", Integer.toString(id), FIELD, Long.toString(nextVal),\n        \"_version_\", Long.toString(version)), params(DISTRIB_UPDATE_PARAM, FROM_LEADER));\n    if (returnedVersion != null) {\n      assertEquals(version, returnedVersion.longValue());\n    }\n\n    \r\n    synchronized (model) {\n      DocInfo currInfo = model.get(id);\n      if (version > currInfo.version) {\n        model.put(id, new DocInfo(version, nextVal));\n      }\n    }\n\n    ifVerbose(\"adding id\", id, \"val=\", nextVal, \"version\", version, \"DONE\");\n  }\n","realPath":"solr/core/src/test/org/apache/solr/search/TestReloadDeadlock.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"N"}],"commitId":"b01e249c9ec724b6df120a5d731020cfe4de3fce","commitMessage":"@@@SOLR-14574: Fix or suppress warnings in solr/core/src/test (part 1)\n","date":"2020-06-18 05:51:41","modifiedFileCount":"213","status":"M","submitter":"Erick Erickson"}]
