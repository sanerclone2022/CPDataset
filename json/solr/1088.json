[{"authorTime":"2017-02-23 02:00:42","codes":[{"authorDate":"2018-12-17 00:58:20","commitOrder":5,"curCode":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n\n          if (scheduler.isShutdown())\n            break;\n\n          loopCount++;\n\n          \r\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n\n          interruptRunnerThreadsPolling();\n\n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n\n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","date":"2018-12-17 00:58:20","endLine":473,"groupId":"43373","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"blockUntilFinished","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ac/7449b65054af6f2ed91807ede3091664826b8c.src","preCode":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n\n          if (scheduler.isShutdown())\n            break;\n\n          loopCount++;\n\n          \r\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n\n          interruptRunnerThreadsPolling();\n\n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n\n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":420,"status":"B"},{"authorDate":"2017-02-23 02:00:42","commitOrder":5,"curCode":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          \r\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","date":"2017-02-23 03:44:18","endLine":640,"groupId":"43373","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"blockUntilFinished","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/4e/ac2a534a2e886fed7380ee921a862fa2da7d79.src","preCode":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          \r\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":585,"status":"NB"}],"commitId":"f80e8e11672d31c6e12069d2bd12a28b92e5a336","commitMessage":"@@@Merge jira/http2 branch to master\n","date":"2018-12-17 00:58:20","modifiedFileCount":"47","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2019-12-11 04:45:43","codes":[{"authorDate":"2019-12-11 04:45:43","commitOrder":6,"curCode":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n\n          if (scheduler.isShutdown())\n            break;\n\n          loopCount++;\n\n          \r\n          int queueSize = queue.size();\n          \r\n          if (lastQueueSize != queueSize) {\n            \r\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n\r\n\r\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n\n          interruptRunnerThreadsPolling();\n\n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n\n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","date":"2019-12-11 04:45:43","endLine":530,"groupId":"42755","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"blockUntilFinished","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bb/0c5822f6ec10743fcadef6d9198373adcb3ebf.src","preCode":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n\n          if (scheduler.isShutdown())\n            break;\n\n          loopCount++;\n\n          \r\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n\n          interruptRunnerThreadsPolling();\n\n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n\n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":457,"status":"M"},{"authorDate":"2019-12-11 04:45:43","commitOrder":6,"curCode":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          \r\n          int queueSize = queue.size();\n          \r\n          if (lastQueueSize != queueSize) {\n            \r\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n\r\n\r\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","date":"2019-12-11 04:45:43","endLine":665,"groupId":"42755","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"blockUntilFinished","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d9/21cb2114af37456fe372f44f3bed753cc789a3.src","preCode":"  public synchronized void blockUntilFinished() {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          \r\n          int queueSize = queue.size();\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":590,"status":"M"}],"commitId":"c4f0c3363828c088eefa2b99783178848c2f1f7a","commitMessage":"@@@SOLR-13975.  SOLR-13896: ConcurrentUpdateSolrClient connection stall prevention.\n","date":"2019-12-11 04:45:43","modifiedFileCount":"8","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2020-04-28 08:45:57","codes":[{"authorDate":"2020-04-28 08:45:57","commitOrder":7,"curCode":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n\n          if (scheduler.isShutdown())\n            break;\n\n          loopCount++;\n\n          \r\n          int queueSize = queue.size();\n          \r\n          if (lastQueueSize != queueSize) {\n            \r\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n\r\n\r\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has {}  adding more runners to process remaining requests on queue\"\n                , queueSize);\n            addRunner();\n          }\n\n          interruptRunnerThreadsPolling();\n\n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n\n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","date":"2020-04-28 08:45:57","endLine":532,"groupId":"1088","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"blockUntilFinished","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ea/0f773edc8bc52232bb5fb6f2eda36d898e0367.src","preCode":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n\n          if (scheduler.isShutdown())\n            break;\n\n          loopCount++;\n\n          \r\n          int queueSize = queue.size();\n          \r\n          if (lastQueueSize != queueSize) {\n            \r\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n\r\n\r\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n\n          interruptRunnerThreadsPolling();\n\n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n\n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":459,"status":"M"},{"authorDate":"2020-04-28 08:45:57","commitOrder":7,"curCode":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          \r\n          int queueSize = queue.size();\n          \r\n          if (lastQueueSize != queueSize) {\n            \r\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n\r\n\r\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has {} adding more runners to process remaining requests on queue\"\n                , queueSize);\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","date":"2020-04-28 08:45:57","endLine":669,"groupId":"1088","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"blockUntilFinished","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/c9/5cbd7991b4eba257de5920f4b51a0c3d00cc24.src","preCode":"  public synchronized void blockUntilFinished() throws IOException {\n    lock = new CountDownLatch(1);\n    try {\n\n      waitForEmptyQueue();\n      interruptRunnerThreadsPolling();\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n\n      synchronized (runners) {\n\n        \r\n        \r\n        \r\n        int loopCount = 0;\n        while (!runners.isEmpty()) {\n          \n          if (log.isDebugEnabled()) blockLoops.incrementAndGet();\n          \n          if (scheduler.isShutdown())\n            break;\n          \n          loopCount++;\n          \n          \r\n          int queueSize = queue.size();\n          \r\n          if (lastQueueSize != queueSize) {\n            \r\n            lastQueueSize = queueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + queueSize + \" remaining elements to process.\");\n\r\n\r\n              }\n            }\n          }\n          if (queueSize > 0 && runners.isEmpty()) {\n            \r\n            log.warn(\"No more runners, but queue still has \" +\n                queueSize + \" adding more runners to process remaining requests on queue\");\n            addRunner();\n          }\n          \n          interruptRunnerThreadsPolling();\n          \n          \r\n          \r\n          int timeout;\n          if (loopCount < 3) {\n            timeout = 10;\n          } else if (loopCount < 10) {\n            timeout = 25;\n          } else {\n            timeout = 250;\n          }\n          \n          try {\n            runners.wait(timeout);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n          }\n        }\n      }\n    } finally {\n      lock.countDown();\n      lock = null;\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":594,"status":"M"}],"commitId":"960610a615a2893062b1df3ab1595d8fef6bcdb4","commitMessage":"@@@LUCENE-7788: fail precommit on unparameterised log messages and examine for wasted work/objects\n","date":"2020-04-28 08:45:57","modifiedFileCount":"39","status":"M","submitter":"Erick Erickson"}]
