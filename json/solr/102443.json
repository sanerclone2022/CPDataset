[{"authorTime":"2018-01-23 20:35:14","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":2,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"B"},{"authorDate":"2018-01-23 20:35:14","commitOrder":2,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    SolrCloseableLatch countDownLatch;\n    try {\n      List<ReplicaPosition> positions = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, sessionWrapper);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n      \r\n      ocmh.waitForNewShard(collectionName, sliceName);\n\n      String async = message.getStr(ASYNC);\n      countDownLatch = new SolrCloseableLatch(positions.size(), ocmh);\n      for (ReplicaPosition position : positions) {\n        String nodeName = position.node;\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(), collection, sliceName, position.type);\n        log.info(\"Creating replica \" + coreName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n            + \" on \" + nodeName);\n\n        \r\n        ZkNodeProps addReplicasProps = new ZkNodeProps(\n            COLLECTION_PROP, collectionName,\n            SHARD_ID_PROP, sliceName,\n            ZkStateReader.REPLICA_TYPE, position.type.name(),\n            CoreAdminParams.NODE, nodeName,\n            CoreAdminParams.NAME, coreName,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        Map<String, Object> propertyParams = new HashMap<>();\n        ocmh.addPropertyParams(message, propertyParams);\n        addReplicasProps = addReplicasProps.plus(propertyParams);\n        if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n        final NamedList addResult = new NamedList();\n        ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n          countDownLatch.countDown();\n          Object addResultFailure = addResult.get(\"failure\");\n          if (addResultFailure != null) {\n            SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n            if (failure == null) {\n              failure = new SimpleOrderedMap();\n              results.add(\"failure\", failure);\n            }\n            failure.addAll((NamedList) addResultFailure);\n          } else {\n            SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n            if (success == null) {\n              success = new SimpleOrderedMap();\n              results.add(\"success\", success);\n            }\n            success.addAll((NamedList) addResult.get(\"success\"));\n          }\n        });\n      }\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n\n    log.debug(\"Waiting for create shard action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for create shard action to complete\");\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n\n  }\n","date":"2018-01-23 20:35:14","endLine":140,"groupId":"30497","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/31/1d9ef1e89bbccc26afb22f0239ecd343fb585a.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    SolrCloseableLatch countDownLatch;\n    try {\n      List<ReplicaPosition> positions = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, sessionWrapper);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n      \r\n      ocmh.waitForNewShard(collectionName, sliceName);\n\n      String async = message.getStr(ASYNC);\n      countDownLatch = new SolrCloseableLatch(positions.size(), ocmh);\n      for (ReplicaPosition position : positions) {\n        String nodeName = position.node;\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(), collection, sliceName, position.type);\n        log.info(\"Creating replica \" + coreName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n            + \" on \" + nodeName);\n\n        \r\n        ZkNodeProps addReplicasProps = new ZkNodeProps(\n            COLLECTION_PROP, collectionName,\n            SHARD_ID_PROP, sliceName,\n            ZkStateReader.REPLICA_TYPE, position.type.name(),\n            CoreAdminParams.NODE, nodeName,\n            CoreAdminParams.NAME, coreName,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        Map<String, Object> propertyParams = new HashMap<>();\n        ocmh.addPropertyParams(message, propertyParams);\n        addReplicasProps = addReplicasProps.plus(propertyParams);\n        if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n        final NamedList addResult = new NamedList();\n        ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n          countDownLatch.countDown();\n          Object addResultFailure = addResult.get(\"failure\");\n          if (addResultFailure != null) {\n            SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n            if (failure == null) {\n              failure = new SimpleOrderedMap();\n              results.add(\"failure\", failure);\n            }\n            failure.addAll((NamedList) addResultFailure);\n          } else {\n            SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n            if (success == null) {\n              success = new SimpleOrderedMap();\n              results.add(\"success\", success);\n            }\n            success.addAll((NamedList) addResult.get(\"success\"));\n          }\n        });\n      }\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n\n    log.debug(\"Waiting for create shard action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for create shard action to complete\");\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":69,"status":"NB"}],"commitId":"179c8f9b48af9bf3c327226d0e1fdbe460c4a325","commitMessage":"@@@SOLR-11990: Make it possible to co-locate replicas of multiple collections together in a node.\n\nA collection may be co-located with another collection during collection creation time by specifying a\n'withCollection' parameter. It can also be co-located afterwards by using the modify collection API.\nThe co-location guarantee is enforced regardless of future cluster operations whether they are invoked\nmanually via the Collection API or automatically by the Autoscaling framework.\n\nSquashed commit of the following:\n\ncommit 3827703b38c598f1247c90ab57d3d640ab3a9e21\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Sat Jul 28 11:54:10 2018 +0530\n\n    SOLR-11990: Added change log entry\n\ncommit 7977222e07ba47274062cb8d8a69e7956d644000\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Sat Jul 28 11:52:17 2018 +0530\n\n    SOLR-11990: Added change log entry\n\ncommit 1857075fdb9d535b6149ad4369fed8b64b0c01f6\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Sat Jul 28 11:49:51 2018 +0530\n\n    SOLR-11990: Added note about co-location guarantees being one way only\n\ncommit 8557cbc8a511f21d1fcad99e11ea9d2104d0bef4\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Sat Jul 28 10:43:37 2018 +0530\n\n    SOLR-11990: Remove unused import\n\ncommit 864b013fd744edca9b6b84a8a7573fab3c5310d5\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Sat Jul 28 10:21:59 2018 +0530\n\n    SOLR-11990: Fixing compilation issues after merging master\n\ncommit dd840a2f7e765ee96c899d4d9ea89b6b67c5ae62\nMerge: bb4ffb3 828d281\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Sat Jul 28 10:03:50 2018 +0530\n\n    Merge branch 'master' into jira/solr-11990\n\n    # Conflicts:\n    #\tsolr/solr-ref-guide/src/collections-api.adoc\n    #\tsolr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause.java\n    #\tsolr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggestion.java\n\ncommit bb4ffb32c4960a2809ac8927e214e1e012204a73\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Fri Jul 27 14:09:44 2018 +0530\n\n    SOLR-11990: Ensure that the suggestion are validated by the policy engine otherwise move to the next candidate replica or the next candidate node\n\ncommit a97d45b22f9c232e939f979502c761001be9ae24\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Fri Jul 27 13:22:10 2018 +0530\n\n    SOLR-11990: Autoscaling suggestions for withCollection violations should prefer moving replicas before adding replicas\n\ncommit 7b5a84338dfe7335599a5e96aff2d26cb4eeaac6\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Fri Jul 27 12:22:45 2018 +0530\n\n    SOLR-11990: Fix statement about the behavior of the modify collection API when modifying the withCollection parameter\n\ncommit 63aec4fe0de7025c16b6ebc47dad1004531ecee1\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Thu Jul 26 07:29:07 2018 +0530\n\n    SOLR-11990: Added new page to the reference guide describing how to colocate collections together including guarantees and limitations\n\ncommit 6bfcd0786bb30353de9c26a01ec97ce3191b58f8\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Wed Jul 25 21:42:25 2018 +0530\n\n    SOLR-11990: Added another test which creates two collections which are colocated with two different collections and ensures that create collection and add replica operations work correctly\n\ncommit 4cead778f0044b6fb4012b085abf7b60350f495b\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Wed Jul 25 21:07:47 2018 +0530\n\n    SOLR-11990: Stop or start jettys in test setup to ensure that we always have exactly 2 replicas running before a test starts\n\ncommit 70dbfd042c2164fcd76d406eeab1518e4d3147fb\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Wed Jul 25 19:19:07 2018 +0530\n\n    SOLR-11990: Added description of the new withCollection parameter in the reference guide\n\ncommit 9d8260852b9d667d4d8e026432fd7727b7789393\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Wed Jul 25 19:16:46 2018 +0530\n\n    SOLR-11990: Reset count down latch during test setup\n\ncommit ae508165571b1afde54337859b8d5fdbb1d67312\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Wed Jul 25 15:43:54 2018 +0530\n\n    SOLR-11990: Add support for withCollection in simulated create collection API\n\ncommit 84f026b8c4cc25edb548430b8f5ad09d2486b3b5\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Tue Jul 24 17:21:33 2018 +0530\n\n    SOLR-11990: Ported the refactoring made in CreateCollectionCmd to the simulated version so that simulation tests are able to create collections correctly\n\ncommit defe111c9d31c8e4f0f00b4f2f3c875f5b2fa602\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Tue Jul 24 16:17:52 2018 +0530\n\n    SOLR-11990: Add missing javadoc for return statement\n\ncommit 8e47d5bc4545548c5441909c3fcc1a7901b38185\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Tue Jul 24 16:11:45 2018 +0530\n\n    SOLR-11990: Replace usage of forbidden Charsets with StandardCharsets class\n\ncommit 2d1b9eb25ea96a3a42c000ae654400ed44c17554\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Tue Jul 24 16:07:36 2018 +0530\n\n    SOLR-11990: Extract ConditionType to an interface VarType along with a WithCollectionVarType implementation\n\ncommit 1de2a4f52a59afca28de75bfa5156a3d6567a4f5\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Tue Jul 24 12:53:26 2018 +0530\n\n    SOLR-11990: Pass strict-ness parameter to the ConditionType so that WITH_COLLECTION can choose not to project add replica in strict mode.\n\n    This ensures that add replica or move replica suggesters always choose nodes that already have withCollection replicas first unless there are violations in doing so. Only if the first pass fails to find a suitable replica.  do we go to the other nodes in the cluster. This also removes the need for the majority of changes in AddReplicaSuggester and so they've been reverted.\n\ncommit 0d616ed9e9bad791548c87086cba7760d724350d\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Tue Jul 24 11:36:34 2018 +0530\n\n    SOLR-11990: Minor changes to formatting and code comments\n\ncommit 1228538f934f35f15797d89c2c66f2deb9cddd8c\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Mon Jul 23 14:26:19 2018 +0530\n\n    SOLR-11990: Added a test which simulates a lost node and asserts that move replica suggester moves the replica on the lost node to a node already having the withCollection present\n\ncommit 582f1fd98de93ab73c74a1f623749dd031beb381\nAuthor: Noble Paul <noble@apache.org>\nDate:   Mon Jul 23 18:35:22 2018 +1000\n\n    SOLR-11990: NPE removing unnecessary System.out.println\n\ncommit 501bc6c1d066321b344bbb8b1de3c2ead52f8c49\nAuthor: Noble Paul <noble@apache.org>\nDate:   Mon Jul 23 18:31:07 2018 +1000\n\n    SOLR-11990: NPE during class init\n\ncommit acbf4a69321e16cff11cc7cf0a1f076fd9ac0037\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Mon Jul 23 13:55:30 2018 +0530\n\n    SOLR-11990: Added asserts on the nodes that should be selected by the add replica suggester\n\ncommit 4824933fd6eb7d1773acbff1a1a0c5e670226e0b\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Fri Jul 20 14:30:52 2018 +0530\n\n    SOLR-11990: Added WITH_COLLECTION to global tags. Fixed implementation of addViolatingReplicas and getSuggestions in the clause impl. Added more asserts in testWithCollectionSuggestions.\n\ncommit dbadb33211c190026e08d8e3ea587b6f8df8720b\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Fri Jul 20 13:44:36 2018 +0530\n\n    SOLR-11990: Added support for comparing violations.  generating suggestions and adding violating replicas\n\ncommit ada1f17d5c93a4186260473e4822d2bee1da0e16\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Wed Jul 18 19:14:56 2018 +0530\n\n    SOLR-11990: Fix mock node state provider in TestPolicy to use the right cluster state. Added nocommits to ensure that we return the right suggestions for this feature.\n\ncommit ef2d61812e0d96eb2275b3411906d9de57ab835e\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Wed Jul 18 18:39:51 2018 +0530\n\n    SOLR-11990: Add missing node in nodeValues configuration\n\ncommit 34841fc01fea4a9f1e6a9f64050e576f2247a72b\nAuthor: Shalin Shekhar Mangar <shalin@apache.org>\nDate:   Wed Jul 18 16:32:57 2018 +0530\n\n    SOLR-11990: Make it possible to co-locate replicas of multiple collections together in a node\n","date":"2018-07-29 09:56:13","modifiedFileCount":"22","status":"M","submitter":"Shalin Shekhar Mangar"},{"authorTime":"2018-09-23 18:45:59","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":3,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2018-09-23 18:45:59","commitOrder":3,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n    \r\n    ocmh.waitForNewShard(collectionName, sliceName);\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","date":"2018-09-23 18:45:59","endLine":119,"groupId":"24131","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e7/f35f16006c33472d402d3a07c3f53418bc100f.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    SolrCloseableLatch countDownLatch;\n    try {\n      List<ReplicaPosition> positions = buildReplicaPositions(ocmh.cloudManager, clusterState, collectionName, message, sessionWrapper);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n      \r\n      ocmh.waitForNewShard(collectionName, sliceName);\n\n      String async = message.getStr(ASYNC);\n      countDownLatch = new SolrCloseableLatch(positions.size(), ocmh);\n      for (ReplicaPosition position : positions) {\n        String nodeName = position.node;\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(), collection, sliceName, position.type);\n        log.info(\"Creating replica \" + coreName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n            + \" on \" + nodeName);\n\n        \r\n        ZkNodeProps addReplicasProps = new ZkNodeProps(\n            COLLECTION_PROP, collectionName,\n            SHARD_ID_PROP, sliceName,\n            ZkStateReader.REPLICA_TYPE, position.type.name(),\n            CoreAdminParams.NODE, nodeName,\n            CoreAdminParams.NAME, coreName,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        Map<String, Object> propertyParams = new HashMap<>();\n        ocmh.addPropertyParams(message, propertyParams);\n        addReplicasProps = addReplicasProps.plus(propertyParams);\n        if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n        final NamedList addResult = new NamedList();\n        ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n          countDownLatch.countDown();\n          Object addResultFailure = addResult.get(\"failure\");\n          if (addResultFailure != null) {\n            SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n            if (failure == null) {\n              failure = new SimpleOrderedMap();\n              results.add(\"failure\", failure);\n            }\n            failure.addAll((NamedList) addResultFailure);\n          } else {\n            SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n            if (success == null) {\n              success = new SimpleOrderedMap();\n              results.add(\"success\", success);\n            }\n            success.addAll((NamedList) addResult.get(\"success\"));\n          }\n        });\n      }\n    } finally {\n      if (sessionWrapper.get() != null) sessionWrapper.get().release();\n    }\n\n    log.debug(\"Waiting for create shard action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for create shard action to complete\");\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"}],"commitId":"e6e3dc7ea8c626f0f4a1173f899a9d7bb1af26d1","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2018-09-23 18:45:59","modifiedFileCount":"14","status":"M","submitter":"Karl Wright"},{"authorTime":"2018-11-30 01:58:18","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":4,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2018-11-30 01:58:18","commitOrder":4,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    ocmh.waitForNewShard(collectionName, sliceName);\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","date":"2018-11-30 01:58:51","endLine":118,"groupId":"24131","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/22/9b799946618de36dd3dc08cdcfa7f6de4dce20.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n    \r\n    ocmh.waitForNewShard(collectionName, sliceName);\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"M"}],"commitId":"75b183196798232aa6f2dcaaaab117f309119053","commitMessage":"@@@SOLR-12801: Make massive improvements to the tests.\n\nSOLR-12804: Remove static modifier from Overseer queue access.\n\nSOLR-12896: Introduce more checks for shutdown and closed to improve clean close and shutdown. (Partial)\n\nSOLR-12897: Introduce AlreadyClosedException to clean up silly close / shutdown logging. (Partial)\n\nSOLR-12898: Replace cluster state polling with ZkStateReader#waitFor. (Partial)\n\nSOLR-12923: The new AutoScaling tests are way too flaky and need special attention. (Partial)\n\nSOLR-12932: ant test (without badapples=false) should pass easily for developers. (Partial)\n\nSOLR-12933: Fix SolrCloud distributed commit.\n","date":"2018-11-30 01:58:51","modifiedFileCount":"339","status":"M","submitter":"markrmiller"},{"authorTime":"2019-04-11 00:44:05","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":5,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2019-04-11 00:44:05","commitOrder":5,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    ocmh.waitForNewShard(collectionName, sliceName);\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","date":"2019-04-11 00:56:39","endLine":119,"groupId":"24131","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ff/e989013298b121588cf20dcb9300d1c09c0176.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    ocmh.waitForNewShard(collectionName, sliceName);\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"M"}],"commitId":"02c4503f8c122361c4c99e3776cfdcef15b859bd","commitMessage":"@@@SOLR-13262: Add collection RENAME command and support using aliases in most collection admin commands.\n","date":"2019-04-11 00:56:39","modifiedFileCount":"32","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2019-07-03 17:05:52","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":6,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2019-07-03 17:05:52","commitOrder":6,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    ocmh.waitForNewShard(collectionName, sliceName);\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","date":"2019-07-03 21:52:36","endLine":126,"groupId":"24131","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/08/d27e580de58dc765302a593c6b18e59022ad61.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    ocmh.waitForNewShard(collectionName, sliceName);\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"}],"commitId":"717afb11fc2d0dba70ea9a0e5e44b4f74be4e969","commitMessage":"@@@SOLR-13583: Impossible to delete a collection with the same name as an existing alias.\n","date":"2019-07-03 21:52:36","modifiedFileCount":"19","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2019-10-12 00:44:11","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":7,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2019-10-12 00:44:11","commitOrder":7,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    \r\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    \r\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","date":"2019-10-15 17:21:02","endLine":130,"groupId":"8638","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bb/1081d5650d16acf7aa5786e1a1d262eb2fcf34.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    ocmh.waitForNewShard(collectionName, sliceName);\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      ocmh.addReplica(zkStateReader.getClusterState(), addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"}],"commitId":"e2b160b865a1e85c19a12971bbd1eec99c52a68e","commitMessage":"@@@SOLR-13834: ZkController#getSolrCloudManager() now uses the same ZkStateReader instance instead of instantiating a new one\n\nZkController#getSolrCloudManager() created a new instance of ZkStateReader.  thereby causing mismatch in the\nvisibility of the cluster state and.  as a result.  undesired race conditions.\n","date":"2019-10-15 17:21:02","modifiedFileCount":"5","status":"M","submitter":"Ishan Chattopadhyaya"},{"authorTime":"2020-04-25 01:34:03","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":8,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2020-04-25 01:34:03","commitOrder":8,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    \r\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    \r\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","date":"2020-04-25 01:34:03","endLine":130,"groupId":"8638","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/02/3bc3c2703b37fe9fc7560af5ad52c7e34b18e3.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    \r\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    \r\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"}],"commitId":"ecc98e8698a3ce8efa51712686697c0f33afab4d","commitMessage":"@@@LUCENE-7788: fail precommit on unparameterised log messages and examine for wasted work/objects\n","date":"2020-04-25 01:34:03","modifiedFileCount":"31","status":"M","submitter":"Erick Erickson"},{"authorTime":"2020-08-30 17:36:28","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":9,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2020-08-30 17:36:28","commitOrder":9,"curCode":"  public void call(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    \r\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    \r\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, cloudConfig, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, cloudConfig, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","date":"2020-08-30 17:36:28","endLine":132,"groupId":"0","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@CloudConfigcloudConfig@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b4/6fce572e81248ae76148c5443a7deaa89d2d5e.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    \r\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    \r\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"}],"commitId":"a3b3ba10e34b3401e7a93c1b69889df4feb6430b","commitMessage":"@@@SOLR-14794: pass configuration to Collection API commands (#1801)\n\nPass CloudConfig instance representing the solrcloud section of solr.xml configuration from Overseer to the Collection and Config Set API commands it executes.","date":"2020-08-30 17:36:28","modifiedFileCount":"32","status":"M","submitter":"Ilan Ginzburg"},{"authorTime":"2020-09-01 23:21:12","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":10,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2020-09-01 23:21:12","commitOrder":10,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    \r\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    \r\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","date":"2020-09-01 23:21:12","endLine":131,"groupId":"8638","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/98/9003aee7d2fca6ab9b0fe497dc3b7b1328d278.src","preCode":"  public void call(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    \r\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    \r\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, cloudConfig, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, cloudConfig, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"}],"commitId":"825c18c59b36dc3dee9763746d136b745bf22b21","commitMessage":"@@@SOLR-14794: revert commit passing CloudConfig everywhere (a3b3ba10e34b3401e7a93c1b69889df4feb6430b) and remove tab in solr/bin/solr.cmd\n","date":"2020-09-01 23:21:12","modifiedFileCount":"32","status":"M","submitter":"Ilan Ginzburg"},{"authorTime":"2021-02-13 09:42:18","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":11,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2021-02-13 09:42:18","commitOrder":11,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    if (ocmh.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      \r\n      \r\n      \r\n      ocmh.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.CollectionCreateShard, message,\n          ocmh.cloudManager, ocmh.zkStateReader);\n    } else {\n      \r\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    }\n\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","date":"2021-02-13 09:42:18","endLine":139,"groupId":"0","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/04/eb0f9e6abbcf8a7099ba1325aabfd705c03b5f.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    \r\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    \r\n    \r\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"}],"commitId":"23755ddfdd36a9613010cb9e6201127df55be744","commitMessage":"@@@SOLR-14928: allow cluster state updates to be done in a distributed way and not through Overseer (#2364)\n\n","date":"2021-02-13 09:42:18","modifiedFileCount":"42","status":"M","submitter":"Ilan Ginzburg"},{"authorTime":"2021-02-19 21:40:23","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":12,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"3401","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2021-02-19 21:40:23","commitOrder":12,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ccc.getSolrCloudManager().getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      \r\n      \r\n      \r\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.CollectionCreateShard, message,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      \r\n      ccc.offerStateUpdate(Utils.toJSON(message));\n    }\n\n    \r\n    clusterState = CollectionHandlingUtils.waitForNewShard(collectionName, sliceName, ccc.getZkStateReader());\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        CollectionHandlingUtils.CREATE_NODE_SET, message.getStr(CollectionHandlingUtils.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    CollectionHandlingUtils.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      new AddReplicaCmd(ccc).addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ccc).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","date":"2021-02-19 21:40:23","endLine":138,"groupId":"41172","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedListresults)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/14/bcaec8873a7bf13f236d6305242960b0ded0ff.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    if (ocmh.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      \r\n      \r\n      \r\n      ocmh.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.CollectionCreateShard, message,\n          ocmh.cloudManager, ocmh.zkStateReader);\n    } else {\n      \r\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n    }\n\n    \r\n    clusterState = ocmh.waitForNewShard(collectionName, sliceName);\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, message.getStr(OverseerCollectionMessageHandler.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    ocmh.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      \r\n      ocmh.addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ocmh).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":56,"status":"M"}],"commitId":"e7c80f6445a04cb3d1b49d85d773fde283c916fe","commitMessage":"@@@SOLR-15157: refactor Collection API to separate from Overseer and message handling abstractions (#2390)\n\nNo functional changes. In preparation of distributing the Collection API command execution.","date":"2021-02-19 21:40:23","modifiedFileCount":"42","status":"M","submitter":"Ilan Ginzburg"},{"authorTime":"2021-07-13 23:49:56","codes":[{"authorDate":"2018-07-29 09:56:13","commitOrder":13,"curCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","date":"2018-07-29 09:56:13","endLine":397,"groupId":"102443","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"checkReplicaTypes","params":"(ZkNodePropsmessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/45/ced2b674dcc277138f8795c76b3fd14c506093.src","preCode":"  public static void checkReplicaTypes(ZkNodeProps message) {\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, numTlogReplicas > 0 ? 0 : 1));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":390,"status":"N"},{"authorDate":"2021-07-13 23:49:56","commitOrder":13,"curCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList<Object> results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ccc.getSolrCloudManager().getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      \r\n      \r\n      \r\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.CollectionCreateShard, message,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      \r\n      ccc.offerStateUpdate(Utils.toJSON(message));\n    }\n\n    \r\n    clusterState = CollectionHandlingUtils.waitForNewShard(collectionName, sliceName, ccc.getZkStateReader());\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        CollectionHandlingUtils.CREATE_NODE_SET, message.getStr(CollectionHandlingUtils.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    CollectionHandlingUtils.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList<Object> addResult = new NamedList<>();\n    try {\n      new AddReplicaCmd(ccc).addReplica(clusterState, addReplicasProps, addResult, () -> {\n        @SuppressWarnings(\"unchecked\")\n        NamedList<Object> addResultFailure = (NamedList<Object>) addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          @SuppressWarnings(\"unchecked\")\n          SimpleOrderedMap<Object> failure = (SimpleOrderedMap<Object>) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap<>();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll(addResultFailure);\n        } else {\n          @SuppressWarnings(\"unchecked\")\n          SimpleOrderedMap<Object> success = (SimpleOrderedMap<Object>) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap<>();\n            results.add(\"success\", success);\n          }\n          @SuppressWarnings(\"unchecked\")\n          NamedList<Object> addResultSuccess = (NamedList<Object>) addResult.get(\"success\");\n          success.addAll(addResultSuccess);\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ccc).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","date":"2021-07-13 23:49:56","endLine":142,"groupId":"102443","id":24,"instanceNumber":2,"isCurCommit":1,"methodName":"call","params":"(ClusterStateclusterState@ZkNodePropsmessage@NamedList<Object>results)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/25/c4cb5dab2775533dd61c7199ec826bbcc4e949.src","preCode":"  public void call(ClusterState clusterState, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n\n    log.info(\"Create shard invoked: {}\", message);\n    if (extCollectionName == null || sliceName == null)\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ccc.getSolrCloudManager().getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    DocCollection collection = clusterState.getCollection(collectionName);\n\n    int numNrtReplicas = message.getInt(NRT_REPLICAS, message.getInt(REPLICATION_FACTOR, collection.getInt(NRT_REPLICAS, collection.getInt(REPLICATION_FACTOR, 1))));\n    int numPullReplicas = message.getInt(PULL_REPLICAS, collection.getInt(PULL_REPLICAS, 0));\n    int numTlogReplicas = message.getInt(TLOG_REPLICAS, collection.getInt(TLOG_REPLICAS, 0));\n\n    if (numNrtReplicas + numTlogReplicas <= 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, NRT_REPLICAS + \" + \" + TLOG_REPLICAS + \" must be greater than 0\");\n    }\n\n    if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n      \r\n      \r\n      \r\n      ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.CollectionCreateShard, message,\n          ccc.getSolrCloudManager(), ccc.getZkStateReader());\n    } else {\n      \r\n      ccc.offerStateUpdate(Utils.toJSON(message));\n    }\n\n    \r\n    clusterState = CollectionHandlingUtils.waitForNewShard(collectionName, sliceName, ccc.getZkStateReader());\n\n    String async = message.getStr(ASYNC);\n    ZkNodeProps addReplicasProps = new ZkNodeProps(\n        COLLECTION_PROP, collectionName,\n        SHARD_ID_PROP, sliceName,\n        ZkStateReader.NRT_REPLICAS, String.valueOf(numNrtReplicas),\n        ZkStateReader.TLOG_REPLICAS, String.valueOf(numTlogReplicas),\n        ZkStateReader.PULL_REPLICAS, String.valueOf(numPullReplicas),\n        CollectionHandlingUtils.CREATE_NODE_SET, message.getStr(CollectionHandlingUtils.CREATE_NODE_SET),\n        CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n\n    Map<String, Object> propertyParams = new HashMap<>();\n    CollectionHandlingUtils.addPropertyParams(message, propertyParams);\n    addReplicasProps = addReplicasProps.plus(propertyParams);\n    if (async != null) addReplicasProps.getProperties().put(ASYNC, async);\n    final NamedList addResult = new NamedList();\n    try {\n      new AddReplicaCmd(ccc).addReplica(clusterState, addReplicasProps, addResult, () -> {\n        Object addResultFailure = addResult.get(\"failure\");\n        if (addResultFailure != null) {\n          SimpleOrderedMap failure = (SimpleOrderedMap) results.get(\"failure\");\n          if (failure == null) {\n            failure = new SimpleOrderedMap();\n            results.add(\"failure\", failure);\n          }\n          failure.addAll((NamedList) addResultFailure);\n        } else {\n          SimpleOrderedMap success = (SimpleOrderedMap) results.get(\"success\");\n          if (success == null) {\n            success = new SimpleOrderedMap();\n            results.add(\"success\", success);\n          }\n          success.addAll((NamedList) addResult.get(\"success\"));\n        }\n      });\n    } catch (Assign.AssignmentException e) {\n      \r\n      ZkNodeProps deleteShard = new ZkNodeProps(COLLECTION_PROP, collectionName, SHARD_ID_PROP, sliceName, ASYNC, async);\n      new DeleteShardCmd(ccc).call(clusterState, deleteShard, results);\n      throw e;\n    }\n\n    log.info(\"Finished create command on all shards for collection: {}\", collectionName);\n  }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateShardCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":55,"status":"M"}],"commitId":"09986130545fabfb2cc76ced85a0da6ba536acf0","commitMessage":"@@@SOLR-15385 RawTypes Part VI (#207)\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>","date":"2021-07-13 23:49:56","modifiedFileCount":"185","status":"M","submitter":"Mike Drob"}]
