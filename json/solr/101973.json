[{"authorTime":"2015-03-17 13:13:36","codes":[{"authorDate":"2015-03-17 13:13:36","commitOrder":1,"curCode":"  public ManagedIndexSchema replaceField\n      (String fieldName, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      SchemaField oldField = fields.get(fieldName);\n      if (null == oldField) {\n        String msg = \"The field '\" + fieldName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      newSchema.fields.remove(fieldName);\n      newSchema.fieldsWithDefaultValue.remove(oldField);\n      newSchema.requiredFields.remove(oldField);\n\n      \r\n      SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, replacementArgs);\n      newSchema.fields.put(fieldName, replacementField);\n      if (null != replacementField.getDefaultValue()) {\n        log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n        newSchema.fieldsWithDefaultValue.add(replacementField);\n      }\n      if (replacementField.isRequired()) {\n        log.debug(\"{} is required in this schema\", replacementField.getName());\n        newSchema.requiredFields.add(replacementField);\n      }\n\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n\n      newSchema.copyFieldTargetCounts.remove(oldField); \r\n\n      \r\n      for (Map.Entry<String,List<CopyField>> entry : newSchema.copyFieldsMap.entrySet()) {\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          if (fieldName.equals(checkDestCopyField.getDestination().getName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n          }\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (fieldName.equals(dynamicCopy.getRegex()) || fieldName.equals(destinationPrototype.getName())) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-03-17 13:13:36","endLine":561,"groupId":"39453","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"replaceField","params":"(StringfieldName@FieldTypereplacementFieldType@Map<String@?>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f9/6a89fc0c2f45c79f0f4cf9a721b2a3740e8ddd.src","preCode":"  public ManagedIndexSchema replaceField\n      (String fieldName, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      SchemaField oldField = fields.get(fieldName);\n      if (null == oldField) {\n        String msg = \"The field '\" + fieldName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      newSchema.fields.remove(fieldName);\n      newSchema.fieldsWithDefaultValue.remove(oldField);\n      newSchema.requiredFields.remove(oldField);\n\n      \r\n      SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, replacementArgs);\n      newSchema.fields.put(fieldName, replacementField);\n      if (null != replacementField.getDefaultValue()) {\n        log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n        newSchema.fieldsWithDefaultValue.add(replacementField);\n      }\n      if (replacementField.isRequired()) {\n        log.debug(\"{} is required in this schema\", replacementField.getName());\n        newSchema.requiredFields.add(replacementField);\n      }\n\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n\n      newSchema.copyFieldTargetCounts.remove(oldField); \r\n\n      \r\n      for (Map.Entry<String,List<CopyField>> entry : newSchema.copyFieldsMap.entrySet()) {\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          if (fieldName.equals(checkDestCopyField.getDestination().getName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n          }\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (fieldName.equals(dynamicCopy.getRegex()) || fieldName.equals(destinationPrototype.getName())) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"B"},{"authorDate":"2015-03-17 13:13:36","commitOrder":1,"curCode":"  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      \r\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          \r\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          \r\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); \r\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      \r\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); \r\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      \r\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      \r\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-03-17 13:13:36","endLine":1157,"groupId":"20244","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"replaceFieldType","params":"(StringtypeName@StringreplacementClassName@Map<String@Object>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f9/6a89fc0c2f45c79f0f4cf9a721b2a3740e8ddd.src","preCode":"  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      \r\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          \r\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          \r\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); \r\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      \r\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); \r\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      \r\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      \r\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1037,"status":"B"}],"commitId":"ff83497b27c56dd86a94f64e081c2694772bd571","commitMessage":"@@@SOLR-6141: Schema API: Remove fields.  dynamic fields.  field types and copy fields; and replace fields.  dynamic fields and field types\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1667175 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-03-17 13:13:36","modifiedFileCount":"11","status":"B","submitter":"Steven Rowe"},{"authorTime":"2015-03-25 14:25:24","codes":[{"authorDate":"2015-03-17 13:13:36","commitOrder":2,"curCode":"  public ManagedIndexSchema replaceField\n      (String fieldName, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      SchemaField oldField = fields.get(fieldName);\n      if (null == oldField) {\n        String msg = \"The field '\" + fieldName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      newSchema.fields.remove(fieldName);\n      newSchema.fieldsWithDefaultValue.remove(oldField);\n      newSchema.requiredFields.remove(oldField);\n\n      \r\n      SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, replacementArgs);\n      newSchema.fields.put(fieldName, replacementField);\n      if (null != replacementField.getDefaultValue()) {\n        log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n        newSchema.fieldsWithDefaultValue.add(replacementField);\n      }\n      if (replacementField.isRequired()) {\n        log.debug(\"{} is required in this schema\", replacementField.getName());\n        newSchema.requiredFields.add(replacementField);\n      }\n\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n\n      newSchema.copyFieldTargetCounts.remove(oldField); \r\n\n      \r\n      for (Map.Entry<String,List<CopyField>> entry : newSchema.copyFieldsMap.entrySet()) {\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          if (fieldName.equals(checkDestCopyField.getDestination().getName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n          }\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (fieldName.equals(dynamicCopy.getRegex()) || fieldName.equals(destinationPrototype.getName())) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-03-17 13:13:36","endLine":561,"groupId":"39453","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"replaceField","params":"(StringfieldName@FieldTypereplacementFieldType@Map<String@?>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f9/6a89fc0c2f45c79f0f4cf9a721b2a3740e8ddd.src","preCode":"  public ManagedIndexSchema replaceField\n      (String fieldName, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      SchemaField oldField = fields.get(fieldName);\n      if (null == oldField) {\n        String msg = \"The field '\" + fieldName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      newSchema.fields.remove(fieldName);\n      newSchema.fieldsWithDefaultValue.remove(oldField);\n      newSchema.requiredFields.remove(oldField);\n\n      \r\n      SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, replacementArgs);\n      newSchema.fields.put(fieldName, replacementField);\n      if (null != replacementField.getDefaultValue()) {\n        log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n        newSchema.fieldsWithDefaultValue.add(replacementField);\n      }\n      if (replacementField.isRequired()) {\n        log.debug(\"{} is required in this schema\", replacementField.getName());\n        newSchema.requiredFields.add(replacementField);\n      }\n\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n\n      newSchema.copyFieldTargetCounts.remove(oldField); \r\n\n      \r\n      for (Map.Entry<String,List<CopyField>> entry : newSchema.copyFieldsMap.entrySet()) {\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          if (fieldName.equals(checkDestCopyField.getDestination().getName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n          }\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (fieldName.equals(dynamicCopy.getRegex()) || fieldName.equals(destinationPrototype.getName())) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":478,"status":"N"},{"authorDate":"2015-03-25 14:25:24","commitOrder":2,"curCode":"  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      \r\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          \r\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          \r\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); \r\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      \r\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); \r\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      \r\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      \r\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-03-25 14:25:24","endLine":1169,"groupId":"20244","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"replaceFieldType","params":"(StringtypeName@StringreplacementClassName@Map<String@Object>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/0d/dfb5969dffa0a8f64b61261fcd1443eb72bd9f.src","preCode":"  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      \r\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          \r\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          \r\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); \r\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      \r\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); \r\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      \r\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      \r\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1047,"status":"M"}],"commitId":"9b255d6cc4f105e97a559b8d402d802349fcd694","commitMessage":"@@@SOLR-6141: fix TestBulkSchemaConcurrent; fix field deletion to fail when a dynamic copy field directive has the field as its source; don't attempt to decrement a SchemaField's count in copyFieldTargetCounts if it's not present in the map.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1669055 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-03-25 14:25:24","modifiedFileCount":"2","status":"M","submitter":"Steven Rowe"},{"authorTime":"2015-04-09 12:42:30","codes":[{"authorDate":"2015-04-09 12:42:30","commitOrder":3,"curCode":"  public ManagedIndexSchema replaceField\n      (String fieldName, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      SchemaField oldField = fields.get(fieldName);\n      if (null == oldField) {\n        String msg = \"The field '\" + fieldName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      newSchema.fields.remove(fieldName);\n      newSchema.fieldsWithDefaultValue.remove(oldField);\n      newSchema.requiredFields.remove(oldField);\n\n      \r\n      SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, replacementArgs);\n      newSchema.fields.put(fieldName, replacementField);\n      if (null != replacementField.getDefaultValue()) {\n        log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n        newSchema.fieldsWithDefaultValue.add(replacementField);\n      }\n      if (replacementField.isRequired()) {\n        log.debug(\"{} is required in this schema\", replacementField.getName());\n        newSchema.requiredFields.add(replacementField);\n      }\n\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n\n      newSchema.copyFieldTargetCounts.remove(oldField); \r\n\n      \r\n      for (Map.Entry<String,List<CopyField>> entry : newSchema.copyFieldsMap.entrySet()) {\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          if (fieldName.equals(checkDestCopyField.getDestination().getName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n          }\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (fieldName.equals(dynamicCopy.getRegex()) || fieldName.equals(destinationPrototype.getName())) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-04-09 12:42:30","endLine":555,"groupId":"39453","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"replaceField","params":"(StringfieldName@FieldTypereplacementFieldType@Map<String@?>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/66/6d6bc65b8edc75fb83961e5399755eea21c27c.src","preCode":"  public ManagedIndexSchema replaceField\n      (String fieldName, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      SchemaField oldField = fields.get(fieldName);\n      if (null == oldField) {\n        String msg = \"The field '\" + fieldName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      newSchema.fields.remove(fieldName);\n      newSchema.fieldsWithDefaultValue.remove(oldField);\n      newSchema.requiredFields.remove(oldField);\n\n      \r\n      SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, replacementArgs);\n      newSchema.fields.put(fieldName, replacementField);\n      if (null != replacementField.getDefaultValue()) {\n        log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n        newSchema.fieldsWithDefaultValue.add(replacementField);\n      }\n      if (replacementField.isRequired()) {\n        log.debug(\"{} is required in this schema\", replacementField.getName());\n        newSchema.requiredFields.add(replacementField);\n      }\n\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n\n      newSchema.copyFieldTargetCounts.remove(oldField); \r\n\n      \r\n      for (Map.Entry<String,List<CopyField>> entry : newSchema.copyFieldsMap.entrySet()) {\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          if (fieldName.equals(checkDestCopyField.getDestination().getName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n          }\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (fieldName.equals(dynamicCopy.getRegex()) || fieldName.equals(destinationPrototype.getName())) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":474,"status":"M"},{"authorDate":"2015-04-09 12:42:30","commitOrder":3,"curCode":"  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      \r\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          \r\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          \r\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); \r\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      \r\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); \r\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      \r\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      \r\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2015-04-09 12:42:30","endLine":1124,"groupId":"20244","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"replaceFieldType","params":"(StringtypeName@StringreplacementClassName@Map<String@Object>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/66/6d6bc65b8edc75fb83961e5399755eea21c27c.src","preCode":"  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      \r\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          \r\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          \r\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); \r\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      \r\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); \r\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      \r\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      \r\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      for (FieldType fieldType : newSchema.fieldTypes.values()) {\n        newSchema.informResourceLoaderAwareObjectsForFieldType(fieldType);\n      }\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1007,"status":"M"}],"commitId":"4c83c2200c9b2097cad09e5dd0f97033254620df","commitMessage":"@@@SOLR-7366: fix regression in ManagedIndexSchema's handling of ResourceLoaderAware objects used by field types.  causing example XML docs to not be indexable via bin/post; add a test indexing example docs that fails without the patch and succeeds with it\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1672238 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-04-09 12:42:30","modifiedFileCount":"2","status":"M","submitter":"Steven Rowe"},{"authorTime":"2020-04-20 03:58:50","codes":[{"authorDate":"2020-04-20 03:58:50","commitOrder":4,"curCode":"  public ManagedIndexSchema replaceField\n      (String fieldName, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      SchemaField oldField = fields.get(fieldName);\n      if (null == oldField) {\n        String msg = \"The field '\" + fieldName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      newSchema.fields.remove(fieldName);\n      newSchema.fieldsWithDefaultValue.remove(oldField);\n      newSchema.requiredFields.remove(oldField);\n\n      \r\n      SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, replacementArgs);\n      newSchema.fields.put(fieldName, replacementField);\n      if (null != replacementField.getDefaultValue()) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"{} contains default value: {}\", replacementField.getName(), replacementField.getDefaultValue());\n        }\n        newSchema.fieldsWithDefaultValue.add(replacementField);\n      }\n      if (replacementField.isRequired()) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"{} is required in this schema\", replacementField.getName());\n        }\n        newSchema.requiredFields.add(replacementField);\n      }\n\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n\n      newSchema.copyFieldTargetCounts.remove(oldField); \r\n\n      \r\n      for (Map.Entry<String,List<CopyField>> entry : newSchema.copyFieldsMap.entrySet()) {\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          if (fieldName.equals(checkDestCopyField.getDestination().getName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n          }\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (fieldName.equals(dynamicCopy.getRegex()) || fieldName.equals(destinationPrototype.getName())) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2020-04-20 03:58:50","endLine":575,"groupId":"101973","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"replaceField","params":"(StringfieldName@FieldTypereplacementFieldType@Map<String@?>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/8f/04b2230384f85bff293769ea6c93b239d6756d.src","preCode":"  public ManagedIndexSchema replaceField\n      (String fieldName, FieldType replacementFieldType, Map<String,?> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      SchemaField oldField = fields.get(fieldName);\n      if (null == oldField) {\n        String msg = \"The field '\" + fieldName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n\n      \r\n      newSchema.fields.remove(fieldName);\n      newSchema.fieldsWithDefaultValue.remove(oldField);\n      newSchema.requiredFields.remove(oldField);\n\n      \r\n      SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, replacementArgs);\n      newSchema.fields.put(fieldName, replacementField);\n      if (null != replacementField.getDefaultValue()) {\n        log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n        newSchema.fieldsWithDefaultValue.add(replacementField);\n      }\n      if (replacementField.isRequired()) {\n        log.debug(\"{} is required in this schema\", replacementField.getName());\n        newSchema.requiredFields.add(replacementField);\n      }\n\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n\n      newSchema.copyFieldTargetCounts.remove(oldField); \r\n\n      \r\n      for (Map.Entry<String,List<CopyField>> entry : newSchema.copyFieldsMap.entrySet()) {\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          if (fieldName.equals(checkDestCopyField.getDestination().getName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n          }\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (fieldName.equals(dynamicCopy.getRegex()) || fieldName.equals(destinationPrototype.getName())) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":490,"status":"M"},{"authorDate":"2020-04-20 03:58:50","commitOrder":4,"curCode":"  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      \r\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          \r\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          \r\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); \r\n          if (null != replacementField.getDefaultValue()) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"{} contains default value: {}\", replacementField.getName(), replacementField.getDefaultValue());\n            }\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"{} is required in this schema\", replacementField.getName());\n            }\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      \r\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); \r\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      \r\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      \r\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","date":"2020-04-20 03:58:50","endLine":1170,"groupId":"101973","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"replaceFieldType","params":"(StringtypeName@StringreplacementClassName@Map<String@Object>replacementArgs)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/8f/04b2230384f85bff293769ea6c93b239d6756d.src","preCode":"  public ManagedIndexSchema replaceFieldType(String typeName, String replacementClassName, Map<String,Object> replacementArgs) {\n    ManagedIndexSchema newSchema;\n    if (isMutable) {\n      if ( ! fieldTypes.containsKey(typeName)) {\n        String msg = \"The field type '\" + typeName + \"' is not present in this schema, and so cannot be replaced.\";\n        throw new SolrException(ErrorCode.BAD_REQUEST, msg);\n      }\n      newSchema = shallowCopy(true);\n      \r\n      newSchema.fieldTypes = (Map<String,FieldType>)((HashMap<String,FieldType>)fieldTypes).clone();\n      newSchema.copyFieldsMap = cloneCopyFieldsMap(copyFieldsMap);\n      newSchema.copyFieldTargetCounts\n          = (Map<SchemaField,Integer>)((HashMap<SchemaField,Integer>)copyFieldTargetCounts).clone();\n      newSchema.dynamicCopyFields = new DynamicCopy[dynamicCopyFields.length];\n      System.arraycopy(dynamicCopyFields, 0, newSchema.dynamicCopyFields, 0, dynamicCopyFields.length);\n      newSchema.dynamicFields = new DynamicField[dynamicFields.length];\n      System.arraycopy(dynamicFields, 0, newSchema.dynamicFields, 0, dynamicFields.length);\n      \n      newSchema.fieldTypes.remove(typeName);\n      FieldType replacementFieldType = newSchema.newFieldType(typeName, replacementClassName, replacementArgs);\n      newSchema.fieldTypes.put(typeName, replacementFieldType);\n\n      \r\n      List<CopyField> copyFieldsToRebuild = new ArrayList<>();\n      List<SchemaField> replacementFields = new ArrayList<>();\n      Iterator<Map.Entry<String,SchemaField>> fieldsIter = newSchema.fields.entrySet().iterator();\n      while (fieldsIter.hasNext()) {\n        Map.Entry<String,SchemaField> entry = fieldsIter.next();\n        SchemaField oldField = entry.getValue();\n        if (oldField.getType().getTypeName().equals(typeName)) {\n          String fieldName = oldField.getName();\n          \n          \r\n          fieldsIter.remove();\n          newSchema.fieldsWithDefaultValue.remove(oldField);\n          newSchema.requiredFields.remove(oldField);\n          \n          \r\n          SchemaField replacementField = SchemaField.create(fieldName, replacementFieldType, oldField.getArgs());\n          replacementFields.add(replacementField); \r\n          if (null != replacementField.getDefaultValue()) {\n            log.debug(replacementField.getName() + \" contains default value: \" + replacementField.getDefaultValue());\n            newSchema.fieldsWithDefaultValue.add(replacementField);\n          }\n          if (replacementField.isRequired()) {\n            log.debug(\"{} is required in this schema\", replacementField.getName());\n            newSchema.requiredFields.add(replacementField);\n          }\n          newSchema.removeCopyFieldSource(fieldName, copyFieldsToRebuild);\n        }\n      }\n      for (SchemaField replacementField : replacementFields) {\n        newSchema.fields.put(replacementField.getName(), replacementField);\n      }\n      \r\n      Iterator<Map.Entry<String,List<CopyField>>> copyFieldsMapIter = newSchema.copyFieldsMap.entrySet().iterator();\n      while (copyFieldsMapIter.hasNext()) {\n        Map.Entry<String,List<CopyField>> entry = copyFieldsMapIter.next();\n        List<CopyField> perSourceCopyFields = entry.getValue();\n        Iterator<CopyField> checkDestCopyFieldsIter = perSourceCopyFields.iterator();\n        while (checkDestCopyFieldsIter.hasNext()) {\n          CopyField checkDestCopyField = checkDestCopyFieldsIter.next();\n          SchemaField destination = checkDestCopyField.getDestination();\n          if (typeName.equals(destination.getType().getTypeName())) {\n            checkDestCopyFieldsIter.remove();\n            copyFieldsToRebuild.add(checkDestCopyField);\n            newSchema.copyFieldTargetCounts.remove(destination); \r\n          }\n        }\n        if (perSourceCopyFields.isEmpty()) {\n          copyFieldsMapIter.remove();\n        }\n      }\n      \r\n      for (int i = 0; i < newSchema.dynamicFields.length; ++i) {\n        SchemaField prototype = newSchema.dynamicFields[i].getPrototype();\n        if (typeName.equals(prototype.getType().getTypeName())) {\n          newSchema.dynamicFields[i] = new DynamicField\n              (SchemaField.create(prototype.getName(), replacementFieldType, prototype.getArgs()));\n        }\n      }\n      \r\n      \r\n      List<DynamicCopy> dynamicCopyFieldsToRebuild = new ArrayList<>();\n      List<DynamicCopy> newDynamicCopyFields = new ArrayList<>();\n      for (int i = 0 ; i < newSchema.dynamicCopyFields.length ; ++i) {\n        DynamicCopy dynamicCopy = newSchema.dynamicCopyFields[i];\n        DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n        SchemaField destinationPrototype = dynamicCopy.getDestination().getPrototype();\n        if (typeName.equals(destinationPrototype.getType().getTypeName())\n            || (null != sourceDynamicBase && typeName.equals(sourceDynamicBase.getPrototype().getType().getTypeName()))) {\n          dynamicCopyFieldsToRebuild.add(dynamicCopy);\n          if (newSchema.copyFieldTargetCounts.containsKey(destinationPrototype)) {\n            newSchema.decrementCopyFieldTargetCount(destinationPrototype);\n          }\n          \r\n        } else {\n          newDynamicCopyFields.add(dynamicCopy);\n        }\n      }\n      \r\n      if (dynamicCopyFieldsToRebuild.size() > 0) {\n        newSchema.dynamicCopyFields = newDynamicCopyFields.toArray(new DynamicCopy[newDynamicCopyFields.size()]);\n        for (DynamicCopy dynamicCopy : dynamicCopyFieldsToRebuild) {\n          newSchema.registerCopyField(dynamicCopy.getRegex(), dynamicCopy.getDestFieldName(), dynamicCopy.getMaxChars());\n        }\n      }\n      newSchema.rebuildCopyFields(copyFieldsToRebuild);\n\n      newSchema.postReadInform();\n      newSchema.refreshAnalyzers();\n    } else {\n      String msg = \"This ManagedIndexSchema is not mutable.\";\n      log.error(msg);\n      throw new SolrException(ErrorCode.SERVER_ERROR, msg);\n    }\n    return newSchema;\n  }\n","realPath":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":1049,"status":"M"}],"commitId":"f01c040ab3a600eb20995a9faf8d1b526efef321","commitMessage":"@@@LUCENE-7788: fail precommit on unparameterised log messages and examine for wasted work/objects\n","date":"2020-04-20 03:58:50","modifiedFileCount":"27","status":"M","submitter":"Erick Erickson"}]
