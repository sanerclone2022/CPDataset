[{"authorTime":"2017-06-29 17:00:17","codes":[{"authorDate":"2017-06-29 17:00:17","commitOrder":3,"curCode":"  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    \r\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id: \" + msg,\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n","date":"2017-06-29 17:00:17","endLine":396,"groupId":"26450","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testClientErrorOnMalformedDate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/52/e2e7818195f888a74aa9efc56fd13d173f26e7.src","preCode":"  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    \r\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id: \" + msg,\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"B"},{"authorDate":"2017-06-29 17:00:17","commitOrder":3,"curCode":"  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    \r\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id\",\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n","date":"2017-06-29 17:00:17","endLine":454,"groupId":"26450","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testClientErrorOnMalformedNumbers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/52/e2e7818195f888a74aa9efc56fd13d173f26e7.src","preCode":"  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    \r\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id\",\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":399,"status":"MB"}],"commitId":"b4fa0e785b70e39a3a1420bc020ad1183308b7af","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2017-06-29 17:00:17","modifiedFileCount":"697","status":"M","submitter":"Karl Wright"},{"authorTime":"2018-08-10 03:42:17","codes":[{"authorDate":"2018-08-10 03:42:17","commitOrder":4,"curCode":"  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    \r\n    for (String field : FIELDS) {\n      SolrException e1 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a bad date: \" + field,\n          () -> h.update(add( doc(\"id\",\"100\", field, BAD_VALUE))));\n      String msg1 = e1.getMessage();\n      assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg1,\n          400 <= e1.code() && e1.code() < 500);\n      assertTrue(\"(update) client error does not mention bad value: \" + msg1,\n          msg1.contains(BAD_VALUE));\n      assertTrue(\"client error does not mention document id: \" + msg1,\n          msg1.contains(\"[doc=100]\"));\n      SchemaField sf = h.getCore().getLatestSchema().getField(field);\n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      SolrException e2 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a bad date: \" + field,\n          () -> h.query(req(\"q\",field + \":\" + BAD_VALUE))\n      );\n      String msg2 = e2.toString();\n      assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg2,\n          400 <= e2.code() && e2.code() < 500);\n      assertTrue(\"(search) client error does not mention bad value: \" + msg2,\n          msg2.contains(BAD_VALUE));\n\n      SolrException e3 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a bad date: \" + field,\n          () -> h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"))\n      );\n      String msg3 = e3.toString();\n      assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg3,\n          400 <= e3.code() && e3.code() < 500);\n      assertTrue(\"(search) client error does not mention bad value: \" + msg3,\n          msg3.contains(BAD_VALUE));\n    }\n  }\n","date":"2018-08-10 03:46:50","endLine":393,"groupId":"103356","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testClientErrorOnMalformedDate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/18/c4f69f78e9b088e7666689c23aae1014966aaf.src","preCode":"  public void testClientErrorOnMalformedDate() throws Exception {\n    final String BAD_VALUE = \"NOT_A_DATE\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"tdt\", \"tdt1\", \"tdtdv\", \"tdtdv1\",\n        \"dt_dv\", \"dt_dvo\", \"dt\", \"dt1\", \"dt_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    \r\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id: \" + msg,\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[NOW TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a bad date: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":345,"status":"M"},{"authorDate":"2018-08-10 03:42:17","commitOrder":4,"curCode":"  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    \r\n    for (String field : FIELDS) {\n      SolrException e1 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a non-number: \" + field,\n          () -> h.update(add( doc(\"id\",\"100\", field, BAD_VALUE))));\n      String msg1 = e1.toString();\n      assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg1,\n          400 <= e1.code() && e1.code() < 500);\n      assertTrue(\"(update) client error does not mention bad value: \" + msg1,\n          msg1.contains(BAD_VALUE));\n      assertTrue(\"client error does not mention document id\",\n          msg1.contains(\"[doc=100]\"));\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n\n      SolrException e2 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a non-number: \" + field,\n          () -> h.query(req(\"q\",field + \":\" + BAD_VALUE))\n      );\n      String msg2 = e2.toString();\n      assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg2,\n          400 <= e2.code() && e2.code() < 500);\n      assertTrue(\"(search) client error does not mention bad value: \" + msg2,\n          msg2.contains(BAD_VALUE));\n\n      SolrException e3 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a non-number: \" + field,\n          () -> h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"))\n      );\n      String msg3 = e3.toString();\n      assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg3,\n          400 <= e3.code() && e3.code() < 500);\n      assertTrue(\"(search) client error does not mention bad value: \" + msg3,\n          msg3.contains(BAD_VALUE));\n    }\n  }\n","date":"2018-08-10 03:46:50","endLine":449,"groupId":"103356","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testClientErrorOnMalformedNumbers","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/18/c4f69f78e9b088e7666689c23aae1014966aaf.src","preCode":"  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    \r\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id\",\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n","realPath":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":396,"status":"M"}],"commitId":"00aeb64c10290780256476de2266a9bb600c336d","commitMessage":"@@@SOLR-12555: Use `expectThrows` for expected exceptions\n\nThis commit replaces the `try { doX(); fail(); }` pattern with the\n`expectThrows` test helper.  which was created for this purpose.  This\ncommit makes these changes in the core package: `o.a.solr.cloud`.\n\nCloses #425\n","date":"2018-08-10 03:46:50","modifiedFileCount":"27","status":"M","submitter":"Jason Gerlowski"}]
