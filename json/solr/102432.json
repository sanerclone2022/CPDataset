[{"authorTime":"2021-02-04 21:47:30","codes":[{"authorDate":"2021-02-04 21:47:30","commitOrder":1,"curCode":"    private void markAllShardsAsConstruction(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      \r\n      Map<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.CONSTRUCTION.toString());\n      }\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n    }\n","date":"2021-02-04 21:47:30","endLine":347,"groupId":"36420","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"markAllShardsAsConstruction","params":"(DocCollectionrestoreCollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/48/a584bbb4f0a1a2beaf11dfdf6ab48edc884f96.src","preCode":"    private void markAllShardsAsConstruction(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      \r\n      Map<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.CONSTRUCTION.toString());\n      }\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":338,"status":"B"},{"authorDate":"2021-02-04 21:47:30","commitOrder":1,"curCode":"    private void markAllShardsAsActive(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      HashMap<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.ACTIVE.toString());\n      }\n      ocmh.overseer.offerStateUpdate((Utils.toJSON(new ZkNodeProps(propMap))));\n    }\n","date":"2021-02-04 21:47:30","endLine":465,"groupId":"36422","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"markAllShardsAsActive","params":"(DocCollectionrestoreCollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/48/a584bbb4f0a1a2beaf11dfdf6ab48edc884f96.src","preCode":"    private void markAllShardsAsActive(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      HashMap<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.ACTIVE.toString());\n      }\n      ocmh.overseer.offerStateUpdate((Utils.toJSON(new ZkNodeProps(propMap))));\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":457,"status":"B"}],"commitId":"33d16b570c7630fde784552193ad495b63abd3e3","commitMessage":"@@@SOLR-13608: Incremental backup file format (#2250)\n\nThis commit introduces a new way for Solr to do backups (with a new\nunderlying file structure).  This new \"incremental\" backup process\nimproves over the existing backup mechanism in several ways:\n\n- multiple backups \"points\" can now be stored at a given backup\n  location/name.  allowing users to choose which point in time they want\n  to restore\n- subsequent backups skip over uploading files that were uploaded by\n  previous backups.  saving time and network time.\n- files are checksumed as they're uploaded.  ensuring that corrupted\n  indices aren't persisted and accidentally restored later.\n\nIncremental backups are now the default.  and traditional backups\nshould now be considered 'deprecated' but can still be created by\npassing an `incremental=false` parameter on backup requests.","date":"2021-02-04 21:47:30","modifiedFileCount":"23","status":"B","submitter":"Jason Gerlowski"},{"authorTime":"2021-02-13 09:42:18","codes":[{"authorDate":"2021-02-13 09:42:18","commitOrder":2,"curCode":"    private void markAllShardsAsConstruction(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      \r\n      Map<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.CONSTRUCTION.toString());\n      }\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      if (ocmh.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n        ocmh.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceUpdateShardState, new ZkNodeProps(propMap),\n            ocmh.cloudManager, ocmh.zkStateReader);\n      } else {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n      }\n    }\n","date":"2021-02-13 09:42:18","endLine":352,"groupId":"30175","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"markAllShardsAsConstruction","params":"(DocCollectionrestoreCollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/77/4e054c69499ee3c2124d15442afb0e786110cb.src","preCode":"    private void markAllShardsAsConstruction(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      \r\n      Map<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.CONSTRUCTION.toString());\n      }\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":338,"status":"M"},{"authorDate":"2021-02-13 09:42:18","commitOrder":2,"curCode":"    private void markAllShardsAsActive(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      HashMap<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.ACTIVE.toString());\n      }\n      if (ocmh.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n        ocmh.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceUpdateShardState, new ZkNodeProps(propMap),\n            ocmh.cloudManager, ocmh.zkStateReader);\n      } else {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n      }\n    }\n","date":"2021-02-13 09:42:18","endLine":475,"groupId":"30179","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"markAllShardsAsActive","params":"(DocCollectionrestoreCollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/77/4e054c69499ee3c2124d15442afb0e786110cb.src","preCode":"    private void markAllShardsAsActive(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      HashMap<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.ACTIVE.toString());\n      }\n      ocmh.overseer.offerStateUpdate((Utils.toJSON(new ZkNodeProps(propMap))));\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":462,"status":"M"}],"commitId":"23755ddfdd36a9613010cb9e6201127df55be744","commitMessage":"@@@SOLR-14928: allow cluster state updates to be done in a distributed way and not through Overseer (#2364)\n\n","date":"2021-02-13 09:42:18","modifiedFileCount":"42","status":"M","submitter":"Ilan Ginzburg"},{"authorTime":"2021-02-19 21:40:23","codes":[{"authorDate":"2021-02-19 21:40:23","commitOrder":3,"curCode":"    private void markAllShardsAsConstruction(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      \r\n      Map<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.CONSTRUCTION.toString());\n      }\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n        ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceUpdateShardState, new ZkNodeProps(propMap),\n            ccc.getSolrCloudManager(), ccc.getZkStateReader());\n      } else {\n        ccc.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n      }\n    }\n","date":"2021-02-19 21:40:23","endLine":353,"groupId":"102432","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"markAllShardsAsConstruction","params":"(DocCollectionrestoreCollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/86/0605cda463d7d0908bf8d0a31dd31f476a6148.src","preCode":"    private void markAllShardsAsConstruction(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      \r\n      Map<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.CONSTRUCTION.toString());\n      }\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      if (ocmh.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n        ocmh.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceUpdateShardState, new ZkNodeProps(propMap),\n            ocmh.cloudManager, ocmh.zkStateReader);\n      } else {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n      }\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":339,"status":"M"},{"authorDate":"2021-02-19 21:40:23","commitOrder":3,"curCode":"    private void markAllShardsAsActive(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      HashMap<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.ACTIVE.toString());\n      }\n      if (ccc.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n        ccc.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceUpdateShardState, new ZkNodeProps(propMap),\n            ccc.getSolrCloudManager(), ccc.getZkStateReader());\n      } else {\n        ccc.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n      }\n    }\n","date":"2021-02-19 21:40:23","endLine":476,"groupId":"102432","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"markAllShardsAsActive","params":"(DocCollectionrestoreCollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/86/0605cda463d7d0908bf8d0a31dd31f476a6148.src","preCode":"    private void markAllShardsAsActive(DocCollection restoreCollection) throws KeeperException, InterruptedException {\n      HashMap<String, Object> propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n      propMap.put(ZkStateReader.COLLECTION_PROP, restoreCollection.getName());\n      for (Slice shard : restoreCollection.getSlices()) {\n        propMap.put(shard.getName(), Slice.State.ACTIVE.toString());\n      }\n      if (ocmh.getDistributedClusterStateUpdater().isDistributedStateUpdate()) {\n        ocmh.getDistributedClusterStateUpdater().doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.SliceUpdateShardState, new ZkNodeProps(propMap),\n            ocmh.cloudManager, ocmh.zkStateReader);\n      } else {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(new ZkNodeProps(propMap)));\n      }\n    }\n","realPath":"solr/core/src/java/org/apache/solr/cloud/api/collections/RestoreCmd.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":463,"status":"M"}],"commitId":"e7c80f6445a04cb3d1b49d85d773fde283c916fe","commitMessage":"@@@SOLR-15157: refactor Collection API to separate from Overseer and message handling abstractions (#2390)\n\nNo functional changes. In preparation of distributing the Collection API command execution.","date":"2021-02-19 21:40:23","modifiedFileCount":"42","status":"M","submitter":"Ilan Ginzburg"}]
