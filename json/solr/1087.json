[{"authorTime":"2016-04-14 04:15:53","codes":[{"authorDate":"2018-12-17 00:58:20","commitOrder":6,"curCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      request.setBasePath(basePath);\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n    req.setBasePath(basePath);\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","date":"2018-12-17 00:58:20","endLine":418,"groupId":"31910","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"request","params":"(finalSolrRequestrequest@Stringcollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/ac/7449b65054af6f2ed91807ede3091664826b8c.src","preCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      request.setBasePath(basePath);\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n    req.setBasePath(basePath);\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":330,"status":"B"},{"authorDate":"2016-04-14 04:15:53","commitOrder":6,"curCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","date":"2016-04-14 04:15:53","endLine":504,"groupId":"31910","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"request","params":"(finalSolrRequestrequest@Stringcollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f2/09672b247fece5cb4571f5ad8cb0984e026e30.src","preCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":417,"status":"NB"}],"commitId":"f80e8e11672d31c6e12069d2bd12a28b92e5a336","commitMessage":"@@@Merge jira/http2 branch to master\n","date":"2018-12-17 00:58:20","modifiedFileCount":"47","status":"M","submitter":"Cao Manh Dat"},{"authorTime":"2019-12-11 04:45:43","codes":[{"authorDate":"2019-12-11 04:45:43","commitOrder":7,"curCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      request.setBasePath(basePath);\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n    req.setBasePath(basePath);\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","date":"2019-12-11 04:45:43","endLine":455,"groupId":"31910","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"request","params":"(finalSolrRequestrequest@Stringcollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/bb/0c5822f6ec10743fcadef6d9198373adcb3ebf.src","preCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      request.setBasePath(basePath);\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n    req.setBasePath(basePath);\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":346,"status":"M"},{"authorDate":"2019-12-11 04:45:43","commitOrder":7,"curCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","date":"2019-12-11 04:45:43","endLine":588,"groupId":"31910","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"request","params":"(finalSolrRequestrequest@Stringcollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/d9/21cb2114af37456fe372f44f3bed753cc789a3.src","preCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":480,"status":"M"}],"commitId":"c4f0c3363828c088eefa2b99783178848c2f1f7a","commitMessage":"@@@SOLR-13975.  SOLR-13896: ConcurrentUpdateSolrClient connection stall prevention.\n","date":"2019-12-11 04:45:43","modifiedFileCount":"8","status":"M","submitter":"Andrzej Bialecki"},{"authorTime":"2020-06-13 08:06:16","codes":[{"authorDate":"2020-06-13 08:06:16","commitOrder":8,"curCode":"  public NamedList<Object> request(@SuppressWarnings({\"rawtypes\"})final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      request.setBasePath(basePath);\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n    req.setBasePath(basePath);\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","date":"2020-06-13 08:06:16","endLine":458,"groupId":"31910","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"request","params":"(@SuppressWarnings({\"rawtypes\"})finalSolrRequestrequest@Stringcollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a1/334cbf1c3786a6d8611942a52e21532b27b12e.src","preCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      request.setBasePath(basePath);\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n    req.setBasePath(basePath);\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":349,"status":"M"},{"authorDate":"2020-06-13 08:06:16","commitOrder":8,"curCode":"  public NamedList<Object> request(@SuppressWarnings({\"rawtypes\"})final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","date":"2020-06-13 08:06:16","endLine":593,"groupId":"31910","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"request","params":"(@SuppressWarnings({\"rawtypes\"})finalSolrRequestrequest@Stringcollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/b3/bbcc2bfaa4616cf7ea90c1297733b88edb4523.src","preCode":"  public NamedList<Object> request(final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":485,"status":"M"}],"commitId":"6801d4c13982b42007ec6d1ea1f443902e2fb438","commitMessage":"@@@SOLR-14565: Fix or suppress warnings in solrj/impl and solrj/io/graph\n","date":"2020-06-13 08:06:16","modifiedFileCount":"28","status":"M","submitter":"Erick Erickson"},{"authorTime":"2021-06-22 00:19:37","codes":[{"authorDate":"2021-06-22 00:19:37","commitOrder":9,"curCode":"  public NamedList<Object> request(final SolrRequest<?> request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      request.setBasePath(basePath);\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n    req.setBasePath(basePath);\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","date":"2021-06-22 00:19:37","endLine":458,"groupId":"1087","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"request","params":"(finalSolrRequest<?>request@Stringcollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a7/05121a8842c554831a0d83fb06cfa45bec09d6.src","preCode":"  public NamedList<Object> request(@SuppressWarnings({\"rawtypes\"})final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      request.setBasePath(basePath);\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n    req.setBasePath(basePath);\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":349,"status":"M"},{"authorDate":"2021-06-22 00:19:37","commitOrder":9,"curCode":"  public NamedList<Object> request(final SolrRequest<?> request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","date":"2021-06-22 00:19:37","endLine":594,"groupId":"1087","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"request","params":"(finalSolrRequest<?>request@Stringcollection)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/94/bd8671074e31484afb6ee971c2a49925b8a081.src","preCode":"  public NamedList<Object> request(@SuppressWarnings({\"rawtypes\"})final SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    if (!(request instanceof UpdateRequest)) {\n      return client.request(request, collection);\n    }\n    UpdateRequest req = (UpdateRequest) request;\n\n    \r\n    if (streamDeletes) {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())\n          && (req.getDeleteById() == null || req.getDeleteById().isEmpty())\n          && (req.getDeleteByIdMap() == null || req.getDeleteByIdMap().isEmpty())) {\n        if (req.getDeleteQuery() == null) {\n          blockUntilFinished();\n          return client.request(request, collection);\n        }\n      }\n    } else {\n      if ((req.getDocuments() == null || req.getDocuments().isEmpty())) {\n        blockUntilFinished();\n        return client.request(request, collection);\n      }\n    }\n\n\n    SolrParams params = req.getParams();\n    if (params != null) {\n      \r\n      if (params.getBool(UpdateParams.WAIT_SEARCHER, false)) {\n        log.info(\"blocking for commit/optimize\");\n        blockUntilFinished(); \r\n        return client.request(request, collection);\n      }\n    }\n\n    try {\n      CountDownLatch tmpLock = lock;\n      if (tmpLock != null) {\n        tmpLock.await();\n      }\n\n      Update update = new Update(req, collection);\n      boolean success = queue.offer(update);\n\n      long lastStallTime = -1;\n      int lastQueueSize = -1;\n      for (;;) {\n        synchronized (runners) {\n          \r\n          \r\n          \r\n          if (runners.isEmpty() || (queue.remainingCapacity() < queue.size() && runners.size() < threadCount))\n          {\n            \r\n            addRunner();\n          } else {\n            \r\n            \r\n            \r\n            \r\n            if (success)\n              break;\n          }\n        }\n\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        if (!success) {\n          success = queue.offer(update, 100, TimeUnit.MILLISECONDS);\n        }\n        if (!success) {\n          \r\n          int currentQueueSize = queue.size();\n          if (currentQueueSize != lastQueueSize) {\n            \r\n            lastQueueSize = currentQueueSize;\n            lastStallTime = -1;\n          } else {\n            if (lastStallTime == -1) {\n              \r\n              lastStallTime = System.nanoTime();\n            } else {\n              long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n              if (currentStallTime > stallTime) {\n                throw new IOException(\"Request processing has stalled for \" + currentStallTime + \"ms with \" + queue.size() + \" remaining elements in the queue.\");\n              }\n            }\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.error(\"interrupted\", e);\n      throw new IOException(e.getLocalizedMessage());\n    }\n\n    \r\n    NamedList<Object> dummy = new NamedList<>();\n    dummy.add(\"NOTE\", \"the request is processed in a background stream\");\n    return dummy;\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":486,"status":"M"}],"commitId":"1725e778ac86d88e2deff8f7339d45bb4e50a719","commitMessage":"@@@SOLR-15385 RawTypes Part III.  contrib and solrj (#169)\n\n* SOLR-15385 RawTypes Part III.  contrib and solrj\n\nCo-authored-by: Christine Poerschke <cpoerschke@apache.org>","date":"2021-06-22 00:19:37","modifiedFileCount":"216","status":"M","submitter":"Mike Drob"}]
