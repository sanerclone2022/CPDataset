[{"authorTime":"2016-05-26 01:42:11","codes":[{"authorDate":"2016-05-26 01:42:11","commitOrder":1,"curCode":"  public void testLongFieldCache() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = newIndexWriterConfig(new MockAnalyzer(random()));\n    cfg.setMergePolicy(newLogMergePolicy());\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    Document doc = new Document();\n    LongPoint field = new LongPoint(\"f\", 0L);\n    StoredField field2 = new StoredField(\"f\", 0L);\n    doc.add(field);\n    doc.add(field2);\n    final long[] values = new long[TestUtil.nextInt(random(), 1, 10)];\n    for (int i = 0; i < values.length; ++i) {\n      final long v;\n      switch (random().nextInt(10)) {\n        case 0:\n          v = Long.MIN_VALUE;\n          break;\n        case 1:\n          v = 0;\n          break;\n        case 2:\n          v = Long.MAX_VALUE;\n          break;\n        default:\n          v = TestUtil.nextLong(random(), -10, 10);\n          break;\n      }\n      values[i] = v;\n      if (v == 0 && random().nextBoolean()) {\n        \r\n        iw.addDocument(new Document());\n      } else {\n        field.setLongValue(v);\n        field2.setLongValue(v);\n        iw.addDocument(doc);\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    final NumericDocValues longs = FieldCache.DEFAULT.getNumerics(getOnlyLeafReader(reader), \"f\", FieldCache.LONG_POINT_PARSER, false);\n    for (int i = 0; i < values.length; ++i) {\n      assertEquals(values[i], longs.get(i));\n    }\n    reader.close();\n    iw.close();\n    dir.close();\n  }\n","date":"2016-05-26 01:42:11","endLine":683,"groupId":"28104","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testLongFieldCache","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/af/9ea952f6e27496597155605ce2dd009b5af1b3.src","preCode":"  public void testLongFieldCache() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = newIndexWriterConfig(new MockAnalyzer(random()));\n    cfg.setMergePolicy(newLogMergePolicy());\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    Document doc = new Document();\n    LongPoint field = new LongPoint(\"f\", 0L);\n    StoredField field2 = new StoredField(\"f\", 0L);\n    doc.add(field);\n    doc.add(field2);\n    final long[] values = new long[TestUtil.nextInt(random(), 1, 10)];\n    for (int i = 0; i < values.length; ++i) {\n      final long v;\n      switch (random().nextInt(10)) {\n        case 0:\n          v = Long.MIN_VALUE;\n          break;\n        case 1:\n          v = 0;\n          break;\n        case 2:\n          v = Long.MAX_VALUE;\n          break;\n        default:\n          v = TestUtil.nextLong(random(), -10, 10);\n          break;\n      }\n      values[i] = v;\n      if (v == 0 && random().nextBoolean()) {\n        \r\n        iw.addDocument(new Document());\n      } else {\n        field.setLongValue(v);\n        field2.setLongValue(v);\n        iw.addDocument(doc);\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    final NumericDocValues longs = FieldCache.DEFAULT.getNumerics(getOnlyLeafReader(reader), \"f\", FieldCache.LONG_POINT_PARSER, false);\n    for (int i = 0; i < values.length; ++i) {\n      assertEquals(values[i], longs.get(i));\n    }\n    reader.close();\n    iw.close();\n    dir.close();\n  }\n","realPath":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCache.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":637,"status":"B"},{"authorDate":"2016-05-26 01:42:11","commitOrder":1,"curCode":"  public void testLongFieldCache() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = newIndexWriterConfig(new MockAnalyzer(random()));\n    cfg.setMergePolicy(newLogMergePolicy());\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    Document doc = new Document();\n    LegacyLongField field = new LegacyLongField(\"f\", 0L, Store.YES);\n    doc.add(field);\n    final long[] values = new long[TestUtil.nextInt(random(), 1, 10)];\n    for (int i = 0; i < values.length; ++i) {\n      final long v;\n      switch (random().nextInt(10)) {\n        case 0:\n          v = Long.MIN_VALUE;\n          break;\n        case 1:\n          v = 0;\n          break;\n        case 2:\n          v = Long.MAX_VALUE;\n          break;\n        default:\n          v = TestUtil.nextLong(random(), -10, 10);\n          break;\n      }\n      values[i] = v;\n      if (v == 0 && random().nextBoolean()) {\n        \r\n        iw.addDocument(new Document());\n      } else {\n        field.setLongValue(v);\n        iw.addDocument(doc);\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    final NumericDocValues longs = FieldCache.DEFAULT.getNumerics(getOnlyLeafReader(reader), \"f\", FieldCache.LEGACY_LONG_PARSER, false);\n    for (int i = 0; i < values.length; ++i) {\n      assertEquals(values[i], longs.get(i));\n    }\n    reader.close();\n    iw.close();\n    dir.close();\n  }\n","date":"2016-05-26 01:42:11","endLine":449,"groupId":"950","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongFieldCache","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/11/92f4b77c8a5ca7b3b081b3cbb831d5161eaa2c.src","preCode":"  public void testLongFieldCache() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = newIndexWriterConfig(new MockAnalyzer(random()));\n    cfg.setMergePolicy(newLogMergePolicy());\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    Document doc = new Document();\n    LegacyLongField field = new LegacyLongField(\"f\", 0L, Store.YES);\n    doc.add(field);\n    final long[] values = new long[TestUtil.nextInt(random(), 1, 10)];\n    for (int i = 0; i < values.length; ++i) {\n      final long v;\n      switch (random().nextInt(10)) {\n        case 0:\n          v = Long.MIN_VALUE;\n          break;\n        case 1:\n          v = 0;\n          break;\n        case 2:\n          v = Long.MAX_VALUE;\n          break;\n        default:\n          v = TestUtil.nextLong(random(), -10, 10);\n          break;\n      }\n      values[i] = v;\n      if (v == 0 && random().nextBoolean()) {\n        \r\n        iw.addDocument(new Document());\n      } else {\n        field.setLongValue(v);\n        iw.addDocument(doc);\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    final NumericDocValues longs = FieldCache.DEFAULT.getNumerics(getOnlyLeafReader(reader), \"f\", FieldCache.LEGACY_LONG_PARSER, false);\n    for (int i = 0; i < values.length; ++i) {\n      assertEquals(values[i], longs.get(i));\n    }\n    reader.close();\n    iw.close();\n    dir.close();\n  }\n","realPath":"solr/core/src/test/org/apache/solr/uninverting/TestLegacyFieldCache.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":406,"status":"B"}],"commitId":"366f8d18fe3ac9c9fb93493fe60d2bf4157de032","commitMessage":"@@@Merge remote-tracking branch 'origin/master'\n","date":"2016-05-26 01:42:11","modifiedFileCount":"50","status":"B","submitter":"Noble Paul"},{"authorTime":"2016-10-03 03:18:22","codes":[{"authorDate":"2016-10-03 03:18:22","commitOrder":2,"curCode":"  public void testLongFieldCache() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = newIndexWriterConfig(new MockAnalyzer(random()));\n    cfg.setMergePolicy(newLogMergePolicy());\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    Document doc = new Document();\n    LongPoint field = new LongPoint(\"f\", 0L);\n    StoredField field2 = new StoredField(\"f\", 0L);\n    doc.add(field);\n    doc.add(field2);\n    final long[] values = new long[TestUtil.nextInt(random(), 1, 10)];\n    Set<Integer> missing = new HashSet<>();\n    for (int i = 0; i < values.length; ++i) {\n      final long v;\n      switch (random().nextInt(10)) {\n        case 0:\n          v = Long.MIN_VALUE;\n          break;\n        case 1:\n          v = 0;\n          break;\n        case 2:\n          v = Long.MAX_VALUE;\n          break;\n        default:\n          v = TestUtil.nextLong(random(), -10, 10);\n          break;\n      }\n      values[i] = v;\n      if (v == 0 && random().nextBoolean()) {\n        \r\n        iw.addDocument(new Document());\n        missing.add(i);\n      } else {\n        field.setLongValue(v);\n        field2.setLongValue(v);\n        iw.addDocument(doc);\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    final NumericDocValues longs = FieldCache.DEFAULT.getNumerics(getOnlyLeafReader(reader), \"f\", FieldCache.LONG_POINT_PARSER);\n    for (int i = 0; i < values.length; ++i) {\n      if (missing.contains(i) == false) {\n        assertEquals(i, longs.nextDoc());\n        assertEquals(values[i], longs.longValue());\n      }\n    }\n    assertEquals(NO_MORE_DOCS, longs.nextDoc());\n    reader.close();\n    iw.close();\n    dir.close();\n  }\n","date":"2016-10-03 03:18:22","endLine":676,"groupId":"103335","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testLongFieldCache","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2d/2c381f84ee2d3f02403e5f701ee19571254f48.src","preCode":"  public void testLongFieldCache() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = newIndexWriterConfig(new MockAnalyzer(random()));\n    cfg.setMergePolicy(newLogMergePolicy());\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    Document doc = new Document();\n    LongPoint field = new LongPoint(\"f\", 0L);\n    StoredField field2 = new StoredField(\"f\", 0L);\n    doc.add(field);\n    doc.add(field2);\n    final long[] values = new long[TestUtil.nextInt(random(), 1, 10)];\n    for (int i = 0; i < values.length; ++i) {\n      final long v;\n      switch (random().nextInt(10)) {\n        case 0:\n          v = Long.MIN_VALUE;\n          break;\n        case 1:\n          v = 0;\n          break;\n        case 2:\n          v = Long.MAX_VALUE;\n          break;\n        default:\n          v = TestUtil.nextLong(random(), -10, 10);\n          break;\n      }\n      values[i] = v;\n      if (v == 0 && random().nextBoolean()) {\n        \r\n        iw.addDocument(new Document());\n      } else {\n        field.setLongValue(v);\n        field2.setLongValue(v);\n        iw.addDocument(doc);\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    final NumericDocValues longs = FieldCache.DEFAULT.getNumerics(getOnlyLeafReader(reader), \"f\", FieldCache.LONG_POINT_PARSER, false);\n    for (int i = 0; i < values.length; ++i) {\n      assertEquals(values[i], longs.get(i));\n    }\n    reader.close();\n    iw.close();\n    dir.close();\n  }\n","realPath":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCache.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":624,"status":"M"},{"authorDate":"2016-10-03 03:18:22","commitOrder":2,"curCode":"  public void testLongFieldCache() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = newIndexWriterConfig(new MockAnalyzer(random()));\n    cfg.setMergePolicy(newLogMergePolicy());\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    Document doc = new Document();\n    LegacyLongField field = new LegacyLongField(\"f\", 0L, Store.YES);\n    doc.add(field);\n    final long[] values = new long[TestUtil.nextInt(random(), 1, 10)];\n    Set<Integer> missing = new HashSet<>();\n    for (int i = 0; i < values.length; ++i) {\n      final long v;\n      switch (random().nextInt(10)) {\n        case 0:\n          v = Long.MIN_VALUE;\n          break;\n        case 1:\n          v = 0;\n          break;\n        case 2:\n          v = Long.MAX_VALUE;\n          break;\n        default:\n          v = TestUtil.nextLong(random(), -10, 10);\n          break;\n      }\n      values[i] = v;\n      if (v == 0 && random().nextBoolean()) {\n        \r\n        iw.addDocument(new Document());\n        missing.add(i);\n      } else {\n        field.setLongValue(v);\n        iw.addDocument(doc);\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    final NumericDocValues longs = FieldCache.DEFAULT.getNumerics(getOnlyLeafReader(reader), \"f\", FieldCache.LEGACY_LONG_PARSER);\n    for (int i = 0; i < values.length; ++i) {\n      if (missing.contains(i) == false) {\n        assertEquals(i, longs.nextDoc());\n        assertEquals(values[i], longs.longValue());\n      }\n    }\n    assertEquals(NO_MORE_DOCS, longs.nextDoc());\n    reader.close();\n    iw.close();\n    dir.close();\n  }\n","date":"2016-10-03 03:18:22","endLine":450,"groupId":"103335","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testLongFieldCache","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9d/c047bcb3a10293e0e49cad7c003fe6f6ca2f01.src","preCode":"  public void testLongFieldCache() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig cfg = newIndexWriterConfig(new MockAnalyzer(random()));\n    cfg.setMergePolicy(newLogMergePolicy());\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, cfg);\n    Document doc = new Document();\n    LegacyLongField field = new LegacyLongField(\"f\", 0L, Store.YES);\n    doc.add(field);\n    final long[] values = new long[TestUtil.nextInt(random(), 1, 10)];\n    for (int i = 0; i < values.length; ++i) {\n      final long v;\n      switch (random().nextInt(10)) {\n        case 0:\n          v = Long.MIN_VALUE;\n          break;\n        case 1:\n          v = 0;\n          break;\n        case 2:\n          v = Long.MAX_VALUE;\n          break;\n        default:\n          v = TestUtil.nextLong(random(), -10, 10);\n          break;\n      }\n      values[i] = v;\n      if (v == 0 && random().nextBoolean()) {\n        \r\n        iw.addDocument(new Document());\n      } else {\n        field.setLongValue(v);\n        iw.addDocument(doc);\n      }\n    }\n    iw.forceMerge(1);\n    final DirectoryReader reader = iw.getReader();\n    final NumericDocValues longs = FieldCache.DEFAULT.getNumerics(getOnlyLeafReader(reader), \"f\", FieldCache.LEGACY_LONG_PARSER, false);\n    for (int i = 0; i < values.length; ++i) {\n      assertEquals(values[i], longs.get(i));\n    }\n    reader.close();\n    iw.close();\n    dir.close();\n  }\n","realPath":"solr/core/src/test/org/apache/solr/uninverting/TestLegacyFieldCache.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":401,"status":"M"}],"commitId":"3182cd9872af3cb73a1f73e36de68b8d76646e59","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2016-10-03 03:18:22","modifiedFileCount":"570","status":"M","submitter":"Karl Wright"}]
