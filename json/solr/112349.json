[{"authorTime":"2021-06-17 03:49:29","codes":[{"authorDate":"2021-06-17 03:49:29","commitOrder":2,"curCode":"    protected String translateMatch(RexNode condition) {\n      final SqlKind kind = condition.getKind();\n      if (kind.belongsTo(SqlKind.COMPARISON) || kind == SqlKind.NOT) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        \r\n        \r\n        RexCall call = (RexCall) condition;\n        List<RexNode> operands = call.getOperands();\n        String query = null;\n        if (operands.size() == 2) {\n          RexNode lhs = operands.get(0);\n          RexNode rhs = operands.get(1);\n          if (lhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL && rhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL) {\n            query = translateBetween(lhs, rhs);\n          } else if (lhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL && rhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL) {\n            \r\n            query = translateBetween(rhs, lhs);\n          }\n        }\n        return query != null ? query : \"(\" + translateAnd(condition) + \")\";\n      } else if (condition.isA(SqlKind.OR)) {\n        return \"(\" + translateOr(condition) + \")\";\n      } else if (kind == SqlKind.LIKE) {\n        return translateLike(condition, false);\n      } else if (kind == SqlKind.IS_NOT_NULL || kind == SqlKind.IS_NULL) {\n        return translateIsNullOrIsNotNull(condition);\n      } else {\n        return null;\n      }\n    }\n","date":"2021-06-17 03:49:29","endLine":114,"groupId":"24134","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"translateMatch","params":"(RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2f/817507e99de9526740ea9c55b59a4d2d9a228b.src","preCode":"    protected String translateMatch(RexNode condition) {\n      final SqlKind kind = condition.getKind();\n      if (kind.belongsTo(SqlKind.COMPARISON) || kind == SqlKind.NOT) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        \r\n        \r\n        RexCall call = (RexCall) condition;\n        List<RexNode> operands = call.getOperands();\n        String query = null;\n        if (operands.size() == 2) {\n          RexNode lhs = operands.get(0);\n          RexNode rhs = operands.get(1);\n          if (lhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL && rhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL) {\n            query = translateBetween(lhs, rhs);\n          } else if (lhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL && rhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL) {\n            \r\n            query = translateBetween(rhs, lhs);\n          }\n        }\n        return query != null ? query : \"(\" + translateAnd(condition) + \")\";\n      } else if (condition.isA(SqlKind.OR)) {\n        return \"(\" + translateOr(condition) + \")\";\n      } else if (kind == SqlKind.LIKE) {\n        return translateLike(condition, false);\n      } else if (kind == SqlKind.IS_NOT_NULL || kind == SqlKind.IS_NULL) {\n        return translateIsNullOrIsNotNull(condition);\n      } else {\n        return null;\n      }\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":84,"status":"MB"},{"authorDate":"2021-06-17 03:49:29","commitOrder":2,"curCode":"    protected String translateMatch(RexNode condition) {\n      if (condition.getKind().belongsTo(SqlKind.COMPARISON)) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        return translateAnd(condition);\n      } else if (condition.isA(SqlKind.OR)) {\n        return translateOr(condition);\n      } else {\n        return null;\n      }\n    }\n","date":"2021-06-17 03:49:29","endLine":333,"groupId":"21744","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"translateMatch","params":"(RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2f/817507e99de9526740ea9c55b59a4d2d9a228b.src","preCode":"    protected String translateMatch(RexNode condition) {\n      if (condition.getKind().belongsTo(SqlKind.COMPARISON)) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        return translateAnd(condition);\n      } else if (condition.isA(SqlKind.OR)) {\n        return translateOr(condition);\n      } else {\n        return null;\n      }\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"B"}],"commitId":"a79e71c732a4488b82d24713568b1a553c85266b","commitMessage":"@@@SOLR-15460: Implement LIKE.  IS NOT NULL.  IS NULL.  and support wildcard * in equals string literal (#173)\n\nAlso fixes SOLR-15459 & SOLR-15463","date":"2021-06-17 03:49:29","modifiedFileCount":"2","status":"M","submitter":"Timothy Potter"},{"authorTime":"2021-06-17 03:49:29","codes":[{"authorDate":"2021-06-29 22:22:46","commitOrder":3,"curCode":"    protected String translateMatch(RexNode condition) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"translateMatch condition={} {}\", condition.getKind(), condition.getClass().getName());\n      }\n\n      final SqlKind kind = condition.getKind();\n\n      if (condition.isA(SqlKind.SEARCH)) {\n\n        return translateMatch(RexUtil.expandSearch(builder, null, condition));\n      }\n\n      if (kind.belongsTo(SqlKind.COMPARISON) || kind == SqlKind.NOT) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        \r\n        \r\n        RexCall call = (RexCall) condition;\n        List<RexNode> operands = call.getOperands();\n        String query = null;\n        if (operands.size() == 2) {\n          RexNode lhs = operands.get(0);\n          RexNode rhs = operands.get(1);\n          if (lhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL && rhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL) {\n            query = translateBetween(lhs, rhs);\n          } else if (lhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL && rhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL) {\n            \r\n            query = translateBetween(rhs, lhs);\n          }\n        }\n        query = query != null ? query : \"(\" + translateAnd(condition) + \")\";\n        if (log.isDebugEnabled()) {\n          log.debug(\"translated query match={}\", query);\n        }\n        return query;\n      } else if (condition.isA(SqlKind.OR)) {\n        return \"(\" + translateOr(condition) + \")\";\n      } else if (kind == SqlKind.LIKE) {\n        return translateLike(condition, false);\n      } else if (kind == SqlKind.IS_NOT_NULL || kind == SqlKind.IS_NULL) {\n        return translateIsNullOrIsNotNull(condition);\n      } else {\n        return null;\n      }\n    }\n","date":"2021-06-29 22:22:46","endLine":140,"groupId":"24134","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"translateMatch","params":"(RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/1c/01b21ef3e491e060ae9e45ed2babe0b918fb73.src","preCode":"    protected String translateMatch(RexNode condition) {\n      final SqlKind kind = condition.getKind();\n      if (kind.belongsTo(SqlKind.COMPARISON) || kind == SqlKind.NOT) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        \r\n        \r\n        RexCall call = (RexCall) condition;\n        List<RexNode> operands = call.getOperands();\n        String query = null;\n        if (operands.size() == 2) {\n          RexNode lhs = operands.get(0);\n          RexNode rhs = operands.get(1);\n          if (lhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL && rhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL) {\n            query = translateBetween(lhs, rhs);\n          } else if (lhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL && rhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL) {\n            \r\n            query = translateBetween(rhs, lhs);\n          }\n        }\n        return query != null ? query : \"(\" + translateAnd(condition) + \")\";\n      } else if (condition.isA(SqlKind.OR)) {\n        return \"(\" + translateOr(condition) + \")\";\n      } else if (kind == SqlKind.LIKE) {\n        return translateLike(condition, false);\n      } else if (kind == SqlKind.IS_NOT_NULL || kind == SqlKind.IS_NULL) {\n        return translateIsNullOrIsNotNull(condition);\n      } else {\n        return null;\n      }\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":96,"status":"M"},{"authorDate":"2021-06-17 03:49:29","commitOrder":3,"curCode":"    protected String translateMatch(RexNode condition) {\n      if (condition.getKind().belongsTo(SqlKind.COMPARISON)) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        return translateAnd(condition);\n      } else if (condition.isA(SqlKind.OR)) {\n        return translateOr(condition);\n      } else {\n        return null;\n      }\n    }\n","date":"2021-06-17 03:49:29","endLine":333,"groupId":"21744","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"translateMatch","params":"(RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2f/817507e99de9526740ea9c55b59a4d2d9a228b.src","preCode":"    protected String translateMatch(RexNode condition) {\n      if (condition.getKind().belongsTo(SqlKind.COMPARISON)) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        return translateAnd(condition);\n      } else if (condition.isA(SqlKind.OR)) {\n        return translateOr(condition);\n      } else {\n        return null;\n      }\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"N"}],"commitId":"e89593cfca11c419bdc9b29146eedb605c76169a","commitMessage":"@@@SOLR-15461: Upgrade Apache Calcite to latest release. (#177)\n\n","date":"2021-06-29 22:22:46","modifiedFileCount":"5","status":"M","submitter":"Mark Robert Miller"},{"authorTime":"2021-06-17 03:49:29","codes":[{"authorDate":"2021-08-13 00:39:32","commitOrder":4,"curCode":"    protected String translateMatch(RexNode condition) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"translateMatch condition={} {}\", condition.getKind(), condition.getClass().getName());\n      }\n\n      final SqlKind kind = condition.getKind();\n\n      if (condition.isA(SqlKind.SEARCH)) {\n        return translateSearch(condition);\n      } else if (kind.belongsTo(SqlKind.COMPARISON) || kind == SqlKind.NOT) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        return translateAndOrBetween(condition);\n      } else if (condition.isA(SqlKind.OR)) {\n        return \"(\" + translateOr(condition) + \")\";\n      } else if (kind == SqlKind.LIKE) {\n        return translateLike(condition);\n      } else if (kind == SqlKind.IS_NOT_NULL || kind == SqlKind.IS_NULL) {\n        return translateIsNullOrIsNotNull(condition);\n      } else {\n        return null;\n      }\n    }\n","date":"2021-08-13 00:39:32","endLine":125,"groupId":"112349","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"translateMatch","params":"(RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/f3/3bdbade0273ff971390b8312c869bbbaf73f8d.src","preCode":"    protected String translateMatch(RexNode condition) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"translateMatch condition={} {}\", condition.getKind(), condition.getClass().getName());\n      }\n\n      final SqlKind kind = condition.getKind();\n\n      if (condition.isA(SqlKind.SEARCH)) {\n\n        return translateMatch(RexUtil.expandSearch(builder, null, condition));\n      }\n\n      if (kind.belongsTo(SqlKind.COMPARISON) || kind == SqlKind.NOT) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        \r\n        \r\n        RexCall call = (RexCall) condition;\n        List<RexNode> operands = call.getOperands();\n        String query = null;\n        if (operands.size() == 2) {\n          RexNode lhs = operands.get(0);\n          RexNode rhs = operands.get(1);\n          if (lhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL && rhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL) {\n            query = translateBetween(lhs, rhs);\n          } else if (lhs.getKind() == SqlKind.LESS_THAN_OR_EQUAL && rhs.getKind() == SqlKind.GREATER_THAN_OR_EQUAL) {\n            \r\n            query = translateBetween(rhs, lhs);\n          }\n        }\n        query = query != null ? query : \"(\" + translateAnd(condition) + \")\";\n        if (log.isDebugEnabled()) {\n          log.debug(\"translated query match={}\", query);\n        }\n        return query;\n      } else if (condition.isA(SqlKind.OR)) {\n        return \"(\" + translateOr(condition) + \")\";\n      } else if (kind == SqlKind.LIKE) {\n        return translateLike(condition, false);\n      } else if (kind == SqlKind.IS_NOT_NULL || kind == SqlKind.IS_NULL) {\n        return translateIsNullOrIsNotNull(condition);\n      } else {\n        return null;\n      }\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":103,"status":"M"},{"authorDate":"2021-06-17 03:49:29","commitOrder":4,"curCode":"    protected String translateMatch(RexNode condition) {\n      if (condition.getKind().belongsTo(SqlKind.COMPARISON)) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        return translateAnd(condition);\n      } else if (condition.isA(SqlKind.OR)) {\n        return translateOr(condition);\n      } else {\n        return null;\n      }\n    }\n","date":"2021-06-17 03:49:29","endLine":333,"groupId":"112349","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"translateMatch","params":"(RexNodecondition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/2f/817507e99de9526740ea9c55b59a4d2d9a228b.src","preCode":"    protected String translateMatch(RexNode condition) {\n      if (condition.getKind().belongsTo(SqlKind.COMPARISON)) {\n        return translateComparison(condition);\n      } else if (condition.isA(SqlKind.AND)) {\n        return translateAnd(condition);\n      } else if (condition.isA(SqlKind.OR)) {\n        return translateOr(condition);\n      } else {\n        return null;\n      }\n    }\n","realPath":"solr/core/src/java/org/apache/solr/handler/sql/SolrFilter.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":323,"status":"N"}],"commitId":"38848e62b246ff41fffb4347efd56c949a7b6f49","commitMessage":"@@@SOLR-15579: Re-configure calcite to allow more values in an IN clause (#249)\n\n","date":"2021-08-13 00:39:32","modifiedFileCount":"4","status":"M","submitter":"Timothy Potter"}]
