[{"authorTime":"2020-06-10 21:41:52","codes":[{"authorDate":"2020-06-10 21:41:52","commitOrder":17,"curCode":"  protected NamedList<Object> executeMethod(HttpRequestBase method, Principal userPrincipal, final ResponseParser processor, final boolean isV2Api) throws SolrServerException {\n    method.addHeader(\"User-Agent\", AGENT);\n \n    org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n    if (soTimeout != null) {\n      requestConfigBuilder.setSocketTimeout(soTimeout);\n    }\n    if (connectionTimeout != null) {\n      requestConfigBuilder.setConnectTimeout(connectionTimeout);\n    }\n    if (followRedirects != null) {\n      requestConfigBuilder.setRedirectsEnabled(followRedirects);\n    }\n\n    method.setConfig(requestConfigBuilder.build());\n    \n    HttpEntity entity = null;\n    InputStream respBody = null;\n    boolean shouldClose = true;\n    try {\n      \r\n      HttpClientContext httpClientRequestContext = HttpClientUtil.createNewHttpClientRequestContext();\n      if (userPrincipal != null) {\n        \r\n        \r\n        \r\n        httpClientRequestContext.setUserToken(userPrincipal);\n      }\n      final HttpResponse response = httpClient.execute(method, httpClientRequestContext);\n\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      \r\n      entity = response.getEntity();\n      respBody = entity.getContent();\n      String mimeType = null;\n      Charset charset = null;\n      String charsetName = null;\n\n      ContentType contentType = ContentType.get(entity);\n      if (contentType != null) {\n        mimeType = contentType.getMimeType().trim().toLowerCase(Locale.ROOT);\n        charset = contentType.getCharset();\n\n        if (charset != null) {\n          charsetName = charset.name();\n        }\n      }\n\n      \r\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  \r\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || contentType == null) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null || processor instanceof InputStreamResponseParser) {\n        \n        \r\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", respBody);\n        rsp.add(\"closeableResponse\", response);\n        \r\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          \r\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Charset exceptionCharset = charset != null? charset : FALLBACK_CHARSET;\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, exceptionCharset);\n          } catch (IOException e) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionCharset, e);\n          }\n          throw new RemoteSolrException(baseUrl, httpStatus, msg, null);\n        }\n      }\n      \n      NamedList<Object> rsp = null;\n      try {\n        rsp = processor.processResponse(respBody, charsetName);\n      } catch (Exception e) {\n        throw new RemoteSolrException(baseUrl, httpStatus, e.getMessage(), e);\n      }\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (isV2Api || String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n          throw RemoteExecutionException.create(baseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          if (error != null) {\n            reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"msg\"));\n            if(reason == null) {\n              reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"trace\"));\n            }\n            Object metadataObj = Utils.getObjectByPath(error, false, Collections.singletonList(\"metadata\"));\n            if  (metadataObj instanceof NamedList) {\n              metadata = (NamedList<String>) metadataObj;\n            } else if (metadataObj instanceof List) {\n              \r\n              List<Object> list = (List<Object>) metadataObj;\n              metadata = new NamedList<>(list.size()/2);\n              for (int i = 0; i < list.size(); i+=2) {\n                metadata.add((String)list.get(i), (String) list.get(i+1));\n              }\n            } else if (metadataObj instanceof Map) {\n              metadata = new NamedList((Map) metadataObj);\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase())\n            .append(\"\\n\\n\")\n            .append(\"request: \")\n            .append(method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(baseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occurred while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occurred when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (shouldClose) {\n        Utils.consumeFully(entity);\n      }\n    }\n  }\n","date":"2020-06-10 21:41:52","endLine":695,"groupId":"47706","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"executeMethod","params":"(HttpRequestBasemethod@PrincipaluserPrincipal@finalResponseParserprocessor@finalbooleanisV2Api)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/a7/348318f36a1de1dade03860587adfaa147c858.src","preCode":"  protected NamedList<Object> executeMethod(HttpRequestBase method, Principal userPrincipal, final ResponseParser processor, final boolean isV2Api) throws SolrServerException {\n    method.addHeader(\"User-Agent\", AGENT);\n \n    org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n    if (soTimeout != null) {\n      requestConfigBuilder.setSocketTimeout(soTimeout);\n    }\n    if (connectionTimeout != null) {\n      requestConfigBuilder.setConnectTimeout(connectionTimeout);\n    }\n    if (followRedirects != null) {\n      requestConfigBuilder.setRedirectsEnabled(followRedirects);\n    }\n\n    method.setConfig(requestConfigBuilder.build());\n    \n    HttpEntity entity = null;\n    InputStream respBody = null;\n    boolean shouldClose = true;\n    try {\n      \r\n      HttpClientContext httpClientRequestContext = HttpClientUtil.createNewHttpClientRequestContext();\n      if (userPrincipal != null) {\n        \r\n        \r\n        \r\n        httpClientRequestContext.setUserToken(userPrincipal);\n      }\n      final HttpResponse response = httpClient.execute(method, httpClientRequestContext);\n\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      \r\n      entity = response.getEntity();\n      respBody = entity.getContent();\n      String mimeType = null;\n      Charset charset = null;\n      String charsetName = null;\n\n      ContentType contentType = ContentType.get(entity);\n      if (contentType != null) {\n        mimeType = contentType.getMimeType().trim().toLowerCase(Locale.ROOT);\n        charset = contentType.getCharset();\n\n        if (charset != null) {\n          charsetName = charset.name();\n        }\n      }\n\n      \r\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  \r\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || contentType == null) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null || processor instanceof InputStreamResponseParser) {\n        \n        \r\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", respBody);\n        rsp.add(\"closeableResponse\", response);\n        \r\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          \r\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Charset exceptionCharset = charset != null? charset : FALLBACK_CHARSET;\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, exceptionCharset);\n          } catch (IOException e) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionCharset, e);\n          }\n          throw new RemoteSolrException(baseUrl, httpStatus, msg, null);\n        }\n      }\n      \n      NamedList<Object> rsp = null;\n      try {\n        rsp = processor.processResponse(respBody, charsetName);\n      } catch (Exception e) {\n        throw new RemoteSolrException(baseUrl, httpStatus, e.getMessage(), e);\n      }\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (isV2Api || String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n          throw RemoteExecutionException.create(baseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          if (error != null) {\n            reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"msg\"));\n            if(reason == null) {\n              reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"trace\"));\n            }\n            Object metadataObj = Utils.getObjectByPath(error, false, Collections.singletonList(\"metadata\"));\n            if  (metadataObj instanceof NamedList) {\n              metadata = (NamedList<String>) metadataObj;\n            } else if (metadataObj instanceof List) {\n              \r\n              List<Object> list = (List<Object>) metadataObj;\n              metadata = new NamedList<>(list.size()/2);\n              for (int i = 0; i < list.size(); i+=2) {\n                metadata.add((String)list.get(i), (String) list.get(i+1));\n              }\n            } else if (metadataObj instanceof Map) {\n              metadata = new NamedList((Map) metadataObj);\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase())\n            .append(\"\\n\\n\")\n            .append(\"request: \")\n            .append(method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(baseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occurred while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occurred when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (shouldClose) {\n        Utils.consumeFully(entity);\n      }\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":537,"status":"MB"},{"authorDate":"2020-06-10 21:41:52","commitOrder":17,"curCode":"  private NamedList<Object> processErrorsAndResponse(Response response,\n                                                     final ResponseParser processor,\n                                                     InputStream is,\n                                                     String mimeType,\n                                                     String encoding,\n                                                     final boolean isV2Api)\n      throws SolrServerException {\n    boolean shouldClose = true;\n    try {\n      \r\n      int httpStatus = response.getStatus();\n\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT: \r\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!httpClient.isFollowRedirects()) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || mimeType == null) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getReason(),\n                null);\n          }\n      }\n\n      if (wantStream(parser)) {\n        \r\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", is);\n        \r\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          \r\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          String exceptionEncoding = encoding != null? encoding : FALLBACK_CHARSET.name();\n          try {\n            msg = msg + \" \" + IOUtils.toString(is, exceptionEncoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionEncoding, e);\n          }\n          throw new RemoteSolrException(serverBaseUrl, httpStatus, msg, null);\n        }\n      }\n\n      NamedList<Object> rsp;\n      try {\n        rsp = processor.processResponse(is, encoding);\n      } catch (Exception e) {\n        throw new RemoteSolrException(serverBaseUrl, httpStatus, e.getMessage(), e);\n      }\n\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n        throw RemoteExecutionException.create(serverBaseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          if (error != null) {\n            reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"msg\"));\n            if(reason == null) {\n              reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"trace\"));\n            }\n            Object metadataObj = Utils.getObjectByPath(error, false, Collections.singletonList(\"metadata\"));\n            if  (metadataObj instanceof NamedList) {\n              metadata = (NamedList<String>) metadataObj;\n            } else if (metadataObj instanceof List) {\n              \r\n              List<Object> list = (List<Object>) metadataObj;\n              metadata = new NamedList<>(list.size()/2);\n              for (int i = 0; i < list.size(); i+=2) {\n                metadata.add((String)list.get(i), (String) list.get(i+1));\n              }\n            } else if (metadataObj instanceof Map) {\n              metadata = new NamedList((Map) metadataObj);\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getReason())\n              .append(\"\\n\\n\")\n              .append(\"request: \")\n              .append(response.getRequest().getMethod());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(serverBaseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } finally {\n      if (shouldClose) {\n        try {\n          is.close();\n          assert ObjectReleaseTracker.release(is);\n        } catch (IOException e) {\n          \r\n        }\n      }\n    }\n  }\n","date":"2020-06-10 21:41:52","endLine":749,"groupId":"44787","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"processErrorsAndResponse","params":"(Responseresponse@finalResponseParserprocessor@InputStreamis@StringmimeType@Stringencoding@finalbooleanisV2Api)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/46a96d6ca73f6b432d12dc115eb2721ddbafe1.src","preCode":"  private NamedList<Object> processErrorsAndResponse(Response response,\n                                                     final ResponseParser processor,\n                                                     InputStream is,\n                                                     String mimeType,\n                                                     String encoding,\n                                                     final boolean isV2Api)\n      throws SolrServerException {\n    boolean shouldClose = true;\n    try {\n      \r\n      int httpStatus = response.getStatus();\n\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT: \r\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!httpClient.isFollowRedirects()) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || mimeType == null) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getReason(),\n                null);\n          }\n      }\n\n      if (wantStream(parser)) {\n        \r\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", is);\n        \r\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          \r\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          String exceptionEncoding = encoding != null? encoding : FALLBACK_CHARSET.name();\n          try {\n            msg = msg + \" \" + IOUtils.toString(is, exceptionEncoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionEncoding, e);\n          }\n          throw new RemoteSolrException(serverBaseUrl, httpStatus, msg, null);\n        }\n      }\n\n      NamedList<Object> rsp;\n      try {\n        rsp = processor.processResponse(is, encoding);\n      } catch (Exception e) {\n        throw new RemoteSolrException(serverBaseUrl, httpStatus, e.getMessage(), e);\n      }\n\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n        throw RemoteExecutionException.create(serverBaseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          if (error != null) {\n            reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"msg\"));\n            if(reason == null) {\n              reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"trace\"));\n            }\n            Object metadataObj = Utils.getObjectByPath(error, false, Collections.singletonList(\"metadata\"));\n            if  (metadataObj instanceof NamedList) {\n              metadata = (NamedList<String>) metadataObj;\n            } else if (metadataObj instanceof List) {\n              \r\n              List<Object> list = (List<Object>) metadataObj;\n              metadata = new NamedList<>(list.size()/2);\n              for (int i = 0; i < list.size(); i+=2) {\n                metadata.add((String)list.get(i), (String) list.get(i+1));\n              }\n            } else if (metadataObj instanceof Map) {\n              metadata = new NamedList((Map) metadataObj);\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getReason())\n              .append(\"\\n\\n\")\n              .append(\"request: \")\n              .append(response.getRequest().getMethod());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(serverBaseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } finally {\n      if (shouldClose) {\n        try {\n          is.close();\n          assert ObjectReleaseTracker.release(is);\n        } catch (IOException e) {\n          \r\n        }\n      }\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":634,"status":"MB"}],"commitId":"53040984f62eedd425c98eb6f60bc54a0e83258b","commitMessage":"@@@SOLR-14345: return correct err msg when non-binary resp parser is used\n\n* This adds support to parse error properly in case of non-binary\n  resp parser but the problem still exists for noopResponseParser\n","date":"2020-06-10 21:41:52","modifiedFileCount":"4","status":"M","submitter":"Munendra S N"},{"authorTime":"2020-06-10 21:41:52","codes":[{"authorDate":"2020-08-08 04:06:06","commitOrder":18,"curCode":"  protected NamedList<Object> executeMethod(HttpRequestBase method, Principal userPrincipal, final ResponseParser processor, final boolean isV2Api) throws SolrServerException {\n    method.addHeader(\"User-Agent\", AGENT);\n \n    org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n    if (soTimeout != null) {\n      requestConfigBuilder.setSocketTimeout(soTimeout);\n    }\n    if (connectionTimeout != null) {\n      requestConfigBuilder.setConnectTimeout(connectionTimeout);\n    }\n    if (followRedirects != null) {\n      requestConfigBuilder.setRedirectsEnabled(followRedirects);\n    }\n\n    method.setConfig(requestConfigBuilder.build());\n    \n    HttpEntity entity = null;\n    InputStream respBody = null;\n    boolean shouldClose = true;\n    try {\n      \r\n      HttpClientContext httpClientRequestContext = HttpClientUtil.createNewHttpClientRequestContext();\n      if (userPrincipal != null) {\n        \r\n        \r\n        \r\n        httpClientRequestContext.setUserToken(userPrincipal);\n      }\n      final HttpResponse response = httpClient.execute(method, httpClientRequestContext);\n\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      \r\n      entity = response.getEntity();\n      respBody = entity.getContent();\n      String mimeType = null;\n      Charset charset = null;\n      String charsetName = null;\n\n      ContentType contentType = ContentType.get(entity);\n      if (contentType != null) {\n        mimeType = contentType.getMimeType().trim().toLowerCase(Locale.ROOT);\n        charset = contentType.getCharset();\n\n        if (charset != null) {\n          charsetName = charset.name();\n        }\n      }\n\n      \r\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  \r\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || contentType == null) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null || processor instanceof InputStreamResponseParser) {\n        \n        \r\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", respBody);\n        rsp.add(\"closeableResponse\", response);\n        \r\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          if (isUnmatchedErrorCode(mimeType, httpStatus)) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"non ok status: \" + httpStatus\n                  + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                  null);\n          }\n\n          \r\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Charset exceptionCharset = charset != null? charset : FALLBACK_CHARSET;\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, exceptionCharset);\n          } catch (IOException e) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionCharset, e);\n          }\n          throw new RemoteSolrException(baseUrl, httpStatus, msg, null);\n        }\n      }\n      \n      NamedList<Object> rsp = null;\n      try {\n        rsp = processor.processResponse(respBody, charsetName);\n      } catch (Exception e) {\n        throw new RemoteSolrException(baseUrl, httpStatus, e.getMessage(), e);\n      }\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (isV2Api || String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n          throw RemoteExecutionException.create(baseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          if (error != null) {\n            reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"msg\"));\n            if(reason == null) {\n              reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"trace\"));\n            }\n            Object metadataObj = Utils.getObjectByPath(error, false, Collections.singletonList(\"metadata\"));\n            if  (metadataObj instanceof NamedList) {\n              metadata = (NamedList<String>) metadataObj;\n            } else if (metadataObj instanceof List) {\n              \r\n              List<Object> list = (List<Object>) metadataObj;\n              metadata = new NamedList<>(list.size()/2);\n              for (int i = 0; i < list.size(); i+=2) {\n                metadata.add((String)list.get(i), (String) list.get(i+1));\n              }\n            } else if (metadataObj instanceof Map) {\n              metadata = new NamedList((Map) metadataObj);\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase())\n            .append(\"\\n\\n\")\n            .append(\"request: \")\n            .append(method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(baseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occurred while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occurred when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (shouldClose) {\n        Utils.consumeFully(entity);\n      }\n    }\n  }\n","date":"2020-08-08 04:06:06","endLine":718,"groupId":"1280","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"executeMethod","params":"(HttpRequestBasemethod@PrincipaluserPrincipal@finalResponseParserprocessor@finalbooleanisV2Api)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/e9/5c5d0d31582df4dc5737431b7338b1ed7f947e.src","preCode":"  protected NamedList<Object> executeMethod(HttpRequestBase method, Principal userPrincipal, final ResponseParser processor, final boolean isV2Api) throws SolrServerException {\n    method.addHeader(\"User-Agent\", AGENT);\n \n    org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n    if (soTimeout != null) {\n      requestConfigBuilder.setSocketTimeout(soTimeout);\n    }\n    if (connectionTimeout != null) {\n      requestConfigBuilder.setConnectTimeout(connectionTimeout);\n    }\n    if (followRedirects != null) {\n      requestConfigBuilder.setRedirectsEnabled(followRedirects);\n    }\n\n    method.setConfig(requestConfigBuilder.build());\n    \n    HttpEntity entity = null;\n    InputStream respBody = null;\n    boolean shouldClose = true;\n    try {\n      \r\n      HttpClientContext httpClientRequestContext = HttpClientUtil.createNewHttpClientRequestContext();\n      if (userPrincipal != null) {\n        \r\n        \r\n        \r\n        httpClientRequestContext.setUserToken(userPrincipal);\n      }\n      final HttpResponse response = httpClient.execute(method, httpClientRequestContext);\n\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      \r\n      entity = response.getEntity();\n      respBody = entity.getContent();\n      String mimeType = null;\n      Charset charset = null;\n      String charsetName = null;\n\n      ContentType contentType = ContentType.get(entity);\n      if (contentType != null) {\n        mimeType = contentType.getMimeType().trim().toLowerCase(Locale.ROOT);\n        charset = contentType.getCharset();\n\n        if (charset != null) {\n          charsetName = charset.name();\n        }\n      }\n\n      \r\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  \r\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || contentType == null) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null || processor instanceof InputStreamResponseParser) {\n        \n        \r\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", respBody);\n        rsp.add(\"closeableResponse\", response);\n        \r\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          \r\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Charset exceptionCharset = charset != null? charset : FALLBACK_CHARSET;\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, exceptionCharset);\n          } catch (IOException e) {\n            throw new RemoteSolrException(baseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionCharset, e);\n          }\n          throw new RemoteSolrException(baseUrl, httpStatus, msg, null);\n        }\n      }\n      \n      NamedList<Object> rsp = null;\n      try {\n        rsp = processor.processResponse(respBody, charsetName);\n      } catch (Exception e) {\n        throw new RemoteSolrException(baseUrl, httpStatus, e.getMessage(), e);\n      }\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (isV2Api || String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n          throw RemoteExecutionException.create(baseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          if (error != null) {\n            reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"msg\"));\n            if(reason == null) {\n              reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"trace\"));\n            }\n            Object metadataObj = Utils.getObjectByPath(error, false, Collections.singletonList(\"metadata\"));\n            if  (metadataObj instanceof NamedList) {\n              metadata = (NamedList<String>) metadataObj;\n            } else if (metadataObj instanceof List) {\n              \r\n              List<Object> list = (List<Object>) metadataObj;\n              metadata = new NamedList<>(list.size()/2);\n              for (int i = 0; i < list.size(); i+=2) {\n                metadata.add((String)list.get(i), (String) list.get(i+1));\n              }\n            } else if (metadataObj instanceof Map) {\n              metadata = new NamedList((Map) metadataObj);\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase())\n            .append(\"\\n\\n\")\n            .append(\"request: \")\n            .append(method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(baseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occurred while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occurred when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (shouldClose) {\n        Utils.consumeFully(entity);\n      }\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":554,"status":"M"},{"authorDate":"2020-06-10 21:41:52","commitOrder":18,"curCode":"  private NamedList<Object> processErrorsAndResponse(Response response,\n                                                     final ResponseParser processor,\n                                                     InputStream is,\n                                                     String mimeType,\n                                                     String encoding,\n                                                     final boolean isV2Api)\n      throws SolrServerException {\n    boolean shouldClose = true;\n    try {\n      \r\n      int httpStatus = response.getStatus();\n\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT: \r\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!httpClient.isFollowRedirects()) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || mimeType == null) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getReason(),\n                null);\n          }\n      }\n\n      if (wantStream(parser)) {\n        \r\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", is);\n        \r\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          \r\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          String exceptionEncoding = encoding != null? encoding : FALLBACK_CHARSET.name();\n          try {\n            msg = msg + \" \" + IOUtils.toString(is, exceptionEncoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionEncoding, e);\n          }\n          throw new RemoteSolrException(serverBaseUrl, httpStatus, msg, null);\n        }\n      }\n\n      NamedList<Object> rsp;\n      try {\n        rsp = processor.processResponse(is, encoding);\n      } catch (Exception e) {\n        throw new RemoteSolrException(serverBaseUrl, httpStatus, e.getMessage(), e);\n      }\n\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n        throw RemoteExecutionException.create(serverBaseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          if (error != null) {\n            reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"msg\"));\n            if(reason == null) {\n              reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"trace\"));\n            }\n            Object metadataObj = Utils.getObjectByPath(error, false, Collections.singletonList(\"metadata\"));\n            if  (metadataObj instanceof NamedList) {\n              metadata = (NamedList<String>) metadataObj;\n            } else if (metadataObj instanceof List) {\n              \r\n              List<Object> list = (List<Object>) metadataObj;\n              metadata = new NamedList<>(list.size()/2);\n              for (int i = 0; i < list.size(); i+=2) {\n                metadata.add((String)list.get(i), (String) list.get(i+1));\n              }\n            } else if (metadataObj instanceof Map) {\n              metadata = new NamedList((Map) metadataObj);\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getReason())\n              .append(\"\\n\\n\")\n              .append(\"request: \")\n              .append(response.getRequest().getMethod());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(serverBaseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } finally {\n      if (shouldClose) {\n        try {\n          is.close();\n          assert ObjectReleaseTracker.release(is);\n        } catch (IOException e) {\n          \r\n        }\n      }\n    }\n  }\n","date":"2020-06-10 21:41:52","endLine":749,"groupId":"1280","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"processErrorsAndResponse","params":"(Responseresponse@finalResponseParserprocessor@InputStreamis@StringmimeType@Stringencoding@finalbooleanisV2Api)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-solr-10-0.7/blobInfo/CC_OUT/blobs/9e/46a96d6ca73f6b432d12dc115eb2721ddbafe1.src","preCode":"  private NamedList<Object> processErrorsAndResponse(Response response,\n                                                     final ResponseParser processor,\n                                                     InputStream is,\n                                                     String mimeType,\n                                                     String encoding,\n                                                     final boolean isV2Api)\n      throws SolrServerException {\n    boolean shouldClose = true;\n    try {\n      \r\n      int httpStatus = response.getStatus();\n\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT: \r\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!httpClient.isFollowRedirects()) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null || mimeType == null) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"non ok status: \" + httpStatus\n                + \", message:\" + response.getReason(),\n                null);\n          }\n      }\n\n      if (wantStream(parser)) {\n        \r\n        NamedList<Object> rsp = new NamedList<>();\n        rsp.add(\"stream\", is);\n        \r\n        shouldClose = false;\n        return rsp;\n      }\n\n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          \r\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          String exceptionEncoding = encoding != null? encoding : FALLBACK_CHARSET.name();\n          try {\n            msg = msg + \" \" + IOUtils.toString(is, exceptionEncoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(serverBaseUrl, httpStatus, \"Could not parse response with encoding \" + exceptionEncoding, e);\n          }\n          throw new RemoteSolrException(serverBaseUrl, httpStatus, msg, null);\n        }\n      }\n\n      NamedList<Object> rsp;\n      try {\n        rsp = processor.processResponse(is, encoding);\n      } catch (Exception e) {\n        throw new RemoteSolrException(serverBaseUrl, httpStatus, e.getMessage(), e);\n      }\n\n      Object error = rsp == null ? null : rsp.get(\"error\");\n      if (error != null && (String.valueOf(getObjectByPath(error, true, errPath)).endsWith(\"ExceptionWithErrObject\"))) {\n        throw RemoteExecutionException.create(serverBaseUrl, rsp);\n      }\n      if (httpStatus != HttpStatus.SC_OK && !isV2Api) {\n        NamedList<String> metadata = null;\n        String reason = null;\n        try {\n          if (error != null) {\n            reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"msg\"));\n            if(reason == null) {\n              reason = (String) Utils.getObjectByPath(error, false, Collections.singletonList(\"trace\"));\n            }\n            Object metadataObj = Utils.getObjectByPath(error, false, Collections.singletonList(\"metadata\"));\n            if  (metadataObj instanceof NamedList) {\n              metadata = (NamedList<String>) metadataObj;\n            } else if (metadataObj instanceof List) {\n              \r\n              List<Object> list = (List<Object>) metadataObj;\n              metadata = new NamedList<>(list.size()/2);\n              for (int i = 0; i < list.size(); i+=2) {\n                metadata.add((String)list.get(i), (String) list.get(i+1));\n              }\n            } else if (metadataObj instanceof Map) {\n              metadata = new NamedList((Map) metadataObj);\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getReason())\n              .append(\"\\n\\n\")\n              .append(\"request: \")\n              .append(response.getRequest().getMethod());\n          reason = java.net.URLDecoder.decode(msg.toString(), FALLBACK_CHARSET);\n        }\n        RemoteSolrException rss = new RemoteSolrException(serverBaseUrl, httpStatus, reason, null);\n        if (metadata != null) rss.setMetadata(metadata);\n        throw rss;\n      }\n      return rsp;\n    } finally {\n      if (shouldClose) {\n        try {\n          is.close();\n          assert ObjectReleaseTracker.release(is);\n        } catch (IOException e) {\n          \r\n        }\n      }\n    }\n  }\n","realPath":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java","repoName":"solr","snippetEndLine":0,"snippetStartLine":0,"startLine":634,"status":"N"}],"commitId":"a074418da0d03b6beff2ca4199660c04f6348dfb","commitMessage":"@@@SOLR-13528: Implement Request Rate Limiters (#1686)\n\nThis commit introduces two functionalities: request rate limiting and ability to identify requests based on type (indexing.  search.  admin). The default rate limiter rate limits query requests based on configurable parameters which can be set in web.xml. Note that this rate limiting works at a JVM level.  not a core/collection level.","date":"2020-08-08 04:06:06","modifiedFileCount":"26","status":"M","submitter":"Atri Sharma"}]
