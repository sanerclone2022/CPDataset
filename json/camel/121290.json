[{"authorTime":"2020-10-26 22:35:14","codes":[{"authorDate":"2020-10-26 22:35:14","commitOrder":1,"curCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new AsyncAfterTask(states, exchange, originalCallback);\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                reactiveExecutor.schedule(() -> {\n                    \r\n                    uow.afterProcess(processor, exchange, callback, false);\n                });\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","date":"2020-10-26 22:35:14","endLine":332,"groupId":"20502","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/b4/09d9fef455db35cf8f8e0c144d3b5cb45026b0.src","preCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new AsyncAfterTask(states, exchange, originalCallback);\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                reactiveExecutor.schedule(() -> {\n                    \r\n                    uow.afterProcess(processor, exchange, callback, false);\n                });\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/CamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"B"},{"authorDate":"2020-10-26 22:35:14","commitOrder":1,"curCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                reactiveExecutor.schedule(() -> {\n                    \r\n                    uow.afterProcess(processor, exchange, callback, sync);\n                });\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","date":"2020-10-26 22:35:14","endLine":237,"groupId":"14664","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback@AsyncProcessorprocessor@ProcessorresultProcessor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/61/e7fafa1c79fb88fe574e26c4d20dddf961c310.src","preCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                reactiveExecutor.schedule(() -> {\n                    \r\n                    uow.afterProcess(processor, exchange, callback, sync);\n                });\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/SharedCamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"B"}],"commitId":"2870bb9e619b4e18bfe8de11b449be9cd67d1f3c","commitMessage":"@@@CAMEL-15758: camel-core - Modularize base into base-engine\n","date":"2020-10-26 22:35:14","modifiedFileCount":"3","status":"B","submitter":"Claus Ibsen"},{"authorTime":"2021-02-03 18:29:13","codes":[{"authorDate":"2021-02-03 18:29:13","commitOrder":2,"curCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new AsyncAfterTask(states, exchange, originalCallback);\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","date":"2021-02-03 18:29:13","endLine":330,"groupId":"20502","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/8f/ba8fee8735b527b93fbfff7e45b9eab95ae5c8.src","preCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new AsyncAfterTask(states, exchange, originalCallback);\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                reactiveExecutor.schedule(() -> {\n                    \r\n                    uow.afterProcess(processor, exchange, callback, false);\n                });\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/CamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"},{"authorDate":"2021-02-03 18:29:13","commitOrder":2,"curCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","date":"2021-02-03 18:29:13","endLine":235,"groupId":"14664","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback@AsyncProcessorprocessor@ProcessorresultProcessor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/44/9c1ac99cfcc5648b628cafcced521604b93a99.src","preCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                reactiveExecutor.schedule(() -> {\n                    \r\n                    uow.afterProcess(processor, exchange, callback, sync);\n                });\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/SharedCamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"M"}],"commitId":"430a194f364373d534779f47853b514940a309d0","commitMessage":"@@@CAMEL-16034: Using MDC would take up too much memory. Thanks to Benjamin Graf for the test case.\n","date":"2021-02-03 18:29:13","modifiedFileCount":"2","status":"M","submitter":"Claus Ibsen"},{"authorTime":"2021-02-03 18:29:13","codes":[{"authorDate":"2021-03-09 16:08:06","commitOrder":3,"curCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            if (taskFactory != null) {\n                taskFactory.release(afterTask);\n            }\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","date":"2021-03-09 16:08:06","endLine":386,"groupId":"18297","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/79/919eadc6b708326af19e3378e03d87341d5f88.src","preCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        \r\n        AsyncCallback callback = new AsyncAfterTask(states, exchange, originalCallback);\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/CamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":268,"status":"M"},{"authorDate":"2021-02-03 18:29:13","commitOrder":3,"curCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","date":"2021-02-03 18:29:13","endLine":235,"groupId":"14664","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback@AsyncProcessorprocessor@ProcessorresultProcessor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/44/9c1ac99cfcc5648b628cafcced521604b93a99.src","preCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/SharedCamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"N"}],"commitId":"ee5a18c8b4989ce2933203c47220830c9c7a8a82","commitMessage":"@@@CAMEL-16279: camel-core - Optimize core to reduce object allocations by pooloing reusable tasks in the routing engine.\n","date":"2021-03-09 16:08:06","modifiedFileCount":"8","status":"M","submitter":"Claus Ibsen"},{"authorTime":"2021-02-03 18:29:13","codes":[{"authorDate":"2021-03-10 03:37:43","commitOrder":4,"curCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            try {\n                \r\n                \r\n                \r\n                processor.process(exchange);\n                \r\n                \r\n                \r\n            } catch (Throwable e) {\n                exchange.setException(e);\n            } finally {\n                afterTask.done(true);\n                if (taskFactory != null) {\n                    taskFactory.release(afterTask);\n                }\n            }\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","date":"2021-03-10 03:37:43","endLine":389,"groupId":"18297","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/3e/fa6f668fc2940f07a5325c1bf69f9346e67b36.src","preCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            if (taskFactory != null) {\n                taskFactory.release(afterTask);\n            }\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/CamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":269,"status":"M"},{"authorDate":"2021-02-03 18:29:13","commitOrder":4,"curCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","date":"2021-02-03 18:29:13","endLine":235,"groupId":"14664","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback@AsyncProcessorprocessor@ProcessorresultProcessor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/44/9c1ac99cfcc5648b628cafcced521604b93a99.src","preCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/SharedCamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"N"}],"commitId":"3de21e8df16471ec018b727294dc66675dd55573","commitMessage":"@@@CAMEL-16324: camel-core - Spring Transactions does not work due recent optimization\n","date":"2021-03-10 03:37:43","modifiedFileCount":"1","status":"M","submitter":"Claus Ibsen"},{"authorTime":"2021-02-03 18:29:13","codes":[{"authorDate":"2021-03-10 14:44:08","commitOrder":5,"curCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                \r\n                exchange.setException(e);\n                try {\n                    originalCallback.done(true);\n                } finally {\n                    \r\n                    if (taskFactory != null) {\n                        taskFactory.release(afterTask);\n                    }\n                }\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            try {\n                \r\n                \r\n                \r\n                processor.process(exchange);\n                \r\n                \r\n                \r\n            } catch (Throwable e) {\n                exchange.setException(e);\n            } finally {\n                \r\n                afterTask.done(true);\n                \r\n                if (taskFactory != null) {\n                    taskFactory.release(afterTask);\n                }\n            }\n            \r\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","date":"2021-03-10 15:02:40","endLine":400,"groupId":"13899","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/80/b037eae04b72c98f8b5d0d93367dc5ff3a6245.src","preCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            try {\n                \r\n                \r\n                \r\n                processor.process(exchange);\n                \r\n                \r\n                \r\n            } catch (Throwable e) {\n                exchange.setException(e);\n            } finally {\n                afterTask.done(true);\n                if (taskFactory != null) {\n                    taskFactory.release(afterTask);\n                }\n            }\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/CamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":269,"status":"M"},{"authorDate":"2021-02-03 18:29:13","commitOrder":5,"curCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","date":"2021-02-03 18:29:13","endLine":235,"groupId":"14664","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback@AsyncProcessorprocessor@ProcessorresultProcessor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/44/9c1ac99cfcc5648b628cafcced521604b93a99.src","preCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/SharedCamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"N"}],"commitId":"baf7cd432cd528f2cb07d394383db3166921979b","commitMessage":"@@@CAMEL-16279: camel-core - Optimize core to reduce object allocations by pooloing reusable tasks in the routing engine.\n","date":"2021-03-10 15:02:40","modifiedFileCount":"1","status":"M","submitter":"Claus Ibsen"},{"authorTime":"2021-02-03 18:29:13","codes":[{"authorDate":"2021-03-10 16:15:28","commitOrder":6,"curCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                \r\n                exchange.setException(e);\n                try {\n                    originalCallback.done(true);\n                } finally {\n                    \r\n                    if (taskFactory != null) {\n                        taskFactory.release(afterTask);\n                    }\n                }\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            try {\n                \r\n                \r\n                \r\n                processor.process(exchange);\n                \r\n                \r\n                \r\n            } catch (Throwable e) {\n                exchange.setException(e);\n            } finally {\n                \r\n                afterTask.done(true);\n            }\n            \r\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","date":"2021-03-10 16:35:59","endLine":396,"groupId":"13899","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/20/6625a4a26f8c62c22555bc3334cc30f19475a7.src","preCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                \r\n                exchange.setException(e);\n                try {\n                    originalCallback.done(true);\n                } finally {\n                    \r\n                    if (taskFactory != null) {\n                        taskFactory.release(afterTask);\n                    }\n                }\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            try {\n                \r\n                \r\n                \r\n                processor.process(exchange);\n                \r\n                \r\n                \r\n            } catch (Throwable e) {\n                exchange.setException(e);\n            } finally {\n                \r\n                afterTask.done(true);\n                \r\n                if (taskFactory != null) {\n                    taskFactory.release(afterTask);\n                }\n            }\n            \r\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/CamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":269,"status":"M"},{"authorDate":"2021-02-03 18:29:13","commitOrder":6,"curCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","date":"2021-02-03 18:29:13","endLine":235,"groupId":"14664","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback@AsyncProcessorprocessor@ProcessorresultProcessor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/44/9c1ac99cfcc5648b628cafcced521604b93a99.src","preCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/SharedCamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"N"}],"commitId":"a3230c089a362c800b4256284b2bd7aea0a65ca9","commitMessage":"@@@CAMEL-16279: camel-core - Optimize core to reduce object allocations by pooloing reusable tasks in the routing engine.\n","date":"2021-03-10 16:35:59","modifiedFileCount":"1","status":"M","submitter":"Claus Ibsen"},{"authorTime":"2021-02-03 18:29:13","codes":[{"authorDate":"2021-03-13 19:25:32","commitOrder":7,"curCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        if (shutdownStrategy.isForceShutdown()) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                \r\n                exchange.setException(e);\n                try {\n                    originalCallback.done(true);\n                } finally {\n                    \r\n                    if (taskFactory != null) {\n                        taskFactory.release(afterTask);\n                    }\n                }\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            try {\n                \r\n                \r\n                \r\n                processor.process(exchange);\n                \r\n                \r\n                \r\n            } catch (Throwable e) {\n                exchange.setException(e);\n            } finally {\n                \r\n                afterTask.done(true);\n            }\n            \r\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","date":"2021-03-13 19:25:46","endLine":400,"groupId":"121290","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/8f/367eb39a2d154a0b6d5300ad250d8815737cfa.src","preCode":"    public boolean process(Exchange exchange, AsyncCallback originalCallback) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || exchange.isRouteStop()) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        boolean forceShutdown = shutdownStrategy.forceShutdown(this);\n        if (forceShutdown) {\n            String msg = \"Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: \"\n                         + exchange;\n            LOG.debug(msg);\n            if (exchange.getException() == null) {\n                exchange.setException(new RejectedExecutionException(msg));\n            }\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        Object[] states;\n\n        \r\n        CamelInternalTask afterTask = taskFactory != null ? taskFactory.acquire() : null;\n        if (afterTask == null) {\n            states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n            afterTask = new AsyncAfterTask(states);\n        } else {\n            states = afterTask.getStates();\n        }\n        afterTask.prepare(exchange, originalCallback);\n\n        \r\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice<?> task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                \r\n                exchange.setException(e);\n                try {\n                    originalCallback.done(true);\n                } finally {\n                    \r\n                    if (taskFactory != null) {\n                        taskFactory.release(afterTask);\n                    }\n                }\n                return true;\n            }\n        }\n\n        if (exchange.isTransacted()) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\", exchange.getExchangeId(),\n                        exchange);\n            }\n            try {\n                \r\n                \r\n                \r\n                processor.process(exchange);\n                \r\n                \r\n                \r\n            } catch (Throwable e) {\n                exchange.setException(e);\n            } finally {\n                \r\n                afterTask.done(true);\n            }\n            \r\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = afterTask;\n            boolean beforeAndAfter = uow != null && uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, afterTask, false);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            \r\n            return false;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/CamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":274,"status":"M"},{"authorDate":"2021-02-03 18:29:13","commitOrder":7,"curCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","date":"2021-02-03 18:29:13","endLine":235,"groupId":"121290","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"process","params":"(Exchangeexchange@AsyncCallbackoriginalCallback@AsyncProcessorprocessor@ProcessorresultProcessor)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-camel-10-0.7/blobInfo/CC_OUT/blobs/44/9c1ac99cfcc5648b628cafcced521604b93a99.src","preCode":"    public boolean process(\n            Exchange exchange, AsyncCallback originalCallback, AsyncProcessor processor, Processor resultProcessor) {\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n\n        if (processor == null || !continueProcessing(exchange, processor)) {\n            \r\n            originalCallback.done(true);\n            return true;\n        }\n\n        \r\n        final Object[] states = statefulAdvices > 0 ? new Object[statefulAdvices] : EMPTY_STATES;\n        \r\n        for (int i = 0, j = 0; i < advices.size(); i++) {\n            CamelInternalProcessorAdvice task = advices.get(i);\n            try {\n                Object state = task.before(exchange);\n                if (task.hasState()) {\n                    states[j++] = state;\n                }\n            } catch (Throwable e) {\n                exchange.setException(e);\n                originalCallback.done(true);\n                return true;\n            }\n        }\n\n        \r\n        AsyncCallback callback = new InternalCallback(states, exchange, originalCallback, resultProcessor);\n\n        \r\n        Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC);\n        if (exchange.isTransacted() || synchronous != null) {\n            \r\n            if (LOG.isTraceEnabled()) {\n                if (exchange.isTransacted()) {\n                    LOG.trace(\"Transacted Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                } else {\n                    LOG.trace(\"Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}\",\n                            exchange.getExchangeId(), exchange);\n                }\n            }\n            \r\n            \r\n            \r\n            try {\n                processor.process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            \r\n            \r\n            \r\n            callback.done(true);\n            return true;\n        } else {\n            final UnitOfWork uow = exchange.getUnitOfWork();\n\n            \r\n            \r\n            AsyncCallback async = callback;\n            boolean beforeAndAfter = uow.isBeforeAfterProcess();\n            if (beforeAndAfter) {\n                async = uow.beforeProcess(processor, exchange, async);\n            }\n\n            \r\n            \r\n            \r\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Processing exchange for exchangeId: {} -> {}\", exchange.getExchangeId(), exchange);\n            }\n            boolean sync = processor.process(exchange, async);\n            \r\n            \r\n            \r\n\n            \r\n            if (beforeAndAfter) {\n                \r\n                uow.afterProcess(processor, exchange, callback, sync);\n            }\n\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}\",\n                        exchange.getExchangeId(), exchange);\n            }\n            return sync;\n        }\n    }\n","realPath":"core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/SharedCamelInternalProcessor.java","repoName":"camel","snippetEndLine":0,"snippetStartLine":0,"startLine":133,"status":"N"}],"commitId":"66287711c48470d7a3e254e9133f116d80ec0b9b","commitMessage":"@@@CAMEL-16348: camel-core - Optimize shutdown strategy forceShutdown check\n","date":"2021-03-13 19:25:46","modifiedFileCount":"7","status":"M","submitter":"Claus Ibsen"}]
