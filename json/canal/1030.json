[{"authorTime":"2020-02-28 11:00:08","codes":[{"authorDate":"2019-08-26 18:16:33","commitOrder":9,"curCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                            sub,\n                            packet.getType(),\n                            ackBytes.length,\n                            System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(sub.getDestination(),\n                                sub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(),\n                            ackBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                ackBytes.length,\n                                System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\n\n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES).setVersion(NettyUtils.VERSION);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString())\n                                .build()\n                                .toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(),\n                                errorBytes,\n                                new ChannelFutureAggregator(ack.getDestination(),\n                                    ack,\n                                    packet.getType(),\n                                    errorBytes.length,\n                                    System.nanoTime() - start,\n                                    (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                0,\n                                System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(),\n                            rollback,\n                            packet.getType(),\n                            0,\n                            System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400,\n                        MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                        .getRemoteAddress()\n                        .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                .getRemoteAddress()\n                .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","date":"2019-08-26 18:16:33","endLine":339,"groupId":"1240","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"messageReceived","params":"(ChannelHandlerContextctx@MessageEvente)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/aa/9eef7ac3741de1c6ae7f7f941cc784f68d7945.src","preCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                            sub,\n                            packet.getType(),\n                            ackBytes.length,\n                            System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(sub.getDestination(),\n                                sub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(),\n                            ackBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                ackBytes.length,\n                                System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\n\n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES).setVersion(NettyUtils.VERSION);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString())\n                                .build()\n                                .toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(),\n                                errorBytes,\n                                new ChannelFutureAggregator(ack.getDestination(),\n                                    ack,\n                                    packet.getType(),\n                                    errorBytes.length,\n                                    System.nanoTime() - start,\n                                    (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                0,\n                                System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(),\n                            rollback,\n                            packet.getType(),\n                            0,\n                            System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400,\n                        MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                        .getRemoteAddress()\n                        .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                .getRemoteAddress()\n                .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","realPath":"server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"NB"},{"authorDate":"2020-02-28 11:00:08","commitOrder":9,"curCode":"    public static byte[] serializer(Message data, boolean filterTransactionEntry) {\n        try {\n            if (data != null) {\n                if (data.getId() != -1) {\n                    if (data.isRaw() && !CollectionUtils.isEmpty(data.getRawEntries())) {\n                        \r\n                        List<ByteString> rowEntries = data.getRawEntries();\n                        \r\n                        int messageSize = 0;\n                        messageSize += CodedOutputStream.computeInt64Size(1, data.getId());\n\n                        int dataSize = 0;\n                        for (int i = 0; i < rowEntries.size(); i++) {\n                            dataSize += CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                        }\n                        messageSize += dataSize;\n                        messageSize += 1 * rowEntries.size();\n                        \r\n                        int size = 0;\n                        size += CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n                        size += CodedOutputStream.computeTagSize(5)\n                                + CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n                        \r\n                        byte[] body = new byte[size];\n                        CodedOutputStream output = CodedOutputStream.newInstance(body);\n                        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                        output.writeRawVarint32(messageSize);\n                        \r\n                        output.writeInt64(1, data.getId());\n                        for (int i = 0; i < rowEntries.size(); i++) {\n                            output.writeBytes(2, rowEntries.get(i));\n                        }\n                        output.checkNoSpaceLeft();\n                        return body;\n                    } else if (!CollectionUtils.isEmpty(data.getEntries())) {\n                        \r\n                        CanalPacket.Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                        for (CanalEntry.Entry entry : data.getEntries()) {\n                            if (filterTransactionEntry\n                                && (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN\n                                    || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND)) {\n                                continue;\n                            }\n\n                            messageBuilder.addMessages(entry.toByteString());\n                        }\n\n                        CanalPacket.Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                        packetBuilder.setType(PacketType.MESSAGES);\n                        packetBuilder.setVersion(1);\n                        packetBuilder.setBody(messageBuilder.build().toByteString());\n                        return packetBuilder.build().toByteArray();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error when serializing message to byte[] \");\n        }\n        return null;\n    }\n","date":"2020-02-28 11:00:08","endLine":86,"groupId":"1240","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"serializer","params":"(Messagedata@booleanfilterTransactionEntry)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/c0/becb2ce4663ef7e25b6987190d7a8864cae506.src","preCode":"    public static byte[] serializer(Message data, boolean filterTransactionEntry) {\n        try {\n            if (data != null) {\n                if (data.getId() != -1) {\n                    if (data.isRaw() && !CollectionUtils.isEmpty(data.getRawEntries())) {\n                        \r\n                        List<ByteString> rowEntries = data.getRawEntries();\n                        \r\n                        int messageSize = 0;\n                        messageSize += CodedOutputStream.computeInt64Size(1, data.getId());\n\n                        int dataSize = 0;\n                        for (int i = 0; i < rowEntries.size(); i++) {\n                            dataSize += CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                        }\n                        messageSize += dataSize;\n                        messageSize += 1 * rowEntries.size();\n                        \r\n                        int size = 0;\n                        size += CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n                        size += CodedOutputStream.computeTagSize(5)\n                                + CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n                        \r\n                        byte[] body = new byte[size];\n                        CodedOutputStream output = CodedOutputStream.newInstance(body);\n                        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                        output.writeRawVarint32(messageSize);\n                        \r\n                        output.writeInt64(1, data.getId());\n                        for (int i = 0; i < rowEntries.size(); i++) {\n                            output.writeBytes(2, rowEntries.get(i));\n                        }\n                        output.checkNoSpaceLeft();\n                        return body;\n                    } else if (!CollectionUtils.isEmpty(data.getEntries())) {\n                        \r\n                        CanalPacket.Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                        for (CanalEntry.Entry entry : data.getEntries()) {\n                            if (filterTransactionEntry\n                                && (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN\n                                    || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND)) {\n                                continue;\n                            }\n\n                            messageBuilder.addMessages(entry.toByteString());\n                        }\n\n                        CanalPacket.Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                        packetBuilder.setType(PacketType.MESSAGES);\n                        packetBuilder.setVersion(1);\n                        packetBuilder.setBody(messageBuilder.build().toByteString());\n                        return packetBuilder.build().toByteArray();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error when serializing message to byte[] \");\n        }\n        return null;\n    }\n","realPath":"connector/core/src/main/java/com/alibaba/otter/canal/connector/core/util/CanalMessageSerializerUtil.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":25,"status":"B"}],"commitId":"265a8e8594f68882c24e8d72319a4b66966527f0","commitMessage":"@@@???mq connector (#2562)\n\n* add connector module.  add kafka producer connector module for server\n\n* add rocketMQ producer connector module for server\n\n* add rabbitMQ producer connector module for server\n\n* optimize code.  add annotation\n\n* add canal message consumer connector for canal-adapter module\n","date":"2020-02-28 11:00:08","modifiedFileCount":"8","status":"M","submitter":"rewerma"},{"authorTime":"2020-09-17 22:49:35","codes":[{"authorDate":"2020-09-17 22:49:35","commitOrder":10,"curCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                            sub,\n                            packet.getType(),\n                            ackBytes.length,\n                            System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(sub.getDestination(),\n                                sub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(),\n                            ackBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                ackBytes.length,\n                                System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (ByteString rowEntry : rowEntries) {\n                                dataSize += CodedOutputStream.computeBytesSizeNoTag(rowEntry);\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (ByteString rowEntry : rowEntries) {\n                                output.writeBytes(2, rowEntry);\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\n\n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES).setVersion(NettyUtils.VERSION);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString())\n                                .build()\n                                .toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(),\n                                errorBytes,\n                                new ChannelFutureAggregator(ack.getDestination(),\n                                    ack,\n                                    packet.getType(),\n                                    errorBytes.length,\n                                    System.nanoTime() - start,\n                                    (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                0,\n                                System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(),\n                            rollback,\n                            packet.getType(),\n                            0,\n                            System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400,\n                        MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                        .getRemoteAddress()\n                        .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                .getRemoteAddress()\n                .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","date":"2020-09-17 23:22:25","endLine":339,"groupId":"1030","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"messageReceived","params":"(ChannelHandlerContextctx@MessageEvente)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/f5/53ddfb51a509dbfd80d7f23887e48ad476ec5a.src","preCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                            sub,\n                            packet.getType(),\n                            ackBytes.length,\n                            System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(sub.getDestination(),\n                                sub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(),\n                            ackBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                ackBytes.length,\n                                System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\n\n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES).setVersion(NettyUtils.VERSION);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString())\n                                .build()\n                                .toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(),\n                                errorBytes,\n                                new ChannelFutureAggregator(ack.getDestination(),\n                                    ack,\n                                    packet.getType(),\n                                    errorBytes.length,\n                                    System.nanoTime() - start,\n                                    (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                0,\n                                System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(),\n                            rollback,\n                            packet.getType(),\n                            0,\n                            System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400,\n                        MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                        .getRemoteAddress()\n                        .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                .getRemoteAddress()\n                .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","realPath":"server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"},{"authorDate":"2020-09-17 22:49:35","commitOrder":10,"curCode":"    public static byte[] serializer(Message data, boolean filterTransactionEntry) {\n        try {\n            if (data != null) {\n                if (data.getId() != -1) {\n                    if (data.isRaw() && !CollectionUtils.isEmpty(data.getRawEntries())) {\n                        \r\n                        List<ByteString> rowEntries = data.getRawEntries();\n                        \r\n                        int messageSize = 0;\n                        messageSize += CodedOutputStream.computeInt64Size(1, data.getId());\n\n                        int dataSize = 0;\n                        for (ByteString rowEntry : rowEntries) {\n                            dataSize += CodedOutputStream.computeBytesSizeNoTag(rowEntry);\n                        }\n                        messageSize += dataSize;\n                        messageSize += 1 * rowEntries.size();\n                        \r\n                        int size = 0;\n                        size += CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n                        size += CodedOutputStream.computeTagSize(5)\n                                + CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n                        \r\n                        byte[] body = new byte[size];\n                        CodedOutputStream output = CodedOutputStream.newInstance(body);\n                        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                        output.writeRawVarint32(messageSize);\n                        \r\n                        output.writeInt64(1, data.getId());\n                        for (ByteString rowEntry : rowEntries) {\n                            output.writeBytes(2, rowEntry);\n                        }\n                        output.checkNoSpaceLeft();\n                        return body;\n                    } else if (!CollectionUtils.isEmpty(data.getEntries())) {\n                        \r\n                        CanalPacket.Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                        for (CanalEntry.Entry entry : data.getEntries()) {\n                            if (filterTransactionEntry\n                                && (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND)) {\n                                continue;\n                            }\n\n                            messageBuilder.addMessages(entry.toByteString());\n                        }\n\n                        CanalPacket.Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                        packetBuilder.setType(PacketType.MESSAGES);\n                        packetBuilder.setVersion(1);\n                        packetBuilder.setBody(messageBuilder.build().toByteString());\n                        return packetBuilder.build().toByteArray();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error when serializing message to byte[] \");\n        }\n        return null;\n    }\n","date":"2020-09-17 23:22:25","endLine":85,"groupId":"1030","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"serializer","params":"(Messagedata@booleanfilterTransactionEntry)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/5f/ac0e672204a6c4fcb6464ec9b6439ddc912e47.src","preCode":"    public static byte[] serializer(Message data, boolean filterTransactionEntry) {\n        try {\n            if (data != null) {\n                if (data.getId() != -1) {\n                    if (data.isRaw() && !CollectionUtils.isEmpty(data.getRawEntries())) {\n                        \r\n                        List<ByteString> rowEntries = data.getRawEntries();\n                        \r\n                        int messageSize = 0;\n                        messageSize += CodedOutputStream.computeInt64Size(1, data.getId());\n\n                        int dataSize = 0;\n                        for (int i = 0; i < rowEntries.size(); i++) {\n                            dataSize += CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                        }\n                        messageSize += dataSize;\n                        messageSize += 1 * rowEntries.size();\n                        \r\n                        int size = 0;\n                        size += CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n                        size += CodedOutputStream.computeTagSize(5)\n                                + CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n                        \r\n                        byte[] body = new byte[size];\n                        CodedOutputStream output = CodedOutputStream.newInstance(body);\n                        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                        output.writeRawVarint32(messageSize);\n                        \r\n                        output.writeInt64(1, data.getId());\n                        for (int i = 0; i < rowEntries.size(); i++) {\n                            output.writeBytes(2, rowEntries.get(i));\n                        }\n                        output.checkNoSpaceLeft();\n                        return body;\n                    } else if (!CollectionUtils.isEmpty(data.getEntries())) {\n                        \r\n                        CanalPacket.Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                        for (CanalEntry.Entry entry : data.getEntries()) {\n                            if (filterTransactionEntry\n                                && (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND)) {\n                                continue;\n                            }\n\n                            messageBuilder.addMessages(entry.toByteString());\n                        }\n\n                        CanalPacket.Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                        packetBuilder.setType(PacketType.MESSAGES);\n                        packetBuilder.setVersion(1);\n                        packetBuilder.setBody(messageBuilder.build().toByteString());\n                        return packetBuilder.build().toByteArray();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error when serializing message to byte[] \");\n        }\n        return null;\n    }\n","realPath":"connector/core/src/main/java/com/alibaba/otter/canal/connector/core/util/CanalMessageSerializerUtil.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":25,"status":"M"}],"commitId":"df24596092971cf2578244b69c61129d8ce2b336","commitMessage":"@@@= code cleanup\n\n  - for loop replaceable with enhanced 'for' loop\n  - using diamond in generic type\n  - collapse try catch exception\n  - using try-with-resource\n  - using  List#sort instead of Collections#sort\n  - replaced lambda with method reference\n  - using native compare method to compare numbers\n  - using switch instead of if for in ESSyncUtil\n","date":"2020-09-17 23:22:25","modifiedFileCount":"33","status":"M","submitter":"zavakid"}]
