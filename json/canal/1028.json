[{"authorTime":"2018-07-19 13:35:38","codes":[{"authorDate":"2018-07-19 13:35:38","commitOrder":4,"curCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","date":"2018-07-19 13:35:38","endLine":91,"groupId":"1240","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"buildData","params":"(Messagemessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/cb/078ddffbfe3bc78639e1d23b778c67fb78fc12.src","preCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","realPath":"server/src/test/java/com/alibaba/otter/canal/server/ProtocolTest.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"B"},{"authorDate":"2018-07-19 13:35:38","commitOrder":4,"curCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        ctx.setAttachment(clientIdentity);\r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, null);\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            packetBuilder.setBody(messageBuilder.build().toByteString());\n                            NettyUtils.write(ctx.getChannel(), packetBuilder.build().toByteArray(), null);\r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            NettyUtils.error(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage(),\n                                ctx.getChannel(),\n                                null);\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                default:\n                    NettyUtils.error(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType())\n                        .getMessage(), ctx.getChannel(), null);\n                    break;\n            }\n        } catch (Throwable exception) {\n            NettyUtils.error(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage(),\n                ctx.getChannel(),\n                null);\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","date":"2018-07-19 13:35:38","endLine":245,"groupId":"966","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"messageReceived","params":"(ChannelHandlerContextctx@MessageEvente)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/8b/94d452de5130c4dd4768b73caa6e0cb736744b.src","preCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        ctx.setAttachment(clientIdentity);\r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, null);\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            packetBuilder.setBody(messageBuilder.build().toByteString());\n                            NettyUtils.write(ctx.getChannel(), packetBuilder.build().toByteArray(), null);\r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            NettyUtils.error(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage(),\n                                ctx.getChannel(),\n                                null);\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                default:\n                    NettyUtils.error(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType())\n                        .getMessage(), ctx.getChannel(), null);\n                    break;\n            }\n        } catch (Throwable exception) {\n            NettyUtils.error(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage(),\n                ctx.getChannel(),\n                null);\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","realPath":"server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"MB"}],"commitId":"5582a38930814d30b147285a4074fe93c72849a0","commitMessage":"@@@fixed issue #726.  ??SessionHandler????byte[]. ??protobuf?????\n","date":"2018-07-19 13:35:38","modifiedFileCount":"8","status":"M","submitter":"??"},{"authorTime":"2018-07-19 17:55:53","codes":[{"authorDate":"2018-07-19 13:35:38","commitOrder":5,"curCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","date":"2018-07-19 13:35:38","endLine":91,"groupId":"1240","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"buildData","params":"(Messagemessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/cb/078ddffbfe3bc78639e1d23b778c67fb78fc12.src","preCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","realPath":"server/src/test/java/com/alibaba/otter/canal/server/ProtocolTest.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"N"},{"authorDate":"2018-07-19 17:55:53","commitOrder":5,"curCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, null);\n                            \n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            packetBuilder.setBody(messageBuilder.build().toByteString());\n                            NettyUtils.write(ctx.getChannel(), packetBuilder.build().toByteArray(), null);\r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            NettyUtils.error(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage(),\n                                ctx.getChannel(),\n                                null);\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                default:\n                    NettyUtils.error(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType())\n                        .getMessage(), ctx.getChannel(), null);\n                    break;\n            }\n        } catch (Throwable exception) {\n            NettyUtils.error(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage(),\n                ctx.getChannel(),\n                null);\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","date":"2018-07-19 17:55:53","endLine":262,"groupId":"966","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"messageReceived","params":"(ChannelHandlerContextctx@MessageEvente)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/11/bba043172ba37ec1d881a0622fa1940abee854.src","preCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        ctx.setAttachment(clientIdentity);\r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, null);\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            packetBuilder.setBody(messageBuilder.build().toByteString());\n                            NettyUtils.write(ctx.getChannel(), packetBuilder.build().toByteArray(), null);\r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            NettyUtils.error(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage(),\n                                ctx.getChannel(),\n                                null);\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                default:\n                    NettyUtils.error(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType())\n                        .getMessage(), ctx.getChannel(), null);\n                    break;\n            }\n        } catch (Throwable exception) {\n            NettyUtils.error(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage(),\n                ctx.getChannel(),\n                null);\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","realPath":"server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":52,"status":"M"}],"commitId":"b19eaeb89a90b980e550e98b38e89efdd5ead222","commitMessage":"@@@fixed issue #726 .  ?????ByteBuffer??\n","date":"2018-07-19 17:55:53","modifiedFileCount":"2","status":"M","submitter":"??"},{"authorTime":"2018-08-10 23:22:52","codes":[{"authorDate":"2018-07-19 13:35:38","commitOrder":6,"curCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","date":"2018-07-19 13:35:38","endLine":91,"groupId":"1240","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"buildData","params":"(Messagemessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/cb/078ddffbfe3bc78639e1d23b778c67fb78fc12.src","preCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","realPath":"server/src/test/java/com/alibaba/otter/canal/server/ProtocolTest.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"N"},{"authorDate":"2018-08-10 23:22:52","commitOrder":6,"curCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                                sub, packet.getType(), ackBytes.length, System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes ,new ChannelFutureAggregator(sub.getDestination(),\n                                sub, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub, packet.getType(), ackBytes.length, System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                    get, packet.getType(), body.length, System.nanoTime() - start, message.getId() == -1));\n                            \n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString()).build().toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                    get, packet.getType(), body.length, System.nanoTime() - start, message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(get.getDestination(),\n                                get, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402, MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ack.getDestination(),\n                                    ack, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ack.getDestination(),\n                                ack, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", rollback.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel().getRemoteAddress().toString(),\n                            null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400, MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel().getRemoteAddress().toString(),\n                    null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","date":"2018-08-10 23:22:52","endLine":263,"groupId":"1240","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"messageReceived","params":"(ChannelHandlerContextctx@MessageEvente)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/a9/8e7b8be06ebf5b4a31d37ccc455c3597cbdcc6.src","preCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        NettyUtils.ack(ctx.getChannel(), null);\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, null);\n                            \n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            packetBuilder.setBody(messageBuilder.build().toByteString());\n                            NettyUtils.write(ctx.getChannel(), packetBuilder.build().toByteArray(), null);\r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            NettyUtils.error(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage(),\n                                ctx.getChannel(),\n                                null);\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                    } else {\n                        NettyUtils.error(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage(),\n                            ctx.getChannel(),\n                            null);\n                    }\n                    break;\n                default:\n                    NettyUtils.error(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType())\n                        .getMessage(), ctx.getChannel(), null);\n                    break;\n            }\n        } catch (Throwable exception) {\n            NettyUtils.error(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage(),\n                ctx.getChannel(),\n                null);\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","realPath":"server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"M"}],"commitId":"fb1126cf390c3f062ec6ccabbae9900003cd3aa9","commitMessage":"@@@Merge pull request #828 from lcybo/master\n\ncanal ??????","date":"2018-08-10 23:22:52","modifiedFileCount":"18","status":"M","submitter":"agapple"},{"authorTime":"2018-08-19 20:48:23","codes":[{"authorDate":"2018-07-19 13:35:38","commitOrder":7,"curCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","date":"2018-07-19 13:35:38","endLine":91,"groupId":"1240","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"buildData","params":"(Messagemessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/cb/078ddffbfe3bc78639e1d23b778c67fb78fc12.src","preCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","realPath":"server/src/test/java/com/alibaba/otter/canal/server/ProtocolTest.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"N"},{"authorDate":"2018-08-19 20:48:23","commitOrder":7,"curCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                                sub, packet.getType(), ackBytes.length, System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes ,new ChannelFutureAggregator(sub.getDestination(),\n                                sub, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub, packet.getType(), ackBytes.length, System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                    get, packet.getType(), body.length, System.nanoTime() - start, message.getId() == -1));\n                            \n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString()).build().toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                    get, packet.getType(), body.length, System.nanoTime() - start, message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(get.getDestination(),\n                                get, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402, MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ack.getDestination(),\n                                    ack, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(), ack, packet.getType(), 0, System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ack.getDestination(),\n                                ack, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(), rollback, packet.getType(), 0, System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", rollback.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel().getRemoteAddress().toString(),\n                            null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400, MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel().getRemoteAddress().toString(),\n                    null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","date":"2018-08-19 20:48:23","endLine":265,"groupId":"1240","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"messageReceived","params":"(ChannelHandlerContextctx@MessageEvente)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/fe/8c5538e25d1acf68ff5c7c1d323c84724ae802.src","preCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                                sub, packet.getType(), ackBytes.length, System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes ,new ChannelFutureAggregator(sub.getDestination(),\n                                sub, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub, packet.getType(), ackBytes.length, System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                    get, packet.getType(), body.length, System.nanoTime() - start, message.getId() == -1));\n                            \n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString()).build().toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                    get, packet.getType(), body.length, System.nanoTime() - start, message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(get.getDestination(),\n                                get, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402, MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ack.getDestination(),\n                                    ack, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ack.getDestination(),\n                                ack, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", rollback.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel().getRemoteAddress().toString(),\n                            null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400, MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel().getRemoteAddress().toString(),\n                    null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","realPath":"server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":53,"status":"M"}],"commitId":"35797ca6ff766e87f00da31b3dd848299b5d1fbe","commitMessage":"@@@Merge pull request #854 from lcybo/master\n\n??comments???","date":"2018-08-19 20:48:23","modifiedFileCount":"7","status":"M","submitter":"agapple"},{"authorTime":"2019-08-26 18:16:33","codes":[{"authorDate":"2018-07-19 13:35:38","commitOrder":8,"curCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","date":"2018-07-19 13:35:38","endLine":91,"groupId":"1240","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"buildData","params":"(Messagemessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/cb/078ddffbfe3bc78639e1d23b778c67fb78fc12.src","preCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","realPath":"server/src/test/java/com/alibaba/otter/canal/server/ProtocolTest.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"N"},{"authorDate":"2019-08-26 18:16:33","commitOrder":8,"curCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                            sub,\n                            packet.getType(),\n                            ackBytes.length,\n                            System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(sub.getDestination(),\n                                sub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(),\n                            ackBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                ackBytes.length,\n                                System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\n\n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES).setVersion(NettyUtils.VERSION);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString())\n                                .build()\n                                .toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(),\n                                errorBytes,\n                                new ChannelFutureAggregator(ack.getDestination(),\n                                    ack,\n                                    packet.getType(),\n                                    errorBytes.length,\n                                    System.nanoTime() - start,\n                                    (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                0,\n                                System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(),\n                            rollback,\n                            packet.getType(),\n                            0,\n                            System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400,\n                        MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                        .getRemoteAddress()\n                        .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                .getRemoteAddress()\n                .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","date":"2019-08-26 18:16:33","endLine":339,"groupId":"1240","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"messageReceived","params":"(ChannelHandlerContextctx@MessageEvente)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/aa/9eef7ac3741de1c6ae7f7f941cc784f68d7945.src","preCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                                sub, packet.getType(), ackBytes.length, System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes ,new ChannelFutureAggregator(sub.getDestination(),\n                                sub, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub, packet.getType(), ackBytes.length, System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                    get, packet.getType(), body.length, System.nanoTime() - start, message.getId() == -1));\n                            \n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString()).build().toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                    get, packet.getType(), body.length, System.nanoTime() - start, message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(get.getDestination(),\n                                get, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402, MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ack.getDestination(),\n                                    ack, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(), ack, packet.getType(), 0, System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ack.getDestination(),\n                                ack, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(), rollback, packet.getType(), 0, System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401, MessageFormatter.format(\"destination or clientId is null\", rollback.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400, MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel().getRemoteAddress().toString(),\n                            null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400, MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel().getRemoteAddress().toString(),\n                    null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","realPath":"server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"}],"commitId":"3d4dbc9a8c53de730e5b0433c39ea1d69e2dd480","commitMessage":"@@@fixed issue #2099 .  support user/passwd acl and canal admin operator\n","date":"2019-08-26 18:16:33","modifiedFileCount":"24","status":"M","submitter":"agapple"},{"authorTime":"2020-09-17 22:49:35","codes":[{"authorDate":"2020-09-17 22:49:35","commitOrder":9,"curCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (ByteString rowEntry : rowEntries) {\n            dataSize += CodedOutputStream.computeBytesSizeNoTag(rowEntry);\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (ByteString rowEntry : rowEntries) {\n            output.writeBytes(2, rowEntry);\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","date":"2020-09-17 23:22:25","endLine":91,"groupId":"1028","id":11,"instanceNumber":1,"isCurCommit":1,"methodName":"buildData","params":"(Messagemessage)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/da/479e20f236a60f52a531da5c22f752d5eb8665.src","preCode":"    private byte[] buildData(Message message) throws IOException {\n        List<ByteString> rowEntries = message.getRawEntries();\n        \r\n        int messageSize = 0;\n        messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n        int dataSize = 0;\n        for (int i = 0; i < rowEntries.size(); i++) {\n            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n        }\n        messageSize += dataSize;\n        messageSize += 1 * rowEntries.size();\n        \r\n        int size = 0;\n        size += com.google.protobuf.CodedOutputStream.computeEnumSize(3, PacketType.MESSAGES.getNumber());\n        size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize) + messageSize;\n        \r\n        byte[] body = new byte[size];\n        CodedOutputStream output = CodedOutputStream.newInstance(body);\n        output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n        output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n        output.writeRawVarint32(messageSize);\n        \r\n        output.writeInt64(1, message.getId());\n        for (int i = 0; i < rowEntries.size(); i++) {\n            output.writeBytes(2, rowEntries.get(i));\n        }\n        output.checkNoSpaceLeft();\n\n        return body;\n    }\n","realPath":"server/src/test/java/com/alibaba/otter/canal/server/ProtocolTest.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":59,"status":"M"},{"authorDate":"2020-09-17 22:49:35","commitOrder":9,"curCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                            sub,\n                            packet.getType(),\n                            ackBytes.length,\n                            System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(sub.getDestination(),\n                                sub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(),\n                            ackBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                ackBytes.length,\n                                System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (ByteString rowEntry : rowEntries) {\n                                dataSize += CodedOutputStream.computeBytesSizeNoTag(rowEntry);\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (ByteString rowEntry : rowEntries) {\n                                output.writeBytes(2, rowEntry);\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\n\n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES).setVersion(NettyUtils.VERSION);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString())\n                                .build()\n                                .toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(),\n                                errorBytes,\n                                new ChannelFutureAggregator(ack.getDestination(),\n                                    ack,\n                                    packet.getType(),\n                                    errorBytes.length,\n                                    System.nanoTime() - start,\n                                    (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                0,\n                                System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(),\n                            rollback,\n                            packet.getType(),\n                            0,\n                            System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400,\n                        MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                        .getRemoteAddress()\n                        .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                .getRemoteAddress()\n                .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","date":"2020-09-17 23:22:25","endLine":339,"groupId":"1028","id":12,"instanceNumber":2,"isCurCommit":1,"methodName":"messageReceived","params":"(ChannelHandlerContextctx@MessageEvente)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-canal-10-0.7/blobInfo/CC_OUT/blobs/f5/53ddfb51a509dbfd80d7f23887e48ad476ec5a.src","preCode":"    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        logger.info(\"message receives in session handler...\");\n        long start = System.nanoTime();\n        ChannelBuffer buffer = (ChannelBuffer) e.getMessage();\n        Packet packet = Packet.parseFrom(buffer.readBytes(buffer.readableBytes()).array());\n        ClientIdentity clientIdentity = null;\n        try {\n            switch (packet.getType()) {\n                case SUBSCRIPTION:\n                    Sub sub = Sub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(sub.getDestination()) && StringUtils.isNotEmpty(sub.getClientId())) {\n                        clientIdentity = new ClientIdentity(sub.getDestination(),\n                            Short.valueOf(sub.getClientId()),\n                            sub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n\n                        \r\n                        if (!embeddedServer.isStart(clientIdentity.getDestination())) {\n                            ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(clientIdentity.getDestination());\n                            if (!runningMonitor.isStart()) {\n                                runningMonitor.start();\n                            }\n                        }\n\n                        embeddedServer.subscribe(clientIdentity);\n                        \r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(), ackBytes, new ChannelFutureAggregator(sub.getDestination(),\n                            sub,\n                            packet.getType(),\n                            ackBytes.length,\n                            System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", sub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(sub.getDestination(),\n                                sub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case UNSUBSCRIPTION:\n                    Unsub unsub = Unsub.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(unsub.getDestination()) && StringUtils.isNotEmpty(unsub.getClientId())) {\n                        clientIdentity = new ClientIdentity(unsub.getDestination(),\n                            Short.valueOf(unsub.getClientId()),\n                            unsub.getFilter());\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        embeddedServer.unsubscribe(clientIdentity);\n                        stopCanalInstanceIfNecessary(clientIdentity);\r\n                        byte[] ackBytes = NettyUtils.ackPacket();\n                        NettyUtils.write(ctx.getChannel(),\n                            ackBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                ackBytes.length,\n                                System.nanoTime() - start));\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", unsub.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(unsub.getDestination(),\n                                unsub,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case GET:\n                    Get get = CanalPacket.Get.parseFrom(packet.getBody());\n                    if (StringUtils.isNotEmpty(get.getDestination()) && StringUtils.isNotEmpty(get.getClientId())) {\n                        clientIdentity = new ClientIdentity(get.getDestination(), Short.valueOf(get.getClientId()));\n                        MDC.put(\"destination\", clientIdentity.getDestination());\n                        Message message = null;\n\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        \r\n                        if (get.getTimeout() == -1) {\r\n                            message = embeddedServer.getWithoutAck(clientIdentity, get.getFetchSize());\n                        } else {\n                            TimeUnit unit = convertTimeUnit(get.getUnit());\n                            message = embeddedServer.getWithoutAck(clientIdentity,\n                                get.getFetchSize(),\n                                get.getTimeout(),\n                                unit);\n                        }\n                        \r\n\n                        if (message.getId() != -1 && message.isRaw()) {\n                            List<ByteString> rowEntries = message.getRawEntries();\n                            \r\n                            int messageSize = 0;\n                            messageSize += com.google.protobuf.CodedOutputStream.computeInt64Size(1, message.getId());\n\n                            int dataSize = 0;\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(rowEntries.get(i));\n                            }\n                            messageSize += dataSize;\n                            messageSize += 1 * rowEntries.size();\n                            \r\n                            int size = 0;\n                            size += com.google.protobuf.CodedOutputStream.computeEnumSize(3,\n                                PacketType.MESSAGES.getNumber());\n                            size += com.google.protobuf.CodedOutputStream.computeTagSize(5)\n                                    + com.google.protobuf.CodedOutputStream.computeRawVarint32Size(messageSize)\n                                    + messageSize;\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            \r\n                            byte[] body = new byte[size];\n                            CodedOutputStream output = CodedOutputStream.newInstance(body);\n                            output.writeEnum(3, PacketType.MESSAGES.getNumber());\n\n                            output.writeTag(5, WireFormat.WIRETYPE_LENGTH_DELIMITED);\n                            output.writeRawVarint32(messageSize);\n                            \r\n                            output.writeInt64(1, message.getId());\n                            for (int i = 0; i < rowEntries.size(); i++) {\n                                output.writeBytes(2, rowEntries.get(i));\n                            }\n                            output.checkNoSpaceLeft();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\n\n                            \r\n                            \r\n                            \r\n                            \r\n                        } else {\n                            Packet.Builder packetBuilder = CanalPacket.Packet.newBuilder();\n                            packetBuilder.setType(PacketType.MESSAGES).setVersion(NettyUtils.VERSION);\n\n                            Messages.Builder messageBuilder = CanalPacket.Messages.newBuilder();\n                            messageBuilder.setBatchId(message.getId());\n                            if (message.getId() != -1) {\n                                if (message.isRaw() && !CollectionUtils.isEmpty(message.getRawEntries())) {\n                                    messageBuilder.addAllMessages(message.getRawEntries());\n                                } else if (!CollectionUtils.isEmpty(message.getEntries())) {\n                                    for (Entry entry : message.getEntries()) {\n                                        messageBuilder.addMessages(entry.toByteString());\n                                    }\n                                }\n                            }\n                            byte[] body = packetBuilder.setBody(messageBuilder.build().toByteString())\n                                .build()\n                                .toByteArray();\n                            NettyUtils.write(ctx.getChannel(), body, new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                body.length,\n                                System.nanoTime() - start,\n                                message.getId() == -1));\r\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", get.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(get.getDestination(),\n                                get,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTACK:\n                    ClientAck ack = CanalPacket.ClientAck.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", ack.getDestination());\n                    if (StringUtils.isNotEmpty(ack.getDestination()) && StringUtils.isNotEmpty(ack.getClientId())) {\n                        if (ack.getBatchId() == 0L) {\n                            byte[] errorBytes = NettyUtils.errorPacket(402,\n                                MessageFormatter.format(\"batchId should assign value\", ack.toString()).getMessage());\n                            NettyUtils.write(ctx.getChannel(),\n                                errorBytes,\n                                new ChannelFutureAggregator(ack.getDestination(),\n                                    ack,\n                                    packet.getType(),\n                                    errorBytes.length,\n                                    System.nanoTime() - start,\n                                    (short) 402));\n                        } else if (ack.getBatchId() == -1L) { \r\n                            \r\n                        } else {\n                            clientIdentity = new ClientIdentity(ack.getDestination(), Short.valueOf(ack.getClientId()));\n                            embeddedServer.ack(clientIdentity, ack.getBatchId());\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                0,\n                                System.nanoTime() - start).operationComplete(null);\n                        }\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", ack.toString()).getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(ack.getDestination(),\n                                ack,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                case CLIENTROLLBACK:\n                    ClientRollback rollback = CanalPacket.ClientRollback.parseFrom(packet.getBody());\n                    MDC.put(\"destination\", rollback.getDestination());\n                    if (StringUtils.isNotEmpty(rollback.getDestination())\n                        && StringUtils.isNotEmpty(rollback.getClientId())) {\n                        clientIdentity = new ClientIdentity(rollback.getDestination(),\n                            Short.valueOf(rollback.getClientId()));\n                        if (rollback.getBatchId() == 0L) {\n                            embeddedServer.rollback(clientIdentity);\r\n                        } else {\n                            embeddedServer.rollback(clientIdentity, rollback.getBatchId()); \r\n                        }\n                        new ChannelFutureAggregator(rollback.getDestination(),\n                            rollback,\n                            packet.getType(),\n                            0,\n                            System.nanoTime() - start).operationComplete(null);\n                    } else {\n                        byte[] errorBytes = NettyUtils.errorPacket(401,\n                            MessageFormatter.format(\"destination or clientId is null\", rollback.toString())\n                                .getMessage());\n                        NettyUtils.write(ctx.getChannel(),\n                            errorBytes,\n                            new ChannelFutureAggregator(rollback.getDestination(),\n                                rollback,\n                                packet.getType(),\n                                errorBytes.length,\n                                System.nanoTime() - start,\n                                (short) 401));\n                    }\n                    break;\n                default:\n                    byte[] errorBytes = NettyUtils.errorPacket(400,\n                        MessageFormatter.format(\"packet type={} is NOT supported!\", packet.getType()).getMessage());\n                    NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                        .getRemoteAddress()\n                        .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n                    break;\n            }\n        } catch (Throwable exception) {\n            byte[] errorBytes = NettyUtils.errorPacket(400,\n                MessageFormatter.format(\"something goes wrong with channel:{}, exception={}\",\n                    ctx.getChannel(),\n                    ExceptionUtils.getStackTrace(exception)).getMessage());\n            NettyUtils.write(ctx.getChannel(), errorBytes, new ChannelFutureAggregator(ctx.getChannel()\n                .getRemoteAddress()\n                .toString(), null, packet.getType(), errorBytes.length, System.nanoTime() - start, (short) 400));\n        } finally {\n            MDC.remove(\"destination\");\n        }\n    }\n","realPath":"server/src/main/java/com/alibaba/otter/canal/server/netty/handler/SessionHandler.java","repoName":"canal","snippetEndLine":0,"snippetStartLine":0,"startLine":54,"status":"M"}],"commitId":"df24596092971cf2578244b69c61129d8ce2b336","commitMessage":"@@@= code cleanup\n\n  - for loop replaceable with enhanced 'for' loop\n  - using diamond in generic type\n  - collapse try catch exception\n  - using try-with-resource\n  - using  List#sort instead of Collections#sort\n  - replaced lambda with method reference\n  - using native compare method to compare numbers\n  - using switch instead of if for in ESSyncUtil\n","date":"2020-09-17 23:22:25","modifiedFileCount":"33","status":"M","submitter":"zavakid"}]
