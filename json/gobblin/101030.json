[{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  private static Optional<Schema> removeUncomparableFieldsFromRecord(Schema record, Set<Schema> processed) {\n    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);\n\n    if (processed.contains(record)) {\n      return Optional.absent();\n    }\n    processed.add(record);\n\n    List<Field> fields = Lists.newArrayList();\n    for (Field field : record.getFields()) {\n      Optional<Schema> newFieldSchema = removeUncomparableFields(field.schema(), processed);\n      if (newFieldSchema.isPresent()) {\n        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));\n      }\n    }\n\n    Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getNamespace(), false);\n    newSchema.setFields(fields);\n    return Optional.of(newSchema);\n  }\n","date":"2017-07-31 15:51:25","endLine":559,"groupId":"4453","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"removeUncomparableFieldsFromRecord","params":"(Schemarecord@Set<Schema>processed)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/69/4a40b55fa00a5acf339c22dbf636a6064ab518.src","preCode":"  private static Optional<Schema> removeUncomparableFieldsFromRecord(Schema record, Set<Schema> processed) {\n    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);\n\n    if (processed.contains(record)) {\n      return Optional.absent();\n    }\n    processed.add(record);\n\n    List<Field> fields = Lists.newArrayList();\n    for (Field field : record.getFields()) {\n      Optional<Schema> newFieldSchema = removeUncomparableFields(field.schema(), processed);\n      if (newFieldSchema.isPresent()) {\n        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));\n      }\n    }\n\n    Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getNamespace(), false);\n    newSchema.setFields(fields);\n    return Optional.of(newSchema);\n  }\n","realPath":"gobblin-utility/src/main/java/org/apache/gobblin/util/AvroUtils.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":540,"status":"B"},{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  public static Optional<Schema> getKeySchemaFromRecord(Schema record) {\n    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);\n\n    List<Field> fields = Lists.newArrayList();\n    for (Field field : record.getFields()) {\n      Optional<Schema> newFieldSchema = getKeySchema(field);\n      if (newFieldSchema.isPresent()) {\n        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));\n      }\n    }\n    if (!fields.isEmpty()) {\n      Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getName(), false);\n      newSchema.setFields(fields);\n      return Optional.of(newSchema);\n    } else {\n      return Optional.absent();\n    }\n  }\n","date":"2017-07-31 15:51:25","endLine":214,"groupId":"7085","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"getKeySchemaFromRecord","params":"(Schemarecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/00/b67425778085410026949fa315c8ea1c97a972.src","preCode":"  public static Optional<Schema> getKeySchemaFromRecord(Schema record) {\n    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);\n\n    List<Field> fields = Lists.newArrayList();\n    for (Field field : record.getFields()) {\n      Optional<Schema> newFieldSchema = getKeySchema(field);\n      if (newFieldSchema.isPresent()) {\n        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));\n      }\n    }\n    if (!fields.isEmpty()) {\n      Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getName(), false);\n      newSchema.setFields(fields);\n      return Optional.of(newSchema);\n    } else {\n      return Optional.absent();\n    }\n  }\n","realPath":"gobblin-compaction/src/main/java/org/apache/gobblin/compaction/mapreduce/avro/MRCompactorAvroKeyDedupJobRunner.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"B"}],"commitId":"5457af88d56b8fb89b172129fd1ff24ecdd4eba8","commitMessage":"@@@Merge pull request #2031 from abti/move_packages_to_apache\n","date":"2017-07-31 15:51:25","modifiedFileCount":"2","status":"B","submitter":"Abhishek Tiwari"},{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2019-05-09 00:49:53","commitOrder":2,"curCode":"  private static Optional<Schema> removeUncomparableFieldsFromRecord(Schema record, Map<Schema, Optional<Schema>> processed) {\n    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);\n\n    Optional<Schema> result = processed.get(record);\n    if (null != result) {\n      return result;\n    }\n\n    List<Field> fields = Lists.newArrayList();\n    for (Field field : record.getFields()) {\n      Optional<Schema> newFieldSchema = removeUncomparableFields(field.schema(), processed);\n      if (newFieldSchema.isPresent()) {\n        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));\n      }\n    }\n\n    Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getNamespace(), false);\n    newSchema.setFields(fields);\n    result = Optional.of(newSchema);\n    processed.put(record, result);\n\n    return result;\n  }\n","date":"2019-05-09 00:49:53","endLine":653,"groupId":"101030","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"removeUncomparableFieldsFromRecord","params":"(Schemarecord@Map<Schema@Optional<Schema>>processed)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/43/f03f79dd8a7e9841359911c5a6b7d5129eeb65.src","preCode":"  private static Optional<Schema> removeUncomparableFieldsFromRecord(Schema record, Set<Schema> processed) {\n    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);\n\n    if (processed.contains(record)) {\n      return Optional.absent();\n    }\n    processed.add(record);\n\n    List<Field> fields = Lists.newArrayList();\n    for (Field field : record.getFields()) {\n      Optional<Schema> newFieldSchema = removeUncomparableFields(field.schema(), processed);\n      if (newFieldSchema.isPresent()) {\n        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));\n      }\n    }\n\n    Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getNamespace(), false);\n    newSchema.setFields(fields);\n    return Optional.of(newSchema);\n  }\n","realPath":"gobblin-utility/src/main/java/org/apache/gobblin/util/AvroUtils.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":631,"status":"M"},{"authorDate":"2017-07-31 15:51:25","commitOrder":2,"curCode":"  public static Optional<Schema> getKeySchemaFromRecord(Schema record) {\n    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);\n\n    List<Field> fields = Lists.newArrayList();\n    for (Field field : record.getFields()) {\n      Optional<Schema> newFieldSchema = getKeySchema(field);\n      if (newFieldSchema.isPresent()) {\n        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));\n      }\n    }\n    if (!fields.isEmpty()) {\n      Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getName(), false);\n      newSchema.setFields(fields);\n      return Optional.of(newSchema);\n    } else {\n      return Optional.absent();\n    }\n  }\n","date":"2017-07-31 15:51:25","endLine":214,"groupId":"101030","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"getKeySchemaFromRecord","params":"(Schemarecord)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/00/b67425778085410026949fa315c8ea1c97a972.src","preCode":"  public static Optional<Schema> getKeySchemaFromRecord(Schema record) {\n    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);\n\n    List<Field> fields = Lists.newArrayList();\n    for (Field field : record.getFields()) {\n      Optional<Schema> newFieldSchema = getKeySchema(field);\n      if (newFieldSchema.isPresent()) {\n        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));\n      }\n    }\n    if (!fields.isEmpty()) {\n      Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getName(), false);\n      newSchema.setFields(fields);\n      return Optional.of(newSchema);\n    } else {\n      return Optional.absent();\n    }\n  }\n","realPath":"gobblin-compaction/src/main/java/org/apache/gobblin/compaction/mapreduce/avro/MRCompactorAvroKeyDedupJobRunner.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":197,"status":"N"}],"commitId":"8a9b5d0c803a95b4bfb9ac3135ee4e849ccdb27b","commitMessage":"@@@[GOBBLIN-763] Support fields removal for compaction dedup key schema\n\nCloses #2627 from zxcware/compact\n","date":"2019-05-09 00:49:53","modifiedFileCount":"3","status":"M","submitter":"zhchen"}]
