[{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId));\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId));\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","date":"2017-07-31 15:51:25","endLine":346,"groupId":"7908","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/5e/1a7311a75a23823cf001727f7f3797efec6989.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId));\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId));\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/BaseDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":291,"status":"B"},{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId));\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","date":"2017-07-31 15:51:25","endLine":59,"groupId":"1554","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/89/ecdf62a096047b35f30b9458920f162aa2ae09.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId));\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/TimestampDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"B"}],"commitId":"5457af88d56b8fb89b172129fd1ff24ecdd4eba8","commitMessage":"@@@Merge pull request #2031 from abti/move_packages_to_apache\n","date":"2017-07-31 15:51:25","modifiedFileCount":"2","status":"B","submitter":"Abhishek Tiwari"},{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2017-08-18 02:25:11","commitOrder":2,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId));\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          addPublisherLineageInfo(state, branchId, publisherOutputDir.toString());\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId));\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n      addPublisherLineageInfo(state, branchId, publisherOutputDir.toString());\n    }\n  }\n","date":"2017-08-18 02:25:11","endLine":352,"groupId":"0","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/19/314e5e32a436b71e09685af77290c2cbac18fc.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId));\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId));\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/BaseDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":295,"status":"M"},{"authorDate":"2017-07-31 15:51:25","commitOrder":2,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId));\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","date":"2017-07-31 15:51:25","endLine":59,"groupId":"1554","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/89/ecdf62a096047b35f30b9458920f162aa2ae09.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId));\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/TimestampDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"N"}],"commitId":"280b1d35edbb66ec9db19d852caa1b8ed43a34ac","commitMessage":"@@@[GOBBLIN-182] Add lineage event for query based source\n\nCloses #2034 from yukuai518/lineage2\n","date":"2017-08-18 02:25:11","modifiedFileCount":"4","status":"M","submitter":"Kuai Yu"},{"authorTime":"2017-09-08 10:34:48","codes":[{"authorDate":"2017-09-08 10:34:48","commitOrder":3,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          addPublisherLineageInfo(state, branchId, publisherOutputDir.toString());\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n      addPublisherLineageInfo(state, branchId, publisherOutputDir.toString());\n    }\n  }\n","date":"2017-09-08 10:34:48","endLine":392,"groupId":"2457","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/9b/dcbdd0a8f97e55b9507a5828317e13d17a8bbd.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId));\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          addPublisherLineageInfo(state, branchId, publisherOutputDir.toString());\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId));\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n      addPublisherLineageInfo(state, branchId, publisherOutputDir.toString());\n    }\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/BaseDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":335,"status":"M"},{"authorDate":"2017-09-08 10:34:48","commitOrder":3,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), this.retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","date":"2017-09-08 10:34:48","endLine":59,"groupId":"1554","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/36/bcd49ce0ad242ff2975c38f4f7dbf976c6bce1.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermission(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId));\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/TimestampDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"M"}],"commitId":"344d6d3c68b23ba451cabbf3bacb389e38e27f11","commitMessage":"@@@Merge pull request #1993 from treff7es/eventual_consistent_fs_support\n","date":"2017-09-08 10:34:48","modifiedFileCount":"14","status":"M","submitter":"Abhishek Tiwari"},{"authorTime":"2017-09-08 10:34:48","codes":[{"authorDate":"2017-11-14 06:15:51","commitOrder":4,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","date":"2017-11-14 06:15:51","endLine":399,"groupId":"2457","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/00/97c153d41e92e4c29b42cf8b28c8d8846a8ee5.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          addPublisherLineageInfo(state, branchId, publisherOutputDir.toString());\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n      addPublisherLineageInfo(state, branchId, publisherOutputDir.toString());\n    }\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/BaseDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"M"},{"authorDate":"2017-09-08 10:34:48","commitOrder":4,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), this.retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","date":"2017-09-08 10:34:48","endLine":59,"groupId":"1554","id":8,"instanceNumber":2,"isCurCommit":1,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/36/bcd49ce0ad242ff2975c38f4f7dbf976c6bce1.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), this.retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/TimestampDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"N"}],"commitId":"3e229db9810de8410e0b8fcaf680fcb9f80b5db2","commitMessage":"@@@[GOBBLIN-307] Implement lineage event as LineageEventBuilder in gobblin\n\nCloses #2161 from zxcware/lineage\n","date":"2017-11-14 06:15:51","modifiedFileCount":"18","status":"M","submitter":"zhchen"},{"authorTime":"2017-09-08 10:34:48","codes":[{"authorDate":"2021-07-20 04:29:32","commitOrder":5,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      if(this.publisherOutputDirOwnerGroupByBranches.get(branchId).isPresent()) {\n        LOG.info(String.format(\"Setting path %s group to %s\", publisherOutputDir.toString(), this.publisherOutputDirOwnerGroupByBranches.get(branchId).get()));\n        HadoopUtils.setGroup(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir, this.publisherOutputDirOwnerGroupByBranches.get(branchId).get());\n      }\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n        if(this.publisherOutputDirOwnerGroupByBranches.get(branchId).isPresent()) {\n          LOG.info(String.format(\"Setting path %s group to %s\", publisherOutputDir.toString(), this.publisherOutputDirOwnerGroupByBranches.get(branchId).get()));\n          HadoopUtils.setGroup(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir, this.publisherOutputDirOwnerGroupByBranches.get(branchId).get());\n        }\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","date":"2021-07-20 04:29:32","endLine":444,"groupId":"121381","id":9,"instanceNumber":1,"isCurCommit":1,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/56/d7270ff835c841386ff46e021db85e255d3af4.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/BaseDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":381,"status":"M"},{"authorDate":"2017-09-08 10:34:48","commitOrder":5,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), this.retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","date":"2017-09-08 10:34:48","endLine":59,"groupId":"121381","id":10,"instanceNumber":2,"isCurCommit":1,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/36/bcd49ce0ad242ff2975c38f4f7dbf976c6bce1.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), this.retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/TimestampDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":51,"status":"N"}],"commitId":"07e76fc8205beeceb935594f3816c832614a474d","commitMessage":"@@@[GOBBLIN-1488] Added option to set perm group at table level (#3334)\n\nThis option will allow us to set permissions for publisher output.  on table level.\n\nThe publisher output directory can be one of the following:\n* data.publisher.final.dir ( if data.publisher.appendExtractToFinalDir is set to false)\n* data.publisher.final.dir/db/table ( if data.publisher.appendExtractToFinalDir is set to true and writer.file.path.type = namespace_table)\n* data.publisher.final.dir/table ( if data.publisher.appendExtractToFinalDir is set to true and writer.file.path.type = tablename)\n*and a default\n\nDeprecated data.publisher.final.dir.group since it is set incorrectly.","date":"2021-07-20 04:29:32","modifiedFileCount":"2","status":"M","submitter":"vbohra"}]
