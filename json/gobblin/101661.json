[{"authorTime":"2018-09-01 00:08:48","codes":[{"authorDate":"2018-09-01 00:08:48","commitOrder":1,"curCode":"  public void testGetFilesAtPath() throws IOException {\n    String datePattern = \"yyyy/MM/dd/HH\";\n    DateTimeFormatter formatter = DateTimeFormat.forPattern(datePattern);\n\n    LocalDateTime endDate = LocalDateTime.now();\n\n    Set<String> candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_HOURS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n\n    PathFilter pathFilter = new HiddenFilter();\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    List<FileStatus> fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_HOURS + 1);\n\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n    candidateFiles = new HashSet<>();\n    datePattern = \"yyyy/MM/dd/HH\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      if (i < NUM_DAYS_HOURS_DIRS + 1) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    Assert.assertEquals(fileStatusList.size(), NUM_DAYS_HOURS_DIRS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    datePattern = \"yyyy/MM/dd\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n    endDate = LocalDateTime.now();\n\n    candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_DAILY_DIRS; i++) {\n      String startDate = endDate.minusDays(i).toString(formatter);\n      Path subDirPath = new Path(baseDir2, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_DAYS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir2, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_DAYS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n  }\n","date":"2018-09-01 00:08:48","endLine":170,"groupId":"6197","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testGetFilesAtPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/f2/ed2cb6f1fb7b830b49f74c0dfb746b7387dc28.src","preCode":"  public void testGetFilesAtPath() throws IOException {\n    String datePattern = \"yyyy/MM/dd/HH\";\n    DateTimeFormatter formatter = DateTimeFormat.forPattern(datePattern);\n\n    LocalDateTime endDate = LocalDateTime.now();\n\n    Set<String> candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_HOURS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n\n    PathFilter pathFilter = new HiddenFilter();\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    List<FileStatus> fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_HOURS + 1);\n\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n    candidateFiles = new HashSet<>();\n    datePattern = \"yyyy/MM/dd/HH\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      if (i < NUM_DAYS_HOURS_DIRS + 1) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    Assert.assertEquals(fileStatusList.size(), NUM_DAYS_HOURS_DIRS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    datePattern = \"yyyy/MM/dd\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n    endDate = LocalDateTime.now();\n\n    candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_DAILY_DIRS; i++) {\n      String startDate = endDate.minusDays(i).toString(formatter);\n      Path subDirPath = new Path(baseDir2, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_DAYS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir2, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_DAYS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/TimeAwareRecursiveCopyableDatasetTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":82,"status":"B"},{"authorDate":"2018-09-01 00:08:48","commitOrder":1,"curCode":"  public void testInstantiationError() {\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n  }\n","date":"2018-09-01 00:08:48","endLine":181,"groupId":"1413","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testInstantiationError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/f2/ed2cb6f1fb7b830b49f74c0dfb746b7387dc28.src","preCode":"  public void testInstantiationError() {\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/TimeAwareRecursiveCopyableDatasetTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"B"}],"commitId":"ef438c872625704b39014741a110f54901c7dfab","commitMessage":"@@@[GOBBLIN-573] Add option to use finer level granularity at the hour level for TimeAwareDatasetfinder\n\nCloses #2438 from sv2000/hourly\n","date":"2018-09-01 00:08:48","modifiedFileCount":"2","status":"B","submitter":"sv2000"},{"authorTime":"2018-09-01 00:08:48","codes":[{"authorDate":"2018-11-16 06:58:27","commitOrder":2,"curCode":"  public void testGetFilesAtPath() throws IOException {\n    String datePattern = \"yyyy/MM/dd/HH\";\n    DateTimeFormatter formatter = DateTimeFormat.forPattern(datePattern);\n\n    LocalDateTime endDate = LocalDateTime.now(DateTimeZone.forID(TimeAwareRecursiveCopyableDataset.DEFAULT_DATE_PATTERN_TIMEZONE));\n\n    Set<String> candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_HOURS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n\n    PathFilter pathFilter = new HiddenFilter();\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    List<FileStatus> fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_HOURS + 1);\n\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n    candidateFiles = new HashSet<>();\n    datePattern = \"yyyy/MM/dd/HH\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      if (i < NUM_DAYS_HOURS_DIRS + 1) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    Assert.assertEquals(fileStatusList.size(), NUM_DAYS_HOURS_DIRS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    datePattern = \"yyyy/MM/dd\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n    endDate = LocalDateTime.now(DateTimeZone.forID(TimeAwareRecursiveCopyableDataset.DEFAULT_DATE_PATTERN_TIMEZONE));\n\n    candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_DAILY_DIRS; i++) {\n      String startDate = endDate.minusDays(i).toString(formatter);\n      Path subDirPath = new Path(baseDir2, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_DAYS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir2, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_DAYS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n  }\n","date":"2018-11-16 06:58:27","endLine":171,"groupId":"6197","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testGetFilesAtPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/1c/eb906d328e21b9cf79a8e647e787121b144aa5.src","preCode":"  public void testGetFilesAtPath() throws IOException {\n    String datePattern = \"yyyy/MM/dd/HH\";\n    DateTimeFormatter formatter = DateTimeFormat.forPattern(datePattern);\n\n    LocalDateTime endDate = LocalDateTime.now();\n\n    Set<String> candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_HOURS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n\n    PathFilter pathFilter = new HiddenFilter();\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    List<FileStatus> fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_HOURS + 1);\n\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n    candidateFiles = new HashSet<>();\n    datePattern = \"yyyy/MM/dd/HH\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      if (i < NUM_DAYS_HOURS_DIRS + 1) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    Assert.assertEquals(fileStatusList.size(), NUM_DAYS_HOURS_DIRS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    datePattern = \"yyyy/MM/dd\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n    endDate = LocalDateTime.now();\n\n    candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_DAILY_DIRS; i++) {\n      String startDate = endDate.minusDays(i).toString(formatter);\n      Path subDirPath = new Path(baseDir2, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_DAYS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir2, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_DAYS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/TimeAwareRecursiveCopyableDatasetTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":83,"status":"M"},{"authorDate":"2018-09-01 00:08:48","commitOrder":2,"curCode":"  public void testInstantiationError() {\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n  }\n","date":"2018-09-01 00:08:48","endLine":181,"groupId":"1413","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testInstantiationError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/f2/ed2cb6f1fb7b830b49f74c0dfb746b7387dc28.src","preCode":"  public void testInstantiationError() {\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/TimeAwareRecursiveCopyableDatasetTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":173,"status":"N"}],"commitId":"f00266f06aa0fd762ee4d93cafd6b3f84780e373","commitMessage":"@@@[GOBBLIN-631] Add option to use timezone for TimeAwareDatasetFinder\n\nCloses #2501 from amarnathkarthik/master\n","date":"2018-11-16 06:58:27","modifiedFileCount":"2","status":"M","submitter":"Karthik Amarnath"},{"authorTime":"2019-10-03 07:24:46","codes":[{"authorDate":"2019-10-03 07:24:46","commitOrder":3,"curCode":"  public void testGetFilesAtPath() throws IOException {\n    String datePattern = \"yyyy/MM/dd/HH\";\n    DateTimeFormatter formatter = DateTimeFormat.forPattern(datePattern);\n\n    LocalDateTime endDate = LocalDateTime.now(DateTimeZone.forID(TimeAwareRecursiveCopyableDataset.DEFAULT_DATE_PATTERN_TIMEZONE));\n\n    Set<String> candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_HOURS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n\n    PathFilter pathFilter = new HiddenFilter();\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    List<FileStatus> fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_HOURS + 1);\n\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n    candidateFiles = new HashSet<>();\n    datePattern = \"yyyy/MM/dd/HH\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      if (i < NUM_DAYS_HOURS_DIRS + 1) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    Assert.assertEquals(fileStatusList.size(), NUM_DAYS_HOURS_DIRS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    datePattern = \"yyyy/MM/dd\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n    endDate = LocalDateTime.now(DateTimeZone.forID(TimeAwareRecursiveCopyableDataset.DEFAULT_DATE_PATTERN_TIMEZONE));\n\n    candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_DAILY_DIRS; i++) {\n      String startDate = endDate.minusDays(i).toString(formatter);\n      Path subDirPath = new Path(baseDir2, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_DAYS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir2, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_DAYS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    datePattern = \"yyyy-MM-dd-HH-mm\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n    endDate = LocalDateTime.now(DateTimeZone.forID(TimeAwareRecursiveCopyableDataset.DEFAULT_DATE_PATTERN_TIMEZONE));\n\n    Random random = new Random();\n\n    candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_DAILY_DIRS; i++) {\n      String startDate = endDate.minusDays(i).withMinuteOfHour(random.nextInt(60)).toString(formatter);\n      if (i == 0) {\n        \r\n        startDate = endDate.minusHours(i).withMinuteOfHour(0).toString(formatter);\n      }\n      Path subDirPath = new Path(baseDir3, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_DAYS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, \"2d1h\");\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy-MM-dd-HH-mm\");\n\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir3, properties,\n        new Path(\"/tmp/src/ds2/daily\"));\n\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir3, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_DAYS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n  }\n","date":"2019-10-03 07:24:46","endLine":219,"groupId":"101661","id":5,"instanceNumber":1,"isCurCommit":1,"methodName":"testGetFilesAtPath","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/b6/84936bb67aecf5f4790ac6cd23015b072a4179.src","preCode":"  public void testGetFilesAtPath() throws IOException {\n    String datePattern = \"yyyy/MM/dd/HH\";\n    DateTimeFormatter formatter = DateTimeFormat.forPattern(datePattern);\n\n    LocalDateTime endDate = LocalDateTime.now(DateTimeZone.forID(TimeAwareRecursiveCopyableDataset.DEFAULT_DATE_PATTERN_TIMEZONE));\n\n    Set<String> candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_HOURS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n\n    PathFilter pathFilter = new HiddenFilter();\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    List<FileStatus> fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_HOURS + 1);\n\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd/HH\");\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir1, properties,\n        new Path(\"/tmp/src/*/hourly\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir1, pathFilter);\n    candidateFiles = new HashSet<>();\n    datePattern = \"yyyy/MM/dd/HH\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n\n    for (int i = 0; i < MAX_NUM_HOURLY_DIRS; i++) {\n      String startDate = endDate.minusHours(i).toString(formatter);\n      Path subDirPath = new Path(baseDir1, new Path(startDate));\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      if (i < NUM_DAYS_HOURS_DIRS + 1) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    Assert.assertEquals(fileStatusList.size(), NUM_DAYS_HOURS_DIRS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n\n    \r\n    datePattern = \"yyyy/MM/dd\";\n    formatter = DateTimeFormat.forPattern(datePattern);\n    endDate = LocalDateTime.now(DateTimeZone.forID(TimeAwareRecursiveCopyableDataset.DEFAULT_DATE_PATTERN_TIMEZONE));\n\n    candidateFiles = new HashSet<>();\n    for (int i = 0; i < MAX_NUM_DAILY_DIRS; i++) {\n      String startDate = endDate.minusDays(i).toString(formatter);\n      Path subDirPath = new Path(baseDir2, new Path(startDate));\n      fs.mkdirs(subDirPath);\n      Path filePath = new Path(subDirPath, i + \".avro\");\n      fs.create(filePath);\n      if (i < (NUM_LOOKBACK_DAYS + 1)) {\n        candidateFiles.add(filePath.toString());\n      }\n    }\n\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n    fileStatusList = dataset.getFilesAtPath(fs, baseDir2, pathFilter);\n\n    Assert.assertEquals(fileStatusList.size(), NUM_LOOKBACK_DAYS + 1);\n    for (FileStatus fileStatus: fileStatusList) {\n      Assert.assertTrue(candidateFiles.contains(PathUtils.getPathWithoutSchemeAndAuthority(fileStatus.getPath()).toString()));\n    }\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/TimeAwareRecursiveCopyableDatasetTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":93,"status":"M"},{"authorDate":"2019-10-03 07:24:46","commitOrder":3,"curCode":"  public void testInstantiationError() {\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n\n    \r\n    properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_HOURS_MINS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy-MM-dd-HH\");\n\n    dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir3, properties,\n        new Path(\"/tmp/src/ds2/daily\"));\n\n  }\n","date":"2019-10-03 07:24:46","endLine":239,"groupId":"101661","id":6,"instanceNumber":2,"isCurCommit":1,"methodName":"testInstantiationError","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/b6/84936bb67aecf5f4790ac6cd23015b072a4179.src","preCode":"  public void testInstantiationError() {\n    \r\n    Properties properties = new Properties();\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.LOOKBACK_TIME_KEY, NUM_LOOKBACK_DAYS_HOURS_STR);\n    properties.setProperty(TimeAwareRecursiveCopyableDataset.DATE_PATTERN_KEY, \"yyyy/MM/dd\");\n\n    TimeAwareRecursiveCopyableDataset dataset = new TimeAwareRecursiveCopyableDataset(fs, baseDir2, properties,\n        new Path(\"/tmp/src/*/daily\"));\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/TimeAwareRecursiveCopyableDatasetTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":222,"status":"M"}],"commitId":"5b8af8cf6e932e8031ef060c79260a4a8f47974c","commitMessage":"@@@[GOBBLIN-888] Make yyyy-MM-dd-HH-mm recognizable in TimeAwareRecursiveCopyableDataset\n\nCloses #2744 from linweihs/time2\n","date":"2019-10-03 07:24:46","modifiedFileCount":"3","status":"M","submitter":"welin"}]
