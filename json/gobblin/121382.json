[{"authorTime":"2021-02-02 08:20:38","codes":[{"authorDate":"2017-11-14 06:15:51","commitOrder":5,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","date":"2017-11-14 06:15:51","endLine":399,"groupId":"2457","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/00/97c153d41e92e4c29b42cf8b28c8d8846a8ee5.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/BaseDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":344,"status":"NB"},{"authorDate":"2021-02-02 08:20:38","commitOrder":5,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      log.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      \r\n      \r\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","date":"2021-02-02 08:20:38","endLine":84,"groupId":"1554","id":2,"instanceNumber":2,"isCurCommit":1,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/37/9cd143d154546d34e386887bddc996a30f0d87.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      log.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      \r\n      \r\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/TimePartitionedStreamingDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"B"}],"commitId":"edd718e8a562632046f5831c0e4b6b93e22ba0e7","commitMessage":"@@@[GOBBLIN-1336] Implement a streaming version of TimePartitionedDataPub?\n\nGOBBLIN-1336: Implement a streaming version of\nTimePartitionedDataPublisher\n\nIntroduce a config key for final dataset publish\nlocation\n\nCloses #3173 from sv2000/streamingDataPublisher\n","date":"2021-02-02 08:20:38","modifiedFileCount":"1","status":"M","submitter":"suvasude"},{"authorTime":"2021-02-02 08:20:38","codes":[{"authorDate":"2021-07-20 04:29:32","commitOrder":6,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      if(this.publisherOutputDirOwnerGroupByBranches.get(branchId).isPresent()) {\n        LOG.info(String.format(\"Setting path %s group to %s\", publisherOutputDir.toString(), this.publisherOutputDirOwnerGroupByBranches.get(branchId).get()));\n        HadoopUtils.setGroup(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir, this.publisherOutputDirOwnerGroupByBranches.get(branchId).get());\n      }\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n        if(this.publisherOutputDirOwnerGroupByBranches.get(branchId).isPresent()) {\n          LOG.info(String.format(\"Setting path %s group to %s\", publisherOutputDir.toString(), this.publisherOutputDirOwnerGroupByBranches.get(branchId).get()));\n          HadoopUtils.setGroup(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir, this.publisherOutputDirOwnerGroupByBranches.get(branchId).get());\n        }\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","date":"2021-07-20 04:29:32","endLine":444,"groupId":"121382","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/56/d7270ff835c841386ff46e021db85e255d3af4.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved)\n      throws IOException {\n    \r\n    ParallelRunner parallelRunner = this.getParallelRunner(this.writerFileSystemByBranches.get(branchId));\n\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      LOG.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (publishSingleTaskData) {\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId), publisherOutputDir,\n          this.permissions.get(branchId), retrierConfig);\n      addSingleTaskWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n    } else {\n      if (writerOutputPathsMoved.contains(writerOutputDir)) {\n        \r\n        \r\n        return;\n      }\n\n      if (this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n        \r\n        \r\n        boolean replaceFinalOutputDir = this.getState().getPropAsBoolean(ForkOperatorUtils\n            .getPropertyNameForBranch(ConfigurationKeys.DATA_PUBLISHER_REPLACE_FINAL_DIR, this.numBranches, branchId));\n\n        \r\n        if (!replaceFinalOutputDir) {\n          addWriterOutputToExistingDir(writerOutputDir, publisherOutputDir, state, branchId, parallelRunner);\n          writerOutputPathsMoved.add(writerOutputDir);\n          return;\n        }\n\n        \r\n        LOG.info(\"Deleting publisher output dir \" + publisherOutputDir);\n        this.publisherFileSystemByBranches.get(branchId).delete(publisherOutputDir, true);\n      } else {\n        \r\n        WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n            publisherOutputDir.getParent(), this.permissions.get(branchId), retrierConfig);\n      }\n\n      movePath(parallelRunner, state, writerOutputDir, publisherOutputDir, branchId);\n      writerOutputPathsMoved.add(writerOutputDir);\n    }\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/BaseDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":381,"status":"M"},{"authorDate":"2021-02-02 08:20:38","commitOrder":6,"curCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      log.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      \r\n      \r\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","date":"2021-02-02 08:20:38","endLine":84,"groupId":"121382","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"publishData","params":"(WorkUnitStatestate@intbranchId@booleanpublishSingleTaskData@Set<Path>writerOutputPathsMoved)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/37/9cd143d154546d34e386887bddc996a30f0d87.src","preCode":"  protected void publishData(WorkUnitState state, int branchId, boolean publishSingleTaskData,\n      Set<Path> writerOutputPathsMoved) throws IOException {\n    \r\n    Path writerOutputDir = WriterUtils.getWriterOutputDir(state, this.numBranches, branchId);\n\n    if (!this.writerFileSystemByBranches.get(branchId).exists(writerOutputDir)) {\n      log.warn(String.format(\"Branch %d of WorkUnit %s produced no data\", branchId, state.getId()));\n      return;\n    }\n    \r\n    \r\n    Path publisherOutputDir = getPublisherOutputDir(state, branchId);\n\n    if (!this.publisherFileSystemByBranches.get(branchId).exists(publisherOutputDir)) {\n      \r\n      \r\n      \r\n      WriterUtils.mkdirsWithRecursivePermissionWithRetry(this.publisherFileSystemByBranches.get(branchId),\n          publisherOutputDir, this.permissions.get(branchId), retrierConfig);\n    }\n    super.publishData(state, branchId, publishSingleTaskData, writerOutputPathsMoved);\n  }\n","realPath":"gobblin-core/src/main/java/org/apache/gobblin/publisher/TimePartitionedStreamingDataPublisher.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":63,"status":"N"}],"commitId":"07e76fc8205beeceb935594f3816c832614a474d","commitMessage":"@@@[GOBBLIN-1488] Added option to set perm group at table level (#3334)\n\nThis option will allow us to set permissions for publisher output.  on table level.\n\nThe publisher output directory can be one of the following:\n* data.publisher.final.dir ( if data.publisher.appendExtractToFinalDir is set to false)\n* data.publisher.final.dir/db/table ( if data.publisher.appendExtractToFinalDir is set to true and writer.file.path.type = namespace_table)\n* data.publisher.final.dir/table ( if data.publisher.appendExtractToFinalDir is set to true and writer.file.path.type = tablename)\n*and a default\n\nDeprecated data.publisher.final.dir.group since it is set incorrectly.","date":"2021-07-20 04:29:32","modifiedFileCount":"2","status":"M","submitter":"vbohra"}]
