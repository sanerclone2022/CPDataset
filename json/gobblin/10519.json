[{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  private CommandOutput<?, ?> executeSql(List<Command> cmds) {\n    String query = null;\n    int fetchSize = 0;\n\n    for (Command cmd : cmds) {\n      if (cmd instanceof JdbcCommand) {\n        JdbcCommandType type = (JdbcCommandType) cmd.getCommandType();\n        switch (type) {\n          case QUERY:\n            query = cmd.getParams().get(0);\n            break;\n          case FETCHSIZE:\n            fetchSize = Integer.parseInt(cmd.getParams().get(0));\n            break;\n          default:\n            this.log.error(\"Command \" + type.toString() + \" not recognized\");\n            break;\n        }\n      }\n    }\n\n    this.log.info(\"Executing query:\" + query);\n    ResultSet resultSet = null;\n    try {\n      this.jdbcSource = createJdbcSource();\n      this.dataConnection = this.jdbcSource.getConnection();\n      Statement statement = this.dataConnection.createStatement();\n\n      if (fetchSize != 0 && this.getExpectedRecordCount() > 2000) {\n        statement.setFetchSize(fetchSize);\n      }\n      final boolean status = statement.execute(query);\n      if (status == false) {\n        this.log.error(\"Failed to execute sql:\" + query);\n      }\n      resultSet = statement.getResultSet();\n    } catch (Exception e) {\n      this.log.error(\"Failed to execute sql:\" + query + \" ;error-\" + e.getMessage(), e);\n    }\n\n    CommandOutput<JdbcCommand, ResultSet> output = new JdbcCommandOutput();\n    output.put((JdbcCommand) cmds.get(0), resultSet);\n    return output;\n  }\n","date":"2017-07-31 15:51:25","endLine":672,"groupId":"6078","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"executeSql","params":"(List<Command>cmds)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/94/f087ca6146a852da70713632f0b9d5a3e3a40f.src","preCode":"  private CommandOutput<?, ?> executeSql(List<Command> cmds) {\n    String query = null;\n    int fetchSize = 0;\n\n    for (Command cmd : cmds) {\n      if (cmd instanceof JdbcCommand) {\n        JdbcCommandType type = (JdbcCommandType) cmd.getCommandType();\n        switch (type) {\n          case QUERY:\n            query = cmd.getParams().get(0);\n            break;\n          case FETCHSIZE:\n            fetchSize = Integer.parseInt(cmd.getParams().get(0));\n            break;\n          default:\n            this.log.error(\"Command \" + type.toString() + \" not recognized\");\n            break;\n        }\n      }\n    }\n\n    this.log.info(\"Executing query:\" + query);\n    ResultSet resultSet = null;\n    try {\n      this.jdbcSource = createJdbcSource();\n      this.dataConnection = this.jdbcSource.getConnection();\n      Statement statement = this.dataConnection.createStatement();\n\n      if (fetchSize != 0 && this.getExpectedRecordCount() > 2000) {\n        statement.setFetchSize(fetchSize);\n      }\n      final boolean status = statement.execute(query);\n      if (status == false) {\n        this.log.error(\"Failed to execute sql:\" + query);\n      }\n      resultSet = statement.getResultSet();\n    } catch (Exception e) {\n      this.log.error(\"Failed to execute sql:\" + query + \" ;error-\" + e.getMessage(), e);\n    }\n\n    CommandOutput<JdbcCommand, ResultSet> output = new JdbcCommandOutput();\n    output.put((JdbcCommand) cmds.get(0), resultSet);\n    return output;\n  }\n","realPath":"gobblin-modules/gobblin-sql/src/main/java/org/apache/gobblin/source/jdbc/JdbcExtractor.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":629,"status":"B"},{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  private CommandOutput<?, ?> executePreparedSql(List<Command> cmds) {\n    String query = null;\n    List<String> queryParameters = null;\n    int fetchSize = 0;\n\n    for (Command cmd : cmds) {\n      if (cmd instanceof JdbcCommand) {\n        JdbcCommandType type = (JdbcCommandType) cmd.getCommandType();\n        switch (type) {\n          case QUERY:\n            query = cmd.getParams().get(0);\n            break;\n          case QUERYPARAMS:\n            queryParameters = cmd.getParams();\n            break;\n          case FETCHSIZE:\n            fetchSize = Integer.parseInt(cmd.getParams().get(0));\n            break;\n          default:\n            this.log.error(\"Command \" + type.toString() + \" not recognized\");\n            break;\n        }\n      }\n    }\n\n    this.log.info(\"Executing query:\" + query);\n    ResultSet resultSet = null;\n    try {\n      this.jdbcSource = createJdbcSource();\n      this.dataConnection = this.jdbcSource.getConnection();\n\n      PreparedStatement statement =\n          this.dataConnection.prepareStatement(query, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n\n      int parameterPosition = 1;\n      if (queryParameters != null && queryParameters.size() > 0) {\n        for (String parameter : queryParameters) {\n          statement.setString(parameterPosition, parameter);\n          parameterPosition++;\n        }\n      }\n      if (fetchSize != 0) {\n        statement.setFetchSize(fetchSize);\n      }\n      final boolean status = statement.execute();\n      if (status == false) {\n        this.log.error(\"Failed to execute sql:\" + query);\n      }\n      resultSet = statement.getResultSet();\n\n    } catch (Exception e) {\n      this.log.error(\"Failed to execute sql:\" + query + \" ;error-\" + e.getMessage(), e);\n    }\n\n    CommandOutput<JdbcCommand, ResultSet> output = new JdbcCommandOutput();\n    output.put((JdbcCommand) cmds.get(0), resultSet);\n    return output;\n  }\n","date":"2017-07-31 15:51:25","endLine":739,"groupId":"4267","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"executePreparedSql","params":"(List<Command>cmds)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/94/f087ca6146a852da70713632f0b9d5a3e3a40f.src","preCode":"  private CommandOutput<?, ?> executePreparedSql(List<Command> cmds) {\n    String query = null;\n    List<String> queryParameters = null;\n    int fetchSize = 0;\n\n    for (Command cmd : cmds) {\n      if (cmd instanceof JdbcCommand) {\n        JdbcCommandType type = (JdbcCommandType) cmd.getCommandType();\n        switch (type) {\n          case QUERY:\n            query = cmd.getParams().get(0);\n            break;\n          case QUERYPARAMS:\n            queryParameters = cmd.getParams();\n            break;\n          case FETCHSIZE:\n            fetchSize = Integer.parseInt(cmd.getParams().get(0));\n            break;\n          default:\n            this.log.error(\"Command \" + type.toString() + \" not recognized\");\n            break;\n        }\n      }\n    }\n\n    this.log.info(\"Executing query:\" + query);\n    ResultSet resultSet = null;\n    try {\n      this.jdbcSource = createJdbcSource();\n      this.dataConnection = this.jdbcSource.getConnection();\n\n      PreparedStatement statement =\n          this.dataConnection.prepareStatement(query, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n\n      int parameterPosition = 1;\n      if (queryParameters != null && queryParameters.size() > 0) {\n        for (String parameter : queryParameters) {\n          statement.setString(parameterPosition, parameter);\n          parameterPosition++;\n        }\n      }\n      if (fetchSize != 0) {\n        statement.setFetchSize(fetchSize);\n      }\n      final boolean status = statement.execute();\n      if (status == false) {\n        this.log.error(\"Failed to execute sql:\" + query);\n      }\n      resultSet = statement.getResultSet();\n\n    } catch (Exception e) {\n      this.log.error(\"Failed to execute sql:\" + query + \" ;error-\" + e.getMessage(), e);\n    }\n\n    CommandOutput<JdbcCommand, ResultSet> output = new JdbcCommandOutput();\n    output.put((JdbcCommand) cmds.get(0), resultSet);\n    return output;\n  }\n","realPath":"gobblin-modules/gobblin-sql/src/main/java/org/apache/gobblin/source/jdbc/JdbcExtractor.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":682,"status":"B"}],"commitId":"5457af88d56b8fb89b172129fd1ff24ecdd4eba8","commitMessage":"@@@Merge pull request #2031 from abti/move_packages_to_apache\n","date":"2017-07-31 15:51:25","modifiedFileCount":"2","status":"B","submitter":"Abhishek Tiwari"},{"authorTime":"2018-08-03 04:11:03","codes":[{"authorDate":"2018-08-03 04:11:03","commitOrder":2,"curCode":"  private CommandOutput<?, ?> executeSql(List<Command> cmds) {\n    String query = null;\n    int fetchSize = 0;\n\n    for (Command cmd : cmds) {\n      if (cmd instanceof JdbcCommand) {\n        JdbcCommandType type = (JdbcCommandType) cmd.getCommandType();\n        switch (type) {\n          case QUERY:\n            query = cmd.getParams().get(0);\n            break;\n          case FETCHSIZE:\n            fetchSize = Integer.parseInt(cmd.getParams().get(0));\n            break;\n          default:\n            this.log.error(\"Command \" + type.toString() + \" not recognized\");\n            break;\n        }\n      }\n    }\n\n    this.log.info(\"Executing query:\" + query);\n    ResultSet resultSet = null;\n    try {\n      this.jdbcSource = createJdbcSource();\n      if (this.dataConnection == null) {\n        this.dataConnection = this.jdbcSource.getConnection();\n      }\n      Statement statement = this.dataConnection.createStatement();\n\n      if (fetchSize != 0 && this.getExpectedRecordCount() > 2000) {\n        statement.setFetchSize(fetchSize);\n      }\n      final boolean status = statement.execute(query);\n      if (status == false) {\n        this.log.error(\"Failed to execute sql:\" + query);\n      }\n      resultSet = statement.getResultSet();\n    } catch (Exception e) {\n      this.log.error(\"Failed to execute sql:\" + query + \" ;error-\" + e.getMessage(), e);\n    }\n\n    CommandOutput<JdbcCommand, ResultSet> output = new JdbcCommandOutput();\n    output.put((JdbcCommand) cmds.get(0), resultSet);\n    return output;\n  }\n","date":"2018-08-03 04:11:37","endLine":678,"groupId":"10519","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"executeSql","params":"(List<Command>cmds)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/f6/eb79ee4fe9f759ad5e7ff1835146d6ef6be809.src","preCode":"  private CommandOutput<?, ?> executeSql(List<Command> cmds) {\n    String query = null;\n    int fetchSize = 0;\n\n    for (Command cmd : cmds) {\n      if (cmd instanceof JdbcCommand) {\n        JdbcCommandType type = (JdbcCommandType) cmd.getCommandType();\n        switch (type) {\n          case QUERY:\n            query = cmd.getParams().get(0);\n            break;\n          case FETCHSIZE:\n            fetchSize = Integer.parseInt(cmd.getParams().get(0));\n            break;\n          default:\n            this.log.error(\"Command \" + type.toString() + \" not recognized\");\n            break;\n        }\n      }\n    }\n\n    this.log.info(\"Executing query:\" + query);\n    ResultSet resultSet = null;\n    try {\n      this.jdbcSource = createJdbcSource();\n      this.dataConnection = this.jdbcSource.getConnection();\n      Statement statement = this.dataConnection.createStatement();\n\n      if (fetchSize != 0 && this.getExpectedRecordCount() > 2000) {\n        statement.setFetchSize(fetchSize);\n      }\n      final boolean status = statement.execute(query);\n      if (status == false) {\n        this.log.error(\"Failed to execute sql:\" + query);\n      }\n      resultSet = statement.getResultSet();\n    } catch (Exception e) {\n      this.log.error(\"Failed to execute sql:\" + query + \" ;error-\" + e.getMessage(), e);\n    }\n\n    CommandOutput<JdbcCommand, ResultSet> output = new JdbcCommandOutput();\n    output.put((JdbcCommand) cmds.get(0), resultSet);\n    return output;\n  }\n","realPath":"gobblin-modules/gobblin-sql/src/main/java/org/apache/gobblin/source/jdbc/JdbcExtractor.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":633,"status":"M"},{"authorDate":"2018-08-03 04:11:03","commitOrder":2,"curCode":"  private CommandOutput<?, ?> executePreparedSql(List<Command> cmds) {\n    String query = null;\n    List<String> queryParameters = null;\n    int fetchSize = 0;\n\n    for (Command cmd : cmds) {\n      if (cmd instanceof JdbcCommand) {\n        JdbcCommandType type = (JdbcCommandType) cmd.getCommandType();\n        switch (type) {\n          case QUERY:\n            query = cmd.getParams().get(0);\n            break;\n          case QUERYPARAMS:\n            queryParameters = cmd.getParams();\n            break;\n          case FETCHSIZE:\n            fetchSize = Integer.parseInt(cmd.getParams().get(0));\n            break;\n          default:\n            this.log.error(\"Command \" + type.toString() + \" not recognized\");\n            break;\n        }\n      }\n    }\n\n    this.log.info(\"Executing query:\" + query);\n    ResultSet resultSet = null;\n    try {\n      this.jdbcSource = createJdbcSource();\n      if (this.dataConnection == null) {\n        this.dataConnection = this.jdbcSource.getConnection();\n      }\n\n      PreparedStatement statement =\n          this.dataConnection.prepareStatement(query, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n\n      int parameterPosition = 1;\n      if (queryParameters != null && queryParameters.size() > 0) {\n        for (String parameter : queryParameters) {\n          statement.setString(parameterPosition, parameter);\n          parameterPosition++;\n        }\n      }\n      if (fetchSize != 0) {\n        statement.setFetchSize(fetchSize);\n      }\n      final boolean status = statement.execute();\n      if (status == false) {\n        this.log.error(\"Failed to execute sql:\" + query);\n      }\n      resultSet = statement.getResultSet();\n\n    } catch (Exception e) {\n      this.log.error(\"Failed to execute sql:\" + query + \" ;error-\" + e.getMessage(), e);\n    }\n\n    CommandOutput<JdbcCommand, ResultSet> output = new JdbcCommandOutput();\n    output.put((JdbcCommand) cmds.get(0), resultSet);\n    return output;\n  }\n","date":"2018-08-03 04:11:37","endLine":747,"groupId":"10519","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"executePreparedSql","params":"(List<Command>cmds)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/f6/eb79ee4fe9f759ad5e7ff1835146d6ef6be809.src","preCode":"  private CommandOutput<?, ?> executePreparedSql(List<Command> cmds) {\n    String query = null;\n    List<String> queryParameters = null;\n    int fetchSize = 0;\n\n    for (Command cmd : cmds) {\n      if (cmd instanceof JdbcCommand) {\n        JdbcCommandType type = (JdbcCommandType) cmd.getCommandType();\n        switch (type) {\n          case QUERY:\n            query = cmd.getParams().get(0);\n            break;\n          case QUERYPARAMS:\n            queryParameters = cmd.getParams();\n            break;\n          case FETCHSIZE:\n            fetchSize = Integer.parseInt(cmd.getParams().get(0));\n            break;\n          default:\n            this.log.error(\"Command \" + type.toString() + \" not recognized\");\n            break;\n        }\n      }\n    }\n\n    this.log.info(\"Executing query:\" + query);\n    ResultSet resultSet = null;\n    try {\n      this.jdbcSource = createJdbcSource();\n      this.dataConnection = this.jdbcSource.getConnection();\n\n      PreparedStatement statement =\n          this.dataConnection.prepareStatement(query, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);\n\n      int parameterPosition = 1;\n      if (queryParameters != null && queryParameters.size() > 0) {\n        for (String parameter : queryParameters) {\n          statement.setString(parameterPosition, parameter);\n          parameterPosition++;\n        }\n      }\n      if (fetchSize != 0) {\n        statement.setFetchSize(fetchSize);\n      }\n      final boolean status = statement.execute();\n      if (status == false) {\n        this.log.error(\"Failed to execute sql:\" + query);\n      }\n      resultSet = statement.getResultSet();\n\n    } catch (Exception e) {\n      this.log.error(\"Failed to execute sql:\" + query + \" ;error-\" + e.getMessage(), e);\n    }\n\n    CommandOutput<JdbcCommand, ResultSet> output = new JdbcCommandOutput();\n    output.put((JdbcCommand) cmds.get(0), resultSet);\n    return output;\n  }\n","realPath":"gobblin-modules/gobblin-sql/src/main/java/org/apache/gobblin/source/jdbc/JdbcExtractor.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":688,"status":"M"}],"commitId":"b9a774a827ab9b929c7d9e66516ae06cee4022f3","commitMessage":"@@@[GOBBLIN-551] Fixed re-using data connection in executeSql and execute?\n\nCloses #2412 from mvachhani/master\n","date":"2018-08-03 04:11:37","modifiedFileCount":"1","status":"M","submitter":"Monish Vachhani"}]
