[{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  public void test1to1() throws Exception {\n    MyAsyncConverter1to1 converter = new MyAsyncConverter1to1();\n\n    List<Throwable> errors = Lists.newArrayList();\n    AtomicBoolean done = new AtomicBoolean(false);\n\n    WorkUnitState workUnitState = new WorkUnitState();\n    workUnitState.setProp(AsyncConverter1to1.MAX_CONCURRENT_ASYNC_CONVERSIONS_KEY, 3);\n\n    RecordStreamWithMetadata<String, String> stream =\n        new RecordStreamWithMetadata<>(Flowable.range(0, 5).map(i -> i.toString()).map(RecordEnvelope::new), \"schema\");\n\n    Set<String> outputRecords = Sets.newConcurrentHashSet();\n\n    converter.processStream(stream, workUnitState).getRecordStream().subscribeOn(Schedulers.newThread())\n        .subscribe(r -> outputRecords.add(((RecordEnvelope<String>)r).getRecord()), errors::add, () -> done.set(true));\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"0\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"0\")).await());\n    Assert.assertEquals(outputRecords.size(), 1);\n\n    \r\n    Assert.assertFalse(\n        ExponentialBackoff.awaitCondition().maxWait(200L).callable(() -> converter.completeFutureIfPresent(\"4\")).await());\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"3\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"3\")).await());\n    \r\n    Assert.assertEquals(outputRecords.size(), 2);\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"4\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"4\")).await());\n    Assert.assertEquals(outputRecords.size(), 3);\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"1\")).await());\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"2\")).await());\n\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.size() == 5).await());\n    Assert.assertEquals(outputRecords, Sets.newHashSet(\"0\", \"1\", \"2\", \"3\", \"4\"));\n\n    Assert.assertTrue(errors.isEmpty());\n    Assert.assertTrue(done.get());\n  }\n","date":"2017-07-31 15:51:25","endLine":96,"groupId":"213","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"test1to1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/01/ec3b408bd64a1885d1c20735fdecd5146eb056.src","preCode":"  public void test1to1() throws Exception {\n    MyAsyncConverter1to1 converter = new MyAsyncConverter1to1();\n\n    List<Throwable> errors = Lists.newArrayList();\n    AtomicBoolean done = new AtomicBoolean(false);\n\n    WorkUnitState workUnitState = new WorkUnitState();\n    workUnitState.setProp(AsyncConverter1to1.MAX_CONCURRENT_ASYNC_CONVERSIONS_KEY, 3);\n\n    RecordStreamWithMetadata<String, String> stream =\n        new RecordStreamWithMetadata<>(Flowable.range(0, 5).map(i -> i.toString()).map(RecordEnvelope::new), \"schema\");\n\n    Set<String> outputRecords = Sets.newConcurrentHashSet();\n\n    converter.processStream(stream, workUnitState).getRecordStream().subscribeOn(Schedulers.newThread())\n        .subscribe(r -> outputRecords.add(((RecordEnvelope<String>)r).getRecord()), errors::add, () -> done.set(true));\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"0\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"0\")).await());\n    Assert.assertEquals(outputRecords.size(), 1);\n\n    \r\n    Assert.assertFalse(\n        ExponentialBackoff.awaitCondition().maxWait(200L).callable(() -> converter.completeFutureIfPresent(\"4\")).await());\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"3\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"3\")).await());\n    \r\n    Assert.assertEquals(outputRecords.size(), 2);\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"4\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"4\")).await());\n    Assert.assertEquals(outputRecords.size(), 3);\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"1\")).await());\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"2\")).await());\n\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.size() == 5).await());\n    Assert.assertEquals(outputRecords, Sets.newHashSet(\"0\", \"1\", \"2\", \"3\", \"4\"));\n\n    Assert.assertTrue(errors.isEmpty());\n    Assert.assertTrue(done.get());\n  }\n","realPath":"gobblin-core-base/src/test/java/org/apache/gobblin/converter/AsyncConverter1to1Test.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"B"},{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  public void testFailedConversion() throws Exception {\n    MyAsyncConverter1to1 converter = new MyAsyncConverter1to1();\n\n    List<Throwable> errors = Lists.newArrayList();\n    AtomicBoolean done = new AtomicBoolean(false);\n\n    WorkUnitState workUnitState = new WorkUnitState();\n    workUnitState.setProp(AsyncConverter1to1.MAX_CONCURRENT_ASYNC_CONVERSIONS_KEY, 3);\n\n    RecordStreamWithMetadata<String, String> stream =\n        new RecordStreamWithMetadata<>(Flowable.just(\"0\", MyAsyncConverter1to1.FAIL, \"1\").map(RecordEnvelope::new), \"schema\");\n\n    Set<String> outputRecords = Sets.newConcurrentHashSet();\n\n    converter.processStream(stream, workUnitState).getRecordStream().subscribeOn(Schedulers.newThread())\n        .subscribe(r -> outputRecords.add(((RecordEnvelope<String>)r).getRecord()), errors::add, () -> done.set(true));\n\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> errors.size() > 0).await());\n\n    Assert.assertEquals(errors.size(), 1);\n    Assert.assertEquals(errors.get(0).getCause().getMessage(), \"injected failure\");\n  }\n","date":"2017-07-31 15:51:25","endLine":120,"groupId":"3317","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFailedConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/01/ec3b408bd64a1885d1c20735fdecd5146eb056.src","preCode":"  public void testFailedConversion() throws Exception {\n    MyAsyncConverter1to1 converter = new MyAsyncConverter1to1();\n\n    List<Throwable> errors = Lists.newArrayList();\n    AtomicBoolean done = new AtomicBoolean(false);\n\n    WorkUnitState workUnitState = new WorkUnitState();\n    workUnitState.setProp(AsyncConverter1to1.MAX_CONCURRENT_ASYNC_CONVERSIONS_KEY, 3);\n\n    RecordStreamWithMetadata<String, String> stream =\n        new RecordStreamWithMetadata<>(Flowable.just(\"0\", MyAsyncConverter1to1.FAIL, \"1\").map(RecordEnvelope::new), \"schema\");\n\n    Set<String> outputRecords = Sets.newConcurrentHashSet();\n\n    converter.processStream(stream, workUnitState).getRecordStream().subscribeOn(Schedulers.newThread())\n        .subscribe(r -> outputRecords.add(((RecordEnvelope<String>)r).getRecord()), errors::add, () -> done.set(true));\n\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> errors.size() > 0).await());\n\n    Assert.assertEquals(errors.size(), 1);\n    Assert.assertEquals(errors.get(0).getCause().getMessage(), \"injected failure\");\n  }\n","realPath":"gobblin-core-base/src/test/java/org/apache/gobblin/converter/AsyncConverter1to1Test.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":99,"status":"B"}],"commitId":"5457af88d56b8fb89b172129fd1ff24ecdd4eba8","commitMessage":"@@@Merge pull request #2031 from abti/move_packages_to_apache\n","date":"2017-07-31 15:51:25","modifiedFileCount":"2","status":"B","submitter":"Abhishek Tiwari"},{"authorTime":"2017-09-15 03:54:23","codes":[{"authorDate":"2017-09-15 03:54:23","commitOrder":2,"curCode":"  public void test1to1() throws Exception {\n    MyAsyncConverter1to1 converter = new MyAsyncConverter1to1();\n\n    List<Throwable> errors = Lists.newArrayList();\n    AtomicBoolean done = new AtomicBoolean(false);\n\n    WorkUnitState workUnitState = new WorkUnitState();\n    workUnitState.setProp(AsyncConverter1to1.MAX_CONCURRENT_ASYNC_CONVERSIONS_KEY, 3);\n\n    RecordStreamWithMetadata<String, String> stream =\n        new RecordStreamWithMetadata<>(Flowable.range(0, 5).map(i -> i.toString()).map(RecordEnvelope::new),\n            GlobalMetadata.<String>builder().schema(\"schema\").build());\n\n    Set<String> outputRecords = Sets.newConcurrentHashSet();\n\n    converter.processStream(stream, workUnitState).getRecordStream().subscribeOn(Schedulers.newThread())\n        .subscribe(r -> outputRecords.add(((RecordEnvelope<String>)r).getRecord()), errors::add, () -> done.set(true));\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"0\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"0\")).await());\n    Assert.assertEquals(outputRecords.size(), 1);\n\n    \r\n    Assert.assertFalse(\n        ExponentialBackoff.awaitCondition().maxWait(200L).callable(() -> converter.completeFutureIfPresent(\"4\")).await());\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"3\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"3\")).await());\n    \r\n    Assert.assertEquals(outputRecords.size(), 2);\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"4\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"4\")).await());\n    Assert.assertEquals(outputRecords.size(), 3);\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"1\")).await());\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"2\")).await());\n\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.size() == 5).await());\n    Assert.assertEquals(outputRecords, Sets.newHashSet(\"0\", \"1\", \"2\", \"3\", \"4\"));\n\n    Assert.assertTrue(errors.isEmpty());\n    Assert.assertTrue(done.get());\n  }\n","date":"2017-09-15 03:54:23","endLine":98,"groupId":"1070","id":3,"instanceNumber":1,"isCurCommit":1,"methodName":"test1to1","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/77/ae3ab8b3b704b929a1866734bf205fe812654f.src","preCode":"  public void test1to1() throws Exception {\n    MyAsyncConverter1to1 converter = new MyAsyncConverter1to1();\n\n    List<Throwable> errors = Lists.newArrayList();\n    AtomicBoolean done = new AtomicBoolean(false);\n\n    WorkUnitState workUnitState = new WorkUnitState();\n    workUnitState.setProp(AsyncConverter1to1.MAX_CONCURRENT_ASYNC_CONVERSIONS_KEY, 3);\n\n    RecordStreamWithMetadata<String, String> stream =\n        new RecordStreamWithMetadata<>(Flowable.range(0, 5).map(i -> i.toString()).map(RecordEnvelope::new), \"schema\");\n\n    Set<String> outputRecords = Sets.newConcurrentHashSet();\n\n    converter.processStream(stream, workUnitState).getRecordStream().subscribeOn(Schedulers.newThread())\n        .subscribe(r -> outputRecords.add(((RecordEnvelope<String>)r).getRecord()), errors::add, () -> done.set(true));\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"0\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"0\")).await());\n    Assert.assertEquals(outputRecords.size(), 1);\n\n    \r\n    Assert.assertFalse(\n        ExponentialBackoff.awaitCondition().maxWait(200L).callable(() -> converter.completeFutureIfPresent(\"4\")).await());\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"3\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"3\")).await());\n    \r\n    Assert.assertEquals(outputRecords.size(), 2);\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"4\")).await());\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.contains(\"4\")).await());\n    Assert.assertEquals(outputRecords.size(), 3);\n\n    \r\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"1\")).await());\n    Assert.assertTrue(\n        ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> converter.completeFutureIfPresent(\"2\")).await());\n\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> outputRecords.size() == 5).await());\n    Assert.assertEquals(outputRecords, Sets.newHashSet(\"0\", \"1\", \"2\", \"3\", \"4\"));\n\n    Assert.assertTrue(errors.isEmpty());\n    Assert.assertTrue(done.get());\n  }\n","realPath":"gobblin-core-base/src/test/java/org/apache/gobblin/converter/AsyncConverter1to1Test.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2017-09-15 03:54:23","commitOrder":2,"curCode":"  public void testFailedConversion() throws Exception {\n    MyAsyncConverter1to1 converter = new MyAsyncConverter1to1();\n\n    List<Throwable> errors = Lists.newArrayList();\n    AtomicBoolean done = new AtomicBoolean(false);\n\n    WorkUnitState workUnitState = new WorkUnitState();\n    workUnitState.setProp(AsyncConverter1to1.MAX_CONCURRENT_ASYNC_CONVERSIONS_KEY, 3);\n\n    RecordStreamWithMetadata<String, String> stream =\n        new RecordStreamWithMetadata<>(Flowable.just(\"0\", MyAsyncConverter1to1.FAIL, \"1\").map(RecordEnvelope::new),\n            GlobalMetadata.<String>builder().schema(\"schema\").build());\n\n    Set<String> outputRecords = Sets.newConcurrentHashSet();\n\n    converter.processStream(stream, workUnitState).getRecordStream().subscribeOn(Schedulers.newThread())\n        .subscribe(r -> outputRecords.add(((RecordEnvelope<String>)r).getRecord()), errors::add, () -> done.set(true));\n\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> errors.size() > 0).await());\n\n    Assert.assertEquals(errors.size(), 1);\n    Assert.assertEquals(errors.get(0).getCause().getMessage(), \"injected failure\");\n  }\n","date":"2017-09-15 03:54:23","endLine":123,"groupId":"1070","id":4,"instanceNumber":2,"isCurCommit":1,"methodName":"testFailedConversion","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/77/ae3ab8b3b704b929a1866734bf205fe812654f.src","preCode":"  public void testFailedConversion() throws Exception {\n    MyAsyncConverter1to1 converter = new MyAsyncConverter1to1();\n\n    List<Throwable> errors = Lists.newArrayList();\n    AtomicBoolean done = new AtomicBoolean(false);\n\n    WorkUnitState workUnitState = new WorkUnitState();\n    workUnitState.setProp(AsyncConverter1to1.MAX_CONCURRENT_ASYNC_CONVERSIONS_KEY, 3);\n\n    RecordStreamWithMetadata<String, String> stream =\n        new RecordStreamWithMetadata<>(Flowable.just(\"0\", MyAsyncConverter1to1.FAIL, \"1\").map(RecordEnvelope::new), \"schema\");\n\n    Set<String> outputRecords = Sets.newConcurrentHashSet();\n\n    converter.processStream(stream, workUnitState).getRecordStream().subscribeOn(Schedulers.newThread())\n        .subscribe(r -> outputRecords.add(((RecordEnvelope<String>)r).getRecord()), errors::add, () -> done.set(true));\n\n    Assert.assertTrue(ExponentialBackoff.awaitCondition().maxWait(100L).callable(() -> errors.size() > 0).await());\n\n    Assert.assertEquals(errors.size(), 1);\n    Assert.assertEquals(errors.get(0).getCause().getMessage(), \"injected failure\");\n  }\n","realPath":"gobblin-core-base/src/test/java/org/apache/gobblin/converter/AsyncConverter1to1Test.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":101,"status":"M"}],"commitId":"3a035737f72ce2bffbbe58beac2044b3b46da992","commitMessage":"@@@[GOBBLIN-236] Add a ControlMessage injector as a RecordStreamProcessor\n\nCloses #2090 from htran1/control_message_injection\n","date":"2017-09-15 03:54:23","modifiedFileCount":"14","status":"M","submitter":"Hung Tran"}]
