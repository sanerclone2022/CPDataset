[{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"   public RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        long startTimeNanos = 0;\n\n        if (isInstrumentationEnabled()) {\n          startTimeNanos = System.nanoTime();\n          beforeRead();\n        }\n\n        StreamEntity<D> record = readStreamEntityImpl();\n\n        if (isInstrumentationEnabled()) {\n          D unwrappedRecord = null;\n\n          if (record instanceof RecordEnvelope) {\n            unwrappedRecord = ((RecordEnvelope<D>) record).getRecord();\n          }\n\n          afterRead(unwrappedRecord, startTimeNanos);\n        }\n\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        if (isInstrumentationEnabled()) {\n          onException(exc);\n        }\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, schema);\n  }\n","date":"2017-07-31 15:51:25","endLine":194,"groupId":"7341","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"recordStream","params":"(AtomicBooleanshutdownRequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/35/de7121b3f3d283cc6cc1d4520855ccc68b552a.src","preCode":"   public RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        long startTimeNanos = 0;\n\n        if (isInstrumentationEnabled()) {\n          startTimeNanos = System.nanoTime();\n          beforeRead();\n        }\n\n        StreamEntity<D> record = readStreamEntityImpl();\n\n        if (isInstrumentationEnabled()) {\n          D unwrappedRecord = null;\n\n          if (record instanceof RecordEnvelope) {\n            unwrappedRecord = ((RecordEnvelope<D>) record).getRecord();\n          }\n\n          afterRead(unwrappedRecord, startTimeNanos);\n        }\n\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        if (isInstrumentationEnabled()) {\n          onException(exc);\n        }\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, schema);\n  }\n","realPath":"gobblin-core-base/src/main/java/org/apache/gobblin/instrumented/extractor/InstrumentedExtractorBase.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":154,"status":"B"},{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  default RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        StreamEntity<D> record = readStreamEntity();\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, schema);\n  }\n","date":"2017-07-31 15:51:25","endLine":132,"groupId":"1556","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"recordStream","params":"(AtomicBooleanshutdownRequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/22/b16709ccf2726ef8892b8ce0719b0570f5805e.src","preCode":"  default RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        StreamEntity<D> record = readStreamEntity();\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, schema);\n  }\n","realPath":"gobblin-api/src/main/java/org/apache/gobblin/source/extractor/Extractor.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":113,"status":"B"}],"commitId":"5457af88d56b8fb89b172129fd1ff24ecdd4eba8","commitMessage":"@@@Merge pull request #2031 from abti/move_packages_to_apache\n","date":"2017-07-31 15:51:25","modifiedFileCount":"2","status":"B","submitter":"Abhishek Tiwari"},{"authorTime":"2017-09-15 03:54:23","codes":[{"authorDate":"2017-09-15 03:54:23","commitOrder":2,"curCode":"   public RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        long startTimeNanos = 0;\n\n        if (isInstrumentationEnabled()) {\n          startTimeNanos = System.nanoTime();\n          beforeRead();\n        }\n\n        StreamEntity<D> record = readStreamEntityImpl();\n\n        if (isInstrumentationEnabled()) {\n          D unwrappedRecord = null;\n\n          if (record instanceof RecordEnvelope) {\n            unwrappedRecord = ((RecordEnvelope<D>) record).getRecord();\n          }\n\n          afterRead(unwrappedRecord, startTimeNanos);\n        }\n\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        if (isInstrumentationEnabled()) {\n          onException(exc);\n        }\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n\n  }\n","date":"2017-09-15 03:54:23","endLine":196,"groupId":"7341","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"recordStream","params":"(AtomicBooleanshutdownRequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/1d/cb1d1b1240d78d9df7f4a033d0592163cb4578.src","preCode":"   public RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        long startTimeNanos = 0;\n\n        if (isInstrumentationEnabled()) {\n          startTimeNanos = System.nanoTime();\n          beforeRead();\n        }\n\n        StreamEntity<D> record = readStreamEntityImpl();\n\n        if (isInstrumentationEnabled()) {\n          D unwrappedRecord = null;\n\n          if (record instanceof RecordEnvelope) {\n            unwrappedRecord = ((RecordEnvelope<D>) record).getRecord();\n          }\n\n          afterRead(unwrappedRecord, startTimeNanos);\n        }\n\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        if (isInstrumentationEnabled()) {\n          onException(exc);\n        }\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, schema);\n  }\n","realPath":"gobblin-core-base/src/main/java/org/apache/gobblin/instrumented/extractor/InstrumentedExtractorBase.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"M"},{"authorDate":"2017-09-15 03:54:23","commitOrder":2,"curCode":"  default RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        StreamEntity<D> record = readStreamEntity();\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n  }\n","date":"2017-09-15 03:54:23","endLine":133,"groupId":"1556","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"recordStream","params":"(AtomicBooleanshutdownRequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/97/49795fbcc153c7774a122f73d2782382599a1f.src","preCode":"  default RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        StreamEntity<D> record = readStreamEntity();\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, schema);\n  }\n","realPath":"gobblin-api/src/main/java/org/apache/gobblin/source/extractor/Extractor.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":114,"status":"M"}],"commitId":"3a035737f72ce2bffbbe58beac2044b3b46da992","commitMessage":"@@@[GOBBLIN-236] Add a ControlMessage injector as a RecordStreamProcessor\n\nCloses #2090 from htran1/control_message_injection\n","date":"2017-09-15 03:54:23","modifiedFileCount":"14","status":"M","submitter":"Hung Tran"},{"authorTime":"2019-03-05 02:08:31","codes":[{"authorDate":"2017-09-15 03:54:23","commitOrder":3,"curCode":"   public RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        long startTimeNanos = 0;\n\n        if (isInstrumentationEnabled()) {\n          startTimeNanos = System.nanoTime();\n          beforeRead();\n        }\n\n        StreamEntity<D> record = readStreamEntityImpl();\n\n        if (isInstrumentationEnabled()) {\n          D unwrappedRecord = null;\n\n          if (record instanceof RecordEnvelope) {\n            unwrappedRecord = ((RecordEnvelope<D>) record).getRecord();\n          }\n\n          afterRead(unwrappedRecord, startTimeNanos);\n        }\n\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        if (isInstrumentationEnabled()) {\n          onException(exc);\n        }\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n\n  }\n","date":"2017-09-15 03:54:23","endLine":196,"groupId":"7341","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"recordStream","params":"(AtomicBooleanshutdownRequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/1d/cb1d1b1240d78d9df7f4a033d0592163cb4578.src","preCode":"   public RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        long startTimeNanos = 0;\n\n        if (isInstrumentationEnabled()) {\n          startTimeNanos = System.nanoTime();\n          beforeRead();\n        }\n\n        StreamEntity<D> record = readStreamEntityImpl();\n\n        if (isInstrumentationEnabled()) {\n          D unwrappedRecord = null;\n\n          if (record instanceof RecordEnvelope) {\n            unwrappedRecord = ((RecordEnvelope<D>) record).getRecord();\n          }\n\n          afterRead(unwrappedRecord, startTimeNanos);\n        }\n\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        if (isInstrumentationEnabled()) {\n          onException(exc);\n        }\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n\n  }\n","realPath":"gobblin-core-base/src/main/java/org/apache/gobblin/instrumented/extractor/InstrumentedExtractorBase.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":155,"status":"N"},{"authorDate":"2019-03-05 02:08:31","commitOrder":3,"curCode":"  default RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        \r\n        try {\n          shutdown();\n        } catch (JobShutdownException exc) {\n          emitter.onError(exc);\n        }\n      }\n      try {\n        StreamEntity<D> record = readStreamEntity();\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n  }\n","date":"2019-03-05 02:08:31","endLine":156,"groupId":"4279","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"recordStream","params":"(AtomicBooleanshutdownRequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/2e/a900b3b1c10463328b80a59f16eb88f592194f.src","preCode":"  default RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        StreamEntity<D> record = readStreamEntity();\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n  }\n","realPath":"gobblin-api/src/main/java/org/apache/gobblin/source/extractor/Extractor.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"M"}],"commitId":"9e95bd32d6115175b532dbbd9f7e73bae8059c02","commitMessage":"@@@[GOBBLIN-677] Allow early termination of Gobblin jobs based on a predicate on the job progress\n\nCloses #2548 from ibuenros/early-termination-2\n","date":"2019-03-05 02:08:31","modifiedFileCount":"12","status":"M","submitter":"ibuenros"},{"authorTime":"2019-03-05 02:08:31","codes":[{"authorDate":"2021-01-07 03:32:48","commitOrder":4,"curCode":"   public RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        \r\n        try {\n          shutdown();\n        } catch (JobShutdownException exc) {\n          emitter.onError(exc);\n        }\n      }\n      try {\n        long startTimeNanos = 0;\n\n        if (isInstrumentationEnabled()) {\n          startTimeNanos = System.nanoTime();\n          beforeRead();\n        }\n\n        StreamEntity<D> record = readStreamEntityImpl();\n\n        if (isInstrumentationEnabled()) {\n          D unwrappedRecord = null;\n\n          if (record instanceof RecordEnvelope) {\n            unwrappedRecord = ((RecordEnvelope<D>) record).getRecord();\n          }\n\n          afterRead(unwrappedRecord, startTimeNanos);\n        }\n\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        if (isInstrumentationEnabled()) {\n          onException(exc);\n        }\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n\n  }\n","date":"2021-01-07 03:32:48","endLine":202,"groupId":"1085","id":7,"instanceNumber":1,"isCurCommit":1,"methodName":"recordStream","params":"(AtomicBooleanshutdownRequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/b9/51bfc91ce49c7530d1a2a2e6c7846bb7266737.src","preCode":"   public RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        emitter.onComplete();\n      }\n      try {\n        long startTimeNanos = 0;\n\n        if (isInstrumentationEnabled()) {\n          startTimeNanos = System.nanoTime();\n          beforeRead();\n        }\n\n        StreamEntity<D> record = readStreamEntityImpl();\n\n        if (isInstrumentationEnabled()) {\n          D unwrappedRecord = null;\n\n          if (record instanceof RecordEnvelope) {\n            unwrappedRecord = ((RecordEnvelope<D>) record).getRecord();\n          }\n\n          afterRead(unwrappedRecord, startTimeNanos);\n        }\n\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        if (isInstrumentationEnabled()) {\n          onException(exc);\n        }\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n\n  }\n","realPath":"gobblin-core-base/src/main/java/org/apache/gobblin/instrumented/extractor/InstrumentedExtractorBase.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"},{"authorDate":"2019-03-05 02:08:31","commitOrder":4,"curCode":"  default RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        \r\n        try {\n          shutdown();\n        } catch (JobShutdownException exc) {\n          emitter.onError(exc);\n        }\n      }\n      try {\n        StreamEntity<D> record = readStreamEntity();\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n  }\n","date":"2019-03-05 02:08:31","endLine":156,"groupId":"1085","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"recordStream","params":"(AtomicBooleanshutdownRequest)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/2e/a900b3b1c10463328b80a59f16eb88f592194f.src","preCode":"  default RecordStreamWithMetadata<D, S> recordStream(AtomicBoolean shutdownRequest) throws IOException {\n    S schema = getSchema();\n    Flowable<StreamEntity<D>> recordStream = Flowable.generate(() -> shutdownRequest, (BiConsumer<AtomicBoolean, Emitter<StreamEntity<D>>>) (state, emitter) -> {\n      if (state.get()) {\n        \r\n        try {\n          shutdown();\n        } catch (JobShutdownException exc) {\n          emitter.onError(exc);\n        }\n      }\n      try {\n        StreamEntity<D> record = readStreamEntity();\n        if (record != null) {\n          emitter.onNext(record);\n        } else {\n          emitter.onComplete();\n        }\n      } catch (DataRecordException | IOException exc) {\n        emitter.onError(exc);\n      }\n    });\n    recordStream = recordStream.doFinally(this::close);\n    return new RecordStreamWithMetadata<>(recordStream, GlobalMetadata.<S>builder().schema(schema).build());\n  }\n","realPath":"gobblin-api/src/main/java/org/apache/gobblin/source/extractor/Extractor.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":132,"status":"N"}],"commitId":"2ee8d1f5d85030df786ca56e214e7782c3c1a4ab","commitMessage":"@@@[GOBBLIN-1351] Ensure KafkaStreamingExtractor shutdown is invoked on task shutdown[]\n\nCloses #3190 from sv2000/taskCancel\n","date":"2021-01-07 03:32:48","modifiedFileCount":"2","status":"M","submitter":"suvasude"}]
