[{"authorTime":"2017-07-31 15:51:25","codes":[{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  public void testFullPathDiffWithUnmanagedPathsWithoutDeletePolicy() throws Exception {\n\n    Map<Path, FileStatus> sourceMap = Maps.newHashMap();\n    Map<Path, FileStatus> targetDesiredMap = Maps.newHashMap();\n    List<Path> expectedFilesToCopy = Lists.newArrayList();\n    List<Path> expectedFilesToSkipCopy = Lists.newArrayList();\n    List<Path> expectedFilesToDelete = Lists.newArrayList();\n    List<Path> expectedFilesToSkipDelete = Lists.newArrayList();\n\n    populateSourceAndTargetEntities(sourceMap, targetDesiredMap, expectedFilesToCopy,\n        expectedFilesToSkipCopy, expectedFilesToDelete, expectedFilesToSkipDelete);\n\n    \r\n    Path path6 = new Path(\"path6\");\n    Path targetPath6 = new Path(targetRoot, path6);\n    Map<Path, FileStatus> targetDesiredMapWithExtraFile = Maps.newHashMap(targetDesiredMap);\n    targetDesiredMapWithExtraFile.put(targetPath6, getFileStatus(targetPath6, 0, 10));\n    expectedFilesToDelete.add(targetPath6);\n\n    TestLocationDescriptor sourceLocation = new TestLocationDescriptor(sourceMap);\n    TestLocationDescriptor targetDesiredLocation = new TestLocationDescriptor(targetDesiredMapWithExtraFile);\n    TestLocationDescriptor existingTargetLocation = new TestLocationDescriptor(Maps.newHashMap(targetDesiredMap));\n\n    Table table = Mockito.mock(Table.class);\n    HiveDataset hiveDataset = Mockito.mock(HiveDataset.class);\n    MultiTimingEvent timer = Mockito.mock(MultiTimingEvent.class);\n    HiveCopyEntityHelper helper = Mockito.mock(HiveCopyEntityHelper.class);\n    HiveTargetPathHelper targetPathHelper = Mockito.mock(HiveTargetPathHelper.class);\n    Mockito.when(helper.getDataset()).thenReturn(hiveDataset);\n    Mockito.when(hiveDataset.getTable()).thenReturn(table);\n    Mockito.when(table.getCompleteName()).thenReturn(\"table1\");\n    Mockito.when(targetPathHelper\n        .getTargetPath(Mockito.any(Path.class), Mockito.any(FileSystem.class), Mockito.any(Optional.class),\n            Mockito.anyBoolean())).then(new Answer<Path>() {\n      @Override\n      public Path answer(InvocationOnMock invocation)\n          throws Throwable {\n        Path path = (Path) invocation.getArguments()[0];\n        return new Path(path.toString().replace(sourceRoot.toString(), targetRoot.toString()));\n      }\n    });\n    Mockito.when(helper.getTargetPathHelper()).thenReturn(targetPathHelper);\n\n    \r\n    Mockito.when(helper.getUnmanagedDataPolicy()).thenReturn(HiveCopyEntityHelper.UnmanagedDataPolicy.ABORT);\n\n    \r\n    try {\n      HiveCopyEntityHelper.DiffPathSet diff =\n          HiveCopyEntityHelper.fullPathDiff(sourceLocation, targetDesiredLocation,\n              Optional.<HiveLocationDescriptor>of(existingTargetLocation), Optional.<Partition>absent(), timer, helper);\n      Assert.fail(\"Expected an IOException but did not receive any\");\n    } catch (IOException ex) {\n      \r\n      String expectedExceptionMessage = \"New table / partition would pick up existing, undesired files in target file \"\n          + \"system. table1, files [/target/path6].\";\n      Assert.assertEquals(ex.getMessage(), expectedExceptionMessage);\n    }\n  }\n","date":"2017-07-31 15:51:25","endLine":173,"groupId":"956","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testFullPathDiffWithUnmanagedPathsWithoutDeletePolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/2f/252cc67feb3ffb3f2301c2716d53e941dd3235.src","preCode":"  public void testFullPathDiffWithUnmanagedPathsWithoutDeletePolicy() throws Exception {\n\n    Map<Path, FileStatus> sourceMap = Maps.newHashMap();\n    Map<Path, FileStatus> targetDesiredMap = Maps.newHashMap();\n    List<Path> expectedFilesToCopy = Lists.newArrayList();\n    List<Path> expectedFilesToSkipCopy = Lists.newArrayList();\n    List<Path> expectedFilesToDelete = Lists.newArrayList();\n    List<Path> expectedFilesToSkipDelete = Lists.newArrayList();\n\n    populateSourceAndTargetEntities(sourceMap, targetDesiredMap, expectedFilesToCopy,\n        expectedFilesToSkipCopy, expectedFilesToDelete, expectedFilesToSkipDelete);\n\n    \r\n    Path path6 = new Path(\"path6\");\n    Path targetPath6 = new Path(targetRoot, path6);\n    Map<Path, FileStatus> targetDesiredMapWithExtraFile = Maps.newHashMap(targetDesiredMap);\n    targetDesiredMapWithExtraFile.put(targetPath6, getFileStatus(targetPath6, 0, 10));\n    expectedFilesToDelete.add(targetPath6);\n\n    TestLocationDescriptor sourceLocation = new TestLocationDescriptor(sourceMap);\n    TestLocationDescriptor targetDesiredLocation = new TestLocationDescriptor(targetDesiredMapWithExtraFile);\n    TestLocationDescriptor existingTargetLocation = new TestLocationDescriptor(Maps.newHashMap(targetDesiredMap));\n\n    Table table = Mockito.mock(Table.class);\n    HiveDataset hiveDataset = Mockito.mock(HiveDataset.class);\n    MultiTimingEvent timer = Mockito.mock(MultiTimingEvent.class);\n    HiveCopyEntityHelper helper = Mockito.mock(HiveCopyEntityHelper.class);\n    HiveTargetPathHelper targetPathHelper = Mockito.mock(HiveTargetPathHelper.class);\n    Mockito.when(helper.getDataset()).thenReturn(hiveDataset);\n    Mockito.when(hiveDataset.getTable()).thenReturn(table);\n    Mockito.when(table.getCompleteName()).thenReturn(\"table1\");\n    Mockito.when(targetPathHelper\n        .getTargetPath(Mockito.any(Path.class), Mockito.any(FileSystem.class), Mockito.any(Optional.class),\n            Mockito.anyBoolean())).then(new Answer<Path>() {\n      @Override\n      public Path answer(InvocationOnMock invocation)\n          throws Throwable {\n        Path path = (Path) invocation.getArguments()[0];\n        return new Path(path.toString().replace(sourceRoot.toString(), targetRoot.toString()));\n      }\n    });\n    Mockito.when(helper.getTargetPathHelper()).thenReturn(targetPathHelper);\n\n    \r\n    Mockito.when(helper.getUnmanagedDataPolicy()).thenReturn(HiveCopyEntityHelper.UnmanagedDataPolicy.ABORT);\n\n    \r\n    try {\n      HiveCopyEntityHelper.DiffPathSet diff =\n          HiveCopyEntityHelper.fullPathDiff(sourceLocation, targetDesiredLocation,\n              Optional.<HiveLocationDescriptor>of(existingTargetLocation), Optional.<Partition>absent(), timer, helper);\n      Assert.fail(\"Expected an IOException but did not receive any\");\n    } catch (IOException ex) {\n      \r\n      String expectedExceptionMessage = \"New table / partition would pick up existing, undesired files in target file \"\n          + \"system. table1, files [/target/path6].\";\n      Assert.assertEquals(ex.getMessage(), expectedExceptionMessage);\n    }\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/hive/HiveCopyEntityHelperTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":115,"status":"B"},{"authorDate":"2017-07-31 15:51:25","commitOrder":1,"curCode":"  public void testFullPathDiffWithUnmanagedPathsWithDeletePolicy() throws Exception {\n\n    Map<Path, FileStatus> sourceMap = Maps.newHashMap();\n    Map<Path, FileStatus> targetDesiredMap = Maps.newHashMap();\n    List<Path> expectedFilesToCopy = Lists.newArrayList();\n    List<Path> expectedFilesToSkipCopy = Lists.newArrayList();\n    List<Path> expectedFilesToDelete = Lists.newArrayList();\n    List<Path> expectedFilesToSkipDelete = Lists.newArrayList();\n\n    populateSourceAndTargetEntities(sourceMap, targetDesiredMap, expectedFilesToCopy,\n        expectedFilesToSkipCopy, expectedFilesToDelete, expectedFilesToSkipDelete);\n\n    \r\n    Path path6 = new Path(\"path6\");\n    Path targetPath6 = new Path(targetRoot, path6);\n    Map<Path, FileStatus> targetDesiredMapWithExtraFile = Maps.newHashMap(targetDesiredMap);\n    targetDesiredMapWithExtraFile.put(targetPath6, getFileStatus(targetPath6, 0, 10));\n    expectedFilesToDelete.add(targetPath6);\n\n    TestLocationDescriptor sourceLocation = new TestLocationDescriptor(sourceMap);\n    TestLocationDescriptor targetDesiredLocation = new TestLocationDescriptor(targetDesiredMapWithExtraFile);\n    TestLocationDescriptor existingTargetLocation = new TestLocationDescriptor(Maps.newHashMap(targetDesiredMap));\n\n    Table table = Mockito.mock(Table.class);\n    HiveDataset hiveDataset = Mockito.mock(HiveDataset.class);\n    MultiTimingEvent timer = Mockito.mock(MultiTimingEvent.class);\n    HiveCopyEntityHelper helper = Mockito.mock(HiveCopyEntityHelper.class);\n    HiveTargetPathHelper targetPathHelper = Mockito.mock(HiveTargetPathHelper.class);\n    Mockito.when(helper.getDataset()).thenReturn(hiveDataset);\n    Mockito.when(hiveDataset.getTable()).thenReturn(table);\n    Mockito.when(table.getCompleteName()).thenReturn(\"table1\");\n    Mockito.when(targetPathHelper\n        .getTargetPath(Mockito.any(Path.class), Mockito.any(FileSystem.class), Mockito.any(Optional.class),\n            Mockito.anyBoolean())).then(new Answer<Path>() {\n      @Override\n      public Path answer(InvocationOnMock invocation)\n          throws Throwable {\n        Path path = (Path) invocation.getArguments()[0];\n        return new Path(path.toString().replace(sourceRoot.toString(), targetRoot.toString()));\n      }\n    });\n    Mockito.when(helper.getTargetPathHelper()).thenReturn(targetPathHelper);\n\n    \r\n    Mockito.when(helper.getUnmanagedDataPolicy()).thenReturn(HiveCopyEntityHelper.UnmanagedDataPolicy.DELETE_UNMANAGED_DATA);\n\n    \r\n    \r\n    HiveCopyEntityHelper.DiffPathSet diff =\n        HiveCopyEntityHelper.fullPathDiff(sourceLocation, targetDesiredLocation,\n            Optional.<HiveLocationDescriptor>of(existingTargetLocation), Optional.<Partition>absent(), timer, helper);\n\n    Assert.assertEquals(diff.filesToCopy.size(), expectedFilesToCopy.size());\n    for (Path expectedFileToCopy : expectedFilesToCopy) {\n      Assert.assertTrue(containsPath(diff.filesToCopy, expectedFileToCopy));\n    }\n    for (Path expectedFileToSkipCopy : expectedFilesToSkipCopy) {\n      Assert.assertFalse(containsPath(diff.filesToCopy, expectedFileToSkipCopy));\n    }\n\n    Assert.assertEquals(diff.pathsToDelete.size(), expectedFilesToDelete.size());\n    for (Path expectedFileToDelete : expectedFilesToDelete) {\n      Assert.assertTrue(diff.pathsToDelete.contains(expectedFileToDelete));\n    }\n    for (Path expectedFileToSkipDelete : expectedFilesToSkipDelete) {\n      Assert.assertFalse(diff.pathsToDelete.contains(expectedFileToSkipDelete));\n    }\n  }\n","date":"2017-07-31 15:51:25","endLine":243,"groupId":"956","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testFullPathDiffWithUnmanagedPathsWithDeletePolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/2f/252cc67feb3ffb3f2301c2716d53e941dd3235.src","preCode":"  public void testFullPathDiffWithUnmanagedPathsWithDeletePolicy() throws Exception {\n\n    Map<Path, FileStatus> sourceMap = Maps.newHashMap();\n    Map<Path, FileStatus> targetDesiredMap = Maps.newHashMap();\n    List<Path> expectedFilesToCopy = Lists.newArrayList();\n    List<Path> expectedFilesToSkipCopy = Lists.newArrayList();\n    List<Path> expectedFilesToDelete = Lists.newArrayList();\n    List<Path> expectedFilesToSkipDelete = Lists.newArrayList();\n\n    populateSourceAndTargetEntities(sourceMap, targetDesiredMap, expectedFilesToCopy,\n        expectedFilesToSkipCopy, expectedFilesToDelete, expectedFilesToSkipDelete);\n\n    \r\n    Path path6 = new Path(\"path6\");\n    Path targetPath6 = new Path(targetRoot, path6);\n    Map<Path, FileStatus> targetDesiredMapWithExtraFile = Maps.newHashMap(targetDesiredMap);\n    targetDesiredMapWithExtraFile.put(targetPath6, getFileStatus(targetPath6, 0, 10));\n    expectedFilesToDelete.add(targetPath6);\n\n    TestLocationDescriptor sourceLocation = new TestLocationDescriptor(sourceMap);\n    TestLocationDescriptor targetDesiredLocation = new TestLocationDescriptor(targetDesiredMapWithExtraFile);\n    TestLocationDescriptor existingTargetLocation = new TestLocationDescriptor(Maps.newHashMap(targetDesiredMap));\n\n    Table table = Mockito.mock(Table.class);\n    HiveDataset hiveDataset = Mockito.mock(HiveDataset.class);\n    MultiTimingEvent timer = Mockito.mock(MultiTimingEvent.class);\n    HiveCopyEntityHelper helper = Mockito.mock(HiveCopyEntityHelper.class);\n    HiveTargetPathHelper targetPathHelper = Mockito.mock(HiveTargetPathHelper.class);\n    Mockito.when(helper.getDataset()).thenReturn(hiveDataset);\n    Mockito.when(hiveDataset.getTable()).thenReturn(table);\n    Mockito.when(table.getCompleteName()).thenReturn(\"table1\");\n    Mockito.when(targetPathHelper\n        .getTargetPath(Mockito.any(Path.class), Mockito.any(FileSystem.class), Mockito.any(Optional.class),\n            Mockito.anyBoolean())).then(new Answer<Path>() {\n      @Override\n      public Path answer(InvocationOnMock invocation)\n          throws Throwable {\n        Path path = (Path) invocation.getArguments()[0];\n        return new Path(path.toString().replace(sourceRoot.toString(), targetRoot.toString()));\n      }\n    });\n    Mockito.when(helper.getTargetPathHelper()).thenReturn(targetPathHelper);\n\n    \r\n    Mockito.when(helper.getUnmanagedDataPolicy()).thenReturn(HiveCopyEntityHelper.UnmanagedDataPolicy.DELETE_UNMANAGED_DATA);\n\n    \r\n    \r\n    HiveCopyEntityHelper.DiffPathSet diff =\n        HiveCopyEntityHelper.fullPathDiff(sourceLocation, targetDesiredLocation,\n            Optional.<HiveLocationDescriptor>of(existingTargetLocation), Optional.<Partition>absent(), timer, helper);\n\n    Assert.assertEquals(diff.filesToCopy.size(), expectedFilesToCopy.size());\n    for (Path expectedFileToCopy : expectedFilesToCopy) {\n      Assert.assertTrue(containsPath(diff.filesToCopy, expectedFileToCopy));\n    }\n    for (Path expectedFileToSkipCopy : expectedFilesToSkipCopy) {\n      Assert.assertFalse(containsPath(diff.filesToCopy, expectedFileToSkipCopy));\n    }\n\n    Assert.assertEquals(diff.pathsToDelete.size(), expectedFilesToDelete.size());\n    for (Path expectedFileToDelete : expectedFilesToDelete) {\n      Assert.assertTrue(diff.pathsToDelete.contains(expectedFileToDelete));\n    }\n    for (Path expectedFileToSkipDelete : expectedFilesToSkipDelete) {\n      Assert.assertFalse(diff.pathsToDelete.contains(expectedFileToSkipDelete));\n    }\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/hive/HiveCopyEntityHelperTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":176,"status":"B"}],"commitId":"5457af88d56b8fb89b172129fd1ff24ecdd4eba8","commitMessage":"@@@Merge pull request #2031 from abti/move_packages_to_apache\n","date":"2017-07-31 15:51:25","modifiedFileCount":"2","status":"B","submitter":"Abhishek Tiwari"},{"authorTime":"2019-04-13 08:10:09","codes":[{"authorDate":"2019-04-13 08:10:09","commitOrder":2,"curCode":"  public void testFullPathDiffWithUnmanagedPathsWithoutDeletePolicy() throws Exception {\n\n    Map<Path, FileStatus> sourceMap = Maps.newHashMap();\n    Map<Path, FileStatus> targetDesiredMap = Maps.newHashMap();\n    List<Path> expectedFilesToCopy = Lists.newArrayList();\n    List<Path> expectedFilesToSkipCopy = Lists.newArrayList();\n    List<Path> expectedFilesToDelete = Lists.newArrayList();\n    List<Path> expectedFilesToSkipDelete = Lists.newArrayList();\n\n    populateSourceAndTargetEntities(sourceMap, targetDesiredMap, expectedFilesToCopy,\n        expectedFilesToSkipCopy, expectedFilesToDelete, expectedFilesToSkipDelete);\n\n    \r\n    Path path6 = new Path(\"path6\");\n    Path targetPath6 = new Path(targetRoot, path6);\n    Map<Path, FileStatus> targetDesiredMapWithExtraFile = Maps.newHashMap(targetDesiredMap);\n    targetDesiredMapWithExtraFile.put(targetPath6, getFileStatus(targetPath6, 0, 10));\n    expectedFilesToDelete.add(targetPath6);\n\n    TestLocationDescriptor sourceLocation = new TestLocationDescriptor(sourceMap);\n    TestLocationDescriptor targetDesiredLocation = new TestLocationDescriptor(targetDesiredMapWithExtraFile);\n    TestLocationDescriptor existingTargetLocation = new TestLocationDescriptor(Maps.newHashMap(targetDesiredMap));\n\n    Table table = Mockito.mock(Table.class);\n    HiveDataset hiveDataset = Mockito.mock(HiveDataset.class);\n    MultiTimingEvent timer = Mockito.mock(MultiTimingEvent.class);\n    HiveCopyEntityHelper helper = Mockito.mock(HiveCopyEntityHelper.class);\n    Mockito.when(helper.isEnforceFileSizeMatch()).thenReturn(true);\n    HiveTargetPathHelper targetPathHelper = Mockito.mock(HiveTargetPathHelper.class);\n    Mockito.when(helper.getDataset()).thenReturn(hiveDataset);\n    Mockito.when(hiveDataset.getTable()).thenReturn(table);\n    Mockito.when(table.getCompleteName()).thenReturn(\"table1\");\n    Mockito.when(targetPathHelper\n        .getTargetPath(Mockito.any(Path.class), Mockito.any(FileSystem.class), Mockito.any(Optional.class),\n            Mockito.anyBoolean())).then(new Answer<Path>() {\n      @Override\n      public Path answer(InvocationOnMock invocation)\n          throws Throwable {\n        Path path = (Path) invocation.getArguments()[0];\n        return new Path(path.toString().replace(sourceRoot.toString(), targetRoot.toString()));\n      }\n    });\n    Mockito.when(helper.getTargetPathHelper()).thenReturn(targetPathHelper);\n\n    \r\n    Mockito.when(helper.getUnmanagedDataPolicy()).thenReturn(HiveCopyEntityHelper.UnmanagedDataPolicy.ABORT);\n\n    \r\n    try {\n      HiveCopyEntityHelper.DiffPathSet diff =\n          HiveCopyEntityHelper.fullPathDiff(sourceLocation, targetDesiredLocation,\n              Optional.<HiveLocationDescriptor>of(existingTargetLocation), Optional.<Partition>absent(), timer, helper);\n      Assert.fail(\"Expected an IOException but did not receive any\");\n    } catch (IOException ex) {\n      \r\n      String expectedExceptionMessage = \"New table / partition would pick up existing, undesired files in target file \"\n          + \"system. table1, files [/target/path6].\";\n      Assert.assertEquals(ex.getMessage(), expectedExceptionMessage);\n    }\n  }\n","date":"2019-04-13 08:10:09","endLine":178,"groupId":"101636","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testFullPathDiffWithUnmanagedPathsWithoutDeletePolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/91/a2e6742ca80119a3290752e1d6487350bc292b.src","preCode":"  public void testFullPathDiffWithUnmanagedPathsWithoutDeletePolicy() throws Exception {\n\n    Map<Path, FileStatus> sourceMap = Maps.newHashMap();\n    Map<Path, FileStatus> targetDesiredMap = Maps.newHashMap();\n    List<Path> expectedFilesToCopy = Lists.newArrayList();\n    List<Path> expectedFilesToSkipCopy = Lists.newArrayList();\n    List<Path> expectedFilesToDelete = Lists.newArrayList();\n    List<Path> expectedFilesToSkipDelete = Lists.newArrayList();\n\n    populateSourceAndTargetEntities(sourceMap, targetDesiredMap, expectedFilesToCopy,\n        expectedFilesToSkipCopy, expectedFilesToDelete, expectedFilesToSkipDelete);\n\n    \r\n    Path path6 = new Path(\"path6\");\n    Path targetPath6 = new Path(targetRoot, path6);\n    Map<Path, FileStatus> targetDesiredMapWithExtraFile = Maps.newHashMap(targetDesiredMap);\n    targetDesiredMapWithExtraFile.put(targetPath6, getFileStatus(targetPath6, 0, 10));\n    expectedFilesToDelete.add(targetPath6);\n\n    TestLocationDescriptor sourceLocation = new TestLocationDescriptor(sourceMap);\n    TestLocationDescriptor targetDesiredLocation = new TestLocationDescriptor(targetDesiredMapWithExtraFile);\n    TestLocationDescriptor existingTargetLocation = new TestLocationDescriptor(Maps.newHashMap(targetDesiredMap));\n\n    Table table = Mockito.mock(Table.class);\n    HiveDataset hiveDataset = Mockito.mock(HiveDataset.class);\n    MultiTimingEvent timer = Mockito.mock(MultiTimingEvent.class);\n    HiveCopyEntityHelper helper = Mockito.mock(HiveCopyEntityHelper.class);\n    HiveTargetPathHelper targetPathHelper = Mockito.mock(HiveTargetPathHelper.class);\n    Mockito.when(helper.getDataset()).thenReturn(hiveDataset);\n    Mockito.when(hiveDataset.getTable()).thenReturn(table);\n    Mockito.when(table.getCompleteName()).thenReturn(\"table1\");\n    Mockito.when(targetPathHelper\n        .getTargetPath(Mockito.any(Path.class), Mockito.any(FileSystem.class), Mockito.any(Optional.class),\n            Mockito.anyBoolean())).then(new Answer<Path>() {\n      @Override\n      public Path answer(InvocationOnMock invocation)\n          throws Throwable {\n        Path path = (Path) invocation.getArguments()[0];\n        return new Path(path.toString().replace(sourceRoot.toString(), targetRoot.toString()));\n      }\n    });\n    Mockito.when(helper.getTargetPathHelper()).thenReturn(targetPathHelper);\n\n    \r\n    Mockito.when(helper.getUnmanagedDataPolicy()).thenReturn(HiveCopyEntityHelper.UnmanagedDataPolicy.ABORT);\n\n    \r\n    try {\n      HiveCopyEntityHelper.DiffPathSet diff =\n          HiveCopyEntityHelper.fullPathDiff(sourceLocation, targetDesiredLocation,\n              Optional.<HiveLocationDescriptor>of(existingTargetLocation), Optional.<Partition>absent(), timer, helper);\n      Assert.fail(\"Expected an IOException but did not receive any\");\n    } catch (IOException ex) {\n      \r\n      String expectedExceptionMessage = \"New table / partition would pick up existing, undesired files in target file \"\n          + \"system. table1, files [/target/path6].\";\n      Assert.assertEquals(ex.getMessage(), expectedExceptionMessage);\n    }\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/hive/HiveCopyEntityHelperTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":119,"status":"M"},{"authorDate":"2019-04-13 08:10:09","commitOrder":2,"curCode":"  public void testFullPathDiffWithUnmanagedPathsWithDeletePolicy() throws Exception {\n\n    Map<Path, FileStatus> sourceMap = Maps.newHashMap();\n    Map<Path, FileStatus> targetDesiredMap = Maps.newHashMap();\n    List<Path> expectedFilesToCopy = Lists.newArrayList();\n    List<Path> expectedFilesToSkipCopy = Lists.newArrayList();\n    List<Path> expectedFilesToDelete = Lists.newArrayList();\n    List<Path> expectedFilesToSkipDelete = Lists.newArrayList();\n\n    populateSourceAndTargetEntities(sourceMap, targetDesiredMap, expectedFilesToCopy,\n        expectedFilesToSkipCopy, expectedFilesToDelete, expectedFilesToSkipDelete);\n\n    \r\n    Path path6 = new Path(\"path6\");\n    Path targetPath6 = new Path(targetRoot, path6);\n    Map<Path, FileStatus> targetDesiredMapWithExtraFile = Maps.newHashMap(targetDesiredMap);\n    targetDesiredMapWithExtraFile.put(targetPath6, getFileStatus(targetPath6, 0, 10));\n    expectedFilesToDelete.add(targetPath6);\n\n    TestLocationDescriptor sourceLocation = new TestLocationDescriptor(sourceMap);\n    TestLocationDescriptor targetDesiredLocation = new TestLocationDescriptor(targetDesiredMapWithExtraFile);\n    TestLocationDescriptor existingTargetLocation = new TestLocationDescriptor(Maps.newHashMap(targetDesiredMap));\n\n    Table table = Mockito.mock(Table.class);\n    HiveDataset hiveDataset = Mockito.mock(HiveDataset.class);\n    MultiTimingEvent timer = Mockito.mock(MultiTimingEvent.class);\n    HiveCopyEntityHelper helper = Mockito.mock(HiveCopyEntityHelper.class);\n    Mockito.when(helper.isEnforceFileSizeMatch()).thenReturn(true);\n    HiveTargetPathHelper targetPathHelper = Mockito.mock(HiveTargetPathHelper.class);\n    Mockito.when(helper.getDataset()).thenReturn(hiveDataset);\n    Mockito.when(hiveDataset.getTable()).thenReturn(table);\n    Mockito.when(table.getCompleteName()).thenReturn(\"table1\");\n    Mockito.when(targetPathHelper\n        .getTargetPath(Mockito.any(Path.class), Mockito.any(FileSystem.class), Mockito.any(Optional.class),\n            Mockito.anyBoolean())).then(new Answer<Path>() {\n      @Override\n      public Path answer(InvocationOnMock invocation)\n          throws Throwable {\n        Path path = (Path) invocation.getArguments()[0];\n        return new Path(path.toString().replace(sourceRoot.toString(), targetRoot.toString()));\n      }\n    });\n    Mockito.when(helper.getTargetPathHelper()).thenReturn(targetPathHelper);\n\n    \r\n    Mockito.when(helper.getUnmanagedDataPolicy()).thenReturn(HiveCopyEntityHelper.UnmanagedDataPolicy.DELETE_UNMANAGED_DATA);\n\n    \r\n    \r\n    HiveCopyEntityHelper.DiffPathSet diff =\n        HiveCopyEntityHelper.fullPathDiff(sourceLocation, targetDesiredLocation,\n            Optional.<HiveLocationDescriptor>of(existingTargetLocation), Optional.<Partition>absent(), timer, helper);\n\n    Assert.assertEquals(diff.filesToCopy.size(), expectedFilesToCopy.size());\n    for (Path expectedFileToCopy : expectedFilesToCopy) {\n      Assert.assertTrue(containsPath(diff.filesToCopy, expectedFileToCopy));\n    }\n    for (Path expectedFileToSkipCopy : expectedFilesToSkipCopy) {\n      Assert.assertFalse(containsPath(diff.filesToCopy, expectedFileToSkipCopy));\n    }\n\n    Assert.assertEquals(diff.pathsToDelete.size(), expectedFilesToDelete.size());\n    for (Path expectedFileToDelete : expectedFilesToDelete) {\n      Assert.assertTrue(diff.pathsToDelete.contains(expectedFileToDelete));\n    }\n    for (Path expectedFileToSkipDelete : expectedFilesToSkipDelete) {\n      Assert.assertFalse(diff.pathsToDelete.contains(expectedFileToSkipDelete));\n    }\n  }\n","date":"2019-04-13 08:10:09","endLine":249,"groupId":"101636","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testFullPathDiffWithUnmanagedPathsWithDeletePolicy","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-gobblin-10-0.7/blobInfo/CC_OUT/blobs/91/a2e6742ca80119a3290752e1d6487350bc292b.src","preCode":"  public void testFullPathDiffWithUnmanagedPathsWithDeletePolicy() throws Exception {\n\n    Map<Path, FileStatus> sourceMap = Maps.newHashMap();\n    Map<Path, FileStatus> targetDesiredMap = Maps.newHashMap();\n    List<Path> expectedFilesToCopy = Lists.newArrayList();\n    List<Path> expectedFilesToSkipCopy = Lists.newArrayList();\n    List<Path> expectedFilesToDelete = Lists.newArrayList();\n    List<Path> expectedFilesToSkipDelete = Lists.newArrayList();\n\n    populateSourceAndTargetEntities(sourceMap, targetDesiredMap, expectedFilesToCopy,\n        expectedFilesToSkipCopy, expectedFilesToDelete, expectedFilesToSkipDelete);\n\n    \r\n    Path path6 = new Path(\"path6\");\n    Path targetPath6 = new Path(targetRoot, path6);\n    Map<Path, FileStatus> targetDesiredMapWithExtraFile = Maps.newHashMap(targetDesiredMap);\n    targetDesiredMapWithExtraFile.put(targetPath6, getFileStatus(targetPath6, 0, 10));\n    expectedFilesToDelete.add(targetPath6);\n\n    TestLocationDescriptor sourceLocation = new TestLocationDescriptor(sourceMap);\n    TestLocationDescriptor targetDesiredLocation = new TestLocationDescriptor(targetDesiredMapWithExtraFile);\n    TestLocationDescriptor existingTargetLocation = new TestLocationDescriptor(Maps.newHashMap(targetDesiredMap));\n\n    Table table = Mockito.mock(Table.class);\n    HiveDataset hiveDataset = Mockito.mock(HiveDataset.class);\n    MultiTimingEvent timer = Mockito.mock(MultiTimingEvent.class);\n    HiveCopyEntityHelper helper = Mockito.mock(HiveCopyEntityHelper.class);\n    HiveTargetPathHelper targetPathHelper = Mockito.mock(HiveTargetPathHelper.class);\n    Mockito.when(helper.getDataset()).thenReturn(hiveDataset);\n    Mockito.when(hiveDataset.getTable()).thenReturn(table);\n    Mockito.when(table.getCompleteName()).thenReturn(\"table1\");\n    Mockito.when(targetPathHelper\n        .getTargetPath(Mockito.any(Path.class), Mockito.any(FileSystem.class), Mockito.any(Optional.class),\n            Mockito.anyBoolean())).then(new Answer<Path>() {\n      @Override\n      public Path answer(InvocationOnMock invocation)\n          throws Throwable {\n        Path path = (Path) invocation.getArguments()[0];\n        return new Path(path.toString().replace(sourceRoot.toString(), targetRoot.toString()));\n      }\n    });\n    Mockito.when(helper.getTargetPathHelper()).thenReturn(targetPathHelper);\n\n    \r\n    Mockito.when(helper.getUnmanagedDataPolicy()).thenReturn(HiveCopyEntityHelper.UnmanagedDataPolicy.DELETE_UNMANAGED_DATA);\n\n    \r\n    \r\n    HiveCopyEntityHelper.DiffPathSet diff =\n        HiveCopyEntityHelper.fullPathDiff(sourceLocation, targetDesiredLocation,\n            Optional.<HiveLocationDescriptor>of(existingTargetLocation), Optional.<Partition>absent(), timer, helper);\n\n    Assert.assertEquals(diff.filesToCopy.size(), expectedFilesToCopy.size());\n    for (Path expectedFileToCopy : expectedFilesToCopy) {\n      Assert.assertTrue(containsPath(diff.filesToCopy, expectedFileToCopy));\n    }\n    for (Path expectedFileToSkipCopy : expectedFilesToSkipCopy) {\n      Assert.assertFalse(containsPath(diff.filesToCopy, expectedFileToSkipCopy));\n    }\n\n    Assert.assertEquals(diff.pathsToDelete.size(), expectedFilesToDelete.size());\n    for (Path expectedFileToDelete : expectedFilesToDelete) {\n      Assert.assertTrue(diff.pathsToDelete.contains(expectedFileToDelete));\n    }\n    for (Path expectedFileToSkipDelete : expectedFilesToSkipDelete) {\n      Assert.assertFalse(diff.pathsToDelete.contains(expectedFileToSkipDelete));\n    }\n  }\n","realPath":"gobblin-data-management/src/test/java/org/apache/gobblin/data/management/copy/hive/HiveCopyEntityHelperTest.java","repoName":"gobblin","snippetEndLine":0,"snippetStartLine":0,"startLine":181,"status":"M"}],"commitId":"5b4cd9e241e6cf00bf72645e0ca35a132c36089e","commitMessage":"@@@[GOBBLIN-729] Add version strategy support for HiveCopyDataset\n\nCloses #2596 from yukuai518/hivest\n","date":"2019-04-13 08:10:09","modifiedFileCount":"3","status":"M","submitter":"Kuai Yu"}]
