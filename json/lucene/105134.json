[{"authorTime":"2012-02-08 03:59:05","codes":[{"authorDate":"2012-02-08 03:59:05","commitOrder":1,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2012-02-08 03:59:05","endLine":283,"groupId":"2180","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ef/8c2ae16782f898d0da612369ea00d1274500ea.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"B"},{"authorDate":"2012-02-08 03:59:05","commitOrder":1,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-02-08 03:59:05","endLine":584,"groupId":"30242","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ef/8c2ae16782f898d0da612369ea00d1274500ea.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":574,"status":"B"}],"commitId":"eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c","commitMessage":"@@@LUCENE-3753: Restructure the Lucene build system\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1241588 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-02-08 03:59:05","modifiedFileCount":"0","status":"B","submitter":"Steven Rowe"},{"authorTime":"2012-02-08 03:59:05","codes":[{"authorDate":"2012-02-11 03:57:07","commitOrder":2,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2012-02-11 03:57:07","endLine":283,"groupId":"2180","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/4b/9e3f7c0e8afbfe117df84ccd6798429a54d803.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2012-02-08 03:59:05","commitOrder":2,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-02-08 03:59:05","endLine":584,"groupId":"30242","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ef/8c2ae16782f898d0da612369ea00d1274500ea.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":574,"status":"N"}],"commitId":"c74d48b857cb3e3d9e8e2f07eb8bf3b44ebc3334","commitMessage":"@@@LUCENE-3760: clean up DirectoryReader/SegmentInfos methods\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1242903 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-02-11 03:57:07","modifiedFileCount":"13","status":"M","submitter":"Michael McCandless"},{"authorTime":"2012-02-08 03:59:05","codes":[{"authorDate":"2012-05-29 03:28:10","commitOrder":3,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2012-05-29 03:28:10","endLine":259,"groupId":"62147","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6a/a56a4cb0a6a6e0711f85869a6ab938058401c3.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2012-02-08 03:59:05","commitOrder":3,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-02-08 03:59:05","endLine":584,"groupId":"30242","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ef/8c2ae16782f898d0da612369ea00d1274500ea.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":574,"status":"N"}],"commitId":"e9bb48725216af399d3d3cd7663b53fa63ec5438","commitMessage":"@@@LUCENE-4055: Refactor SegmentInfo and FieldInfo to make them extensible\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1343365 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-05-29 03:28:10","modifiedFileCount":"205","status":"M","submitter":"Robert Muir"},{"authorTime":"2012-02-08 03:59:05","codes":[{"authorDate":"2012-06-29 00:39:25","commitOrder":4,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2012-06-29 00:39:25","endLine":258,"groupId":"62147","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/44/47472779c43dd104f8945d15fb9a2fa39fdd87.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"},{"authorDate":"2012-02-08 03:59:05","commitOrder":4,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-02-08 03:59:05","endLine":584,"groupId":"30242","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ef/8c2ae16782f898d0da612369ea00d1274500ea.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":574,"status":"N"}],"commitId":"fd16190940d7495e985f44ce7504562c8bbc91e6","commitMessage":"@@@LUCENE-4172: clean up redundant throws clauses\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1355069 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-06-29 00:39:25","modifiedFileCount":"402","status":"M","submitter":"Steven Rowe"},{"authorTime":"2012-02-08 03:59:05","codes":[{"authorDate":"2012-07-05 01:46:28","commitOrder":5,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n          && (fileName.startsWith(\"_\") || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2012-07-05 01:46:28","endLine":259,"groupId":"62147","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/1d/2bdef0d66cded4ba7082da4e905b4259de5acd.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"},{"authorDate":"2012-02-08 03:59:05","commitOrder":5,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-02-08 03:59:05","endLine":584,"groupId":"30242","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ef/8c2ae16782f898d0da612369ea00d1274500ea.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":574,"status":"N"}],"commitId":"458cb4e59a680bee5a0d1085590bdd6f4c70e9ce","commitMessage":"@@@LUCENE-4190: don't delete files in the index directory unless they begin with an underscore\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1357346 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-07-05 01:46:28","modifiedFileCount":"4","status":"M","submitter":"Robert Muir"},{"authorTime":"2012-02-08 03:59:05","codes":[{"authorDate":"2012-07-05 17:55:16","commitOrder":6,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2012-07-05 17:55:16","endLine":258,"groupId":"62147","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/44/47472779c43dd104f8945d15fb9a2fa39fdd87.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n          && (fileName.startsWith(\"_\") || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":123,"status":"M"},{"authorDate":"2012-02-08 03:59:05","commitOrder":6,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-02-08 03:59:05","endLine":584,"groupId":"30242","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ef/8c2ae16782f898d0da612369ea00d1274500ea.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":574,"status":"N"}],"commitId":"80c54757258fb492cd83434c508b7dc56ceeb97a","commitMessage":"@@@LUCENE-4190: revert. lucene isn't a file manager\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1357532 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-07-05 17:55:16","modifiedFileCount":"4","status":"M","submitter":"Robert Muir"},{"authorTime":"2012-02-08 03:59:05","codes":[{"authorDate":"2012-07-30 01:59:49","commitOrder":7,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2012-07-30 01:59:49","endLine":263,"groupId":"62147","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/2c/0856e78f65e05059eb7721670fb07c0ff67519.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        \r\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          \r\n          \r\n          \r\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              \r\n              \r\n              \r\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"M"},{"authorDate":"2012-02-08 03:59:05","commitOrder":7,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-02-08 03:59:05","endLine":584,"groupId":"30242","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ef/8c2ae16782f898d0da612369ea00d1274500ea.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":574,"status":"N"}],"commitId":"08baaf03e5f64353889300a99f562a3d0fa8e018","commitMessage":"@@@LUCENE-4190: restrict allowed filenames to reduce risk of deleting non-lucene file from the index directory\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1366881 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-07-30 01:59:49","modifiedFileCount":"5","status":"M","submitter":"Michael McCandless"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2012-07-30 01:59:49","commitOrder":8,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2012-07-30 01:59:49","endLine":263,"groupId":"62147","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/2c/0856e78f65e05059eb7721670fb07c0ff67519.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":124,"status":"N"},{"authorDate":"2012-10-03 19:01:13","commitOrder":8,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      if (!refCounts.containsKey(fileName)) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"M"}],"commitId":"cb4023151318ab522c99b4637bb79d91c1281590","commitMessage":"@@@LUCENE-4456: fix various bugs (see lucene/CHANGES.txt)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1393408 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2012-10-03 19:01:13","modifiedFileCount":"24","status":"M","submitter":"Michael McCandless"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2013-04-11 06:02:24","commitOrder":9,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2013-04-11 06:02:24","endLine":264,"groupId":"31632","id":17,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/5c/13a7e1203c28a2e45c2174abb528bfdbb91956.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":9,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":18,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"6e24f5adf47061c4ac64d7f111d44a0f9c5866f2","commitMessage":"@@@LUCENE-4738: simplify DirectoryReader.indexExists; fix IndexWriter with CREATE to succeed on a corrupted index; add random IOExceptions to MockDirectoryWrapper.openInput/createOutput\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1466706 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-04-11 06:02:24","modifiedFileCount":"11","status":"M","submitter":"Michael McCandless"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2013-05-03 19:13:19","commitOrder":10,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2013-05-03 19:13:19","endLine":262,"groupId":"31632","id":19,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/9e/8dc76f0c654a33a9c7b9b119b33ef6e7dc2ba6.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":10,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":20,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"efeaac746ae10c63d71051ce2d8575cf85bb6616","commitMessage":"@@@LUCENE-4976: use single file to hold PersistentSnapshotDeletionPolicy state on disk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1478726 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-05-03 19:13:19","modifiedFileCount":"6","status":"M","submitter":"Michael McCandless"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2013-05-03 21:37:45","commitOrder":11,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2013-05-03 21:37:45","endLine":262,"groupId":"31632","id":21,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c6/ec5d03e23462861728ee47e7c833344b6e7c31.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.mergeSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":125,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":11,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":22,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"b895ebde4340ed8ae903c7ae51750da3d9837394","commitMessage":"@@@LUCENE-4946: Refactor SorterTemplate (now Sorter).\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1478785 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-05-03 21:37:45","modifiedFileCount":"30","status":"M","submitter":"Adrien Grand"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2013-06-12 06:26:08","commitOrder":12,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2013-06-12 06:26:08","endLine":263,"groupId":"13837","id":23,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/9f/f0005dc659d190d086064886e0f0c64ec2dd3a.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":126,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":12,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":24,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"a62bdaa9443783792e60b24b879ff2632a70f39e","commitMessage":"@@@LUCENE-5047: Handle NoSuchFileException of Java 7 like FileNotFoundException when opeining index files; document this in Directory.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1491992 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2013-06-12 06:26:08","modifiedFileCount":"11","status":"M","submitter":"Uwe Schindler"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2014-08-30 05:14:15","commitOrder":13,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2014-08-30 05:14:15","endLine":267,"groupId":"13837","id":25,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/3d/944549cb5e9a74c54a13aba42075a6d4d11e2e.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":13,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":26,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"7a189a3aca620649bd719d214d471ebb8845fa6b","commitMessage":"@@@LUCENE-5904: fix corruption case caused by virus checker after an unclean IW shutdown\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1621389 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-08-30 05:14:15","modifiedFileCount":"47","status":"M","submitter":"Michael McCandless"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2014-09-11 13:04:06","commitOrder":14,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2014-09-11 13:04:06","endLine":267,"groupId":"59871","id":27,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/62/bccd24510a6c3f90577b6fddb07eef6d245e0f.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":128,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":14,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":28,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"bb0256f26076849b94de4e036cc5af055f0e6cd4","commitMessage":"@@@LUCENE-5925: use rename instead of segments_N fallback/segments.gen\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1624194 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-09-11 13:04:06","modifiedFileCount":"31","status":"M","submitter":"Robert Muir"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2014-09-14 05:46:29","commitOrder":15,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2014-09-14 05:46:29","endLine":260,"groupId":"59871","id":29,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/bc/7768437d9e3dfea3af9a537bff745348e47794.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      \r\n      files = new String[0];\n    }\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":15,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":30,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"3eb66fb19ca2aa3d9dce53661f3233b6c9d3f974","commitMessage":"@@@LUCENE-5945: Full cutover to Path api from java.io.File\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1624784 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-09-14 05:46:29","modifiedFileCount":"293","status":"M","submitter":"Robert Muir"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2014-09-18 07:39:42","commitOrder":16,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2014-09-18 07:39:42","endLine":261,"groupId":"59871","id":31,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/13/aaca6992ecb0b59c7cef0c83bce03a5c02c1ae.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":16,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":32,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"7a876d886544eb763f0c8d11fa91c7811e368d13","commitMessage":"@@@LUCENE-5958: OOM or exceptions during checkpoint make IndexWriter have a bad day\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1625853 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-09-18 07:39:42","modifiedFileCount":"6","status":"M","submitter":"Robert Muir"},{"authorTime":"2012-10-03 19:01:13","codes":[{"authorDate":"2014-09-20 08:25:48","commitOrder":17,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2014-09-20 08:25:48","endLine":261,"groupId":"59871","id":33,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/9a/b5adfbe098b579e194f6686f6b7fa159e808f0.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2012-10-03 19:01:13","commitOrder":17,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2012-10-03 19:01:13","endLine":574,"groupId":"11010","id":34,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/73/f9f360d99f8236d41f73b71431b710277148d4.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":558,"status":"N"}],"commitId":"8310bd892cbdeeb74f5130c66a4e9c64abfe6696","commitMessage":"@@@LUCENE-5965: CorruptIndexException requires a String or DataInput resource\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1626372 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-09-20 08:25:48","modifiedFileCount":"43","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-10-12 15:48:03","codes":[{"authorDate":"2014-09-20 08:25:48","commitOrder":18,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2014-09-20 08:25:48","endLine":261,"groupId":"59871","id":35,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/9a/b5adfbe098b579e194f6686f6b7fa159e808f0.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"N"},{"authorDate":"2014-10-12 15:48:03","commitOrder":18,"curCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2014-10-12 15:48:03","endLine":716,"groupId":"11010","id":36,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ff/12559673d1b4f0faa54c35a30e7c749d5aa02b.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":700,"status":"M"}],"commitId":"f7cc185443bcc7cb1eff7bca001ff795aca18a9d","commitMessage":"@@@don't allow publishFlushSegment after IW is closed\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1631152 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-10-12 15:48:03","modifiedFileCount":"2","status":"M","submitter":"Michael McCandless"},{"authorTime":"2014-10-12 15:48:03","codes":[{"authorDate":"2014-10-24 10:43:41","commitOrder":19,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2014-10-24 10:43:41","endLine":261,"groupId":"27130","id":37,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/cf/1a6f4378730feb69541ee8388ab7981cae94f2.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2014-10-12 15:48:03","commitOrder":19,"curCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2014-10-12 15:48:03","endLine":716,"groupId":"11010","id":38,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ff/12559673d1b4f0faa54c35a30e7c749d5aa02b.src","preCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":700,"status":"N"}],"commitId":"ff50c35fc223476c9da51e14879973d77c112124","commitMessage":"@@@LUCENE-5969: finish porting rest of codec to 5.0 features\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1633991 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2014-10-24 10:43:41","modifiedFileCount":"118","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-10-12 15:48:03","codes":[{"authorDate":"2015-05-01 17:41:46","commitOrder":20,"curCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2015-05-01 17:41:46","endLine":251,"groupId":"27130","id":39,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/25/00c03cd3c670b3e3f7c8f418cf40a7b76006c0.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                \r\n                \r\n                \r\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":129,"status":"M"},{"authorDate":"2014-10-12 15:48:03","commitOrder":20,"curCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2014-10-12 15:48:03","endLine":716,"groupId":"11010","id":40,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ff/12559673d1b4f0faa54c35a30e7c749d5aa02b.src","preCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":700,"status":"N"}],"commitId":"b3fd1ef5605f2f5a5fae830446c01d3a42f4142c","commitMessage":"@@@remove obsolete fileLength call in IndexFileDeleter: crashes during commit no longer result in 0-length segments_N files\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1677104 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-05-01 17:41:46","modifiedFileCount":"2","status":"M","submitter":"Michael McCandless"},{"authorTime":"2014-10-12 15:48:03","codes":[{"authorDate":"2015-06-05 02:20:44","commitOrder":21,"curCode":"  public IndexFileDeleter(Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directoryOrig, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","date":"2015-06-05 02:20:44","endLine":253,"groupId":"27130","id":41,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(DirectorydirectoryOrig@Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/d4/fd100b544dd80eca2132054380bdf083f34b31.src","preCode":"  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directory, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"M"},{"authorDate":"2014-10-12 15:48:03","commitOrder":21,"curCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2014-10-12 15:48:03","endLine":716,"groupId":"11010","id":42,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ff/12559673d1b4f0faa54c35a30e7c749d5aa02b.src","preCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":700,"status":"N"}],"commitId":"fe6c3dc9397b0397aebf84fedb57875beb163d1d","commitMessage":"@@@LUCENE-6508: Simplify directory/lock API\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1683606 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-05 02:20:44","modifiedFileCount":"37","status":"M","submitter":"Robert Muir"},{"authorTime":"2014-10-12 15:48:03","codes":[{"authorDate":"2015-06-28 16:07:50","commitOrder":22,"curCode":"  public IndexFileDeleter(Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directoryOrig, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","date":"2015-06-28 16:07:50","endLine":263,"groupId":"27130","id":43,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(DirectorydirectoryOrig@Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists@booleanisReaderInit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/1d/afd00c2bf374a2a01a5afc1d031a46873ee525.src","preCode":"  public IndexFileDeleter(Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directoryOrig, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"M"},{"authorDate":"2014-10-12 15:48:03","commitOrder":22,"curCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","date":"2014-10-12 15:48:03","endLine":716,"groupId":"11010","id":44,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ff/12559673d1b4f0faa54c35a30e7c749d5aa02b.src","preCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":700,"status":"N"}],"commitId":"2d0ac9bb7f2276d5a277efda29e676096ea034b4","commitMessage":"@@@LUCENE_6524: init IndexWriter from already opened reader\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1687992 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-06-28 16:07:50","modifiedFileCount":"13","status":"M","submitter":"Michael McCandless"},{"authorTime":"2015-07-08 22:42:43","codes":[{"authorDate":"2015-07-08 22:42:43","commitOrder":23,"curCode":"  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        \r\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","date":"2015-07-08 22:42:43","endLine":251,"groupId":"2223","id":45,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(String[]files@DirectorydirectoryOrig@Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists@booleanisReaderInit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/2c/b14cf86bace22a44845b14eb517542382ec79d.src","preCode":"  public IndexFileDeleter(Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n    String[] files = directory.listAll();\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = null;\n            try {\n              sis = SegmentInfos.readCommit(directoryOrig, fileName);\n            } catch (FileNotFoundException | NoSuchFileException e) {\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              \r\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":130,"status":"M"},{"authorDate":"2015-07-08 22:42:43","commitOrder":23,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"will delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deletable.add(fileName);\n      }\n    }\n\n    deletePendingFiles();\n  }\n","date":"2015-07-08 22:42:43","endLine":732,"groupId":"11010","id":46,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/2c/b14cf86bace22a44845b14eb517542382ec79d.src","preCode":"  void deleteNewFiles(Collection<String> files) {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":714,"status":"M"}],"commitId":"dd75010e6bfc086c34cf892fa40d568e778723c0","commitMessage":"@@@LUCENE-6616: IW lists files only once on init.  IFD no longer suppresses FNFE.  IFD deletes segments_N files last\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1689893 13f79535-47bb-0310-9956-ffa450edef68\n","date":"2015-07-08 22:42:43","modifiedFileCount":"7","status":"M","submitter":"Michael McCandless"},{"authorTime":"2016-02-07 00:34:30","codes":[{"authorDate":"2016-02-07 00:34:30","commitOrder":24,"curCode":"  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        \r\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","date":"2016-02-07 00:34:30","endLine":251,"groupId":"2223","id":47,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(String[]files@DirectorydirectoryOrig@Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists@booleanisReaderInit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/68/86055fb6cd05d9af7f09be596d9ee8c5e57489.src","preCode":"  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        \r\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2016-02-07 00:34:30","commitOrder":24,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    Set<String> toDelete = new HashSet<>();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"will delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n  }\n","date":"2016-02-07 00:34:30","endLine":692,"groupId":"11010","id":48,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/68/86055fb6cd05d9af7f09be596d9ee8c5e57489.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"will delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        deletable.add(fileName);\n      }\n    }\n\n    deletePendingFiles();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":673,"status":"M"}],"commitId":"c04f0cb603caeb719e73f29f7d0b60032f756b7a","commitMessage":"@@@Merge remote-tracking branch 'origin/master'\n","date":"2016-02-07 00:34:30","modifiedFileCount":"124","status":"M","submitter":"Erick Erickson"},{"authorTime":"2016-02-07 00:34:30","codes":[{"authorDate":"2018-05-15 18:31:30","commitOrder":25,"curCode":"  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n    Collection<String> relevantFiles = new HashSet<>(refCounts.keySet());\n    Set<String> pendingDeletions = directoryOrig.getPendingDeletions();\n    if (pendingDeletions.isEmpty() == false) {\n      relevantFiles.addAll(pendingDeletions);\n    }\n    \r\n    inflateGens(segmentInfos, relevantFiles, infoStream);\n\n    \r\n    \r\n    \r\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        \r\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","date":"2018-05-16 17:17:43","endLine":255,"groupId":"2223","id":49,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(String[]files@DirectorydirectoryOrig@Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists@booleanisReaderInit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/cc/9d2e0791d4563aa61ff909492f79511639cca4.src","preCode":"  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n\n    \r\n    inflateGens(segmentInfos, refCounts.keySet(), infoStream);\n\n    \r\n    \r\n    \r\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        \r\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2016-02-07 00:34:30","commitOrder":25,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    Set<String> toDelete = new HashSet<>();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"will delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n  }\n","date":"2016-02-07 00:34:30","endLine":692,"groupId":"11010","id":50,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/68/86055fb6cd05d9af7f09be596d9ee8c5e57489.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    Set<String> toDelete = new HashSet<>();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"will delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":673,"status":"N"}],"commitId":"585952797cfe715aefa29380f08eb93a25acc55e","commitMessage":"@@@LUCENE-8310: Ensure IndexFileDeleter accounts for pending deletes\n\nToday we fail creating the IndexWriter when the directory has a\npending delete. Yet.  this is mainly done to prevent writing still\nexisting files more than once. IndexFileDeleter already accounts for\nthat for existing files which we can now use to also take pending\ndeletes into account which ensures that all file generations per segment\nalways go forward.\n","date":"2018-05-16 17:17:43","modifiedFileCount":"12","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2016-02-07 00:34:30","codes":[{"authorDate":"2019-09-04 15:51:27","commitOrder":26,"curCode":"  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n    Collection<String> relevantFiles = new HashSet<>(refCounts.keySet());\n    Set<String> pendingDeletions = directoryOrig.getPendingDeletions();\n    if (pendingDeletions.isEmpty() == false) {\n      relevantFiles.addAll(pendingDeletions);\n    }\n    \r\n    inflateGens(segmentInfos, relevantFiles, infoStream);\n\n    \r\n    \r\n    \r\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        \r\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","date":"2019-09-04 15:51:27","endLine":255,"groupId":"105134","id":51,"instanceNumber":1,"isCurCommit":0,"methodName":"IndexFileDeleter","params":"(String[]files@DirectorydirectoryOrig@Directorydirectory@IndexDeletionPolicypolicy@SegmentInfossegmentInfos@InfoStreaminfoStream@IndexWriterwriter@booleaninitialIndexExists@booleanisReaderInit)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/71/e412d3674e5c0db1e736b4f910093ad863461f.src","preCode":"  public IndexFileDeleter(String[] files, Directory directoryOrig, Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists,\n                          boolean isReaderInit) throws IOException {\n    Objects.requireNonNull(writer);\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directoryOrig = directoryOrig;\n    this.directory = directory;\n\n    \r\n    \r\n    CommitPoint currentCommitPoint = null;\n\n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n          \n          \r\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {\n            \n            \r\n            \r\n            \r\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = SegmentInfos.readCommit(directoryOrig, fileName);\n\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n              \n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      SegmentInfos sis = null;\n      try {\n        sis = SegmentInfos.readCommit(directoryOrig, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"unable to read current segments_N file\", currentSegmentsFile, e);\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directoryOrig, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    if (isReaderInit) {\n      \r\n      checkpoint(segmentInfos, false);\n    }\n\n    \r\n    CollectionUtil.timSort(commits);\n    Collection<String> relevantFiles = new HashSet<>(refCounts.keySet());\n    Set<String> pendingDeletions = directoryOrig.getPendingDeletions();\n    if (pendingDeletions.isEmpty() == false) {\n      relevantFiles.addAll(pendingDeletions);\n    }\n    \r\n    inflateGens(segmentInfos, relevantFiles, infoStream);\n\n    \r\n    \r\n    \r\n    Set<String> toDelete = new HashSet<>();\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        \r\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n          throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" has refCount=0, which should never happen on init\");\n        }\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n\n    \r\n    \r\n    policy.onInit(commits);\n\n    \r\n    \r\n    checkpoint(segmentInfos, false);\n\n    if (currentCommitPoint == null) {\n      startingCommitDeleted = false;\n    } else {\n      startingCommitDeleted = currentCommitPoint.isDeleted();\n    }\n\n    deleteCommits();\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":127,"status":"M"},{"authorDate":"2016-02-07 00:34:30","commitOrder":26,"curCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    Set<String> toDelete = new HashSet<>();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"will delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n  }\n","date":"2016-02-07 00:34:30","endLine":692,"groupId":"105134","id":52,"instanceNumber":2,"isCurCommit":0,"methodName":"deleteNewFiles","params":"(Collection<String>files)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/68/86055fb6cd05d9af7f09be596d9ee8c5e57489.src","preCode":"  void deleteNewFiles(Collection<String> files) throws IOException {\n    assert locked();\n    Set<String> toDelete = new HashSet<>();\n    for (final String fileName: files) {\n      \r\n      \r\n      \r\n      \r\n      \r\n      \r\n      if (!refCounts.containsKey(fileName) || refCounts.get(fileName).count == 0) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"will delete new file \\\"\" + fileName + \"\\\"\");\n        }\n        toDelete.add(fileName);\n      }\n    }\n\n    deleteFiles(toDelete);\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":673,"status":"N"}],"commitId":"26804a069b929ac53e3e9b4c0431bddc72a6807b","commitMessage":"@@@LUCENE-8150: Remove references to `segments.gen`. (#765)\n\nThis file isn't used anymore since 4.0.  so I tried to contain references to\n`segments.gen` to the minimum that is required to get the right exception when\nopening a too old index.","date":"2019-09-04 15:51:27","modifiedFileCount":"5","status":"M","submitter":"Adrien Grand"}]
