[{"authorTime":"2016-10-11 01:43:46","codes":[{"authorDate":"2019-09-06 23:48:32","commitOrder":5,"curCode":"    protected void setLinear(int position) {\n      assert linear == false;\n\n      int state = 0;\n      assert state == 0;\n      int maxInterval = 0xff;\n      \r\n      for (int i = 0; i < position; i++) {\n        state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n        assert state >= 0: \"state=\" + state;\n      }\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) &&\n            (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n          maxInterval = transition.max;\n          break;\n        }\n      }\n      \r\n      if (maxInterval != 0xff)\n        maxInterval++;\n      int length = position + 1; \n      if (linearUpperBound.bytes.length < length)\n        linearUpperBound.bytes = new byte[length];\n      System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n      linearUpperBound.bytes[position] = (byte) maxInterval;\n      linearUpperBound.length = length;\n\n      linear = true;\n    }\n","date":"2019-09-06 23:48:32","endLine":402,"groupId":"145","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"setLinear","params":"(intposition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/51/9e0d4c00c37eff02e5e51d55e68cbc30a660bd.src","preCode":"    protected void setLinear(int position) {\n      assert linear == false;\n\n      int state = 0;\n      assert state == 0;\n      int maxInterval = 0xff;\n      \r\n      for (int i = 0; i < position; i++) {\n        state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n        assert state >= 0: \"state=\" + state;\n      }\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) &&\n            (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n          maxInterval = transition.max;\n          break;\n        }\n      }\n      \r\n      if (maxInterval != 0xff)\n        maxInterval++;\n      int length = position + 1; \n      if (linearUpperBound.bytes.length < length)\n        linearUpperBound.bytes = new byte[length];\n      System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n      linearUpperBound.bytes[position] = (byte) maxInterval;\n      linearUpperBound.length = length;\n\n      linear = true;\n    }\n","realPath":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"B"},{"authorDate":"2016-10-11 01:43:46","commitOrder":5,"curCode":"  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = 0;\n    assert state == 0;\n    int maxInterval = 0xff;\n    \r\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) && \n          (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n        maxInterval = transition.max;\n        break;\n      }\n    }\n    \r\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; \n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n","date":"2016-10-11 01:43:46","endLine":167,"groupId":"145","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"setLinear","params":"(intposition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/8a/a10ece7f581dd0a80301faa46ed9b41120e4f8.src","preCode":"  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = 0;\n    assert state == 0;\n    int maxInterval = 0xff;\n    \r\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) && \n          (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n        maxInterval = transition.max;\n        break;\n      }\n    }\n    \r\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; \n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":135,"status":"NB"}],"commitId":"b963b7c3dbecda86c2917ad341caee63b93815ac","commitMessage":"@@@LUCENE-8753: New UniformSplit and SharedTermsUniformSplit PostingsFormats\n","date":"2019-09-06 23:48:32","modifiedFileCount":"0","status":"M","submitter":"David Smiley"},{"authorTime":"2020-02-22 01:07:13","codes":[{"authorDate":"2019-09-06 23:48:32","commitOrder":6,"curCode":"    protected void setLinear(int position) {\n      assert linear == false;\n\n      int state = 0;\n      assert state == 0;\n      int maxInterval = 0xff;\n      \r\n      for (int i = 0; i < position; i++) {\n        state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n        assert state >= 0: \"state=\" + state;\n      }\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) &&\n            (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n          maxInterval = transition.max;\n          break;\n        }\n      }\n      \r\n      if (maxInterval != 0xff)\n        maxInterval++;\n      int length = position + 1; \n      if (linearUpperBound.bytes.length < length)\n        linearUpperBound.bytes = new byte[length];\n      System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n      linearUpperBound.bytes[position] = (byte) maxInterval;\n      linearUpperBound.length = length;\n\n      linear = true;\n    }\n","date":"2019-09-06 23:48:32","endLine":402,"groupId":"145","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"setLinear","params":"(intposition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/51/9e0d4c00c37eff02e5e51d55e68cbc30a660bd.src","preCode":"    protected void setLinear(int position) {\n      assert linear == false;\n\n      int state = 0;\n      assert state == 0;\n      int maxInterval = 0xff;\n      \r\n      for (int i = 0; i < position; i++) {\n        state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n        assert state >= 0: \"state=\" + state;\n      }\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) &&\n            (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n          maxInterval = transition.max;\n          break;\n        }\n      }\n      \r\n      if (maxInterval != 0xff)\n        maxInterval++;\n      int length = position + 1; \n      if (linearUpperBound.bytes.length < length)\n        linearUpperBound.bytes = new byte[length];\n      System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n      linearUpperBound.bytes[position] = (byte) maxInterval;\n      linearUpperBound.length = length;\n\n      linear = true;\n    }\n","realPath":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":370,"status":"N"},{"authorDate":"2020-02-22 01:07:13","commitOrder":6,"curCode":"  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = 0;\n    int maxInterval = 0xff;\n    \r\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) && \n          (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n        maxInterval = transition.max;\n        break;\n      }\n    }\n    \r\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; \n    if (linearUpperBound.bytes.length < length) {\n      linearUpperBound.bytes = new byte[ArrayUtil.oversize(length, Byte.BYTES)];\n    }\n    System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n","date":"2020-02-28 17:42:06","endLine":188,"groupId":"145","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"setLinear","params":"(intposition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/0f/00ce1c4ab671ebecc9ee8cdef78f97277d520b.src","preCode":"  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = 0;\n    assert state == 0;\n    int maxInterval = 0xff;\n    \r\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) && \n          (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n        maxInterval = transition.max;\n        break;\n      }\n    }\n    \r\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; \n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"M"}],"commitId":"e0164d1ac848ca3693e7f7faca91c39def1d48da","commitMessage":"@@@LUCENE-9245: Reduce AutomatonTermsEnum memory usage.\n\nCloses #1281\n","date":"2020-02-28 17:42:06","modifiedFileCount":"1","status":"M","submitter":"Bruno Roustant"},{"authorTime":"2020-02-22 01:07:13","codes":[{"authorDate":"2020-02-28 18:17:24","commitOrder":7,"curCode":"    protected void setLinear(int position) {\n      assert linear == false;\n\n      int state = 0;\n      int maxInterval = 0xff;\n      \r\n      for (int i = 0; i < position; i++) {\n        state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n        assert state >= 0 : \"state=\" + state;\n      }\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) &&\n            (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n          maxInterval = transition.max;\n          break;\n        }\n      }\n      \r\n      if (maxInterval != 0xff)\n        maxInterval++;\n      int length = position + 1; \n      if (linearUpperBound.bytes.length < length) {\n        linearUpperBound.bytes = new byte[ArrayUtil.oversize(length, Byte.BYTES)];\n      }\n      System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n      linearUpperBound.bytes[position] = (byte) maxInterval;\n      linearUpperBound.length = length;\n\n      linear = true;\n    }\n","date":"2020-02-28 21:52:19","endLine":452,"groupId":"102092","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"setLinear","params":"(intposition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ab/4af8609d2fc339f318dad993c6e277fe32bfcb.src","preCode":"    protected void setLinear(int position) {\n      assert linear == false;\n\n      int state = 0;\n      assert state == 0;\n      int maxInterval = 0xff;\n      \r\n      for (int i = 0; i < position; i++) {\n        state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n        assert state >= 0: \"state=\" + state;\n      }\n      final int numTransitions = automaton.getNumTransitions(state);\n      automaton.initTransition(state, transition);\n      for (int i = 0; i < numTransitions; i++) {\n        automaton.getNextTransition(transition);\n        if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) &&\n            (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n          maxInterval = transition.max;\n          break;\n        }\n      }\n      \r\n      if (maxInterval != 0xff)\n        maxInterval++;\n      int length = position + 1; \n      if (linearUpperBound.bytes.length < length)\n        linearUpperBound.bytes = new byte[length];\n      System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n      linearUpperBound.bytes[position] = (byte) maxInterval;\n      linearUpperBound.length = length;\n\n      linear = true;\n    }\n","realPath":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":420,"status":"M"},{"authorDate":"2020-02-22 01:07:13","commitOrder":7,"curCode":"  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = 0;\n    int maxInterval = 0xff;\n    \r\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) && \n          (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n        maxInterval = transition.max;\n        break;\n      }\n    }\n    \r\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; \n    if (linearUpperBound.bytes.length < length) {\n      linearUpperBound.bytes = new byte[ArrayUtil.oversize(length, Byte.BYTES)];\n    }\n    System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n","date":"2020-02-28 17:42:06","endLine":188,"groupId":"102092","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"setLinear","params":"(intposition)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/0f/00ce1c4ab671ebecc9ee8cdef78f97277d520b.src","preCode":"  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = 0;\n    int maxInterval = 0xff;\n    \r\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.byteAt(i) & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    final int numTransitions = automaton.getNumTransitions(state);\n    automaton.initTransition(state, transition);\n    for (int i = 0; i < numTransitions; i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min <= (seekBytesRef.byteAt(position) & 0xff) && \n          (seekBytesRef.byteAt(position) & 0xff) <= transition.max) {\n        maxInterval = transition.max;\n        break;\n      }\n    }\n    \r\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; \n    if (linearUpperBound.bytes.length < length) {\n      linearUpperBound.bytes = new byte[ArrayUtil.oversize(length, Byte.BYTES)];\n    }\n    System.arraycopy(seekBytesRef.bytes(), 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n","realPath":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"N"}],"commitId":"99af698107039eeac20544f91a739eda9c0e849c","commitMessage":"@@@LUCENE-9237: Faster UniformSplit intersect TermsEnum.\n\nCloses #1270\n","date":"2020-02-28 21:52:19","modifiedFileCount":"7","status":"M","submitter":"Bruno Roustant"}]
