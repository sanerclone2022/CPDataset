[{"authorTime":"2016-04-18 03:37:20","codes":[{"authorDate":"2016-04-18 03:37:20","commitOrder":1,"curCode":"  protected void verifyRandomRectangles(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = randomRect(small);\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2016-04-18 03:37:20","endLine":931,"groupId":"37189","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRandomRectangles","params":"(booleansmall@double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/db/df189f3c45e6f7e7b9afdecbfe694bfbb74fda.src","preCode":"  protected void verifyRandomRectangles(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = randomRect(small);\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":805,"status":"B"},{"authorDate":"2016-04-18 03:37:20","commitOrder":1,"curCode":"  protected void verifyRandomDistances(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = randomLat(small);\n      final double centerLon = randomLon(small);\n\n      final double radiusMeters;\n      if (small) {\n        \r\n        radiusMeters = random().nextDouble() * 333000 + 1.0;\n      } else {\n        \r\n        radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n      }\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2016-04-18 03:37:20","endLine":1078,"groupId":"15736","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRandomDistances","params":"(booleansmall@double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/db/df189f3c45e6f7e7b9afdecbfe694bfbb74fda.src","preCode":"  protected void verifyRandomDistances(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = randomLat(small);\n      final double centerLon = randomLon(small);\n\n      final double radiusMeters;\n      if (small) {\n        \r\n        radiusMeters = random().nextDouble() * 333000 + 1.0;\n      } else {\n        \r\n        radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n      }\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":933,"status":"B"}],"commitId":"aafdc372d98ec9e170501ed2fef91db892c6368f","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2016-04-18 03:37:20","modifiedFileCount":"5","status":"B","submitter":"Karl Wright"},{"authorTime":"2016-04-19 01:28:30","codes":[{"authorDate":"2016-04-19 01:28:30","commitOrder":2,"curCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2016-04-19 01:28:30","endLine":874,"groupId":"37189","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRandomRectangles","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6b/c1e6e061efa9fe25de500d723e15d39f6d7585.src","preCode":"  protected void verifyRandomRectangles(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = randomRect(small);\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":748,"status":"M"},{"authorDate":"2016-04-19 01:28:30","commitOrder":2,"curCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2016-04-19 01:28:30","endLine":1015,"groupId":"15736","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRandomDistances","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6b/c1e6e061efa9fe25de500d723e15d39f6d7585.src","preCode":"  protected void verifyRandomDistances(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = randomLat(small);\n      final double centerLon = randomLon(small);\n\n      final double radiusMeters;\n      if (small) {\n        \r\n        radiusMeters = random().nextDouble() * 333000 + 1.0;\n      } else {\n        \r\n        radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n      }\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":876,"status":"M"}],"commitId":"a7b138317ab38562c4fc511e8ac782b795accfc6","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2016-04-19 01:28:30","modifiedFileCount":"17","status":"M","submitter":"Karl Wright"},{"authorTime":"2016-10-03 03:18:22","codes":[{"authorDate":"2016-10-03 03:18:22","commitOrder":3,"curCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2016-10-03 03:18:22","endLine":871,"groupId":"61744","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRandomRectangles","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/19/b4a1cfe59513a35f5d9c11408829bf4353e8ba.src","preCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":745,"status":"M"},{"authorDate":"2016-10-03 03:18:22","commitOrder":3,"curCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2016-10-03 03:18:22","endLine":1012,"groupId":"26841","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRandomDistances","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/19/b4a1cfe59513a35f5d9c11408829bf4353e8ba.src","preCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      for(int docID=0;docID<maxDoc;docID++) {\n        int id = (int) docIDToID.get(docID);\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":873,"status":"M"}],"commitId":"3182cd9872af3cb73a1f73e36de68b8d76646e59","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2016-10-03 03:18:22","modifiedFileCount":"570","status":"M","submitter":"Karl Wright"},{"authorTime":"2016-10-03 03:18:22","codes":[{"authorDate":"2017-01-25 02:33:16","commitOrder":4,"curCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n          b.append(\"docID=(\" + docID + \")\\n\");\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2017-01-26 20:59:35","endLine":884,"groupId":"61744","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRandomRectangles","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/56/2db8f613e70b1e2840be6865bcf8ed55dfa136.src","preCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":757,"status":"M"},{"authorDate":"2016-10-03 03:18:22","commitOrder":4,"curCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2016-10-03 03:18:22","endLine":1012,"groupId":"26841","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRandomDistances","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/19/b4a1cfe59513a35f5d9c11408829bf4353e8ba.src","preCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":873,"status":"N"}],"commitId":"cf943c545478e01a2c76013f1c31b96786cdd165","commitMessage":"@@@LUCENE-7656: Implement geo box/distance queries using doc values.\n","date":"2017-01-26 20:59:35","modifiedFileCount":"5","status":"M","submitter":"Adrien Grand"},{"authorTime":"2017-12-08 18:41:33","codes":[{"authorDate":"2017-12-08 18:41:33","commitOrder":5,"curCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n          b.append(\"docID=(\" + docID + \")\\n\");\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2017-12-08 18:41:33","endLine":885,"groupId":"61744","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRandomRectangles","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6b/3993042fae36effad0da62998ae2484ddafd1f.src","preCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n          b.append(\"docID=(\" + docID + \")\\n\");\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":758,"status":"M"},{"authorDate":"2017-12-08 18:41:33","commitOrder":5,"curCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2017-12-08 18:41:33","endLine":1026,"groupId":"26841","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRandomDistances","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6b/3993042fae36effad0da62998ae2484ddafd1f.src","preCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":887,"status":"M"}],"commitId":"dcb84701a4c6d293b8eb30c676630d16d6cdcaa8","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2017-12-08 18:41:33","modifiedFileCount":"293","status":"M","submitter":"Karl Wright"},{"authorTime":"2018-10-19 07:49:13","codes":[{"authorDate":"2018-10-19 07:49:13","commitOrder":6,"curCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n          b.append(\"docID=(\" + docID + \")\\n\");\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2018-10-19 07:49:14","endLine":884,"groupId":"48591","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRandomRectangles","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/74/1e79423a9165e581a047e071e63a66befb6d49.src","preCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n          b.append(\"docID=(\" + docID + \")\\n\");\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":757,"status":"M"},{"authorDate":"2018-10-19 07:49:13","commitOrder":6,"curCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2018-10-19 07:49:14","endLine":1025,"groupId":"61219","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRandomDistances","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/74/1e79423a9165e581a047e071e63a66befb6d49.src","preCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiFields.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":886,"status":"M"}],"commitId":"fd9164801e703b278922dae6cc3c53e0578fa1d6","commitMessage":"@@@LUCENE-7875: Moved MultiFields static methods to MultiTerms.  FieldInfos and MultiBits.\nMultiBits is now public and has getLiveDocs.\n","date":"2018-10-19 07:49:14","modifiedFileCount":"107","status":"M","submitter":"David Smiley"},{"authorTime":"2019-06-11 00:07:43","codes":[{"authorDate":"2019-06-11 00:07:43","commitOrder":7,"curCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n          b.append(\"docID=(\").append(docID).append(\")\\n\");\n\n          if (expected) {\n            b.append(\"FAIL: id=\").append(id).append(\" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\").append(id).append(\" should not match but did\\n\");\n          }\n          b.append(\"  box=\").append(rect).append(\"\\n\");\n          b.append(\"  query=\").append(query).append(\" docID=\").append(docID).append(\"\\n\");\n          b.append(\"  lat=\").append(lats[id]).append(\" lon=\").append(lons[id]).append(\"\\n\");\n          b.append(\"  deleted?=\").append(liveDocs != null && liveDocs.get(docID) == false);\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2019-06-11 00:07:43","endLine":884,"groupId":"48591","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRandomRectangles","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/06/6716aaacf3a757e59c07d7cf21b3ecdf087d11.src","preCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n          b.append(\"docID=(\" + docID + \")\\n\");\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  box=\" + rect + \"\\n\");\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":757,"status":"M"},{"authorDate":"2019-06-11 00:07:43","commitOrder":7,"curCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\").append(id).append(\" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\").append(id).append(\" should not match but did\\n\");\n          }\n          b.append(\"  query=\").append(query).append(\" docID=\").append(docID).append(\"\\n\");\n          b.append(\"  lat=\").append(lats[id]).append(\" lon=\").append(lons[id]).append(\"\\n\");\n          b.append(\"  deleted?=\").append(liveDocs != null && liveDocs.get(docID) == false);\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\").append(centerLat).append(\" centerLon=\").append(centerLon).append(\" distanceMeters=\").append(distanceMeters).append(\" vs radiusMeters=\").append(radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2019-06-11 00:07:43","endLine":1025,"groupId":"61219","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRandomDistances","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/06/6716aaacf3a757e59c07d7cf21b3ecdf087d11.src","preCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\" + id + \" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\" + id + \" should not match but did\\n\");\n          }\n          b.append(\"  query=\" + query + \" docID=\" + docID + \"\\n\");\n          b.append(\"  lat=\" + lats[id] + \" lon=\" + lons[id] + \"\\n\");\n          b.append(\"  deleted?=\" + (liveDocs != null && liveDocs.get(docID) == false));\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":886,"status":"M"}],"commitId":"67104dd615c82de64839de60418110211438f574","commitMessage":"@@@LUCENE-8847: Code Cleanup: Rewrite StringBuilder.append with concatted strings (#707)\n\nThis specific commit affects all points in the casebase where the argument of a StringBuilder.append() call is itself a regular String concatenation.\nThis defeats the purpose of using StringBuilder and also introduces an extra alloction.\nThese changes should avoid that.\n\nant tests have run.  succeeded on local machine.\n\nRemoving test files from the changes.\n\nAnother suggested rework.","date":"2019-06-11 00:07:43","modifiedFileCount":"70","status":"M","submitter":"Koen De Groote"},{"authorTime":"2020-11-03 15:51:28","codes":[{"authorDate":"2020-11-03 15:51:28","commitOrder":8,"curCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    indexPoints(lats, lons, deleted, w);\n    \n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = searchIndex(s, query, maxDoc);\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          buildError(docID, expected, id, lats, lons, query, liveDocs, (b) ->  b.append(\"  rect=\").append(rect));\n          fail = true;\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2020-11-03 15:51:28","endLine":852,"groupId":"103335","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"verifyRandomRectangles","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a4/b47f0cc053a381ea0bbf7c2f040b9eb6690f8a.src","preCode":"  protected void verifyRandomRectangles(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n      \n      Rectangle rect = nextBox();\n\n      Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = rectContainsPoint(rect, lats[id], lons[id]);\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n          b.append(\"docID=(\").append(docID).append(\")\\n\");\n\n          if (expected) {\n            b.append(\"FAIL: id=\").append(id).append(\" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\").append(id).append(\" should not match but did\\n\");\n          }\n          b.append(\"  box=\").append(rect).append(\"\\n\");\n          b.append(\"  query=\").append(query).append(\" docID=\").append(docID).append(\"\\n\");\n          b.append(\"  lat=\").append(lats[id]).append(\" lon=\").append(lons[id]).append(\"\\n\");\n          b.append(\"  deleted?=\").append(liveDocs != null && liveDocs.get(docID) == false);\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":779,"status":"M"},{"authorDate":"2020-11-03 15:51:28","commitOrder":8,"curCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    indexPoints(lats, lons, deleted, w);\n    \n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = searchIndex(s, query, maxDoc);\n      \n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          Consumer<StringBuilder> explain = (b) -> {\n            if (Double.isNaN(lats[id]) == false) {\n              double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n              b.append(\"  centerLat=\").append(centerLat).append(\" centerLon=\").append(centerLon).append(\" distanceMeters=\").append(distanceMeters).append(\" vs radiusMeters=\").append(radiusMeters);\n            }\n          };\n          buildError(docID, expected, id, lats, lons, query, liveDocs, explain);\n          fail = true;\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","date":"2020-11-03 15:51:28","endLine":943,"groupId":"103335","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"verifyRandomDistances","params":"(double[]lats@double[]lons)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/a4/b47f0cc053a381ea0bbf7c2f040b9eb6690f8a.src","preCode":"  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    \r\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    \r\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    \r\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(25);\n\n    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());\n    int maxDoc = s.getIndexReader().maxDoc();\n\n    for (int iter=0;iter<iters;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n      }\n\n      \r\n      final double centerLat = nextLatitude();\n      final double centerLon = nextLongitude();\n\n      \r\n      final double radiusMeters = random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;\n\n      if (VERBOSE) {\n        final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n        System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n      }\n\n      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n      if (VERBOSE) {\n        System.out.println(\"  query=\" + query);\n      }\n\n      final FixedBitSet hits = new FixedBitSet(maxDoc);\n      s.search(query, new SimpleCollector() {\n\n          private int docBase;\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void collect(int doc) {\n            hits.set(docBase+doc);\n          }\n        });\n\n      boolean fail = false;\n      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n      for(int docID=0;docID<maxDoc;docID++) {\n        assertEquals(docID, docIDToID.nextDoc());\n        int id = (int) docIDToID.longValue();\n        boolean expected;\n        if (liveDocs != null && liveDocs.get(docID) == false) {\n          \r\n          expected = false;\n        } else if (Double.isNaN(lats[id])) {\n          expected = false;\n        } else {\n          expected = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;\n        }\n\n        if (hits.get(docID) != expected) {\n          StringBuilder b = new StringBuilder();\n\n          if (expected) {\n            b.append(\"FAIL: id=\").append(id).append(\" should match but did not\\n\");\n          } else {\n            b.append(\"FAIL: id=\").append(id).append(\" should not match but did\\n\");\n          }\n          b.append(\"  query=\").append(query).append(\" docID=\").append(docID).append(\"\\n\");\n          b.append(\"  lat=\").append(lats[id]).append(\" lon=\").append(lons[id]).append(\"\\n\");\n          b.append(\"  deleted?=\").append(liveDocs != null && liveDocs.get(docID) == false);\n          if (Double.isNaN(lats[id]) == false) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);\n            b.append(\"  centerLat=\").append(centerLat).append(\" centerLon=\").append(centerLon).append(\" distanceMeters=\").append(distanceMeters).append(\" vs radiusMeters=\").append(radiusMeters);\n          }\n          if (true) {\n            fail(\"wrong hit (first of possibly more):\\n\\n\" + b);\n          } else {\n            System.out.println(b.toString());\n            fail = true;\n          }\n        }\n      }\n      if (fail) {\n        fail(\"some hits were wrong\");\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n","realPath":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":854,"status":"M"}],"commitId":"8bfbed8d4cd476a008ee85310b1f6535920b4622","commitMessage":"@@@LUCENE-9552: Adds a LatLonPoint query that accepts an array of LatLonGeometries (#1940)\n\n","date":"2020-11-03 15:51:28","modifiedFileCount":"15","status":"M","submitter":"Ignacio Vera"}]
