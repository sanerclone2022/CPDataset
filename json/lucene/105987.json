[{"authorTime":"2018-05-07 17:52:51","codes":[{"authorDate":"2018-05-07 17:52:51","commitOrder":7,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-05-10 00:57:57","endLine":200,"groupId":"36543","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/82/7c6e34d2c3751d598374ab59ab1e931381b215.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":156,"status":"MB"},{"authorDate":"2018-05-07 17:52:51","commitOrder":7,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","date":"2018-05-10 00:57:57","endLine":259,"groupId":"4443","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/82/7c6e34d2c3751d598374ab59ab1e931381b215.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":202,"status":"B"}],"commitId":"a3c86373e47ddd43368c5800eea63b50d2064759","commitMessage":"@@@LUCENE-8298: Allow DocValues updates to reset a value\n\nToday once a document has a value in a certain DV field this values\ncan only be changed but not removed. While resetting / removing a value\nfrom a field is certainly a corner case it can be used to undelete a\nsoft-deleted document unless it's merged away.\nThis allows to rollback changes without rolling back to another commitpoint\nor trashing all uncommitted changes. In certain cenarios it can be used to\n\"repair\" history of documents in distributed systems.\n","date":"2018-05-10 00:57:57","modifiedFileCount":"17","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-06-02 18:30:02","codes":[{"authorDate":"2018-06-02 18:30:02","commitOrder":8,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-02 19:14:53","endLine":204,"groupId":"62762","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/30/47364781e1d6c788da0e6daa63f9ba31f545dc.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"},{"authorDate":"2018-06-02 18:30:02","commitOrder":8,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","date":"2018-06-02 19:14:53","endLine":263,"groupId":"62764","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/30/47364781e1d6c788da0e6daa63f9ba31f545dc.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"a2d927667418d17a1f5f31a193092d5b04a4219e","commitMessage":"@@@LUCENE-8335: Enforce soft-deletes field up-front.\n\nSoft deletes field must be marked as such once it's introduced\nand can't be changed after the fact.\n","date":"2018-06-02 19:14:53","modifiedFileCount":"19","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-06-02 19:47:24","codes":[{"authorDate":"2018-06-02 19:47:24","commitOrder":9,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-02 19:47:24","endLine":204,"groupId":"36543","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/5f/add3f10cdb8c1a3ed5bb9d8fd6b6475443850e.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"},{"authorDate":"2018-06-02 19:47:24","commitOrder":9,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","date":"2018-06-02 19:47:24","endLine":263,"groupId":"4443","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/5f/add3f10cdb8c1a3ed5bb9d8fd6b6475443850e.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"3dc4fa199c175ed6351f66bac5c23c73b4e3f89a","commitMessage":"@@@Revert \"LUCENE-8335: Enforce soft-deletes field up-front.\"\n\nThis reverts commit a2d927667418d17a1f5f31a193092d5b04a4219e.\n","date":"2018-06-02 19:47:24","modifiedFileCount":"19","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-06-04 14:23:31","codes":[{"authorDate":"2018-06-04 14:23:31","commitOrder":10,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-04 14:28:38","endLine":204,"groupId":"62762","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/30/47364781e1d6c788da0e6daa63f9ba31f545dc.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":160,"status":"M"},{"authorDate":"2018-06-04 14:23:31","commitOrder":10,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","date":"2018-06-04 14:28:38","endLine":263,"groupId":"62764","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/30/47364781e1d6c788da0e6daa63f9ba31f545dc.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"}],"commitId":"e7a0a12926c399758a4021715a7419e22e59dab6","commitMessage":"@@@LUCENE-8335: Enforce soft-deletes field up-front\n\nSoft deletes field must be marked as such once it's introduced\nand can't be changed after the fact.\n\nCo-authored-by: Nhat Nguyen <nhat.nguyen@elastic.co>\n","date":"2018-06-04 14:28:38","modifiedFileCount":"24","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-05-27 03:35:46","codes":[{"authorDate":"2018-05-27 03:35:46","commitOrder":11,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-06-04 21:05:12","endLine":250,"groupId":"62762","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/b6/4385529766bec26e461c918f04c7123c28e95b.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(1, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":204,"status":"M"},{"authorDate":"2018-05-27 03:35:46","commitOrder":11,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","date":"2018-06-04 21:05:12","endLine":310,"groupId":"62764","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/b6/4385529766bec26e461c918f04c7123c28e95b.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(1, deletes.numPendingDeletes());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":252,"status":"M"}],"commitId":"fe83838ec3768f25964a04510cd10772cf034d34","commitMessage":"@@@LUCENE-8341: Record soft deletes in SegmentCommitInfo\n\nThis change add the number of documents that are soft deletes but\nnot hard deleted to the segment commit info. This is the last step\ntowards making soft deletes as powerful as hard deltes since now the\nnumber of document can be read from commit points without opening a\nfull blown reader. This also allows merge posliies to make decisions\nwithout requiring an NRT reader to get the relevant statistics. This\nchange doesn't enforce any field to be used as soft deletes and the statistic\nis maintained per segment.\n","date":"2018-06-04 21:05:12","modifiedFileCount":"35","status":"M","submitter":"Simon Willnauer"},{"authorTime":"2018-08-24 20:33:18","codes":[{"authorDate":"2018-08-24 20:33:18","commitOrder":12,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-08-24 20:33:18","endLine":252,"groupId":"9135","id":11,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/03c7e60750628624fbb27f1b2801d813a6bcbc.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"},{"authorDate":"2018-08-24 20:33:18","commitOrder":12,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","date":"2018-08-24 20:33:18","endLine":312,"groupId":"62764","id":12,"instanceNumber":2,"isCurCommit":0,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/7d/03c7e60750628624fbb27f1b2801d813a6bcbc.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = writer.getReader();\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":254,"status":"M"}],"commitId":"f26dd13b34e3d3a6921230cfe44ff34b2c319e7b","commitMessage":"@@@LUCENE-8458: Ensure init PendingSoftDeletes when carry-over deletes\n\nToday when carrying over hard-deletes after merging segments.  we might\nnot adjust soft-deletes count accordingly because we do not always\nensure that the PendingSoftDeletes of the new segment is initialized.\n\nThis change fixes the initialization condition in PendingSoftDeletes and\nmakes sure it is initialized before accepting deletes.\n\nCo-authored-by: Simon Willnauer <simonw@apache.org>\n","date":"2018-08-24 20:33:18","modifiedFileCount":"5","status":"M","submitter":"Nhat Nguyen"},{"authorTime":"2018-10-09 07:51:03","codes":[{"authorDate":"2018-10-09 07:51:03","commitOrder":13,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2018-10-09 07:51:03","endLine":252,"groupId":"23568","id":13,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c8/82a3b88f39098e60b66afd8afd879bdc393785.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":206,"status":"M"},{"authorDate":"2018-10-09 07:51:03","commitOrder":13,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","date":"2018-10-09 07:51:03","endLine":312,"groupId":"23569","id":14,"instanceNumber":2,"isCurCommit":0,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c8/82a3b88f39098e60b66afd8afd879bdc393785.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":254,"status":"M"}],"commitId":"1118299c338253cea09640acdc48dc930dc27fda","commitMessage":"@@@LUCENE-8496: Selective indexing - modify BKDReader/BKDWriter to allow users to select a fewer number of dimensions to be used for creating the index than the total number of dimensions used for field encoding. i.e..  dimensions 0 to N may be used to determine how to split the inner nodes.  and dimensions N+1 to D are ignored and stored as data dimensions at the leaves.\n","date":"2018-10-09 07:51:03","modifiedFileCount":"72","status":"M","submitter":"Nicholas Knize"},{"authorTime":"2020-09-26 19:11:04","codes":[{"authorDate":"2020-09-26 19:11:04","commitOrder":14,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, 0, NONE, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2020-10-18 19:49:36","endLine":254,"groupId":"9134","id":15,"instanceNumber":1,"isCurCommit":0,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/22/6f199c9dea9e971a9efd3271a4e923da6d0b1c.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":208,"status":"M"},{"authorDate":"2020-09-26 19:11:04","commitOrder":14,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, 0, NONE, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, 0, NONE, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","date":"2020-10-18 19:49:36","endLine":314,"groupId":"29065","id":16,"instanceNumber":2,"isCurCommit":0,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/22/6f199c9dea9e971a9efd3271a4e923da6d0b1c.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()\n        .setSoftDeletesField(\"_soft_deletes\")\n        .setMaxBufferedDocs(3) \r\n        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"2\"), doc,\n        new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, true);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo = new FieldInfo(\"_soft_deletes\", 1, false, false, false, IndexOptions.NONE, DocValuesType.NUMERIC, segmentInfo.getNextDocValuesGen(), Collections.emptyMap(), 0, 0, 0, true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":256,"status":"M"}],"commitId":"c02f07f2d5db5c983c2eedf71febf9516189595d","commitMessage":"@@@LUCENE-9322: Add Lucene90 codec.  including VectorFormat\n\nThis commit adds support for dense floating point VectorFields.\nThe new VectorValues class provides access to the indexed vectors.\n","date":"2020-10-18 19:49:36","modifiedFileCount":"58","status":"M","submitter":"Michael Sokolov"},{"authorTime":"2021-07-21 16:06:27","codes":[{"authorDate":"2021-07-21 16:06:27","commitOrder":15,"curCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer =\n        new IndexWriter(\n            dir,\n            newIndexWriterConfig()\n                .setSoftDeletesField(\"_soft_deletes\")\n                .setMaxBufferedDocs(3) \r\n                .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"1\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo =\n        new FieldInfo(\n            \"_soft_deletes\",\n            1,\n            false,\n            false,\n            false,\n            IndexOptions.NONE,\n            DocValuesType.NUMERIC,\n            segmentInfo.getNextDocValuesGen(),\n            Collections.emptyMap(),\n            0,\n            0,\n            0,\n            0,\n            VectorSimilarityFunction.EUCLIDEAN,\n            true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2021-07-21 16:06:27","endLine":320,"groupId":"105987","id":17,"instanceNumber":1,"isCurCommit":1,"methodName":"testUpdateAppliedOnlyOnce","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ec/d3795dcefe8de62b92181a2984a0d24bf841a3.src","preCode":"  public void testUpdateAppliedOnlyOnce() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer =\n        new IndexWriter(\n            dir,\n            newIndexWriterConfig()\n                .setSoftDeletesField(\"_soft_deletes\")\n                .setMaxBufferedDocs(3) \r\n                .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"1\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo =\n        new FieldInfo(\n            \"_soft_deletes\",\n            1,\n            false,\n            false,\n            false,\n            IndexOptions.NONE,\n            DocValuesType.NUMERIC,\n            segmentInfo.getNextDocValuesGen(),\n            Collections.emptyMap(),\n            0,\n            0,\n            0,\n            0,\n            NONE,\n            true);\n    List<Integer> docsDeleted = Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS);\n    List<DocValuesFieldUpdates> updates = Arrays.asList(singleUpdate(docsDeleted, 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":255,"status":"M"},{"authorDate":"2021-07-21 16:06:27","commitOrder":15,"curCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer =\n        new IndexWriter(\n            dir,\n            newIndexWriterConfig()\n                .setSoftDeletesField(\"_soft_deletes\")\n                .setMaxBufferedDocs(3) \r\n                .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"1\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo =\n        new FieldInfo(\n            \"_soft_deletes\",\n            1,\n            false,\n            false,\n            false,\n            IndexOptions.NONE,\n            DocValuesType.NUMERIC,\n            segmentInfo.getNextDocValuesGen(),\n            Collections.emptyMap(),\n            0,\n            0,\n            0,\n            0,\n            VectorSimilarityFunction.EUCLIDEAN,\n            true);\n    List<DocValuesFieldUpdates> updates =\n        Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo =\n        new FieldInfo(\n            \"_soft_deletes\",\n            1,\n            false,\n            false,\n            false,\n            IndexOptions.NONE,\n            DocValuesType.NUMERIC,\n            segmentInfo.getNextDocValuesGen(),\n            Collections.emptyMap(),\n            0,\n            0,\n            0,\n            0,\n            VectorSimilarityFunction.EUCLIDEAN,\n            true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","date":"2021-07-21 16:06:27","endLine":415,"groupId":"105987","id":18,"instanceNumber":2,"isCurCommit":1,"methodName":"testResetOnUpdate","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/ec/d3795dcefe8de62b92181a2984a0d24bf841a3.src","preCode":"  public void testResetOnUpdate() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriter writer =\n        new IndexWriter(\n            dir,\n            newIndexWriterConfig()\n                .setSoftDeletesField(\"_soft_deletes\")\n                .setMaxBufferedDocs(3) \r\n                .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"1\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(\n        new Term(\"id\", \"2\"), doc, new NumericDocValuesField(\"_soft_deletes\", 1));\n    writer.commit();\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();\n    PendingDeletes deletes = newPendingDeletes(segmentInfo);\n    deletes.onNewReader(segmentReader, segmentInfo);\n    FieldInfo fieldInfo =\n        new FieldInfo(\n            \"_soft_deletes\",\n            1,\n            false,\n            false,\n            false,\n            IndexOptions.NONE,\n            DocValuesType.NUMERIC,\n            segmentInfo.getNextDocValuesGen(),\n            Collections.emptyMap(),\n            0,\n            0,\n            0,\n            0,\n            NONE,\n            true);\n    List<DocValuesFieldUpdates> updates =\n        Arrays.asList(singleUpdate(Arrays.asList(0, 1, DocIdSetIterator.NO_MORE_DOCS), 3, false));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    assertEquals(0, deletes.numPendingDeletes());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    Bits liveDocs = deletes.getLiveDocs();\n    deletes.onNewReader(segmentReader, segmentInfo);\n    \r\n    assertSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertTrue(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n\n    segmentInfo.advanceDocValuesGen();\n    fieldInfo =\n        new FieldInfo(\n            \"_soft_deletes\",\n            1,\n            false,\n            false,\n            false,\n            IndexOptions.NONE,\n            DocValuesType.NUMERIC,\n            segmentInfo.getNextDocValuesGen(),\n            Collections.emptyMap(),\n            0,\n            0,\n            0,\n            0,\n            NONE,\n            true);\n    updates = Arrays.asList(singleUpdate(Arrays.asList(1, DocIdSetIterator.NO_MORE_DOCS), 3, true));\n    for (DocValuesFieldUpdates update : updates) {\n      deletes.onDocValuesUpdate(fieldInfo, update.iterator());\n    }\n    \r\n    assertNotSame(liveDocs, deletes.getLiveDocs());\n    assertTrue(deletes.getLiveDocs().get(0));\n    assertFalse(deletes.getLiveDocs().get(1));\n    assertTrue(deletes.getLiveDocs().get(2));\n    assertEquals(0, deletes.numPendingDeletes());\n    assertEquals(1, deletes.getDelCount());\n    IOUtils.close(reader, writer, dir);\n  }\n","realPath":"lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":322,"status":"M"}],"commitId":"28ba8b77975fc1b5a1a07da373916a2b21ea09aa","commitMessage":"@@@LUCENE-10015: Remove VectorSimilarityFunction#NONE. (#219)\n\n","date":"2021-07-21 16:06:27","modifiedFileCount":"21","status":"M","submitter":"Adrien Grand"}]
