[{"authorTime":"2018-04-13 21:40:11","codes":[{"authorDate":"2014-07-31 20:49:22","commitOrder":5,"curCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","date":"2014-07-31 20:49:22","endLine":71,"groupId":"32874","id":1,"instanceNumber":1,"isCurCommit":0,"methodName":"ConnectionCosts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6c/354c018d450d6715b943e8f61bf02824ae3f5f.src","preCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","realPath":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":41,"status":"NB"},{"authorDate":"2018-04-13 21:40:11","commitOrder":5,"curCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","date":"2018-04-13 21:40:11","endLine":73,"groupId":"43923","id":2,"instanceNumber":2,"isCurCommit":0,"methodName":"ConnectionCosts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/95/d0e8b611176a7fa2fdf1033504ac690f17fa65.src","preCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","realPath":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":41,"status":"B"}],"commitId":"f88a553a91207d911c99d17cb3a23d9eeb6b3665","commitMessage":"@@@Merge branch 'master' of https://git-wip-us.apache.org/repos/asf/lucene-solr\n","date":"2018-04-13 21:40:11","modifiedFileCount":"5","status":"M","submitter":"Karl Wright"},{"authorTime":"2019-08-27 02:09:03","codes":[{"authorDate":"2014-07-31 20:49:22","commitOrder":6,"curCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","date":"2014-07-31 20:49:22","endLine":71,"groupId":"32874","id":3,"instanceNumber":1,"isCurCommit":0,"methodName":"ConnectionCosts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/6c/354c018d450d6715b943e8f61bf02824ae3f5f.src","preCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","realPath":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":41,"status":"N"},{"authorDate":"2019-08-27 02:09:03","commitOrder":6,"curCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","date":"2019-08-27 02:09:03","endLine":73,"groupId":"43923","id":4,"instanceNumber":2,"isCurCommit":0,"methodName":"ConnectionCosts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/36/cbe1519d523cc6fac4cc0f77999b6a68558f2d.src","preCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","realPath":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":41,"status":"M"}],"commitId":"a9607b2a88185f03f95e7b0ab282336c8997488e","commitMessage":"@@@LUCENE-8954: refactor Nori analyzer\n\nSigned-off-by: Namgyu Kim <namgyu@apache.org>","date":"2019-08-27 02:09:03","modifiedFileCount":"21","status":"M","submitter":"Namgyu Kim"},{"authorTime":"2019-08-27 02:09:03","codes":[{"authorDate":"2019-09-06 20:34:32","commitOrder":7,"curCode":"  public ConnectionCosts(BinaryDictionary.ResourceScheme scheme, String path) throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getResource(scheme, path.replace('.', '/') + FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","date":"2019-09-11 22:45:50","endLine":74,"groupId":"32874","id":5,"instanceNumber":1,"isCurCommit":0,"methodName":"ConnectionCosts","params":"(BinaryDictionary.ResourceSchemescheme@Stringpath)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c8/86af2fdc64c387c4f08c5e66a662e1a0640885.src","preCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","realPath":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"M"},{"authorDate":"2019-08-27 02:09:03","commitOrder":7,"curCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","date":"2019-08-27 02:09:03","endLine":73,"groupId":"43923","id":6,"instanceNumber":2,"isCurCommit":0,"methodName":"ConnectionCosts","params":"()","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/36/cbe1519d523cc6fac4cc0f77999b6a68558f2d.src","preCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","realPath":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":41,"status":"N"}],"commitId":"770464ec2084d79542e3b701d2454c3a29f89ea0","commitMessage":"@@@LUCENE-8971: Enable constructing JapaneseTokenizer with custom dictionary\n","date":"2019-09-11 22:45:50","modifiedFileCount":"6","status":"M","submitter":"Michael Sokolov"},{"authorTime":"2020-03-03 01:11:44","codes":[{"authorDate":"2019-09-06 20:34:32","commitOrder":8,"curCode":"  public ConnectionCosts(BinaryDictionary.ResourceScheme scheme, String path) throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getResource(scheme, path.replace('.', '/') + FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","date":"2019-09-11 22:45:50","endLine":74,"groupId":"32874","id":7,"instanceNumber":1,"isCurCommit":0,"methodName":"ConnectionCosts","params":"(BinaryDictionary.ResourceSchemescheme@Stringpath)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c8/86af2fdc64c387c4f08c5e66a662e1a0640885.src","preCode":"  public ConnectionCosts(BinaryDictionary.ResourceScheme scheme, String path) throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getResource(scheme, path.replace('.', '/') + FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","realPath":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":44,"status":"N"},{"authorDate":"2020-03-03 01:11:44","commitOrder":8,"curCode":"  public ConnectionCosts(BinaryDictionary.ResourceScheme scheme, String resourcePath) throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getResource(scheme, resourcePath.replace('.', '/') + FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","date":"2020-03-03 01:11:44","endLine":77,"groupId":"43923","id":8,"instanceNumber":2,"isCurCommit":0,"methodName":"ConnectionCosts","params":"(BinaryDictionary.ResourceSchemescheme@StringresourcePath)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/3d/67897d34dfb920a7cf5957137cf94bc3870011.src","preCode":"  private ConnectionCosts() throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getClassResource(getClass(), FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","realPath":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"}],"commitId":"b2dbd18f96e05478146a838108d096df7348d1b4","commitMessage":"@@@LUCENE-9253: Support custom dictionaries in KoreanTokenizer\n\nSigned-off-by: Namgyu Kim <namgyu@apache.org>\n","date":"2020-03-03 01:11:44","modifiedFileCount":"6","status":"M","submitter":"Namgyu Kim"},{"authorTime":"2020-03-06 10:29:39","codes":[{"authorDate":"2020-03-06 10:29:39","commitOrder":9,"curCode":"  public ConnectionCosts(BinaryDictionary.ResourceScheme scheme, String path) throws IOException {\n    InputStream is = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getResource(scheme, path.replace('.', '/') + FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n  }\n","date":"2020-03-06 10:29:39","endLine":76,"groupId":"101667","id":9,"instanceNumber":1,"isCurCommit":0,"methodName":"ConnectionCosts","params":"(BinaryDictionary.ResourceSchemescheme@Stringpath)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/c3/ed8b645ef0a539a892c30dd8942e58b95f7fa7.src","preCode":"  public ConnectionCosts(BinaryDictionary.ResourceScheme scheme, String path) throws IOException {\n    InputStream is = null;\n    short[][] costs = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getResource(scheme, path.replace('.', '/') + FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      int forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      costs = new short[backwardSize][forwardSize];\n      int accum = 0;\n      for (int j = 0; j < costs.length; j++) {\n        final short[] a = costs[j];\n        for (int i = 0; i < a.length; i++) {\n          accum += in.readZInt();\n          a[i] = (short)accum;\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    \n    this.costs = costs;\n  }\n","realPath":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":46,"status":"M"},{"authorDate":"2020-03-06 10:29:39","commitOrder":9,"curCode":"  public ConnectionCosts(BinaryDictionary.ResourceScheme scheme, String resourcePath) throws IOException {\n    InputStream is = null;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getResource(scheme, resourcePath.replace('.', '/') + FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n  }\n","date":"2020-03-06 10:29:39","endLine":75,"groupId":"101667","id":10,"instanceNumber":2,"isCurCommit":0,"methodName":"ConnectionCosts","params":"(BinaryDictionary.ResourceSchemescheme@StringresourcePath)","path":"/mnt/clonedata/CloneManagementServer/ManagementServer/consistResult/result-lucene-10-0.7/blobInfo/CC_OUT/blobs/fc/7be7ab29dec01929045c26d9c299b24e2c30a0.src","preCode":"  public ConnectionCosts(BinaryDictionary.ResourceScheme scheme, String resourcePath) throws IOException {\n    InputStream is = null;\n    ByteBuffer buffer;\n    boolean success = false;\n    try {\n      is = BinaryDictionary.getResource(scheme, resourcePath.replace('.', '/') + FILENAME_SUFFIX);\n      is = new BufferedInputStream(is);\n      final DataInput in = new InputStreamDataInput(is);\n      CodecUtil.checkHeader(in, HEADER, VERSION, VERSION);\n      this.forwardSize = in.readVInt();\n      int backwardSize = in.readVInt();\n      int size = forwardSize * backwardSize;\n\n      \r\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size*2);\n      int accum = 0;\n      for (int j = 0; j < backwardSize; j++) {\n        for (int i = 0; i < forwardSize; i++) {\n          accum += in.readZInt();\n          tmpBuffer.putShort((short) accum);\n        }\n      }\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(is);\n      } else {\n        IOUtils.closeWhileHandlingException(is);\n      }\n    }\n    this.buffer = buffer;\n  }\n","realPath":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/ConnectionCosts.java","repoName":"lucene","snippetEndLine":0,"snippetStartLine":0,"startLine":45,"status":"M"}],"commitId":"9cfdf17b2895866877668002d443277a46cd04e8","commitMessage":"@@@LUCENE-9241: fix tests to pass with -Xmx128m\n","date":"2020-03-06 10:29:39","modifiedFileCount":"22","status":"M","submitter":"Robert Muir"}]
